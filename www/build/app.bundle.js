/*! Copyright ©2013-2016 Memba® Sarl. All rights reserved. - Version 0.2.57 dated 10/14/2016 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, callbacks = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId])
/******/ 				callbacks.push.apply(callbacks, installedChunks[chunkId]);
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			modules[moduleId] = moreModules[moduleId];
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);
/******/ 		while(callbacks.length)
/******/ 			callbacks.shift().call(null, __webpack_require__);
/******/
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// "0" means "already loaded"
/******/ 	// Array means "loading", array contains callbacks
/******/ 	var installedChunks = {
/******/ 		0:0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId, callback) {
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] === 0)
/******/ 			return callback.call(null, __webpack_require__);
/******/
/******/ 		// an array means "currently loading".
/******/ 		if(installedChunks[chunkId] !== undefined) {
/******/ 			installedChunks[chunkId].push(callback);
/******/ 		} else {
/******/ 			// start chunk loading
/******/ 			installedChunks[chunkId] = [callback];
/******/ 			var head = document.getElementsByTagName('head')[0];
/******/ 			var script = document.createElement('script');
/******/ 			script.type = 'text/javascript';
/******/ 			script.charset = 'utf-8';
/******/ 			script.async = true;
/******/
/******/ 			script.src = __webpack_require__.p + "" + ({"1":"app.culture.en","2":"app.culture.fr","3":"app.theme.fiori","4":"app.theme.flat","5":"app.theme.material","6":"app.theme.nova","7":"app.theme.office365"}[chunkId]||chunkId) + ".chunk.js?v=0.2.57";
/******/ 			head.appendChild(script);
/******/ 		}
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./build/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false, require: false, __NODE_ENV__: false */
	
	if (true) {
	
	    // Load other CSS
	    __webpack_require__(177);
	    __webpack_require__(181);
	    __webpack_require__(183);
	    // require('../styles/kidoju.widgets.playbar.less');
	    __webpack_require__(185);
	    __webpack_require__(187);
	    __webpack_require__(189);
	    __webpack_require__(192);
	    __webpack_require__(197);
	
	    // Load config
	    __webpack_require__(199);
	}
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(202),
	        __webpack_require__(204),
	        __webpack_require__(207),
	        __webpack_require__(208),
	        __webpack_require__(209),
	        __webpack_require__(210),
	        __webpack_require__(211),
	        __webpack_require__(212),
	        __webpack_require__(213),
	        __webpack_require__(214),
	        __webpack_require__(215),
	        __webpack_require__(216),
	        __webpack_require__(217),
	        __webpack_require__(219),
	        __webpack_require__(218),
	        __webpack_require__(220),
	        __webpack_require__(221),
	        __webpack_require__(222),
	        __webpack_require__(223),
	        __webpack_require__(224),
	        __webpack_require__(225),
	        __webpack_require__(226),
	        __webpack_require__(227),
	        __webpack_require__(228),
	        __webpack_require__(229),
	        __webpack_require__(230),
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(233),
	        __webpack_require__(234),
	        // './kidoju.widgets.chargrid',
	        __webpack_require__(235),
	        __webpack_require__(238),
	        __webpack_require__(239),
	        __webpack_require__(242),
	        __webpack_require__(243),
	        __webpack_require__(245),
	        // './kidoju.widgets.playbar',
	        __webpack_require__(246),
	        __webpack_require__(247),
	        // './kidoju.widgets.social',
	        __webpack_require__(248),
	        __webpack_require__(249),
	        __webpack_require__(250),
	        __webpack_require__(253),
	        __webpack_require__(263),
	        __webpack_require__(360),
	        __webpack_require__(361),
	        __webpack_require__(201)
	        // './app.db'
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    /* This function has too many statements. */
	    /* jshint -W071 */
	
	    (function ($, undefined) {
	
	        var kendo = window.kendo;
	        var kidoju = window.kidoju;
	        var assert = window.assert;
	        var localStorage = window.localStorage;
	        var logger = new window.Logger('app.mobile');
	        var support = kendo.support;
	        var app = window.app = window.app || {};
	        var mobile = app.mobile = app.mobile || {};
	        var i18n = app.i18n;
	        var Page = kidoju.data.Page;
	        // var PageComponent = kidoju.data.PageComponent;
	        var PageCollectionDataSource = kidoju.data.PageCollectionDataSource;
	        // var PageComponentCollectionDataSource = kidoju.data.PageComponentCollectionDataSource;
	        var UNDEFINED = 'undefined';
	        var NUMBER = 'number';
	        var OBJECT = 'object';
	        var STRING = 'string';
	        var ARRAY = 'array';
	        var CHANGE = 'change';
	        var LOADED = 'i18n.loaded';
	        var RX_MONGODB_ID = /^[0-9a-f]{24}$/;
	        var VIRTUAL_PAGE_SIZE = 30; // Display 10 items * 3 DOM Element * 2
	        var HASH = '#';
	        var PHONE = 'phone';
	        // var TABLET = 'tablet';
	        var DEVICE_SELECTOR = HASH + PHONE;
	        // var DEVICE_SELECTOR = HASH + (support.mobileOS && support.mobileOS.tablet ? TABLET : PHONE)
	        var LAYOUT = {
	            MAIN: '-main-layout'
	        };
	        var VIEW = {
	            ACTIVITIES: '-activities',
	            CATEGORIES: '-categories',
	            DRAWER: '-drawer',
	            FAVOURITES: '-favourites',
	            PLAYER: '-player',
	            SCORE: '-score',
	            SETTINGS: '-settings',
	            SUMMARIES: '-summaries'
	        };
	        var DEFAULT = {
	            LANGUAGE: 'en',
	            THEME: 'nova'
	        };
	        var DISPLAY = {
	            INLINE: 'inline-block',
	            NONE: 'none',
	            TABLE: 'table'
	        };
	        var STORAGE = {
	            LANGUAGE: 'language',
	            THEME: 'theme'
	        };
	        var VIEWMODEL = {
	            CURRENT: 'current',
	            CURRENT_ID: 'current.id',
	            LANGUAGE: 'settings.language',
	            PAGES_COLLECTION: 'version.stream.pages',
	            SELECTED_PAGE: 'selectedPage',
	            THEME: 'settings.theme',
	            VERSION: 'version'
	        };
	
	        /*******************************************************************************************
	         * Global error handler
	         *******************************************************************************************/
	        // TODO See app.logger
	
	        /*******************************************************************************************
	         * viewModel
	         *******************************************************************************************/
	
	        var viewModel = mobile.viewModel = kendo.observable({
	
	            /**
	             * Categories
	             */
	            categories: new app.models.LazyCategoryDataSource(),
	
	            /**
	             * Summaries
	             */
	            summaries: new app.models.LazySummaryDataSource(),
	
	            /**
	             * Favourites
	             */
	            favourites: [],
	
	            /**
	             * Versions
	             */
	            versions: new app.models.LazyVersionDataSource(),
	
	            /**
	             * Selected version
	             */
	            version: new app.models.Version(),
	
	            /**
	             * The selected page displayed in the player
	             */
	            selectedPage: undefined,
	
	            /**
	             * Current test
	             */
	            current: { test: undefined },
	
	            /**
	             * Activities (scores to start with)
	             */
	            activities: [
	                { title: 'Test of Mathematics', score: 10 },
	                { title: 'Test of Physics', score: 20 },
	                { title: 'Test of English', score: 30 },
	                { title: 'Test of Geography', score: 40 },
	                { title: 'Test of History', score: 50 }
	            ],
	
	            /**
	             * Languages
	             */
	            languages: [],
	
	            /**
	             * Themes
	             */
	            themes: [],
	
	            /**
	             * User settings
	             */
	            settings: {
	                user: 'TODO',
	                version: app.version,
	                language: DEFAULT.LANGUAGE,
	                theme: DEFAULT.THEME
	            },
	
	            reset: function () {
	                // this.activities.data([]);
	                // this.categories.data([]);
	                this.categories.read();
	                // this.favourites.data([]);
	                this.summaries.data([]);
	                this.versions.data([]);
	                this.set(VIEWMODEL.VERSION, new app.models.Version());
	                this.set(VIEWMODEL.SELECTED_PAGE, undefined);
	                this.set(VIEWMODEL.CURRENT, { test: undefined });
	            },
	
	            /**
	             * Load settings from local storage
	             */
	            loadSettings: function () {
	                try {
	                    // Language
	                    var language = localStorage.getItem(STORAGE.LANGUAGE);
	                    this.set(VIEWMODEL.LANGUAGE, language || DEFAULT.LANGUAGE);
	                    // Theme
	                    // We need the same localStorage location as in Kidoju.Webapp to be able to use app.theme.js to load themes
	                    var theme = localStorage.getItem(STORAGE.THEME);
	                    this.set(VIEWMODEL.THEME, theme || DEFAULT.THEME);
	                } catch (ex) {
	                    // console.log(ex.message); // TODO
	                }
	            },
	
	            /**
	             * Load lazy summaries
	             * @param query
	             */
	            loadLazySummaries: function (query) {
	                return viewModel.summaries.query(query)
	                    .fail(function (xhr, status, error) {
	                        // TODO: app.notification.error(i18n.culture.player.notifications.versionLoadFailure);
	                        logger.error({
	                            message: 'error loading summaries',
	                            method: 'viewModel.loadLazySummaries',
	                            data: { query: query, status: status, error: error } // TODO xhr.responseText
	                        });
	                    });
	            },
	
	            /**
	             * Load version (and stream pages)
	             * Copied from app.player.js
	             * @param summaryId
	             * @param versionId
	             * @returns {*}
	             */
	            loadVersion: function (summaryId, versionId) {
	
	                function versionLoadFailure(xhr, status, error) {
	                    dfd.reject(xhr, status, error);
	                    // TODO: app.notification.error(i18n.culture.player.notifications.versionLoadFailure);
	                    logger.error({
	                        message: 'error loading version',
	                        method: 'viewModel.loadVersion',
	                        data: { summaryId: summaryId, versionId: versionId, status: status, error: error } // TODO xhr.responseText
	                    });
	                }
	
	                var dfd = $.Deferred();
	
	                // Load version and pages
	                viewModel.version.load(summaryId, versionId)
	                    .done(function () {
	                        // Load stream
	                        viewModel.version.stream.load()
	                            .done(function () {
	                                var promises = [];
	                                var pageCollectionDataSource = viewModel.get(VIEWMODEL.PAGES_COLLECTION);
	                                assert.instanceof(PageCollectionDataSource, pageCollectionDataSource, kendo.format(assert.messages.instanceof.default, 'pageCollectionDataSource', 'kidoju.data.PageCollectionDataSource'));
	                                $.each(pageCollectionDataSource.data(), function (idx, page) {
	                                    assert.instanceof(kidoju.data.Page, page, kendo.format(assert.messages.instanceof.default, 'page', 'kidoju.data.Page'));
	                                    promises.push(page.load());
	                                });
	                                $.when(promises)
	                                    .done(dfd.resolve)
	                                    .fail(versionLoadFailure);
	                            })
	                            .fail(versionLoadFailure);
	                    })
	                    .fail(versionLoadFailure);
	
	                return dfd.promise();
	            },
	
	            /**
	             * Load lazy versions of a summary
	             * @param summaryId
	             */
	            loadLazyVersions: function (summaryId) {
	                return viewModel.versions.load({ summaryId: summaryId })
	                    .fail(function (xhr, status, error) {
	                        // app.notification.error(i18n.culture.finder.notifications.versionsLoadFailure);
	                        logger.error({
	                            message: 'error loading versions',
	                            method: 'viewModel.loadLazyVersions',
	                            data: { summaryId: summaryId, status: status, error: error } // TODO: xhr.responseText
	                        });
	                    });
	            },
	
	            /**
	             * Set current test
	             */
	            setCurrent: function () {
	                viewModel.set(VIEWMODEL.CURRENT, {
	                    test: viewModel.version.stream.pages.getTestFromProperties(),
	                    version : {
	                        summaryId: viewModel.get('version.summaryId'),
	                        versionId: viewModel.get('version.id')
	                    }
	                });
	            },
	
	            /**
	             * Get player view title
	             */
	            getPlayerViewTitle: function () {
	                var page = this.get(VIEWMODEL.SELECTED_PAGE);
	                var pageCollectionDataSource = this.get(VIEWMODEL.PAGES_COLLECTION);
	                assert.instanceof(PageCollectionDataSource, pageCollectionDataSource, kendo.format(assert.messages.instanceof.default, 'pageCollectionDataSource', 'kidoju.data.PageCollectionDataSource'));
	                var index = pageCollectionDataSource.indexOf(page);
	                return kendo.format(i18n.culture.player.viewTitle, index + 1, pageCollectionDataSource.total());
	            },
	
	            /**
	             * Check first page
	             * @returns {boolean}
	             */
	            isFirstPage$: function () {
	                var page = this.get(VIEWMODEL.SELECTED_PAGE);
	                var pageCollectionDataSource = this.get(VIEWMODEL.PAGES_COLLECTION);
	                assert.instanceof(PageCollectionDataSource, pageCollectionDataSource, kendo.format(assert.messages.instanceof.default, 'pageCollectionDataSource', 'kidoju.data.PageCollectionDataSource'));
	                var index = pageCollectionDataSource.indexOf(page);
	                return index === 0;
	            },
	
	            /**
	             * Check last page
	             * @returns {boolean}
	             */
	            isLastPage$: function () {
	                var page = this.get(VIEWMODEL.SELECTED_PAGE);
	                var pageCollectionDataSource = this.get(VIEWMODEL.PAGES_COLLECTION);
	                assert.instanceof(PageCollectionDataSource, pageCollectionDataSource, kendo.format(assert.messages.instanceof.default, 'pageCollectionDataSource', 'kidoju.data.PageCollectionDataSource'));
	                var index = pageCollectionDataSource.indexOf(page);
	                return index === -1 || index === pageCollectionDataSource.total() - 1;
	            },
	
	            /**
	             * Check whether this is the submit page
	             */
	            isSubmitPage$: function () {
	                // It has to be the last page and the test should not have already been submitted/scored
	                return this.isLastPage$() && $.type(this.get(VIEWMODEL.CURRENT_ID)) === UNDEFINED;
	            },
	
	            /**
	             * Select the previous page from viewModel.version.stream.pages
	             */
	            previousPage: function () {
	                var page = this.get(VIEWMODEL.SELECTED_PAGE);
	                var pageCollectionDataSource = this.get(VIEWMODEL.PAGES_COLLECTION);
	                assert.instanceof(PageCollectionDataSource, pageCollectionDataSource, kendo.format(assert.messages.instanceof.default, 'pageCollectionDataSource', 'kidoju.data.PageCollectionDataSource'));
	                var index = pageCollectionDataSource.indexOf(page);
	                if ($.type(index) === NUMBER && index > 0) {
	                    this.set(VIEWMODEL.SELECTED_PAGE, pageCollectionDataSource.at(index - 1));
	                }
	            },
	
	            /**
	             * Select the next page from viewModel.version.stream.pages
	             */
	            nextPage: function () {
	                var page = this.get(VIEWMODEL.SELECTED_PAGE);
	                var pageCollectionDataSource = this.get(VIEWMODEL.PAGES_COLLECTION);
	                assert.instanceof(PageCollectionDataSource, pageCollectionDataSource, kendo.format(assert.messages.instanceof.default, 'pageCollectionDataSource', 'kidoju.data.PageCollectionDataSource'));
	                var index = pageCollectionDataSource.indexOf(page);
	                if ($.type(index) === NUMBER && index < pageCollectionDataSource.total() - 1) {
	                    this.set(VIEWMODEL.SELECTED_PAGE, pageCollectionDataSource.at(index + 1));
	                }
	            }
	
	        });
	
	        /**
	         * Event handler for the viewModel change event
	         */
	        viewModel.bind(CHANGE, function (e) {
	            assert.isPlainObject(e, kendo.format(assert.messages.isOptionalObject.default, 'e'));
	            assert.type(STRING, e.field, kendo.format(assert.messages.type.default, 'e.field', STRING));
	            assert.instanceof(kendo.Observable, e.sender, kendo.format(assert.messages.instanceof.default, 'e.sender', 'kendo.Observable'));
	            switch (e.field) {
	                case VIEWMODEL.LANGUAGE:
	                    mobile._localize(e.sender.get(VIEWMODEL.LANGUAGE));
	                    viewModel.reset();
	                    break;
	                case VIEWMODEL.THEME:
	                    app.theme.name(e.sender.get(VIEWMODEL.THEME));
	                    break;
	                case VIEWMODEL.SELECTED_PAGE:
	                    var playerViewElement = $(DEVICE_SELECTOR + VIEW.PLAYER);
	                    var playerView = playerViewElement.data('kendoMobileView');
	                    mobile._setNavBar(playerView);
	                    mobile._setNavBarTitle(playerView, viewModel.getPlayerViewTitle());
	                    var markdownScrollerElement = playerViewElement.find(kendo.roleSelector('scroller'));
	                    var markdownScroller = markdownScrollerElement.data('kendoMobileScroller');
	                    markdownScroller.reset();
	                    markdownScroller.contentResized();
	            }
	        });
	
	        /*******************************************************************************************
	         * Utility methods (prefixed with underscore)
	         *******************************************************************************************/
	
	        /* This function's cyclomatic complexity is too high. */
	        /* jshint -W074 */
	
	        /**
	         * Show/hide relevant navbar commands
	         * @param view
	         * @private
	         */
	        mobile._setNavBar = function (view) {
	            /* jshint maxcomplexity: 13 */
	            assert.instanceof(kendo.mobile.ui.View, view, kendo.format(assert.messages.instanceof.default, 'view', 'kendo.mobile.ui.View'));
	            var showDrawerButton = false;
	            var showHomeButton = false;
	            var showPreviousButton = false;
	            var showNextButton = false;
	            var showSubmitButton = false;
	            var showSyncButton = false;
	            var showSearchButton = false;
	            var showSortButtons = false;
	            switch (view.id) {
	                case '/':
	                case DEVICE_SELECTOR + VIEW.ACTIVITIES:
	                    showDrawerButton = true;
	                    showSyncButton = true;
	                    break;
	                case DEVICE_SELECTOR + VIEW.CATEGORIES:
	                    showDrawerButton = true;
	                    showSearchButton = true;
	                    break;
	                case DEVICE_SELECTOR + VIEW.FAVOURITES:
	                    showDrawerButton = true;
	                    showSyncButton = true;
	                    break;
	                case DEVICE_SELECTOR + VIEW.PLAYER:
	                    showDrawerButton = true;
	                    showPreviousButton = !viewModel.isFirstPage$();
	                    showNextButton = !viewModel.isSubmitPage$();
	                    showSubmitButton = viewModel.isSubmitPage$();
	                    break;
	                case DEVICE_SELECTOR + VIEW.SCORE:
	                    showDrawerButton = true;
	                    break;
	                case DEVICE_SELECTOR + VIEW.SETTINGS:
	                    showDrawerButton = true;
	                    showSyncButton = true;
	                    break;
	                case DEVICE_SELECTOR + VIEW.SUMMARIES:
	                    showDrawerButton = true;
	                    showHomeButton = true;
	                    // showSearchButton = true;
	                    // showSortButtons = true;
	                    break;
	            }
	            // Note: each view has all buttons by default, so let's fix that
	            view.element.find(DEVICE_SELECTOR + LAYOUT.MAIN + '-drawer').css({ display: showDrawerButton ? DISPLAY.INLINE : DISPLAY.NONE });
	            view.element.find(DEVICE_SELECTOR + LAYOUT.MAIN + '-home').css({ display: showHomeButton ? DISPLAY.INLINE : DISPLAY.NONE });
	            view.element.find(DEVICE_SELECTOR + LAYOUT.MAIN + '-previous').css({ display: showPreviousButton ? DISPLAY.INLINE : DISPLAY.NONE });
	            view.element.find(DEVICE_SELECTOR + LAYOUT.MAIN + '-next').css({ display: showNextButton ? DISPLAY.INLINE : DISPLAY.NONE });
	            view.element.find(DEVICE_SELECTOR + LAYOUT.MAIN + '-submit').css({ display: showSubmitButton ? DISPLAY.INLINE : DISPLAY.NONE });
	            view.element.find(DEVICE_SELECTOR + LAYOUT.MAIN + '-sync').css({ display: showSyncButton ? DISPLAY.INLINE : DISPLAY.NONE });
	            view.element.find(DEVICE_SELECTOR + LAYOUT.MAIN + '-search').css({ display: showSearchButton ? DISPLAY.INLINE : DISPLAY.NONE });
	            view.element.find(DEVICE_SELECTOR + LAYOUT.MAIN + '-sort').css({ display: showSortButtons ? DISPLAY.INLINE : DISPLAY.NONE });
	        };
	
	        /* jshint +W074 */
	
	        /**
	         * Set the navigation bar title
	         * @param locale
	         * @private
	         */
	        mobile._setNavBarTitle = function (view, title) {
	            assert.instanceof(kendo.mobile.ui.View, view, kendo.format(assert.messages.instanceof.default, 'view', 'kendo.mobile.ui.View'));
	            assert.type(STRING, title, kendo.format(assert.messages.type.default, 'title', STRING));
	            var navbarElement = view.header.find('.km-navbar');
	            var navbarWidget = navbarElement.data('kendoMobileNavBar');
	            navbarWidget.title(title);
	            // Fix km-no-title issue to align km-view-title properly within km-navbar
	            navbarElement.find('.km-no-title').removeClass('km-no-title');
	        };
	
	        /**
	         * Converts params into a kendo.data.DataSource filter
	         * @param params
	         * @private
	         */
	        mobile._getDataFilter = function (params) {
	            // TODO If it gets more complicated, consider using $.deparam from app.utils.js in Kidoju.WebApp
	            // assert.isPlainObject(params, kendo.format(assert.messages.isPlainObject.default, 'params'));
	            assert.type(OBJECT, params, kendo.format(assert.messages.type.default, 'params', OBJECT));
	            var field = params['filter[field]'];
	            var operator = params['filter[operator]'];
	            var value = params['filter[value]'];
	            if ($.type(field) === STRING && $.type(operator) === STRING && $.type(value) === STRING) {
	                return { field: field, operator: operator, value: value };
	            }
	        };
	
	        /*******************************************************************************************
	         * Localization
	         * ===============
	         * Localization is tricky because views are only initialized (kendo ui widgets initialized)
	         * when first shown, so the view might not be available when the _localize function is called.
	         *
	         * It would make sense to localize views on the init event (in addition to a change of locale in the viewModel),
	         * but the init event is not triggered on the initial view. Also the navbar is not available until the show event.
	         *******************************************************************************************/
	
	        /**
	         * Localize the user interface
	         * @param language
	         * @private
	         */
	        mobile._localize = function (language) {
	            assert.type(ARRAY, app.locales, kendo.format(assert.messages.type.default, 'app.locales', ARRAY));
	            assert.enum(app.locales, language, kendo.format(assert.messages.enum.default, 'locale', app.locales));
	            localStorage.setItem(STORAGE.LANGUAGE, language);
	            i18n.load(language).then(function () {
	                viewModel.set('languages', i18n.culture.viewModel.languages);
	                viewModel.set('themes', i18n.culture.viewModel.themes);
	                mobile._localizeDrawerView(language);
	                mobile._localizeActivitiesView(language);
	                mobile._localizeCategoriesView(language);
	                mobile._localizeFavouritesView(language);
	                mobile._localizePlayerView(language);
	                mobile._localizeSettingsView(language);
	                mobile._localizeSummariesView(language);
	            });
	        };
	
	        /**
	         * Localize the drawer
	         * @param language
	         * @private
	         */
	        mobile._localizeDrawerView = function (language) {
	            assert.type(ARRAY, app.locales, kendo.format(assert.messages.type.default, 'app.locales', ARRAY));
	            assert.enum(app.locales, language, kendo.format(assert.messages.enum.default, 'language', app.locales));
	            var RX_REPLACE = /^(<[^<>\/]+>)(<\/[^<>\/]+>)([\s\S]+)$/i;
	            var drawerCulture = i18n.culture.drawer;
	            var drawerViewElement = $(DEVICE_SELECTOR + VIEW.DRAWER);
	            // categoriesElement.html() === '<span class="km-icon km-home"></span>Explore' and we only want to replace the Explore title
	            var categoriesElement = drawerViewElement.find('ul>li>a.km-listview-link:eq(0)');
	            categoriesElement.html(categoriesElement.html().replace(RX_REPLACE, '$1$2' + drawerCulture.categories));
	            var scanElement = drawerViewElement.find('ul>li>a.km-listview-link:eq(1)');
	            scanElement.html(scanElement.html().replace(RX_REPLACE, '$1$2' + drawerCulture.scan));
	            var favouritesElement = drawerViewElement.find('ul>li>a.km-listview-link:eq(2)');
	            favouritesElement.html(favouritesElement.html().replace(RX_REPLACE, '$1$2' + drawerCulture.favourites));
	            var activitiesElement = drawerViewElement.find('ul>li>a.km-listview-link:eq(3)');
	            activitiesElement.html(activitiesElement.html().replace(RX_REPLACE, '$1$2' + drawerCulture.activities));
	            var settingsElement = drawerViewElement.find('ul>li>a.km-listview-link:eq(4)');
	            settingsElement.html(settingsElement.html().replace(RX_REPLACE, '$1$2' + drawerCulture.settings));
	        };
	
	        /**
	         * Localize the activities view
	         * @param language
	         * @private
	         */
	        mobile._localizeActivitiesView = function (language) {
	            assert.type(ARRAY, app.locales, kendo.format(assert.messages.type.default, 'app.locales', ARRAY));
	            assert.enum(app.locales, language, kendo.format(assert.messages.enum.default, 'language', app.locales));
	            var activitiesCulture = i18n.culture.activities;
	            var activitiesViewElement = $(DEVICE_SELECTOR + VIEW.ACTIVITIES);
	            // Note: the view might not have been initialized yet
	            var activitiesView = activitiesViewElement.data('kendoMobileView');
	            if (activitiesView instanceof kendo.mobile.ui.View) {
	                mobile._setNavBarTitle(activitiesView, activitiesCulture.viewTitle);
	            }
	        };
	
	        /**
	         * Localize the categories view
	         * @param language
	         * @private
	         */
	        mobile._localizeCategoriesView = function (language) {
	            assert.type(ARRAY, app.locales, kendo.format(assert.messages.type.default, 'app.locales', ARRAY));
	            assert.enum(app.locales, language, kendo.format(assert.messages.enum.default, 'language', app.locales));
	            var categoriesCulture = i18n.culture.categories;
	            var categoriesViewElement = $(DEVICE_SELECTOR + VIEW.CATEGORIES);
	            // Note: the view might not have been initialized yet
	            var categoriesView = categoriesViewElement.data('kendoMobileView');
	            if (categoriesView instanceof kendo.mobile.ui.View) {
	                mobile._setNavBarTitle(categoriesView, categoriesCulture.viewTitle);
	            }
	        };
	
	        /**
	         * Localize the favourites view
	         * @param language
	         * @private
	         */
	        mobile._localizeFavouritesView = function (language) {
	            assert.type(ARRAY, app.locales, kendo.format(assert.messages.type.default, 'app.locales', ARRAY));
	            assert.enum(app.locales, language, kendo.format(assert.messages.enum.default, 'language', app.locales));
	            var favouritesCulture = i18n.culture.favourites;
	            var favouritesViewElement = $(DEVICE_SELECTOR + VIEW.FAVOURITES);
	            // The view may not have been intialized yet
	            var favouritesView = favouritesViewElement.data('kendoMobileView');
	            if (favouritesView instanceof kendo.mobile.ui.View) {
	                mobile._setNavBarTitle(favouritesView, favouritesCulture.viewTitle);
	            }
	        };
	
	        /**
	         * Localize the player view
	         * @param language
	         * @private
	         */
	        mobile._localizePlayerView = function (language) {
	            assert.type(ARRAY, app.locales, kendo.format(assert.messages.type.default, 'app.locales', ARRAY));
	            assert.enum(app.locales, language, kendo.format(assert.messages.enum.default, 'language', app.locales));
	            var playerCulture = i18n.culture.player;
	            var playersViewElement = $(DEVICE_SELECTOR + VIEW.PLAYER);
	            // mobile._setNavBarTitle is called when selectedPage is changed in the viewModel
	            playersViewElement.find('span.instructions').html(playerCulture.instructions);
	            playersViewElement.find('span.explanations').html(playerCulture.explanations);
	        };
	
	        /**
	         * Localize the settings view
	         * @param language
	         * @private
	         */
	        mobile._localizeSettingsView = function (language) {
	            assert.type(ARRAY, app.locales, kendo.format(assert.messages.type.default, 'app.locales', ARRAY));
	            assert.enum(app.locales, language, kendo.format(assert.messages.enum.default, 'language', app.locales));
	            var settingsCulture = i18n.culture.settings;
	            var settingsViewElement = $(DEVICE_SELECTOR + VIEW.SETTINGS);
	            // The view may not have been intialized yet
	            var settingsView = settingsViewElement.data('kendoMobileView');
	            if (settingsView instanceof kendo.mobile.ui.View) {
	                mobile._setNavBarTitle(settingsView, settingsCulture.viewTitle);
	            }
	            // Localize field labels
	            settingsViewElement.find('ul>li>label>span:not(.k-widget):eq(0)').text(settingsCulture.user);
	            settingsViewElement.find('ul>li>label>span:not(.k-widget):eq(1)').text(settingsCulture.version);
	            settingsViewElement.find('ul>li>label>span:not(.k-widget):eq(2)').text(settingsCulture.language);
	            settingsViewElement.find('ul>li>label>span:not(.k-widget):eq(3)').text(settingsCulture.theme);
	        };
	
	        /**
	         * Localize the summaries view
	         * @param language
	         * @private
	         */
	        mobile._localizeSummariesView = function (language) {
	            assert.type(ARRAY, app.locales, kendo.format(assert.messages.type.default, 'app.locales', ARRAY));
	            assert.enum(app.locales, language, kendo.format(assert.messages.enum.default, 'language', app.locales));
	            var summariesCulture = i18n.culture.summaries;
	            var summariesViewElement = $(DEVICE_SELECTOR + VIEW.SUMMARIES);
	            // The view may not have been intialized yet
	            var summariesView = summariesViewElement.data('kendoMobileView');
	            if (summariesView instanceof kendo.mobile.ui.View) {
	                mobile._setNavBarTitle(summariesView, summariesCulture.viewTitle);
	            }
	            // TODO localize Go button or use icon
	
	            // Localize actionsheet (it is not not within summariesViewElement)
	            var summariesActionSheetElement = $(DEVICE_SELECTOR + VIEW.SUMMARIES + '-actionsheet');
	            summariesActionSheetElement.find('li.km-actionsheet-cancel > a').text(summariesCulture.actionSheet.cancel);
	            summariesActionSheetElement.find('li.km-actionsheet-play > a').text(summariesCulture.actionSheet.play);
	            summariesActionSheetElement.find('li.km-actionsheet-share > a').text(summariesCulture.actionSheet.share);
	        };
	
	        /*******************************************************************************************
	         * Resizing
	         *******************************************************************************************/
	
	        /**
	         * Resize the UI
	         * @private
	         */
	        mobile._resize = function () {
	            mobile._resizePlayer();
	        };
	
	        /**
	         * Resize player
	         * @private
	         */
	        mobile._resizePlayer = function () {
	            var content = $(DEVICE_SELECTOR + VIEW.PLAYER).find(kendo.roleSelector('content'));
	            var stageElement = content.find(kendo.roleSelector('stage'));
	            // If the stage widget has not yet been initialized, we won't get the correct stageWrapper
	            if (stageElement.data('kendoStage') instanceof kendo.ui.Stage) {
	                var height = content.height();
	                var width = content.width();
	                var stageWrapper = stageElement.parent();
	                assert.ok(stageWrapper.hasClass('kj-stage'), 'Stage wrapper is expected to have class `kj-stage`');
	                var stageContainer = stageWrapper.closest('.stretched-item');
	                var markdownElement = content.find(kendo.roleSelector('markdown'));
	                var markdownScrollerElement = markdownElement.closest(kendo.roleSelector('scroller'));
	                var markdownScroller = markdownScrollerElement.data('kendoMobileScroller');
	                var markdownContainer = markdownElement.closest('.stretched-item');
	                var markdownHeading = markdownContainer.children('.heading');
	                // Resize the stage
	                var scale = (height > width) ? width / stageWrapper.outerWidth() : height / stageWrapper.outerHeight();
	                stageWrapper.css('transform', 'scale(' + scale + ')');
	                stageContainer.height(Math.floor(scale * stageWrapper.outerHeight()));
	                stageContainer.width(Math.floor(scale * stageWrapper.outerWidth()));
	                // Resize the markdown container and scroller for instructons/explanations
	                markdownContainer.outerHeight((height > width) ? height - stageContainer.outerHeight() : height);
	                markdownContainer.outerWidth((height > width) ? width : width - stageContainer.outerWidth());
	                markdownScroller.destroy();
	                markdownScrollerElement.outerHeight(markdownContainer.height() - markdownHeading.outerHeight() - parseInt(markdownContainer.css('padding-bottom'), 10));
	                markdownScrollerElement.kendoMobileScroller();
	            }
	        };
	
	        /*******************************************************************************************
	         * Event handler and utility methods
	         *******************************************************************************************/
	
	        /**
	         * Event Handler triggered when the device is ready (this is a cordova event)
	         * Loads the application
	         */
	        mobile.onDeviceReady = function () {
	            // Setup ajax with longer timeout on mobile devices
	            $.ajaxSetup({ timeout: app.constants.ajaxTimeout });
	            // Load settings including locale and theme
	            viewModel.loadSettings();
	            viewModel.summaries.pageSize(VIRTUAL_PAGE_SIZE);
	            // initialize secure storage
	            window.secureStorage.init('myApp'); // ------------------------------------------------------------------------ TODO myApp
	            // Wait for i18n resources to be loaded
	            $(document).on(LOADED, function () {
	                // Initialize application
	                mobile.application = new kendo.mobile.Application($(DEVICE_SELECTOR), {
	                    initial: DEVICE_SELECTOR + VIEW.CATEGORIES,
	                    // platform: "ios7",
	                    skin: viewModel.get(VIEWMODEL.THEME),
	                    // http://docs.telerik.com/platform/appbuilder/troubleshooting/archive/ios7-status-bar
	                    // http://www.telerik.com/blogs/everything-hybrid-web-apps-need-to-know-about-the-status-bar-in-ios7
	                    // http://devgirl.org/2014/07/31/phonegap-developers-guid/
	                    statusBarStyle: (window.device && window.device.cordova) ? 'black-translucent' : undefined,
	                    init: function (e) {
	                        viewModel.set('languages', i18n.culture.viewModel.languages);
	                        viewModel.set('themes', i18n.culture.viewModel.themes);
	                    }
	                });
	            });
	            // Handle resize event (especially when changing device orientation)
	            $(window).resize(mobile._resize);
	        };
	
	        /**
	         * Event handler triggered when initializing the Drawer view
	         * Note: the init event is triggered the first time the view is requested
	         * @param e
	         */
	        mobile.onDrawerViewInit = function (e) {
	            assert.isPlainObject(e, kendo.format(assert.messages.isPlainObject.default, 'e'));
	            mobile._localizeDrawerView(viewModel.get(VIEWMODEL.LANGUAGE));
	            // mobile._setNavBar(e.view);
	        };
	
	        /**
	         * Event handler trigger when clicking an item in teh drawe menu
	         * @see https://github.com/phonegap/phonegap-plugin-barcodescanner
	         * @param e
	         */
	        mobile.onDrawerListViewClick = function (e) {
	            assert.isPlainObject(e, kendo.format(assert.messages.isPlainObject.default, 'e'));
	            assert.instanceof($, e.item, kendo.format(assert.messages.instanceof.default, 'e.item', 'jQuery'));
	            if (e.item.is('[data-icon=scan]')) {
	                e.preventDefault();
	                if (window.cordova && window.cordova.plugins && window.cordova.plugins.barcodeScanner && $.isFunction(window.cordova.plugins.barcodeScanner.scan)) {
	                    window.cordova.plugins.barcodeScanner.scan(
	                        function (result) {
	                            alert("We got a barcode\n" +
	                                "Result: " + result.text + "\n" +
	                                "Format: " + result.format + "\n" +
	                                "Cancelled: " + result.cancelled);
	                        },
	                        function (error) {
	                            alert("Scanning failed: " + error);
	                        },
	                        {
	                            "preferFrontCamera": true, // iOS and Android
	                            "showFlipCameraButton": true, // iOS and Android
	                            "prompt": "Place a barcode inside the scan area", // supported on Android only
	                            "formats": "QR_CODE", // default: all but PDF_417 and RSS_EXPANDED
	                            "orientation": "landscape" // Android only (portrait|landscape), default unset so it rotates with the device
	                        }
	                    );
	                } else {
	                    // TODO Error
	                }
	            }
	        };
	
	        /**
	         * Event handler triggered when showing the Activities view
	         * Note: the view event is triggered each time the view is requested
	         * @param e
	         */
	        mobile.onActivitiesViewShow = function (e) {
	            assert.isPlainObject(e, kendo.format(assert.messages.isPlainObject.default, 'e'));
	            mobile._localizeActivitiesView(viewModel.get(VIEWMODEL.LANGUAGE));
	            mobile._setNavBar(e.view);
	        };
	
	        /**
	         * Event handler triggered when showing the Categories view
	         * Note: the view event is triggered each time the view is requested
	         * @param e
	         */
	        mobile.onCategoriesViewShow = function (e) {
	            assert.isPlainObject(e, kendo.format(assert.messages.isPlainObject.default, 'e'));
	            mobile._localizeCategoriesView(viewModel.get(VIEWMODEL.LANGUAGE));
	            mobile._setNavBar(e.view);
	        };
	
	        /**
	         * Event handler triggered when showing the Favourites view
	         * Note: the view event is triggered each time the view is requested
	         * @param e
	         */
	        mobile.onFavouritesViewShow = function (e) {
	            assert.isPlainObject(e, kendo.format(assert.messages.isPlainObject.default, 'e'));
	            mobile._localizeFavouritesView(viewModel.get(VIEWMODEL.LANGUAGE));
	            mobile._setNavBar(e.view);
	        };
	
	        /**
	         * Event handler triggered when initializing the Player view
	         * Note: the init event is triggered the first time the view is requested
	         * @param e
	         */
	        mobile.onPlayerViewInit = function (e) {
	            assert.isPlainObject(e, kendo.format(assert.messages.isPlainObject.default, 'e'));
	            e.view.content.kendoTouch({
	                enableSwipe: true,
	                minXDelta: 150,
	                maxDuration: 500,
	                swipe: function (e) {
	                    if (e.direction === 'left') {
	                        viewModel.nextPage();
	                    } else if (e.direction === 'right') {
	                        viewModel.previousPage();
	                    }
	                }
	            });
	        };
	
	        /**
	         * Event handler triggered when showing the Player view
	         * Note: the view event is triggered each time the view is requested
	         * @param e
	         */
	        mobile.onPlayerViewShow = function (e) {
	            assert.isPlainObject(e, kendo.format(assert.messages.isPlainObject.default, 'e'));
	            assert.instanceof(kendo.mobile.ui.View, e.view, kendo.format(assert.messages.instanceof.default, 'e.view', 'kendo.mobile.ui.View'));
	            assert.isPlainObject(e.view.params, kendo.format(assert.messages.isPlainObject.default, 'e.view.params'));
	            assert.match(RX_MONGODB_ID, e.view.params.summaryId, kendo.format(assert.messages.match.default, 'e.view.params.summaryId', RX_MONGODB_ID));
	            assert.match(RX_MONGODB_ID, e.view.params.versionId, kendo.format(assert.messages.match.default, 'e.view.params.versionId', RX_MONGODB_ID));
	            // Localize UI (cannot be done in init because it may have changed during the session)
	            mobile._localizeSettingsView(viewModel.get(VIEWMODEL.LANGUAGE));
	            // Set the navigation bar buttons
	            mobile._setNavBar(e.view);
	            // Load the viewModel with relevant version
	            viewModel.loadVersion(e.view.params.summaryId, e.view.params.versionId)
	                .done(function () {
	                    mobile._resizePlayer(e.view);
	                    viewModel.setCurrent();
	                    viewModel.set(VIEWMODEL.SELECTED_PAGE, viewModel.get(VIEWMODEL.PAGES_COLLECTION).at(0));
	                });
	        };
	
	        /**
	         *
	         * @param e
	         */
	        mobile.onScoreViewShow = function (e) {
	
	        };
	
	        /**
	         * Event handler triggered when showing the Settings view
	         * Note: the view event is triggered each time the view is requested
	         * @param e
	         */
	        mobile.onSettingsViewShow = function (e) {
	            assert.isPlainObject(e, kendo.format(assert.messages.isPlainObject.default, 'e'));
	            mobile._localizeSettingsView(viewModel.get(VIEWMODEL.LANGUAGE));
	            mobile._setNavBar(e.view);
	        };
	
	        /**
	         * Event handler triggered before showing the Summaries view
	         */
	        mobile.onSummariesBeforeViewShow = function () {
	            // Unfortunately, the following does not display the loader
	            // if (mobile.application instanceof kendo.mobile.Application) {
	            //    mobile.application.pane.loader.show();
	            // }
	            // Workaround
	            // ------------
	            // Clearing here the summaries data source avoids a "flickering" effect
	            // where previous results are replaced by new results after the view is shown
	            // Note that we have tried unsuccessfully to use the loader to hide the UI changes as explained at
	            // http://www.telerik.com/forums/-bug-report-databound-event-not-firing-for-kendomobilelistview
	            viewModel.summaries.data([]);
	        };
	
	        /**
	         * Event handler triggered when showing the Summaries view
	         * Note: the view event is triggered each time the view is requested
	         * @param e
	         */
	        mobile.onSummariesViewShow = function (e) {
	            assert.isPlainObject(e, kendo.format(assert.messages.isPlainObject.default, 'e'));
	            mobile._localizeSummariesView(viewModel.get(VIEWMODEL.LANGUAGE));
	            mobile._setNavBar(e.view);
	            // Launch the query
	            var query = {
	                filter: mobile._getDataFilter(e.view.params),
	                page: 1,
	                pageSize: viewModel.summaries.pageSize()
	            };
	            viewModel.loadLazySummaries(query);
	            // See comment for mobile.onSummariesBeforeViewShow
	            // .always(function () {
	            //    mobile.application.pane.loader.hide();
	            // });
	        };
	
	        /**
	         * Event handler for clicking the play option in the action sheet displayed from the GO button of summaries
	         * @param e
	         */
	        mobile.onSummariesActionPlay = function (e) {
	            assert.isPlainObject(e, kendo.format(assert.messages.isPlainObject.default, 'e'));
	            assert.match(RX_MONGODB_ID, e.context, kendo.format(assert.messages.match.default, 'e.context', RX_MONGODB_ID));
	            var summaryId = e.context;
	            // Find latest version (previous versions are not available in the mobile app)
	            viewModel.loadLazyVersions(summaryId)
	                .done(function () {
	                    var version = viewModel.versions.at(0); // First is latest version
	                    assert.instanceof(app.models.LazyVersion, version, kendo.format(assert.messages.instanceof.default, 'version', 'app.models.LazyVersion'));
	                    assert.match(RX_MONGODB_ID, version.id, kendo.format(assert.messages.match.default, 'version.id', RX_MONGODB_ID));
	                    mobile.application.navigate(DEVICE_SELECTOR + VIEW.PLAYER + '?summaryId=' + window.encodeURIComponent(summaryId) + '&versionId=' + window.encodeURIComponent(version.id));
	                });
	        };
	
	        /**
	         * Event handler for clicking the share option in the action sheet displayed from the GO button of summaries
	         * @see https://github.com/EddyVerbruggen/SocialSharing-PhoneGap-Plugin
	         * @param e
	         */
	        mobile.onSummariesActionShare = function (e) {
	            //
	            // this is the complete list of currently supported params you can pass to the plugin (all optional)
	            var options = {
	                message: 'share this', // not supported on some apps (Facebook, Instagram)
	                subject: 'the subject', // fi. for email
	                files: ['', ''], // an array of filenames either locally or remotely
	                url: 'https://www.website.com/foo/#bar?a=b',
	                chooserTitle: 'Pick an app' // Android only, you can override the default share sheet title
	            };
	
	            var onSuccess = function(result) {
	                console.log("Share completed? " + result.completed); // On Android apps mostly return false even while it's true
	                console.log("Shared to app: " + result.app); // On Android result.app is currently empty. On iOS it's empty when sharing is cancelled (result.completed=false)
	            };
	
	            var onError = function(msg) {
	                console.log("Sharing failed with message: " + msg);
	            };
	
	            if (window && window.plugins && window.plugins.socialsharing && $.isFunction(window.plugins.socialsharing.shareWithOptions)) {
	                window.plugins.socialsharing.shareWithOptions(options, onSuccess, onError);
	            } else {
	                navigator.notification.alert('Something went wrong...', null, 'Error', 'OK');
	            }
	        };
	
	
	        /**
	         * Event handler for clicking the previous button in the navbar
	         * @param e
	         */
	        mobile.onNavbarPreviousClick = function (e) {
	            viewModel.previousPage();
	        };
	
	        /**
	         * Event handler for clicking the next button in the navbar
	         * @param e
	         */
	        mobile.onNavbarNextClick = function (e) {
	            viewModel.nextPage();
	        };
	
	        /**
	         * Event handler for clicking the submit button in the navbar
	         * @param e
	         */
	        mobile.onNavbarSubmitClick = function (e) {
	            if (window.device && window.device.cordova) {
	                // https://github.com/apache/cordova-plugin-dialogs
	                navigator.notification.confirm(
	                    'You are the winner!', // message
	                    mobile.onNavbarSubmitConfirm,       // callback to invoke with index of button pressed
	                    'Confirm',             // title
	                    ['Yes', 'No']           // buttonLabels
	                );
	            } else if (window.confirm('?')) {
	                mobile.onNavbarSubmitConfirm(1);
	            }
	        };
	
	        /**
	         * Event handler for confirming after clicking the submit button in the navbar
	         * @param buttonIndex
	         */
	        mobile.onNavbarSubmitConfirm = function (buttonIndex) {
	            if (buttonIndex !== 1) {
	                return;
	            }
	
	        };
	
	        /**
	         * Event handler for clicking the sync button in the navbar
	         * @param e
	         */
	        mobile.onNavbarSyncClick = function (e) {
	            $.noop(e); // TODO
	        };
	
	        /**
	         * Event handler for clicking the search button in the navbar
	         * @param e
	         */
	        mobile.onNavbarSearchClick = function (e) {
	            mobile.application.navigate(DEVICE_SELECTOR + VIEW.SUMMARIES);
	            // @see http://www.telerik.com/forums/hiding-filter-input-in-mobile-listview
	            // var summaryView = $(DEVICE_SELECTOR + VIEW.SUMMARIES);
	            // summaryView.find(kendo.roleSelector('listview')).getKendoMobileListView()._filter._clearFilter({ preventDefault: $.noop });
	            // summaryView.find('.km-filter-form').show();
	        };
	
	        /*******************************************************************************************
	         * Application initialization
	         *******************************************************************************************/
	
	        $(function () {
	            // $(document).on(LOADED, function () {
	            if ($.type(window.device) !== UNDEFINED && $.type(window.device.cordova) !== UNDEFINED) {
	                // Wait for Cordova to load
	                document.addEventListener('deviceready', mobile.onDeviceReady, false);
	            } else {
	                // No need to wait when running/debugging on a PC
	                mobile.onDeviceReady();
	            }
	        });
	
	
	    }(window.jQuery));
	
	    /* jshint +W071 */
	
	    return window.app;
	
	}, __webpack_require__(200));


/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(178);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(180)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/less-loader/index.js!./kidoju.widgets.mediaplayer.less", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/less-loader/index.js!./kidoju.widgets.mediaplayer.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(179)();
	// imports
	
	
	// module
	exports.push([module.id, ".kj-mediaplayer video {\n  background-color: #000000;\n  background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjEwMjRweCIgaGVpZ2h0PSIxMDI0cHgiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIiB0ZXh0LXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIiBpbWFnZS1yZW5kZXJpbmc9Im9wdGltaXplUXVhbGl0eSIgZmlsbC1ydWxlPSJub256ZXJvIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIHZpZXdCb3g9IjAgMCAxMDI0MCAxMDI0MCIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxwYXRoIGlkPSJjdXJ2ZTIiIGZpbGw9IiM4MDgwODAiIGQ9Ik04MTE5IDY0MDBsMTgwMSAwIDAgMjU2MCAtNDE1OCAwYzIxNSwtOTAgNDIxLC0xOTcgNjE2LC0zMjBsMjIgMCAwIC0xNGMxMTAsLTcxIDIxNywtMTQ2IDMyMCwtMjI3bDAgMjQxIDMyMCAwIDAgLTMyMCAtMjIyIDBjNTEzLC00MjYgOTIxLC05NzMgMTE4MiwtMTU5OGwwIDMxOCAzMjAgMCAwIC0zMjAgLTMxOSAwYzQ0LC0xMDUgODMsLTIxMSAxMTgsLTMyMHptLTc1OSAxOTIwbDAgMzIwIDMyMCAwIDAgLTMyMCAtMzIwIDB6bTY0MCAwbDAgMzIwIDMyMCAwIDAgLTMyMCAtMzIwIDB6bTY0MCAwbDAgMzIwIDMyMCAwIDAgLTMyMCAtMzIwIDB6bTY0MCAwbDAgMzIwIDMyMCAwIDAgLTMyMCAtMzIwIDB6bS02NDAgLTE2MDBsMCAzMjAgMzIwIDAgMCAtMzIwIC0zMjAgMHptNjQwIDBsMCAzMjAgMzIwIDAgMCAtMzIwIC0zMjAgMHoiLz48cGF0aCBpZD0iY3VydmUxIiBmaWxsPSIjODA4MDgwIiBkPSJNNTM1OCA3MzE0bC01OTUgLTgyMGMtNzYsLTEwNSAtMjAwLC0xNTIgLTMyNywtMTI0IC0xODEsNDAgLTM3MSw0MCAtNTUyLDAgLTEyNywtMjggLTI1MSwxOSAtMzI3LDEyNGwtNTk1IDgyMGMtNjAsODIgLTc3LDE3OSAtNDgsMjc3IDI4LDk5IDk0LDE3MSAxOTAsMjA5IDY3NiwyNjUgMTQzNiwyNjUgMjExMiwwIDk2LC0zOCAxNjIsLTExMCAxOTAsLTIwOSAyOSwtOTggMTIsLTE5NSAtNDgsLTI3N3ptLTIzMDIgLTE1NDZjLTk0LC0xNjAgLTE1MiwtMzM4IC0xNzAsLTUyMyAtMTIsLTEzMCAtOTYsLTIzNCAtMjIwLC0yNzRsLTk2MyAtMzEzYy05NywtMzEgLTE5NCwtMTcgLTI3OSw0MCAtODQsNTggLTEzMywxNDMgLTEzOSwyNDUgLTQ0LDcyOCAxODgsMTQ0NiA2NTMsMjAxMCA2Niw3OSAxNTUsMTE5IDI1NywxMTYgMTAyLC0zIDE4OSwtNDkgMjQ5LC0xMzJsNTk1IC04MTljNzcsLTEwNSA4MywtMjM4IDE3LC0zNTB6bTE0NiAtMTQ5N2MxMjMsLTEzOCAyNzUsLTI1MCA0NDYsLTMyNCAxMTksLTUzIDE5MiwtMTY0IDE5MiwtMjk0bDAgLTEwMTJjMCwtMTAzIC00MywtMTkxIC0xMjQsLTI1MyAtODEsLTYzIC0xNzcsLTgzIC0yNzYsLTU3IC03MTUsMTg0IC0xMzIzLDYzNiAtMTcxMCwxMjQyIC01NSw4NiAtNjYsMTg0IC0zMSwyODAgMzQsOTcgMTA1LDE2NSAyMDIsMTk3bDk2MyAzMTNjMTI0LDQwIDI1Miw1IDMzOCwtOTJ6bTE0NzAgLTMyNGMxNzEsNzQgMzIzLDE4NiA0NDYsMzI0IDg2LDk3IDIxNCwxMzIgMzM4LDkybDk2MyAtMzEzYzk3LC0zMiAxNjgsLTEwMCAyMDIsLTE5NyAzNSwtOTYgMjQsLTE5NCAtMzEsLTI4MCAtMzg3LC02MDYgLTk5NSwtMTA1OCAtMTcxMCwtMTI0MiAtOTksLTI2IC0xOTUsLTYgLTI3Niw1NyAtODEsNjIgLTEyNCwxNTAgLTEyNCwyNTNsMCAxMDEyYzAsMTMwIDczLDI0MSAxOTIsMjk0em0xNzA5IDMwMDZjNDY2LC01NjQgNjk4LC0xMjgyIDY1NCwtMjAxMCAtNiwtMTAyIC01NSwtMTg3IC0xMzksLTI0NSAtODUsLTU3IC0xODIsLTcxIC0yNzksLTQwbC05NjMgMzEzYy0xMjQsNDAgLTIwOCwxNDQgLTIyMCwyNzQgLTE4LDE4NSAtNzYsMzYzIC0xNzAsNTIzIC02NiwxMTIgLTYwLDI0NSAxNywzNTBsNTk1IDgxOWM2MCw4MyAxNDcsMTI5IDI0OSwxMzIgMTAyLDMgMTkxLC0zNyAyNTYsLTExNnoiLz48cGF0aCBpZD0iY3VydmUwIiBmaWxsPSIjODA4MDgwIiBkPSJNNDE2MCAxNjAwYzE5NDQsMCAzNTIwLDE1NzYgMzUyMCwzNTIwIDAsMTk0NCAtMTU3NiwzNTIwIC0zNTIwLDM1MjAgLTE5NDQsMCAtMzUyMCwtMTU3NiAtMzUyMCwtMzUyMCAwLC0xOTQ0IDE1NzYsLTM1MjAgMzUyMCwtMzUyMHptMCAzMjAwYzE3NywwIDMyMCwxNDMgMzIwLDMyMCAwLDE3NyAtMTQzLDMyMCAtMzIwLDMyMCAtMTc3LDAgLTMyMCwtMTQzIC0zMjAsLTMyMCAwLC0xNzcgMTQzLC0zMjAgMzIwLC0zMjB6bTAgLTMyMGMtMzUzLDAgLTY0MCwyODcgLTY0MCw2NDAgMCwzNTMgMjg3LDY0MCA2NDAsNjQwIDM1MywwIDY0MCwtMjg3IDY0MCwtNjQwIDAsLTM1MyAtMjg3LC02NDAgLTY0MCwtNjQwem0wIC0zMjAwYy0yMTIxLDAgLTM4NDAsMTcxOSAtMzg0MCwzODQwIDAsMjEyMSAxNzE5LDM4NDAgMzg0MCwzODQwIDIxMjEsMCAzODQwLC0xNzE5IDM4NDAsLTM4NDAgMCwtMjEyMSAtMTcxOSwtMzg0MCAtMzg0MCwtMzg0MHoiLz48L3N2Zz4=);\n  background-position: center;\n  background-repeat: no-repeat;\n  background-size: contain;\n}\n.kj-mediaplayer .kj-mediaplayer-toolbar .kj-mediaplayer-button {\n  border-radius: 50%;\n}\n.kj-mediaplayer .kj-mediaplayer-toolbar .kj-mediaplayer-button svg > path {\n  fill: #000000;\n}\n.kj-mediaplayer .kj-mediaplayer-toolbar .kj-mediaplayer-time {\n  color: #000000;\n}\n", ""]);
	
	// exports


/***/ },
/* 179 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(182);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(180)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/less-loader/index.js!./kidoju.widgets.messagebox.less", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/less-loader/index.js!./kidoju.widgets.messagebox.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(179)();
	// imports
	
	
	// module
	exports.push([module.id, ".k-dialog .k-notification-wrap {\n  white-space: initial;\n}\n.k-dialog .k-dialog-buttongroup .k-button .k-image {\n  height: 1.5em;\n  width: 1.5em;\n  margin-right: 0.25em;\n  vertical-align: middle;\n}\n", ""]);
	
	// exports


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(184);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(180)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/less-loader/index.js!./kidoju.widgets.multicheckbox.less", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/less-loader/index.js!./kidoju.widgets.multicheckbox.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(179)();
	// imports
	
	
	// module
	exports.push([module.id, ".kj-multicheckbox .kj-multicheckbox-item {\n  margin-bottom: 0.15em;\n}\n.kj-multicheckbox .k-checkbox-label {\n  vertical-align: initial;\n}\n.km-nova .kj-multicheckbox input[type=checkbox] {\n  opacity: 0;\n}\n", ""]);
	
	// exports


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(186);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(180)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/less-loader/index.js!./kidoju.widgets.quiz.less", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/less-loader/index.js!./kidoju.widgets.quiz.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(179)();
	// imports
	
	
	// module
	exports.push([module.id, ".kj-quiz .kj-quiz-item {\n  margin-bottom: 0.15em;\n}\n.kj-quiz .kj-quiz-item input.k-radio {\n  display: none;\n}\n.kj-quiz .kj-quiz-item .k-radio-label {\n  vertical-align: initial;\n}\n.kj-quiz .kj-quiz-item .k-radio-label:before {\n  border-width: 0.05em;\n  top: 0.1em;\n  left: 0.1em;\n  width: 0.8em;\n  height: 0.8em;\n}\n.kj-quiz .kj-quiz-item .k-radio:checked + .k-radio-label:after {\n  width: 0.7em;\n  height: 0.7em;\n  top: 0.2em;\n  left: 0.2em;\n}\n.k-ff .kj-quiz input.k-button {\n  padding-bottom: initial;\n  padding-top: initial;\n}\n", ""]);
	
	// exports


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(188);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(180)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/less-loader/index.js!./kidoju.widgets.rating.less", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/less-loader/index.js!./kidoju.widgets.rating.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(179)();
	// imports
	
	
	// module
	exports.push([module.id, "/*Copyright ©2011-2012 Memba® Sarl. All rights reserved.*/\n/*******************************************************************/\n/* Rating (kendoRating)\n/*******************************************************************/\n.kj-rating {\n  border: 0 !important;\n  outline: 0;\n}\n.kj-rating .kj-rating-star {\n  background: none;\n  border: 0;\n  box-shadow: none;\n}\n.kj-rating .k-state-selected:not(.k-state-hover) {\n  color: #4D82B8;\n}\n.kj-rating:not(.k-state-disabled) .kj-rating-star {\n  cursor: pointer;\n}\n.kj-rating:not(.k-state-disabled) .k-state-hover {\n  background: none;\n  border: 0;\n  color: #EDC87E;\n}\n", ""]);
	
	// exports


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(190);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(180)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/less-loader/index.js!./kidoju.widgets.stage.less", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/less-loader/index.js!./kidoju.widgets.stage.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(179)();
	// imports
	
	
	// module
	exports.push([module.id, ".kj-stage .kj-element input.k-textbox {\n  text-indent: initial;\n}\n.kj-stage .kj-element-result {\n  position: relative;\n  height: 0 !important;\n}\n.kj-stage .kj-nopage {\n  font-size: xx-large;\n}\n.kj-handle-box {\n  border: 1px solid darkgray;\n  opacity: 0.5;\n  cursor: default;\n}\n.kj-handle-box .kj-handle {\n  pointer-events: all;\n  position: absolute;\n  display: block;\n  width: 36px;\n  height: 36px;\n  /*TODO: replace png sprites with SVG icons*/\n  background: url(" + __webpack_require__(191) + ") no-repeat left top;\n  cursor: pointer;\n  z-index: 0;\n}\n.kj-handle-box .kj-handle[data-command=\"move\"] {\n  left: -9px;\n  top: -10px;\n  background-position: left -144px;\n}\n.kj-handle-box .kj-handle[data-command=\"resize\"] {\n  bottom: -10px;\n  right: -13px;\n  background-position: left -72px;\n}\n.kj-handle-box .kj-handle[data-command=\"rotate\"] {\n  top: -10px;\n  right: -13px;\n  background-position: left -36px;\n}\n.kj-handle-box .kj-handle[data-command=\"menu\"] {\n  left: -9px;\n  bottom: -10px;\n  background-position: left -108px;\n}\n", ""]);
	
	// exports


/***/ },
/* 191 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAAC0CAYAAAA3vWolAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAGzlJREFUeNrsXQd0VcXWnoQYCAZRmmKQkqCAtNAUELDRfCo/YoOlFFGKdP0XuihKEQF5awFGihR/ARuWJzxdqAiIDxDkUaWaCHlIMYKGgATSIPn3Nzlz37kn58yZOffEevZas+49bfacb/bsmdnz3blRRUVFzCpr165lEqlJ6QFK9ShVNY4hRyn9RCmV0gcdO3Y8yv4EEqUIUBylYZR6lytXrnG1atXY5Zdfzi677DJGx/yG3NxcVlBQwM6fP89OnTqF4710+g1KcwisnNJ6gTfeeCOi53v37h0RQGUo9aP0Ys2aNa++9tprOTCXLl1ihYWFDM+K56OioniKjo5mZcqU4UD98MMP7OjRoyfp8jhKSwioS9LC0PO6smzZMiWLNo5LSJ8+fWzzDb2XBKBKlN4lUDrWqFGDxcXFhYBREQFUTk4OO378OMBCpg8TSKcjBYhACVk0VVjjWrVqsSuuuIKVLVuWVyAEFZSXl8d++eUX9v333+M4ZNGUciIFCLXxaR0SKC/Iz2d29ym1YXrpy2JjeSH/Q0Kn7iKQUr0ARMAIi55y4403XpOUlMSBARCi8kQFooJEJQE4AHX48GF24MCBH+nyeFg0pUvaABE4CfSx+4YbbqhyNfkaKPZDUNCT5JvS0tJ+psNkAumEDkAEDix6ed26dTtR2Vj58uU5MBcvXlTSHxMTw4G6cOECysAOHTq0hk73JIBOKwNE4MRRIb8mw2lSvXp1VqTYnJStiWo0IyMDlrSH9La2Om8ngAicenT/qiZNmiTVr1+fv2Shx7LBqgDut99+y/bs2XOYdN5NIKU6ARRtOT/nuuuua3LNNdcUO2Hc6GNCnsgbOuhwnqK/SaDCbmjVqlUSVRw7d+4ct2rRQegmPIs8kBfyRN7Q4QioyXqS6eOxGgkJxZYDBEshIW/oIOlr6JQ6Y3qBj5OTk6tdffXVLJ98oV+CvJAn8oYOw/E7A0Q+4pXrr78+yqszDhubvPkmW7BwIfvpp58cHSB0QacsH7K4FHLGzTC8gK/xajVOCXkib+ggXXMdAUJNUjferkrlyhGDA2A+++wztmHDBjZ23Djee9kJdEGnkxVRjSaTf+iPplDosy+0VAJvbqSrL3TaAkQe/n+rVKkSsY8BOABGCJzplBdfZOfp0+7+qlWrQvdou4LTqHwGmX+0H5bz7rvvsiVLlrCff/7Z0ZKgCzptAaKbul5RoUJEvmXhggVh4JhB2ojzNs9UiI+H7i521kPTmU7wEZHK0qVL2bp169jmzZvZlClT2LFjx2zvgy7otFpRNJl4PCweXZ9XWQjL2bjR9hpGto0aN7a9ZuisbJQhJNnZ2QPQ20VqObAaAGOurJkzZ/JRtt39GNrQtUFhAJGJt8I0IqJmJQHnhRdeYJiqOD0P3SiDZVDXtWLFihGBA8vZsmWLrUV//fXXts9gVE4dR+cwgGJjY1tjlOmpWRE4G13AgekWYjTukAd0owym5hVPkkjJs0VTHrbgiHLRgNP2GnRCN8oQAogGTjUwDdBuVosWqYPjMrKle64Rx2TiTfC835YjyjV58mReLqfncQ/KECofDZjK6863/AJHdLO5eXkhB5iZmZmIOJNXy0HzkYGDZoS4lZNAN8oQau6EVhacpeoAcdHixe7gYJKrOIlEYckvnDMBVgUWrTtgReDMDZwK1FO7jcZh0VSmiiGAaPL4XQXF9q4MjoZFIhJJI+5D4pjmSbli7KMqb9LI3Q0c+BeVqQrKTmUKmVj0ihUrNqPGLuTIo6KrV69mSYmJrGfPnqGgVKTgQGcZqrFVq1ZtFedycnJOypqAV3BU8zTCxqE5UjS9OEKiOQgoybrztO++Y13vuot1796dg2EFB3Hqi5hlawwRoBO6qZJCsaFt27btcRqnWJNKs8JnvhHwU0kYBuzbt2+/eSSdmXn69JFMGobLuvQjR46w79LSWB41iWo0Rbjjjjv+Cw4dc5+jOUyATuimMmSJAm3duvVoVlZWBg0WpS+yfv16hsCZk0V7AQc6T58+nfHll1+GJpDRdKGAJpcfoTdxmn1jDoNr06ZP54Gm/fv3s5MnT/4XHA9RR+QHndBNZcgzW/mpU6f2njlzRvo8KgyVdBdZNcBwAkdHoBO66Wte2FyMBnyr8wsKMo7QzNvOOYr5C7rur2joTiizoUOHegYHOqALOqHben3Pnj0f/vjjj9LaRpkOHjzIXwq9sLBogCPCsbpjKOiE7rBRvfF5gAq6YsSIEU8eO3486jqaGpildu3abOXKlRwMpIvkyNDTqMaDSwB+/DhepiglJWUFdFuvk66Vbdu2HUVzo/qYH1kFFQQLfOWVV9gTTzzBzyGUK8DxEljD84cOHfoWuu1m8yeXL1++9kxWVloWKQeSZqlUqRKja+wcOdUL5EBRAK8xGuQNHdBFOr+AbpvbTn7++eeL0tLSCs3rbyLhZSCY0G7fvp07+yFDhvB5nRfLgQ7oog5rMXTbLhxGRUVRi6n6+McffTSaut+rEBZFvMZPQa0fP3GClY+Ly7q3W7e/0/FrpP+UQ9C+2qRJkz5p165di8TExLB8sNbWoEEDXlFIGEshebXo9PR0tmnTph0TJkz4Gx2esg3ao6BU4F2jR49eeNWVV+ae+OEHvjLqlyAv5Im8oQO6zODYyKmXX355MvmZDPgbc41jXIMlthMENkBHEB7jFy9zN8OXZUCXAMc2Ji1i9xs3bdr/4tSpi2nOcuE0NaujR4/yGvM6ecSzyAN5IU/kDR3Q5QYq+ZpP5s+fP4PMP1s0K4hXS7HzO8gbOqBLaW2ezBzzjkcbNWqUMG/evMfJmVY/e/Ysb27otVQnkqhRMklew4jt0OAvg/zEazQIw5suI73ZiguH8a1bt362X79+w+rVq3dlzZo1fQEHlZaamnrm9ddfn0tjr+mI0ykvPVNBsYp5H9V4lalTp955a4cOHaiNlz1HAynyHyyeJn2xBFTZcuX4VIHPYcjRYRBJXTfLJpPHNAJzvHLlyuX9a8OGDWPHjl1HzhSrqitJZ6bm0nMlAqbPqFGjhjVu3DgJztlrBBQjZXQUe/fuPTx79uw5BBTW6zO1yQudOnUCr+V/KNWoU6fO5ZMmTuzcNDm5Ob1EHIBAd19gmlTyNfiYmOK1cAKOzud8s3v3zgkTJ35O/uI83XKc0j/pfK5H8kI5sub7e/XqdX+bNm26UJnKYwgQGxurvA5mrOpe2LJly+p33nnnH2TV/8B82Su7AyChxAgetcEgFeeomTRqffPN11OzqVi5SpVKMWXK8BLSPCyfpg6nqTme/Xrr1u+oee4TMTBKiGBhubnIjejgtnqN8tC87w4CqkvDhg3b0vcKaMIACt18tGHR6Lrh/wAMXASNkM/RDGAzAbOavn+B8ixbtqzIE7vDpuBwPM0oNWTFtBgVASkAzhi9ldJUWoMfFCpPx44dWxFQieQOKl511VVVyYLLGmGLPJrT/UTN+iwBk06Vvk2Uh4AJlccVoE0O8R0nade+PYJJoMdUNKxKBJOyDWs5SymV8j2rk+8t7dp5IlAZ5XAtD4FiW55ICFROUmocRY8AlYroAhRwFB0ACjiKAUcx4CgGHEUVCTiKivKrchQRNj1w8CD//LNyFEMWZDC9drZt00Y6uoYv+fDDD9n2HTvCzqNWbmzQgHXt2pUHs9z80uYtW6CkOVnRbicLMjiKXyUnJzdDR+FXczc3e3Qgu3fv3kW6byFLyrFaUIzp5lcSExOl4IB7CHqdENSCsdjPA1gADQkg9X70UekgDBzF9PR0cBTbO90HjiJNI0IcRddY97FjvPmhsshKXe8XHEWarzWj6Qg4iv1tLQjWEx8fv6txo0aOmZnpdViLwioCp+3R86h5LA198cUXbPny5fyeDh06sEEDB0oLuHffPqxFNRNWZLYgML0o7x133313tMxyAMrHH38MKyhh0XDmd955J6tXr56rJa1ataqQ9LcgK9pdwoLMHEU7ATBIsBbQ2BISEjj6qK1QVCs+nvXo0YPdfPPNbPz48fx+5IlzToIgHI24wVF8xCbgNqNly5bRMst57733OL3OyaIBGhJAeuihh6SWBI7i9u3bwVHsXGLZJ4yjaBNgeuutt/j34cOH8/X3/Ly8ks2BajmfEq7jvunTp/P1/K5dujgGt2QcRZqZSzmK4AEJep2waKy+oCNAT4WlIWHRABED1r59+zrmZ+YoCivivZgbR3EH+RTUCGonuWlT1+4V13Ef7sdzOyzO3NoMmAeOIoBBgrXMmjWL3XPPPaFmDmDwiWOcx3Xch/vRFGU9nCeOIhb5ILfffntxBFGhO8d9N910E39u565d0nt1OYqw6Pfff5/fN2zYMM75QbdtpQvjGOdxHfdBYFF43gkgTxxFQQTnq60uZAQsKh48cIAnMctH0F6cw/VIOYrffPMNf0lYKAaNbrQWXMd9uB/P4XkniYijeElh5ApT3kVOceq0adxHCJIBjj9fs6YEC0OMbHU4imL559Zbb1VejsJ9NCgs7jn37pXeq81RBPJigKgSZHrssce4w7TmAcdtN8bS5SgKIoXdmr1VAAzmXUgiT/gocS7HhjSmzVGsaQy44Gw7dezoWqhcUvrk4MGhNg9wJk2axKPtdjp0OYpirKRC08N7gaqzZs2a0DlY9OzZs1mzZs3YQBqnWTsdK0cxGhzFXAn9rkXLltzsDpAPkfVI1prr07s3a0QDTxk4IhLpxFG0S2CaiIU/lXkXunY7i4bjtpvTaXMUsUDYv3/xCBwkThRMdZ4zceJEKTheOIo1DGqOzNmaBfyhxx9/PAQSwJkwYQIPlTg5dS2OYiG9XNu2bbkC9ALjn3uOrVi5ssQveHCM8wBRPIdxED795CiCJQ+LRrgCIKk4afidXr16cYsGOMjfKSJg5SjGMIOjSM6pAUbBtquShPZg8isoGAZb9EI8YZ0c7RyZmi0LE8UunTu71q4LR7G6Xa8HH4SOYM6cOXyEj9FzQkKCqy5YDKZAGEQ6DXYBnCeOIq9mAuFRmqFjZIr5lvADqEkBDs5jrtbt3ntdC+yVo4hn4GCFRb/00kvs008/LdEj4RjnxTQJz2G1RTYTsOMoRhmz8dupx3mLzK56yxYtpKFPsfaO7hATQqCOmkbbRvvNVwiDQifCIpRXBr3oI3S83txDde/efRDNh15t3ry5Yx6VK1fmP5SDRQuBJWFkDnDAHRJy3333sdtuu8210nbu3ImB6uCVK1cusEYUOUcRvEFMLdx+53k+O5tT8vCzytq1avFPHOO8CpFJcBShkzlwFMEXNHOCSjTPzEz24IMPhlk0QKHnQuCELLpbN1dwnDiKYjZ/kmpvLXXNdxbk59cDSwOTRdfRtYcIn+AokuW5chRphv13StFOFg3ni0D8yJEjuS+0WjSaIDoCkBfcLNqJo2iOSX/Vt1+/paQwK4NeQuaPvAryRN7QAV10ypEYQDP8N2lQt6t4pchZwN6Ab8EAEGAhBoVPHBsrvK7lgg7oWrduXYll2j8kR9EpoaeC/9Fhuv4pOYp+ScBRlEjAUXSQgKMoceYBR7E0OIoGSG4F/+tyFNGTbdq4UZkJEHAUWcBR9AJQwFF0ACjgKAYcxYCjGHAUVSTgKCpKsI/ib8FRhP8wk6UgbjxEN7/0p+IogpuIH/ELgeMeP26c5xl1aXEUdUWFo6i9jyLiQpGAIySSfRQRBUxNTQ1LXsVtH0UljqI1rrxt+3ZO0oxUvHIUsdyDnsi8UPn00097rjQZR1FpH0U0KaQO7Ytbw0LBeI1wX1c/9lHE+lgk4AiJaB/FFs2bs3Fjx3K6SBhImr9WtIpXjqJ1fQxMVj/2drXjKMaAH4gJp6x51Td6LNwzgEDCJ7bqAkiQ9u3bewYJUxhqZqB/rTcVKsRRtBP0aOhV0bSw4x3YbLi3TZs2EVWYHUcxJoyjqCgDBwzgnyGQ6FmvIJk4iuuN5hVP56T7KDZt2pQzWAEuBCBhBzxIJCBZOIo8iO95H0WAJECRbRuoMrLV3UeRhgg8zILvCFe0bt1a+C4OViTNzJd9FP0EyY99FDHhNIPktK+ZUiw30n0UrTLA2OCINzcCqUizufm1j6IIfAEcgITnBWi6Fq3FUVQFSYBi3msRn26UPV2OoiyBvyRAQaTRS3PzvI+iLkginbfM4cIW8XzYR9EqZpBkeyzKLNrTPooqCfuJPWFqcqG5FyudfRSd0iOPPBLiDAmQcB6fbkQIz/soKieLcAJ6KeyjqAuSSLLfanjeR1FVduzcyRYvXhzejByaWKT7KKoIQEIygHe9346jGGNMG1b37Nmzz5Hvv6+OSavX9SlMSZYuWRI6BqPUKdyBHwKDowjdCxYsCLuOvQxp8tgZoQi/1reEIP5Tt25d23vt9lHU5ijqJEwkkUqDo6gi+OHK22+/HXYux6EzKhWOohfxk6PoJiCO43cZQsBptLOqPzVHUUdAOkeyyl+Goxjso+izBBxFiQQcRafpjR8cRaOwAUeRuWwTGFVc4mAfRYWV0L8uR1E3MEUvocQJpHzP6vqHgKNYOgCVigQcRUuo1rHSAo5iwFEMOIoBR5EFHEUpQL8lR9EK0GvkjPvzP200ncdLgZNzOD1dqzD4u62HH344bKcWgACfRM4bTvsxN4AMjuLOVq1aVTPYYL5UFkbe6ES2bdt2ivQ2J5BO2AGk9F/PAAfuAxNTnYRn8Owf+b+elTiKeFHU7qvz52sVYvCTTzK7iGCkHEXMxrHZ5X+OHNEqT53atfmufCKc7BtHUZg+BoMDBg0K/VWMW5L5lUg4ithEBZFAOF6dhGdWhMfk/eEoFpk+8ZfFKr9Ftz5nJ145ihgyAPh5c+dqWdCQoUP5s9ZWEtE+imYZMWKEXo8heEcO+XrdR1FYJRb6nnnmGTZjxoyI53ue91G0vrBOcpNIOYpFxr8Fq8bHzc/5ylE0y+JFi9gTBgVPeWYsueaFoyjkmWef1SqHiKc75esLR3Ggywa2DuN26QhXl6NofWG/xBeOYqHHOZlsZKvLUTTLaxayhGqsR5WjGKPDUfQyDnIF3IajiAmyqniyaBerNDiKfCddLY4ithod+dRT7OVZszxF5+wkUo7iJQ9zMlneEf3XM2QR9Rp8T1afJJL/ep47Z46WrqHGpreyvK0cxRhwFMeOGcMX+srHxUkVwHp0QxxSizRxFLHXIUSHowj+0ZixY9m0qVN9qzArRzEGHEUCCBzFuDgXgBYZPz3Q9UFO9eXEUQRbXsWC+DiIRvZORC0vTczTPoqhHiY7m416+mk2e+ZMX7p5L/sommUsWY9WiKNsWSlAdvsoxmBRb9CgQR/16d27AYgGbv+tuohq7LwPPkiBo+gK0EJNix42fLj0umeOYt2kJHbo8GFuPbo+CM/ambgfHEUsL40bP569OGWKL03MM0fx4YceYgiQ44V1Ep7Bs6XJUdT1i04SEUeR/6pv1CilCWjYIJC6TATWzfEcPziK+GvjdLJoWI+OlI2NZYlUab5zFAVTAk5aJ+EZMzh+cRTv79GDvyheWCfhmftt/udDxlEMC7FSTXVt367dbSkpKSPPnD1bDowyP7jKEATIwTi7smLF3BEjRry8cdOmL0n3Z7JYTaVKlbpNnjz51SZNmlSvYfqLd0xwMfPWnaxijIOhhTkIhwUE8jsZzz///GDqwT6SrmpQAdHkej3wwAM3jRkzpj+NCcojkIaeTazBexwps1/OnUP858K0adP+74MPPvg3XXqHdF90CWbFNGzYcNhTTz31QoMGDeJV9rHX9TsHDx7MnjVr1nP79+/HsPyiFCCjkAFHkQUcxWAfRasE+ygGHMXwuBYL/utZWQKO4m8hAUfRkICjGHAUf2WOIgZ51E07chStS7hOLyi+23EUaZiQisGmLkC/a46iHUAqzUV8euEo4oVCoYavvirBUYTfE+DIABIgwV9aOYq33HJLyKKTTME9220CDY7iJ4mJiVUw9zKDY7eq6dYLmJ9BXsgTeUMHdKnmReCAo/hvmmZ0wt/WQGiMw7f7wwsLMqe5+eM7zuGa+H8NPANBHsgLeSJvqauwHJfYR7FQExg7oMQ/RHnZR5FeIGwfRbwk/AusR2dnPGO9iz+LPMz7KEKHK0B2HMUQV1EiiFO7xqpNeelwFKngYRxF4Xgj2TJQWBXyMnMUoUsKEDiK4A3q+BozMCoBfXPe0AWd0pBtYWEKOWPOURTzqkIfqMnIQ/xJCfKGDjo31xEgnX0UZYDorHrocBQxAEVSAQf/yImkUlkiXxlHMdoIYYY4ikUK1oPeZk5KShjbA99xzq2rLjL9Yx2cNuke7RBwmwHeoC44dt9llgSrRP6Grhm2AJXYR1GhCwdr3jrusZ6T+STVfRThM1R8jh0gKiDBeSP/iPZRtLOCS5aC4/slRVaGEDeOImpYlbsEaiCS07Gb44Yupf96VvE5vOvGoMxU+ELT/EzFJ6n817MYAKpIeno6T07Hbk0NetT+61kCjs5kUtzrCJLCfz0X+vxjGjeQ7P7rOcaNo2h+QRk/aPjIkdI8nBghdhxFdL3CSmU+B7wmHZE9I6wfk12aWGMgyyl40n0U/QxgOeUl20fRyZ+pOF8dZ27W5bqPorVnmj9vHntyyBB+DLKSZaGRDRw0yPUa8rD+alF8l3EU7QBS7crdrlktSehz3UfRrlCRMCjsnjXriISjWBphVi2OoujOYQ0LXn21eMBmao5mtofdNTzDeyKHF3bjKEKv9Tkz09+uG1e9Zu3hRMtR4ihGWRDl5+hFLllCCmG+xNIlh+ZdRhca1ryYfB9FGUcRLyZAknXjTtfswDGX2XUfxSLLWEaApDsIFNZXAhzTzN5tH0Unxy5A0hUZONClvI+iHcHIbhBo7trx3W4waZcXRGUfRVkvmq75+1m3Z6DLjqPI52LgCeYXFGQcMX5s5hY9RGYppt3lhOCc7KXMeUMXdEK39T7wBEEw+LXWyoQOLY6iXe2bMyxDI2A4YSH4jnNOL2TOU4ejqAqQNcyhGvYQ7+PEURSz+ZPLly9feyYrKw38QSApA6nI5KvQjS8SP2qT3C/yEhxF6HLjKII3aPybuZJ/UTlnB45njmJoUmrpuYTjvkhdoghH4LvVIYuRsgCnNPdRtDpumUO2ii8cRbFqWiIGZBzb/ezRbIF+cBRVelEwYFWduNjkQMZRVN5HUSyjiNiJ2brMVmK9z899FFWammqYQ/idP/Q+ilg4TEpK+lU4iqQr227h8HfNURQrq1TwMI4iIn9uv0xyElg0LMfMUSQ9mYYeNYB+LxxF89IzFb5UOIqkI9ekQx0gSMBRDDiKAUeRRchR/H8BBgBSNpi8Ffu9CQAAAABJRU5ErkJggg=="

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(193);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(180)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/less-loader/index.js!./app.fonts.less", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/less-loader/index.js!./app.fonts.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(179)();
	// imports
	
	
	// module
	exports.push([module.id, "@font-face {\n  font-family: \"kidoju\";\n  src: url(" + __webpack_require__(194) + ");\n  src: url(" + __webpack_require__(194) + "?#iefix) format(\"embedded-opentype\"), url(" + __webpack_require__(195) + ") format(\"woff\"), url(" + __webpack_require__(196) + ") format(\"truetype\");\n  font-weight: normal;\n  font-style: normal;\n}\n.kf {\n  font-family: \"kidoju\";\n  display: inline-block;\n  vertical-align: middle;\n  line-height: 1;\n  font-weight: normal;\n  font-style: normal;\n  speak: none;\n  text-decoration: inherit;\n  text-transform: none;\n  text-rendering: auto;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n.kf-add:before {\n  content: \"\\F101\";\n}\n.kf-android:before {\n  content: \"\\F102\";\n}\n.kf-apple:before {\n  content: \"\\F103\";\n}\n.kf-submit:before {\n  content: \"\\E315\";\n}\n.kf-blog:before {\n  content: \"\\F104\";\n}\n.kf-datetime:before {\n  content: \"\\F105\";\n}\n.kf-sync:before {\n  content: \"\\E31A\";\n}\n.kf-signout:before {\n  content: \"\\F106\";\n}\n.kf-drawer:before {\n  content: \"\\E300\";\n}\n.kf-view:before {\n  content: \"\\F107\";\n}\n.kf-facebook:before {\n  content: \"\\F108\";\n}\n.kf-feed:before {\n  content: \"\\F109\";\n}\n.kf-search-adv:before {\n  content: \"\\F10A\";\n}\n.kf-settings:before {\n  content: \"\\E0DA\";\n}\n.kf-google:before {\n  content: \"\\F10B\";\n}\n.kf-history:before {\n  content: \"\\E305\";\n}\n.kf-home:before {\n  content: \"\\E0DD\";\n}\n.kf-support:before {\n  content: \"\\F10C\";\n}\n.kf-linkedin:before {\n  content: \"\\F10D\";\n}\n.kf-live:before {\n  content: \"\\F10E\";\n}\n.kf-signin:before {\n  content: \"\\F10F\";\n}\n.kf-search:before {\n  content: \"\\E0E9\";\n}\n.kf-report:before {\n  content: \"\\F110\";\n}\n.kf-comment:before {\n  content: \"\\F111\";\n}\n.kf-previous:before {\n  content: \"\\E30A\";\n}\n.kf-next:before {\n  content: \"\\E310\";\n}\n.kf-pinterest:before {\n  content: \"\\F112\";\n}\n.kf-create:before {\n  content: \"\\F113\";\n}\n.kf-publish:before {\n  content: \"\\F114\";\n}\n.kf-help:before {\n  content: \"\\F115\";\n}\n.kf-share:before {\n  content: \"\\F116\";\n}\n.kf-star:before {\n  content: \"\\2605\";\n}\n.kf-star-o:before {\n  content: \"\\2606\";\n}\n.kf-stumbleupon:before {\n  content: \"\\F117\";\n}\n.kf-tags:before {\n  content: \"\\F118\";\n}\n.kf-score:before {\n  content: \"\\F119\";\n}\n.kf-twitter:before {\n  content: \"\\F11A\";\n}\n.kf-user:before {\n  content: \"\\F11B\";\n}\n.kf-uservoice:before {\n  content: \"\\F11C\";\n}\n.kf-youtube:before {\n  content: \"\\F11D\";\n}\n.kf {\n  /* just in case - see https://github.com/kidoju/Kidoju-WebFonts/issues/7 */\n  font-family: \"kidoju\";\n}\n/*********************************************************************************************\n* To understand how this part is built, check\n* See http://docs.telerik.com/kendo-ui/controls/hybrid/styles/icons\n*\n*\n* BEWARE: Kendo UI changes their unicode values which might affect several icons\n* including km-home, km-search and km-settings\n**********************************************************************************************/\n.km-navbar .km-icon:after,\n.km-drawer .km-icon:after,\n.km-navbar .km-icon:before,\n.km-drawer .km-icon:before {\n  font: 1.4em/1.4em \"kidoju\" !important;\n}\n.km-navbar .km-drawer-icon:after,\n.km-drawer .km-drawer-icon:after,\n.km-navbar .km-drawer-icon:before,\n.km-drawer .km-drawer-icon:before {\n  content: \"\\E300\";\n}\n.km-navbar .km-favourites:after,\n.km-drawer .km-favourites:after,\n.km-navbar .km-favourites:before,\n.km-drawer .km-favourites:before {\n  content: \"\\2606\";\n}\n.km-navbar .km-home:after,\n.km-drawer .km-home:after,\n.km-navbar .km-home:before,\n.km-drawer .km-home:before {\n  content: \"\\E0DD\";\n}\n.km-navbar .km-history:after,\n.km-drawer .km-history:after,\n.km-navbar .km-activities:after,\n.km-drawer .km-activities:after,\n.km-navbar .km-history:before,\n.km-drawer .km-history:before,\n.km-navbar .km-activities:before,\n.km-drawer .km-activities:before {\n  content: \"\\E305\";\n}\n.km-navbar .km-previous:after,\n.km-drawer .km-previous:after,\n.km-navbar .km-previous:before,\n.km-drawer .km-previous:before {\n  content: \"\\E30A\";\n}\n.km-navbar .km-next:after,\n.km-drawer .km-next:after,\n.km-navbar .km-next:before,\n.km-drawer .km-next:before {\n  content: \"\\E310\";\n}\n.km-navbar .km-search:after,\n.km-drawer .km-search:after,\n.km-navbar .km-search:before,\n.km-drawer .km-search:before {\n  content: \"\\E0E9\";\n}\n.km-navbar .km-settings:after,\n.km-drawer .km-settings:after,\n.km-navbar .km-settings:before,\n.km-drawer .km-settings:before {\n  content: \"\\E0DA\";\n}\n.km-navbar .km-submit:after,\n.km-drawer .km-submit:after,\n.km-navbar .km-submit:before,\n.km-drawer .km-submit:before {\n  content: \"\\E315\";\n}\n.km-navbar .km-sync:after,\n.km-drawer .km-sync:after,\n.km-navbar .km-sync:before,\n.km-drawer .km-sync:before {\n  content: \"\\E31A\";\n}\n", ""]);
	
	// exports


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "5707551b8b9840fb20af19d8929088b8.eot";

/***/ },
/* 195 */
/***/ function(module, exports) {

	module.exports = "data:application/font-woff;base64,d09GRgABAAAAAB9MAAsAAAAANygAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADMAAABCsP6z7U9TLzIAAAE8AAAARAAAAFZ8e1L2Y21hcAAAAYAAAAFLAAAD4jL9FVRnbHlmAAACzAAAGWAAACzkKQziSmhlYWQAABwsAAAALwAAADYKwpK2aGhlYQAAHFwAAAAdAAAAJAfFA6pobXR4AAAcfAAAAA8AAACkoAAAAGxvY2EAAByMAAAAVAAAAFTZPuQ+bWF4cAAAHOAAAAAfAAAAIAFIAaxuYW1lAAAdAAAAASYAAAH+kW0OVHBvc3QAAB4oAAABIwAAAZSRZa+2eJxjYGRgYOBikGPQYWB0cfMJYeBgYGGAAJAMY05meiJQDMoDyrGAaQ4gZoOIAgCKIwNPAHicY2Bkfs44gYGVgYOpk+kMAwNDP4RmfM1gxMjBwMDEwMrMgBUEpLmmMDiosX6UZW7438AQw9zA0AAUZgTJAQAasQw2eJzl0stOwlAUheG/3IQCUoUKcvEuMvD9xz4HiUmTMyJx4PYFdB0XQ3wCSz5IT5u2dP9AF2jLq3Sg+KIgbx9aLX7X25S/6x3etL+g0kp/22v2zXtzSKRuKlOV6rSMzfc3bLsnjhT5yMmt0BWXJz5wxz3nXHDFQPe81lqHM53f0v279OjruYaMGDPhkikzaua62oo1G2645YFHnnhmyws73ar3xzP8p22Uv4rP494uz8v0vtn2TG+eZm+aAc27aRo0B9NcSJgmpGmbZkUqTVMjVZZnmmrLpaWlaaZEYbm4aBn5t2250OhYLjaOVAFxpB6IM8vFRt/UCDGw/O+jNHVDDE0FESNTS8TYVBVxbuqLmJhKIypTc8SFqT7i0tQhMTUVScxMbRK1qVLiytQrMTeVSyxMDRPXppqJpalrYmUqnFibWic2xu4Hep55cgB4nJ1aCZAc11nu19fr7pnu6btnpufq6Z3uvY/p6eldrXZ3VtKupJWs25IsYXtlR4qsxI7BSpyLypKyQwqHOCZBIVQSlINwGgIhdggQNpCQFFVAKCCmCoosgYIARSUQIKTKHvG/nlntylbCKjs7r9/rd//vP77/f0PRFHVjnfk8s0iZ1DRFoaZjO7aJeczXwyAMWkk7aTN1voxMexZZJGm251BEklYwgmKSkGqaevPli7vn5nZfvPxfm5lPyIYhrxvymmysb2WZzi2N0kz3+stb9bIUJWxb3xDVpo5SZ6kL1Fuod8Ja62SZJllwkyyzRRbMbC17ayuot4HeohtJexzxORTUcTiOFFSFr+W1ghDXg1a7aZt8tJnBVn/X6Z43nyRxWsHWmLfb+5svnzsTtVrRmXNf2cx0f1u17arjoAEXIZaliwNHfRcyCLmDE+ju8cGP8qKYFYRrvCBkRbHraCW7ZrfgW9Kc0IGeVed2xHtx/ZZp0gz6d1u9DtOR5D2TNEsjekpVp+DB0pPWwdHRg+YhMldW7KWH/lfN303a3313znFyd+e17+TT7lBSf4aiKPaWc7iHeuBO6J/AF9eB2iEQXUGY93loFKetkmYV9fqT5g60dGyGh1aOPb9Tyr7P9EaGZVkoi0pNkcq8LHt3FUp5a6AearavG3YlUzSLhdAZzymmdcSvlj3Wm6vvlJjf2jU+ixhaplmGydIcOtNZ6uwaDW0TYRmLGUZgkKj6lebE2AT6NVj3YpUZWurT7AbQzKNESqMi6rUU1fCadhl5caudtNogS7aFHJzSsffJIR6YbwG1k5uf2HBszFfopA2EupkxScsJFAAz05jfniG9mw69hqhi0F0LiiBGstE9dm6s7Jslx8q4ec2tjOlxwxiterYfKiWnpBQ+xMsczcqqoMuXSC6rCZrC6/o5o2XcpkrmDeMeI9Zh/E6nGNSItKKVc2OFdLTQt73qqNGI9bGKq+XdjOWUTL+MjuOsLmhZluZgJF1QZZLj9RiGgkm0V1bB5Od0A0hJcbfw3zJ1grrvTjjQAI4D4R9HoK0UBIJbQbMIGIwoBL8REWGHGhB7xycpORmT3yH3rQ1ncsMHhl87cmB4+MDIl+GRk7qfvU/Wdfm+rK5/+XchyZJkx8K7jnKZDIwFQ30ZRkbw/ImMMq8XdPj/394DaCICTX4faNIBLTlCzVJHgCavod5KPUN9mKKMSPNjHxiNs0ja09s9bZ2+SGzHSjcNaqwBOd+rB7EWaV5sNzcVfUwetpOya0QYt0clGAfG4y2TEIsUGk7TgfGwCcwLUh2CUN/GjDhAeaB7c56cw1ce7XRE9Ph6UJzEoohrWOz4henDaRFRQbEL3NuhqVz9pT8LirViEBRzqte9HpxLWY0kz7ouz8MTSXu13FlbOhu0AmFP4cKRvXuCMAz27P3gZubI3Kt37371m0mCOt2NDZhio7NaDNJpRawWGvRMfoKU1bd/nUwFrda/TqPVDikUg9bo9WKwmpqlNJnbW6ulmdZVoVmoRKSVlrtqPX7LrGmm058Xkk0dug48PEgdpK5QPwWn1JoHgwJHERC9GPhAIiCrQsMBEAomll8fByPbblSAaStQpyAfTgjI6QEdwfqG7bgVgpKAKhD+9NwUwuTjwNo45XmiDkBhGDBKtW+vyUQ4ngcRaJJxkzY52r5CWV98ZDFcqapaRmWCkcnjE7gxPzA7Liiqps7cP72f/kClPtqaOD7Z/aSakzCqVVqV3aNCQVS76xYeAG0jrox1/F3+ALaEo2JZOi500vedjFiu5vOvqEVfgRkLDsPzrJ4xYWDIh51g6i45w/F8PH3/TOfyI+UjI4x9dxOW0+J4FsOco4uMUxhtZHWn+5crGUEYgfMYSmDktRFByKxkpHszmXsl5G3WYcyyr6ynMJzJJ5k15hiVoXJUkapSDWqKugt0i2d5lkLbVeQDPIh9y9ciOKMKchBIlhZCMdEYf1NvzCIO9A/Qzw/rPPTZhEyYtyOniSi02t2QTYnLKBFavUHVOpGS4SRTRn/yWO16p7NWq/W58Vj3F98gSW8wiqcyAl76Fnn1rSUsZE4VmcnOOq0WypLS7dRqNURMXUGl6bUX1+lv/vCLqx16o0tYtGi8+3HRFR/XkYmXRLyKxSVsItAXDFGkzC/RX4OdVqkJssee/EZeT7iZ/6/81Iv/SpQZY5P0e+TpBzR5kZQWZa27cft8qs9hLf9M/z2lw1raQHGCKIjWTVWIDSgLGLsdxduVBpMKQwIN2lHTaUdTwL4gEQ0CKXrwIplHRO3DKdkYbdmELTtBU4PT08emaSnj1NhMZvn1S0uvfxdJlv3ZuiDUHEW285Ctz6Lnhp8+f9+f3nf+6WFF2ZbthlcvXehYVufCpW9sZtAGjDk9KElszclKzPX+mJB01+qzvmPKOQdOtz67PFt/YPWZwaGhwWdWK9X7e7n7q9Xujbldr6qt1F61a+5mhpzXNps3dyf2jvGtCJR5lPR0fwz8aO3QnD23uPijp6ULWW3v6X17dmyy/u1K94/R9OVZM/fa3bOvsNdNap46dCfrDwkfEBAeWhXaiQLSJGxWaCtK+/g73Mvnw+kQ/t8xd3kOPYhGR1YOnz36nkd3P7hv8dHH3rHTvf1jKQyTwcFvPIhgmLOHD46MLe9+9D1H3/HYo4v7KD7d53WwwQYVUsdTC/wM4LybnFxBKSuDovZu8y4J+VRZJ0QjjyN/qp5iQJO0AFYGMlVokmtx0AhsRY/hve0FxknBIFFDC6B3gHohSay4NU/PgkgQ0++gWsr2LJ9XzJKaVdCf3lr+zR9361dz+SynyNWSOpkfyJv6e93W2dbkiTav1TW+fWISSi+tpaKxnMrHh7by1jVRfL9RvAq69uK3XZ3nMiOVUr7cXg6/fVEQpauu0RMQRcmqJVPJ8+zLiuivbLWs0opdUOXSN4YfOtsaPTzO8+OHR1tnH/p0f5ZbEmbsmlSUrhkmvmjwAtK1BhoKl+PKRWwSwEin2Oj3mYh6mvogcB4wFhjC1KgSApNnFZQ5Jp5GrseXYCRTDE6sYA+Lg7HlQa1AmTAdMZDwHEcwEClPIKJxgMB9uE7K8JwHj9LulYP0vZ2WneYCmge1BLoJBsLb1Rr9x5qCxTOSwRsKx+JFTHM0Ek6KEmIFJpc5J7JilmMDjhXyrmiKBwXBMETaYVTJ9ySVthnB1AVhRbAEt4BZbpBhM9DlPFSBZyKJJwXEsAzuCAyXgymkMyJWVAEJSJKqNZg04kTTErkWVNWqkoRE9Idw1K2zl0lCvzurYMZhsFiqSCZe4ElbJuB0yfMkGWFRg6mPQ03eAGPNMSJHi2clmaaRLJ0VaV5kYGDezGNTOi5iaIwwkjOel9G4BiMZpsh3oKpSEjFToHkly4nnoEoWGSwcEhCi8SEBM6LC6tJ54VR/TZD05W5Tv8TU/dRl6o135hFYBB9HcWRFTPqmB7WSdgTHWCfuKbQHA+4T2JX6o3B0zDgNHljbaBEl1DvDCCbaoTr6zOHgrruCw3+tW+HoPGCZxtRrdCGzNxjwvcbUJxojdqFZkLJSOay+mm/tCTPJPn+wXHQHvOl6pQUOa3WnKov2yDyHux+qulXddKN6szaUC+2BeuLPakYoN6vNwKyoilVuoezoAj17ZoZudf+nMCIrhZGpkUIxT8yz3KdxByyRACWDqlFj1C5qP3WKegqk6jeozxGP1vK0yHbA4PQTy0ObHhRRStYPUDAiHvvgirSTvmcSgsIk0PX7PebRD+CHoA4B+3VGmjhklt7yl9FMd/0GBWCVQP07SNZ+XWIeQOtelXguWkVwiE9Qq90+dYQK+rU7cFrWOmTkjl/uFLg6Wk0hnvHY93nQD1e9l9a/zkjfLAZaDqbY/p/TTt2Z25LikL9nPsXUgAuylAeOJ9I8gi40DgSoQURNRDboNxA3ElYD+0VT3XXUWV/rrq2vd9+vS0URXUEPgcLWJan7CDwhod/WXe9+lJAf3ffhtdgQRfRQ9/2iaAB4Re8Vxe7DonuLnJeoAWqUalGL3yNO6SQwuUNk3IQHrAXqMCwOQXUISgHdonRvI7J/O7X8s8tTE5c+axhvKJe7NyYuTZA33bW0jB7cUou3E8S/gDZvMD78sk6oX0Ynt2mvV+KjNnjvd4LvNvERiElkwDeFxGUET1BMffO1Q630TwNN328OiJcufeyBB2qV6Yv1apK3NEUSuB3rm10F3498/+3d59HB7vPP+uHKs3/eqdeQiLOCJMJ+b9XXY+BjxdTMHcVw48SKvJjDvuUkFhfvNOj6zi+VkNj9TulL5LljOPvuj5fW/6WxAekXGv9C3fSdfoHeoMpUQO0hvhPAtU0L0E7AisTptxdm4TZDyI2eV0jiLLd6haDsmDd12/r5GXB5wRbMnNf/tdPp1BRdf+nt3sTE3vFx9LfXJEA47mPgCV78Ki9J/FcvYgHQFKrN7E8Zaf8MOI5rqQa6ThDVselv30RFqecHaKgnv88yf8HcD37fINCdgkU1t8UQW4mDQ8A6LyM7qN5bJebMCRj7PyWp9zCGOkNDF+Izhw4Mj44OHzj0LMl43a+nLtVTJHnhhATtilLv8V5oX/VutiSZM/EFdK3fGJI+nW98jfkI44GeOUo9CGvl04ixZRLAZqfWgeCxPiqLPcC2MQnGWyl2A1vBWzfJbNrguaZh5V6gntiJEFptuuwpy1UQT1OIY1SaQ4grS4G33/LwKIc5jQY0wyBK0dEqqFVvZvfsnrEbVD/cWQuKiBrbM7t7xoNKUKa/Mb9roblBqjaGp5tJtpgVXpJEXmMxr4uycrYa5813yLJgMzLGYo5BftrYa4R5t+GmAaVi4ObDhpeOAYcpeIYJY+tamRfy+VRnbKQy5FEroC9OUKc3NaGVykgvtg576vlLvbOMDOITp5HkVtivuBlxTiUvRTbEYSYhD/jE8O2LV7WSqJx6emHPsbIqNWqPX3xgZjaVtEdb+xWxBkhBUga88Xhx7on5TjxRG8iJkjXXPnLgUDXWXbb7FQQmYPPLdCYnjp5Y3Tu/e0Kxlh+u1MoT1RZipiaOHP/ciaMTky9+xz6ze8gNxpttrzo5HJQ9TVN1rxwMT9Y6teV4wi3QqFQIxuiDnXX4EH5BQJP/ZhgmA3oF7BLR8j1LNIF6klenf7gL3gm6AlblvCh+97siPFwGdYmgkBookbekdtt4Um880D19GVkArJ/G0tDTMJYIPXc03q0+/NU70vFpSyttSnyMoI9Jo/S8ibz2wh3A/n7QFxDMOyYwewLtey5k3LoDd/meY3Ptakk3fCyBe0Cz+ZFwqLU0GJYjr1TnWYPh8k55kKEZZgxwPU83lYI0VZo+MzndjHccKqA/7VfjZjzpBwrD4RLGfGl47IhdQEFjLjodDZbUuayjAEfGYS4nicLnB5pajUH0nuYDenHhdUvxvaVy75xILLVD+RRleFr/NkXrR6p8T+shyVjrx7BWUS29CUGp8HY3etciRAJB+l/xTu63puib8+wFH+NmvBaM7VZEdgSBSoq24rHEMOCedUiDuellA5zlOA3nR+7AQO8SBbWwdaEKJwyLJLHXXZfqCgm0pjFWC6ulA70Aa7gnrJXNs0k/IgtFoBRun4v308vPAes9Bzr/yVTnP4lN+hiM1Bqnp++f6YdNTbW0GTSFrsrU3Gag9a49YUk1mZl7k87l7k8/L4rP6y7x45/8Kgk9fvVJQchcdbff/01QC4D/H4IjAObrxZBpMBU5ZG3dDhBXtx9qJkopPQjjZTcIxs5Nf40t5d3lsEP8+z1JKPGwy9GB0LSCYgcUJ4tE/gIWP7lKTCRUicmOuB39R30uX6xU4uVw9oKtKmS/SriYywlVqxgYis5jCXe/mdI0TejVnXF4/74KhH+NIbkMlacagPGoMdROOB41bIcLuF70phfJMbYX0PYC/aru3xkY1Y3uC0BMo/t3GP3KVtzF38q+9A9b+Y+tudU1F7lrVfj/g62YCU1t5W9sy/f13p8xX2AmAZlRyKn07gbSGAiYXVgNUaUEL6ThjzT2kZ59etRNm57bx6qZDcuTs9rzAmaXsFwfUj8tmuJvaUN1GS+xWHhey8qetZFR2X3YG/YY9gUpmx8Ms0/ypvSCGRbkJ3n8hFwIzRckk38yGw7ms/Ae7B69bW0rP8jqcumdSBp5SZFPGrMB9Rn+AMtu75Oata89VzCkpU8VFwqfWpLMwnMb1Uja8X6G/qrSeMKYLb/whGE88UJ51niiUXnZ/foKde8dWQonIVqnd7PJE/HyrR5sI4IGapFc9ZHXOLz5focmYf/gYrCw0mkYrnGl0VlZCAzX/GUodIag1GnsGFD/jm2NNuYG6nPBl4l6vft0o9NozDe+qBiG8vA95NUZ2zndWGjA+9P9u/NfZd4HercIPl/qK5AbLILnUuAKZ5wgDBoGts1jEQUp8tNS85+A+Uc9+F0PRGYNgJpaNBCQu8zhWql7reT69whlvyLQb+y+1Sh2vwXiDtWxgXLGS6M9Nxk92b0G/HKF3gCf3YBmsVEWoDe6UnZympbrHoQe4O3/h0sqSc8YDRdTH/ulPwJnV+1eo27+bmINznWBOkidpB6Bc+2DsRFy99zDq1Yfh5VhMwBaewg2Tbz45s9s4nnSIW4RRQp4D8ZoEKtHugacgnrILr2umUGpqrXSMenzg4Uruzqrq0HxBuU2Vlc7u67kh1zwM5SO2wDLR1MpmE1DGWurVuYpgUZdKmOtIlp4ClXEUNQkTCNDhqa8mBXQ+fLM5ExnedVtNNzV5Q4UyoYX6sAUDbcDY8GYMHIH6a4eeuiNGevo4eHICa3MficaPnxNQ1plJpgy9/Vg9B51oj5h5V6BlU7eUTSPB3rwfaPrjKOQB6KQhA8B2gJx7CgdIdxxqK42EMr+oDpWaOx2xYNvG81bYamA4hHXze4Og3MTJx586PihwZD1d4x7ohzrjFiCbg7vG2AXk8EfKiJleK+IuYExVC7ycXvq5LHThX7sep1ZBDpUgfepxlaYI8V/8OHJzYAd9pD7LfaC6STjR5fevXR0PFFk2dLKuZX9n9i/kitrliwr3fWtC68p8DXkTEbOu0HroFuwdSebjI4mWUe386WD9N9s3WERPrZgTZ9j/pDZB6vDYNFk8CUNOKUz1Cr1Wupt1Dupn6SuUz9PfRIFaAotoqPo50BicYQnp6yIM6diZyqZSiZnUBj0w+kh5vvOB+SNerjtVzCpq9erTHpvNh0X8plHjo+tNM6Ok3FmAWHfdhI+dWKiNvkdDCDeKT6pAwpLonaVTqAXX6FBSQJjpDH6GeTjhA9xgp2EeIcwamJWOStHbAqfo9MZyWUuWZS/uarUSZqyYgKyNxcIguiE0Ck9niS9F8D1VD2lwrj1Mx7yqWK7ypCO4KySrZC57TQXwJk6diNdXArkeT8gI6RL6f80iEkfZBEJNEjIZUb/JmOBTYeHcdoTqN0nXH9O4io/ixCP0C4G/+MJhOis5MgiohHNZLJOcTCrKos0w/MCoB0B0AliuYyUVe1C1QuHWF4QM7Kcy4EjpumqByhpaA2/9xmaoekLjwuaRLP0U6wanGMQx2sYvGUWSTl4MgINSweAz9I6LykqR0uawGCN5xD4D/zZtzL0m069E79JyggKy9+NckqGhzGho2xKEscFkatnLx/IayKHRBhHZhhYN4MQAlcA/rCsQQ6x+Bg0hzecyNqqw3NzgiiVZYkuhku7VqZOyEZoaVhQcuSja6qgKN2nXIlGIisVEc/RNGuyOCNluBwPYO93chIWq4wY0Ipaoj8yPOEPiFyxOG4Li7vOnTzqsHQ1A/uSG9ViReC1u6QMjWE9DKvlh84oLJvBWU7KijYuZYpBe1/NT8YFPi5wTEbQzAX0Y8hn/g1OQDl3CfoUigv7pqbsUnV4KJpIxs1CBX0RdsLzWdmwK7Xh8emBkbDdGM/pBYalWahiRFEz3Mrg8WOHHp//T5XVaBjs86cZd6CKGfXeU7+Hy5pZBBLhcr3AAq3gNJjVHMMJ53F1wGWgedHUyrDkL9yD0OnfVYKs7Yi0pxUSmhlrNaeq5aKSkcSahjkaSa6S40ZZWCnMnlUNW9MVAOPASwK8YhlJymqMgBGSRJyVdJktLg+oGYR0DovlkVoglyStUg38mbGlkbwIK4X32ZzllORyretLJieoqohN/RScguJgTtSsekbRRCM/qRcly1gIGYzoocRSYRdyOTpWHh8cH66KeVWvcbw7v1uSMM9KDhLUaZfJaWXDRbAcNqMaTlApaiNFieGlSj7nZGna3JPJjrzlwNGnt91rbN1NHwA99irQY2+lnqDeR32U+swdRSYjJ4mw5ceO2Y/+gU13Ws0eFosTi6+ngAwskBXFjN17H4I5tyNi4qO45fRuOTZ/a2FxUexbkRUl/mZnIs9QbpEf7kBVDPYsTjZ/hBo10zYpxIt2Ghj9r5pt1Rq1fUO6kx+wy3k+y79dypVMVSstA8fwLMOL92LO2R+43d90g8BFR9yg++HqvdXKw66ouJYs4NJlV864biZXeNBoOKYx6HI5NtqxRXzXyZNvOXVqfMg2DumOozO53DIWBP5Hrmak16+5hvaB7pdYfAjwLXOeYZAgKor2GrKSj5MkWy7/4jOPZKTXvckEGyqqrxtQOl/MyLXDppM3Fs3CGEg1fFzq/wD4gNnyeJxjYGRgYADi1xUOZ+P5bb4ycLMwgMDle+rhCPr/GubnzPFALgcDE0gUAEfRC4AAeJxjYGRgYG7438AQw8IAAszPGRgZUIEmAFhAA3gAAAB4nGNgYGBgGeQYADPkAKEAAAAAAABQARQBrgJUAt4DtgSABPYFPAXOBiwGoAdsCFwJDgoSClAKvAs0C5QL8gxIDNYNYA2IDbAOXA6QDxQPrBAEEFIQxBFMEbASRhLKExQVehZyeJxjYGRgYNBkXMAgygACTEDMBYQMDP/BfAYAHjoB9gB4nF2QQU7CQBSG/0LBCGqMJibuZmFcaNICSw4AexLZF5hCS+k00ykJWw/gATyFB3DtufzbvoU4L3nzzTd/X5MBcIsfeKiXh37T69XBBU8td0nXwj75XriHIR6F+6wn4QFe8SI8ZPqNEzz/kuYKO+EObuCEu/Tvwj75Q7iHB3wK9+m/hAdY4lt4iGfvbp9sTFot9LbKItse2r7UtkxMrsbBqBVznWsbOb1Rq5Mqj9uJc7GKrTmomcmdzjKjCmtSvXbBzrliGoax+GBtDtgjwQYGKSosoLHlniGCPbv5y0umLEoagxwKYwQYnSXmTORNKuKLaHqFFU7sJY78w4TWIeY5ZsbgQJo10+p0xjI0RXOX0qzpA75z/VWBKUJW/C8fMMVJv5k7VxQAAHicbY/ZcsIwFEOjYuIA3fd93+gMH+XEl8RDYnvs61D+vmF4rR70pDmSsr1sp2n2v+bYwwgCY+SQKDDBFDPs4wCHOMIxTnCKM5zjApe4wjVucIs73OMBj3jCM17wije84wOf+MI35vjJRkprqawOzuix8r6lPKayMyzK1tWFVkxsOhJxYysZTW1d4lwHtaYgekPrYqkqKp1biSWRnkZSoWoWSvdFJGZj65jXztUtycZEdmEjGteRjMl7F7hojV2RNla0ph+aB76x+Q6SB9pGZOW6jiwXPlBvXIrC0i9PvLFMgSLnVaBhpPSpbE1sREOtH8dGhWEzq5BvbeFmkVNXtpS8s4JVHcexcoEkrw0PHJEihcnWemcqkpvhZSopy/4AKitsDAA="

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "15ce033088a0bf7a70131fb53cedfc3b.ttf";

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(198);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(180)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/less-loader/index.js!./app.mobile.less", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js!./../node_modules/postcss-loader/index.js!./../node_modules/less-loader/index.js!./app.mobile.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(179)();
	// imports
	
	
	// module
	exports.push([module.id, "html,\nbody,\n#phone {\n  height: 100%;\n  margin: 0;\n  /**********************************************************\n    * Drawer\n    **********************************************************/\n  /**********************************************************\n    * Activities view\n    **********************************************************/\n  /**********************************************************\n    * Categories view\n    **********************************************************/\n  /**********************************************************\n    * Favourites view\n    **********************************************************/\n  /**********************************************************\n    * Player view\n    **********************************************************/\n  /**********************************************************\n     * Score view\n     **********************************************************/\n  /**********************************************************\n     * Settings view\n     **********************************************************/\n  /**********************************************************\n    * Summaries view (search results)\n    **********************************************************/\n}\nhtml #phone-drawer .km-view-title,\nbody #phone-drawer .km-view-title,\n#phone #phone-drawer .km-view-title {\n  text-align: left;\n  margin-left: 0.5em;\n}\nhtml #phone-drawer .km-scroll-container,\nbody #phone-drawer .km-scroll-container,\n#phone #phone-drawer .km-scroll-container {\n  display: initial;\n}\nhtml #phone-drawer .km-scroll-container .km-listview > li,\nbody #phone-drawer .km-scroll-container .km-listview > li,\n#phone #phone-drawer .km-scroll-container .km-listview > li {\n  padding: .84em .7em;\n}\nhtml #phone-categories .km-listview > li,\nbody #phone-categories .km-listview > li,\n#phone #phone-categories .km-listview > li {\n  padding: .5em .84em;\n}\nhtml #phone-categories .km-listview > li .km-thumbnail,\nbody #phone-categories .km-listview > li .km-thumbnail,\n#phone #phone-categories .km-listview > li .km-thumbnail {\n  border: none;\n  border-radius: 0;\n  height: 1.8rem;\n  width: 1.8rem;\n  vertical-align: middle;\n}\nhtml #phone-player .km-stretched-view,\nbody #phone-player .km-stretched-view,\n#phone #phone-player .km-stretched-view {\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-wrap: wrap;\n      flex-wrap: wrap;\n}\nhtml #phone-player .km-stretched-view .padding,\nbody #phone-player .km-stretched-view .padding,\n#phone #phone-player .km-stretched-view .padding {\n  padding: 1em;\n}\nhtml #phone-player .km-stretched-view .padding .heading h2,\nbody #phone-player .km-stretched-view .padding .heading h2,\n#phone #phone-player .km-stretched-view .padding .heading h2 {\n  margin: 0;\n  font-size: 1rem;\n}\nhtml #phone-player .km-stretched-view .padding .heading h2 img,\nbody #phone-player .km-stretched-view .padding .heading h2 img,\n#phone #phone-player .km-stretched-view .padding .heading h2 img {\n  height: 1.5em;\n  width: 1.5em;\n  margin-right: 0.5em;\n  vertical-align: middle;\n}\nhtml #phone-summaries .km-listview li,\nbody #phone-summaries .km-listview li,\n#phone #phone-summaries .km-listview li {\n  padding-top: 0.7em;\n  padding-bottom: 0.7em;\n}\nhtml #phone-summaries .km-listview li .km-thumbnail,\nbody #phone-summaries .km-listview li .km-thumbnail,\n#phone #phone-summaries .km-listview li .km-thumbnail {\n  border: none;\n  border-radius: 0;\n  height: 3.35rem;\n  width: 3.35rem;\n  margin-right: 0;\n  float: left;\n}\nhtml #phone-summaries .km-listview li .summary,\nbody #phone-summaries .km-listview li .summary,\n#phone #phone-summaries .km-listview li .summary {\n  margin-left: 4rem;\n}\nhtml #phone-summaries .km-listview li .summary h4,\nbody #phone-summaries .km-listview li .summary h4,\n#phone #phone-summaries .km-listview li .summary h4 {\n  margin: 0 .2em;\n  font-weight: bold;\n  font-size: 1.1em;\n}\nhtml #phone-summaries .km-listview li .summary .tags,\nbody #phone-summaries .km-listview li .summary .tags,\n#phone #phone-summaries .km-listview li .summary .tags {\n  margin: 0 .2em;\n  font-size: 0.8em;\n}\nhtml #phone-summaries .km-listview li .summary .metrics,\nbody #phone-summaries .km-listview li .summary .metrics,\n#phone #phone-summaries .km-listview li .summary .metrics {\n  margin: 0 .2em;\n  font-size: 0.8em;\n}\nhtml #phone-summaries .km-listview li .summary .km-button-right,\nbody #phone-summaries .km-listview li .summary .km-button-right,\n#phone #phone-summaries .km-listview li .summary .km-button-right {\n  margin-top: -1em;\n  float: right;\n}\n", ""]);
	
	// exports


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true */
	/* globals define: false, __VERSION__: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    /**
	     * Note: This file is built with webpack using ./web_modules/jsx-loader.
	     * Values are read from any of the JSON config files in ./webapp/config
	     * depending on NODE_ENV: development, test or production (by default).
	     */
	
	    (function () {
	
	        var app = window.app = window.app || {};
	
	        /**
	         * Join url bits, adding slashes where required
	         * TODO: This could be improved to account for . and ..
	         */
	        var url = {
	            join: function () {
	                // Actually we first join with slashes, then we replace double or triple slashes, except when preceded by colons like in http://
	                return Array.prototype.slice.call(arguments).join('/').replace(/([^:])[\/]{2,}/g, '$1/');
	            }
	        };
	
	        /**
	         * application DEBUG mode
	         * @type {boolean}
	         */
	        app.DEBUG = 'true'.toLowerCase() === 'true';
	
	        /**
	         * application version
	         * Note: this is the only way to do it because version does not exist in configuration files loaded by ./web_modules/jsx_loader
	         */
	        app.version = ("0.2.57");
	
	        /**
	         * application locales
	         */
	        app.locales = JSON.parse('["en","fr"]');
	
	        /**
	         * Facebook
	         * @type {{clientId: string}}
	         */
	        app.facebook = { clientID: '628502177236998' };
	
	        /**
	         * Twitter
	         * @type {{account: string}}
	         */
	        app.twitter = { account: 'kidoju' };
	
	        /**
	         * Convert nodejs printf like formatting strings into Kendo UI formatting strings
	         * where %s placeholders are replaced with {i} placeholders
	         * @see https://nodejs.org/api/util.html#util_util_format_format
	         * @see http://docs.telerik.com/kendo-ui/api/javascript/kendo#methods-format
	         * @param value
	         * @returns {*}
	         */
	        function convertFormat (value) {
	            var i = 0;
	            var ret = value;
	            var rx = /%[sdj]/;
	            while (typeof ret === 'string' && rx.test(ret)) {
	                ret = ret.replace(rx, '{' + i + '}');
	                i++;
	            }
	            return ret;
	        }
	
	        /**
	         * Assets for Asset Manager
	         * @type {{audio: {collections, extensions, schemes, transport}, image: {collections, extensions, schemes, transport}, video: {collections, extensions, schemes, transport}}}
	         */
	        app.assets = {
	
	            audio: {
	                collections: JSON.parse('[]'),
	                extensions: JSON.parse('[".mp3",".ogg"]'),
	                schemes: JSON.parse('{"cdn":"https://cdn.kidoju.com/","data":"https://s3.amazonaws.com/kidoju.data/"}')
	                // transport: JSON.parse('')
	            },
	
	            icon: {
	                collections: JSON.parse('[{"name":"O-Collection","transport":{"read":"https://cdn.kidoju.com/images/o_collection/svg/office/index.json"}}]'),
	                extensions: JSON.parse('[".svg"]'),
	                schemes: JSON.parse('{"cdn":"https://cdn.kidoju.com/"}')
	                // transport: JSON.parse('')
	            },
	
	            image: {
	                collections: JSON.parse('[{"name":"G-Collection","transport":{"read":"https://cdn.kidoju.com/images/g_collection/svg/all/index.json"}},{"name":"O-Collection","collections":[{"name":"Dark Grey","transport":{"read":"https://cdn.kidoju.com/images/o_collection/svg/dark_grey/index.json"}},{"name":"Office","transport":{"read":"https://cdn.kidoju.com/images/o_collection/svg/office/index.json"}},{"name":"White","transport":{"read":"https://cdn.kidoju.com/images/o_collection/svg/white/index.json"}}]},{"name":"V-Collection","collections":[{"name":"Small","transport":{"read":"https://cdn.kidoju.com/images/v_collection/png/32x32/index.json"}},{"name":"Medium","transport":{"read":"https://cdn.kidoju.com/images/v_collection/png/64x64/index.json"}},{"name":"Large","transport":{"read":"https://cdn.kidoju.com/images/v_collection/png/128x128/index.json"}},{"name":"Huge","transport":{"read":"https://cdn.kidoju.com/images/v_collection/png/256x256/index.json"}}]},{"name":"X-Collection","collections":[{"name":"Small","transport":{"read":"https://cdn.kidoju.com/images/x_collection/png/32x32/index.json"}},{"name":"Large","transport":{"read":"https://cdn.kidoju.com/images/x_collection/png/128x128/index.json"}}]}]'),
	                extensions: JSON.parse('[".gif",".jpg",".png",".svg"]'),
	                schemes: JSON.parse('{"cdn":"https://cdn.kidoju.com/","data":"https://s3.amazonaws.com/kidoju.data/"}')
	                // transport: JSON.parse('')
	            },
	
	            video: {
	                collections: JSON.parse('[]'),
	                extensions: JSON.parse('[".mp4",".ogv",".wbem"]'),
	                schemes: JSON.parse('{"cdn":"https://cdn.kidoju.com/","data":"https://s3.amazonaws.com/kidoju.data/"}')
	                // transport: JSON.parse('')
	            }
	
	        };
	
	        /**
	         * Application URIs
	         * See /wepapp/middleware/locals.js
	         * ATTENTION, contrary to server-side uris client-side uris are all concatenated with root expect for rapi
	         */
	        app.uris = {
	            rapi: {
	                root: 'http://10.0.0.105:3001',
	                logger: 'http://10.0.0.105:3001' + convertFormat('/api/logger')
	            },
	            cdn: {
	                icons: url.join('https://cdn.kidoju.com', convertFormat('/images/o_collection/svg/office/%s.svg'))
	            },
	            mobile: {
	                icons: convertFormat('./img/%s.svg')
	            },
	            webapp: {
	                editor: url.join('http://10.0.0.105:3001', convertFormat('/%s/e/%s/%s')),
	                error: url.join('http://10.0.0.105:3001', convertFormat('/%s/error')),
	                finder: url.join('http://10.0.0.105:3001', convertFormat('/%s')),
	                home: url.join('http://10.0.0.105:3001', convertFormat('/')),
	                locale: url.join('http://10.0.0.105:3001', convertFormat('/%s')), // redirection when changing locale
	                logger: url.join('http://10.0.0.105:3001', convertFormat('/api/logger')),
	                ping: url.join('http://10.0.0.105:3001', convertFormat('/ping')),
	                player: url.join('http://10.0.0.105:3001', convertFormat('/%s/x/%s/%s/%s')),
	                proxy: url.join('http://10.0.0.105:3001', convertFormat('/proxy')),
	                public: url.join('http://10.0.0.105:3001', convertFormat('/%s')),
	                rss: url.join('http://10.0.0.105:3001', convertFormat('/%s/rss/%s')),
	                sitemap: url.join('http://10.0.0.105:3001', convertFormat('/%s/sitemap/%s')),
	                summary: url.join('http://10.0.0.105:3001', convertFormat('/%s/s/%s')),
	                support: url.join('http://10.0.0.105:3001', convertFormat('/support/%s')),
	                user: url.join('http://10.0.0.105:3001', convertFormat('/%s/u/%s')),
	                workerlib: url.join('./build/', convertFormat('workerlib.bundle.js'))
	            }
	        };
	
	        /**
	         * Logger configuration
	         */
	        app.logger = app.logger || {};
	        app.logger.level = parseInt('0', 10) || 0;
	        app.logger.endPoint = app.uris.webapp.logger;
	
	    }());
	
	    return window.app;
	
	}, __webpack_require__(200));


/***/ },
/* 200 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false, require: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    (function ($, undefined) {
	
	        var UNDEFINED = 'undefined';
	        var SEP = '.';
	
	        /**
	         * SecureStorage
	         * @see https://github.com/Crypho/cordova-plugin-secure-storage
	         * @param name
	         * @constructor
	         */
	        var SecureStorage = function () {
	            this._ss;
	        };
	
	        /**
	         * Initialization;
	         */
	        SecureStorage.prototype.init = function (name) {
	            if ($.type(this._ss) !== UNDEFINED) {
	                return; // TODO assert this._ss?
	            }
	            if (window.cordova && window.cordova.plugins && window.cordova.plugins.SecureStorage) {
	                this._ss = new window.cordova.plugins.SecureStorage(
	                    function () {
	                        console.log('OK'); // TODO
	                    },
	                    function (error) {
	                        console.log(error);
	                        // TODO https://github.com/Crypho/cordova-plugin-secure-storage#users-must-have-a-secure-screen-lock-set
	                        // Test and update on android
	                        navigator.notification.alert(
	                            'Please enable the screen lock on your device. This app cannot operate securely without it.',
	                            function () {
	                                this._ss.secureDevice(
	                                    function () {
	                                        console.log('OK');
	                                    },
	                                    function () {
	                                        this.init();
	                                    }
	                                );
	                            },
	                            'Screen lock is disabled'
	                        );
	                    },
	                    name);
	            } else {
	                this._ss = {
	                    set: function (success, failure, key, value) {
	                        try {
	                            window.localStorage.setItem(name + SEP + key, JSON.stringify(value));
	                            success(key);
	                        } catch (err) {
	                            failure(err);
	                        }
	                    },
	                    get: function (success, failure, key) {
	                        try {
	                            var value = JSON.parse(window.localStorage.getItem(name + SEP + key));
	                            success(value);
	                        } catch (err) {
	                            failure(err);
	                        }
	                    },
	                    remove: function (success, failure, key) {
	                        try {
	                            window.localStorage.removeItem(name + SEP + key);
	                            success(key);
	                        } catch (err) {
	                            failure(err);
	                        }
	                    }
	                }
	            }
	        };
	
	        /**
	         * Set an item by key
	         * @param key
	         * @param value
	         * @returns {*}
	         */
	        SecureStorage.prototype.setItem =  function (key, value) {
	            var dfd = $.Deferred();
	            // TODO assert this._ss, key and value ???
	            this._ss.set(dfd.resolve, dfd.reject, key, value);
	            return dfd.promise();
	        };
	
	        /**
	         * Get an item by key
	         * @param key
	         * @returns {*}
	         */
	        SecureStorage.prototype.getItem =  function (key) {
	            var dfd = $.Deferred();
	            this._ss.get(dfd.resolve, dfd.reject, key);
	            return dfd.promise();
	        };
	
	        /**
	         * Remove an item by key
	         * @param key
	         * @returns {*}
	         */
	        SecureStorage.prototype.removeItem =  function (key) {
	            var dfd = $.Deferred();
	            this._ss.remove(dfd.resolve, dfd.reject, key);
	            return dfd.promise();
	        };
	
	        window.secureStorage = new SecureStorage();
	
	    }(window.jQuery));
	
	    return window.secureStorage;
	
	}, __webpack_require__(200));


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(203)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'core',
	        name: 'Core',
	        category: 'framework',
	        description: 'The core of the Kendo framework.'
	    };
	    (function ($, window, undefined) {
	        var kendo = window.kendo = window.kendo || { cultures: {} }, extend = $.extend, each = $.each, isArray = $.isArray, proxy = $.proxy, noop = $.noop, math = Math, Template, JSON = window.JSON || {}, support = {}, percentRegExp = /%/, formatRegExp = /\{(\d+)(:[^\}]+)?\}/g, boxShadowRegExp = /(\d+(?:\.?)\d*)px\s*(\d+(?:\.?)\d*)px\s*(\d+(?:\.?)\d*)px\s*(\d+)?/i, numberRegExp = /^(\+|-?)\d+(\.?)\d*$/, FUNCTION = 'function', STRING = 'string', NUMBER = 'number', OBJECT = 'object', NULL = 'null', BOOLEAN = 'boolean', UNDEFINED = 'undefined', getterCache = {}, setterCache = {}, slice = [].slice;
	        kendo.version = '2016.3.914'.replace(/^\s+|\s+$/g, '');
	        function Class() {
	        }
	        Class.extend = function (proto) {
	            var base = function () {
	                }, member, that = this, subclass = proto && proto.init ? proto.init : function () {
	                    that.apply(this, arguments);
	                }, fn;
	            base.prototype = that.prototype;
	            fn = subclass.fn = subclass.prototype = new base();
	            for (member in proto) {
	                if (proto[member] != null && proto[member].constructor === Object) {
	                    fn[member] = extend(true, {}, base.prototype[member], proto[member]);
	                } else {
	                    fn[member] = proto[member];
	                }
	            }
	            fn.constructor = subclass;
	            subclass.extend = that.extend;
	            return subclass;
	        };
	        Class.prototype._initOptions = function (options) {
	            this.options = deepExtend({}, this.options, options);
	        };
	        var isFunction = kendo.isFunction = function (fn) {
	            return typeof fn === 'function';
	        };
	        var preventDefault = function () {
	            this._defaultPrevented = true;
	        };
	        var isDefaultPrevented = function () {
	            return this._defaultPrevented === true;
	        };
	        var Observable = Class.extend({
	            init: function () {
	                this._events = {};
	            },
	            bind: function (eventName, handlers, one) {
	                var that = this, idx, eventNames = typeof eventName === STRING ? [eventName] : eventName, length, original, handler, handlersIsFunction = typeof handlers === FUNCTION, events;
	                if (handlers === undefined) {
	                    for (idx in eventName) {
	                        that.bind(idx, eventName[idx]);
	                    }
	                    return that;
	                }
	                for (idx = 0, length = eventNames.length; idx < length; idx++) {
	                    eventName = eventNames[idx];
	                    handler = handlersIsFunction ? handlers : handlers[eventName];
	                    if (handler) {
	                        if (one) {
	                            original = handler;
	                            handler = function () {
	                                that.unbind(eventName, handler);
	                                original.apply(that, arguments);
	                            };
	                            handler.original = original;
	                        }
	                        events = that._events[eventName] = that._events[eventName] || [];
	                        events.push(handler);
	                    }
	                }
	                return that;
	            },
	            one: function (eventNames, handlers) {
	                return this.bind(eventNames, handlers, true);
	            },
	            first: function (eventName, handlers) {
	                var that = this, idx, eventNames = typeof eventName === STRING ? [eventName] : eventName, length, handler, handlersIsFunction = typeof handlers === FUNCTION, events;
	                for (idx = 0, length = eventNames.length; idx < length; idx++) {
	                    eventName = eventNames[idx];
	                    handler = handlersIsFunction ? handlers : handlers[eventName];
	                    if (handler) {
	                        events = that._events[eventName] = that._events[eventName] || [];
	                        events.unshift(handler);
	                    }
	                }
	                return that;
	            },
	            trigger: function (eventName, e) {
	                var that = this, events = that._events[eventName], idx, length;
	                if (events) {
	                    e = e || {};
	                    e.sender = that;
	                    e._defaultPrevented = false;
	                    e.preventDefault = preventDefault;
	                    e.isDefaultPrevented = isDefaultPrevented;
	                    events = events.slice();
	                    for (idx = 0, length = events.length; idx < length; idx++) {
	                        events[idx].call(that, e);
	                    }
	                    return e._defaultPrevented === true;
	                }
	                return false;
	            },
	            unbind: function (eventName, handler) {
	                var that = this, events = that._events[eventName], idx;
	                if (eventName === undefined) {
	                    that._events = {};
	                } else if (events) {
	                    if (handler) {
	                        for (idx = events.length - 1; idx >= 0; idx--) {
	                            if (events[idx] === handler || events[idx].original === handler) {
	                                events.splice(idx, 1);
	                            }
	                        }
	                    } else {
	                        that._events[eventName] = [];
	                    }
	                }
	                return that;
	            }
	        });
	        function compilePart(part, stringPart) {
	            if (stringPart) {
	                return '\'' + part.split('\'').join('\\\'').split('\\"').join('\\\\\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t') + '\'';
	            } else {
	                var first = part.charAt(0), rest = part.substring(1);
	                if (first === '=') {
	                    return '+(' + rest + ')+';
	                } else if (first === ':') {
	                    return '+$kendoHtmlEncode(' + rest + ')+';
	                } else {
	                    return ';' + part + ';$kendoOutput+=';
	                }
	            }
	        }
	        var argumentNameRegExp = /^\w+/, encodeRegExp = /\$\{([^}]*)\}/g, escapedCurlyRegExp = /\\\}/g, curlyRegExp = /__CURLY__/g, escapedSharpRegExp = /\\#/g, sharpRegExp = /__SHARP__/g, zeros = [
	                '',
	                '0',
	                '00',
	                '000',
	                '0000'
	            ];
	        Template = {
	            paramName: 'data',
	            useWithBlock: true,
	            render: function (template, data) {
	                var idx, length, html = '';
	                for (idx = 0, length = data.length; idx < length; idx++) {
	                    html += template(data[idx]);
	                }
	                return html;
	            },
	            compile: function (template, options) {
	                var settings = extend({}, this, options), paramName = settings.paramName, argumentName = paramName.match(argumentNameRegExp)[0], useWithBlock = settings.useWithBlock, functionBody = 'var $kendoOutput, $kendoHtmlEncode = kendo.htmlEncode;', fn, parts, idx;
	                if (isFunction(template)) {
	                    return template;
	                }
	                functionBody += useWithBlock ? 'with(' + paramName + '){' : '';
	                functionBody += '$kendoOutput=';
	                parts = template.replace(escapedCurlyRegExp, '__CURLY__').replace(encodeRegExp, '#=$kendoHtmlEncode($1)#').replace(curlyRegExp, '}').replace(escapedSharpRegExp, '__SHARP__').split('#');
	                for (idx = 0; idx < parts.length; idx++) {
	                    functionBody += compilePart(parts[idx], idx % 2 === 0);
	                }
	                functionBody += useWithBlock ? ';}' : ';';
	                functionBody += 'return $kendoOutput;';
	                functionBody = functionBody.replace(sharpRegExp, '#');
	                try {
	                    fn = new Function(argumentName, functionBody);
	                    fn._slotCount = Math.floor(parts.length / 2);
	                    return fn;
	                } catch (e) {
	                    throw new Error(kendo.format('Invalid template:\'{0}\' Generated code:\'{1}\'', template, functionBody));
	                }
	            }
	        };
	        function pad(number, digits, end) {
	            number = number + '';
	            digits = digits || 2;
	            end = digits - number.length;
	            if (end) {
	                return zeros[digits].substring(0, end) + number;
	            }
	            return number;
	        }
	        (function () {
	            var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
	                    '\b': '\\b',
	                    '\t': '\\t',
	                    '\n': '\\n',
	                    '\f': '\\f',
	                    '\r': '\\r',
	                    '"': '\\"',
	                    '\\': '\\\\'
	                }, rep, toString = {}.toString;
	            if (typeof Date.prototype.toJSON !== FUNCTION) {
	                Date.prototype.toJSON = function () {
	                    var that = this;
	                    return isFinite(that.valueOf()) ? pad(that.getUTCFullYear(), 4) + '-' + pad(that.getUTCMonth() + 1) + '-' + pad(that.getUTCDate()) + 'T' + pad(that.getUTCHours()) + ':' + pad(that.getUTCMinutes()) + ':' + pad(that.getUTCSeconds()) + 'Z' : null;
	                };
	                String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function () {
	                    return this.valueOf();
	                };
	            }
	            function quote(string) {
	                escapable.lastIndex = 0;
	                return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
	                    var c = meta[a];
	                    return typeof c === STRING ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	                }) + '"' : '"' + string + '"';
	            }
	            function str(key, holder) {
	                var i, k, v, length, mind = gap, partial, value = holder[key], type;
	                if (value && typeof value === OBJECT && typeof value.toJSON === FUNCTION) {
	                    value = value.toJSON(key);
	                }
	                if (typeof rep === FUNCTION) {
	                    value = rep.call(holder, key, value);
	                }
	                type = typeof value;
	                if (type === STRING) {
	                    return quote(value);
	                } else if (type === NUMBER) {
	                    return isFinite(value) ? String(value) : NULL;
	                } else if (type === BOOLEAN || type === NULL) {
	                    return String(value);
	                } else if (type === OBJECT) {
	                    if (!value) {
	                        return NULL;
	                    }
	                    gap += indent;
	                    partial = [];
	                    if (toString.apply(value) === '[object Array]') {
	                        length = value.length;
	                        for (i = 0; i < length; i++) {
	                            partial[i] = str(i, value) || NULL;
	                        }
	                        v = partial.length === 0 ? '[]' : gap ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' : '[' + partial.join(',') + ']';
	                        gap = mind;
	                        return v;
	                    }
	                    if (rep && typeof rep === OBJECT) {
	                        length = rep.length;
	                        for (i = 0; i < length; i++) {
	                            if (typeof rep[i] === STRING) {
	                                k = rep[i];
	                                v = str(k, value);
	                                if (v) {
	                                    partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                                }
	                            }
	                        }
	                    } else {
	                        for (k in value) {
	                            if (Object.hasOwnProperty.call(value, k)) {
	                                v = str(k, value);
	                                if (v) {
	                                    partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                                }
	                            }
	                        }
	                    }
	                    v = partial.length === 0 ? '{}' : gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' : '{' + partial.join(',') + '}';
	                    gap = mind;
	                    return v;
	                }
	            }
	            if (typeof JSON.stringify !== FUNCTION) {
	                JSON.stringify = function (value, replacer, space) {
	                    var i;
	                    gap = '';
	                    indent = '';
	                    if (typeof space === NUMBER) {
	                        for (i = 0; i < space; i += 1) {
	                            indent += ' ';
	                        }
	                    } else if (typeof space === STRING) {
	                        indent = space;
	                    }
	                    rep = replacer;
	                    if (replacer && typeof replacer !== FUNCTION && (typeof replacer !== OBJECT || typeof replacer.length !== NUMBER)) {
	                        throw new Error('JSON.stringify');
	                    }
	                    return str('', { '': value });
	                };
	            }
	        }());
	        (function () {
	            var dateFormatRegExp = /dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|HH|H|hh|h|mm|m|fff|ff|f|tt|ss|s|zzz|zz|z|"[^"]*"|'[^']*'/g, standardFormatRegExp = /^(n|c|p|e)(\d*)$/i, literalRegExp = /(\\.)|(['][^']*[']?)|(["][^"]*["]?)/g, commaRegExp = /\,/g, EMPTY = '', POINT = '.', COMMA = ',', SHARP = '#', ZERO = '0', PLACEHOLDER = '??', EN = 'en-US', objectToString = {}.toString;
	            kendo.cultures['en-US'] = {
	                name: EN,
	                numberFormat: {
	                    pattern: ['-n'],
	                    decimals: 2,
	                    ',': ',',
	                    '.': '.',
	                    groupSize: [3],
	                    percent: {
	                        pattern: [
	                            '-n %',
	                            'n %'
	                        ],
	                        decimals: 2,
	                        ',': ',',
	                        '.': '.',
	                        groupSize: [3],
	                        symbol: '%'
	                    },
	                    currency: {
	                        name: 'US Dollar',
	                        abbr: 'USD',
	                        pattern: [
	                            '($n)',
	                            '$n'
	                        ],
	                        decimals: 2,
	                        ',': ',',
	                        '.': '.',
	                        groupSize: [3],
	                        symbol: '$'
	                    }
	                },
	                calendars: {
	                    standard: {
	                        days: {
	                            names: [
	                                'Sunday',
	                                'Monday',
	                                'Tuesday',
	                                'Wednesday',
	                                'Thursday',
	                                'Friday',
	                                'Saturday'
	                            ],
	                            namesAbbr: [
	                                'Sun',
	                                'Mon',
	                                'Tue',
	                                'Wed',
	                                'Thu',
	                                'Fri',
	                                'Sat'
	                            ],
	                            namesShort: [
	                                'Su',
	                                'Mo',
	                                'Tu',
	                                'We',
	                                'Th',
	                                'Fr',
	                                'Sa'
	                            ]
	                        },
	                        months: {
	                            names: [
	                                'January',
	                                'February',
	                                'March',
	                                'April',
	                                'May',
	                                'June',
	                                'July',
	                                'August',
	                                'September',
	                                'October',
	                                'November',
	                                'December'
	                            ],
	                            namesAbbr: [
	                                'Jan',
	                                'Feb',
	                                'Mar',
	                                'Apr',
	                                'May',
	                                'Jun',
	                                'Jul',
	                                'Aug',
	                                'Sep',
	                                'Oct',
	                                'Nov',
	                                'Dec'
	                            ]
	                        },
	                        AM: [
	                            'AM',
	                            'am',
	                            'AM'
	                        ],
	                        PM: [
	                            'PM',
	                            'pm',
	                            'PM'
	                        ],
	                        patterns: {
	                            d: 'M/d/yyyy',
	                            D: 'dddd, MMMM dd, yyyy',
	                            F: 'dddd, MMMM dd, yyyy h:mm:ss tt',
	                            g: 'M/d/yyyy h:mm tt',
	                            G: 'M/d/yyyy h:mm:ss tt',
	                            m: 'MMMM dd',
	                            M: 'MMMM dd',
	                            s: 'yyyy\'-\'MM\'-\'ddTHH\':\'mm\':\'ss',
	                            t: 'h:mm tt',
	                            T: 'h:mm:ss tt',
	                            u: 'yyyy\'-\'MM\'-\'dd HH\':\'mm\':\'ss\'Z\'',
	                            y: 'MMMM, yyyy',
	                            Y: 'MMMM, yyyy'
	                        },
	                        '/': '/',
	                        ':': ':',
	                        firstDay: 0,
	                        twoDigitYearMax: 2029
	                    }
	                }
	            };
	            function findCulture(culture) {
	                if (culture) {
	                    if (culture.numberFormat) {
	                        return culture;
	                    }
	                    if (typeof culture === STRING) {
	                        var cultures = kendo.cultures;
	                        return cultures[culture] || cultures[culture.split('-')[0]] || null;
	                    }
	                    return null;
	                }
	                return null;
	            }
	            function getCulture(culture) {
	                if (culture) {
	                    culture = findCulture(culture);
	                }
	                return culture || kendo.cultures.current;
	            }
	            kendo.culture = function (cultureName) {
	                var cultures = kendo.cultures, culture;
	                if (cultureName !== undefined) {
	                    culture = findCulture(cultureName) || cultures[EN];
	                    culture.calendar = culture.calendars.standard;
	                    cultures.current = culture;
	                } else {
	                    return cultures.current;
	                }
	            };
	            kendo.findCulture = findCulture;
	            kendo.getCulture = getCulture;
	            kendo.culture(EN);
	            function formatDate(date, format, culture) {
	                culture = getCulture(culture);
	                var calendar = culture.calendars.standard, days = calendar.days, months = calendar.months;
	                format = calendar.patterns[format] || format;
	                return format.replace(dateFormatRegExp, function (match) {
	                    var minutes;
	                    var result;
	                    var sign;
	                    if (match === 'd') {
	                        result = date.getDate();
	                    } else if (match === 'dd') {
	                        result = pad(date.getDate());
	                    } else if (match === 'ddd') {
	                        result = days.namesAbbr[date.getDay()];
	                    } else if (match === 'dddd') {
	                        result = days.names[date.getDay()];
	                    } else if (match === 'M') {
	                        result = date.getMonth() + 1;
	                    } else if (match === 'MM') {
	                        result = pad(date.getMonth() + 1);
	                    } else if (match === 'MMM') {
	                        result = months.namesAbbr[date.getMonth()];
	                    } else if (match === 'MMMM') {
	                        result = months.names[date.getMonth()];
	                    } else if (match === 'yy') {
	                        result = pad(date.getFullYear() % 100);
	                    } else if (match === 'yyyy') {
	                        result = pad(date.getFullYear(), 4);
	                    } else if (match === 'h') {
	                        result = date.getHours() % 12 || 12;
	                    } else if (match === 'hh') {
	                        result = pad(date.getHours() % 12 || 12);
	                    } else if (match === 'H') {
	                        result = date.getHours();
	                    } else if (match === 'HH') {
	                        result = pad(date.getHours());
	                    } else if (match === 'm') {
	                        result = date.getMinutes();
	                    } else if (match === 'mm') {
	                        result = pad(date.getMinutes());
	                    } else if (match === 's') {
	                        result = date.getSeconds();
	                    } else if (match === 'ss') {
	                        result = pad(date.getSeconds());
	                    } else if (match === 'f') {
	                        result = math.floor(date.getMilliseconds() / 100);
	                    } else if (match === 'ff') {
	                        result = date.getMilliseconds();
	                        if (result > 99) {
	                            result = math.floor(result / 10);
	                        }
	                        result = pad(result);
	                    } else if (match === 'fff') {
	                        result = pad(date.getMilliseconds(), 3);
	                    } else if (match === 'tt') {
	                        result = date.getHours() < 12 ? calendar.AM[0] : calendar.PM[0];
	                    } else if (match === 'zzz') {
	                        minutes = date.getTimezoneOffset();
	                        sign = minutes < 0;
	                        result = math.abs(minutes / 60).toString().split('.')[0];
	                        minutes = math.abs(minutes) - result * 60;
	                        result = (sign ? '+' : '-') + pad(result);
	                        result += ':' + pad(minutes);
	                    } else if (match === 'zz' || match === 'z') {
	                        result = date.getTimezoneOffset() / 60;
	                        sign = result < 0;
	                        result = math.abs(result).toString().split('.')[0];
	                        result = (sign ? '+' : '-') + (match === 'zz' ? pad(result) : result);
	                    }
	                    return result !== undefined ? result : match.slice(1, match.length - 1);
	                });
	            }
	            function formatNumber(number, format, culture) {
	                culture = getCulture(culture);
	                var numberFormat = culture.numberFormat, decimal = numberFormat[POINT], precision = numberFormat.decimals, pattern = numberFormat.pattern[0], literals = [], symbol, isCurrency, isPercent, customPrecision, formatAndPrecision, negative = number < 0, integer, fraction, integerLength, fractionLength, replacement = EMPTY, value = EMPTY, idx, length, ch, hasGroup, hasNegativeFormat, decimalIndex, sharpIndex, zeroIndex, hasZero, hasSharp, percentIndex, currencyIndex, startZeroIndex, start = -1, end;
	                if (number === undefined) {
	                    return EMPTY;
	                }
	                if (!isFinite(number)) {
	                    return number;
	                }
	                if (!format) {
	                    return culture.name.length ? number.toLocaleString() : number.toString();
	                }
	                formatAndPrecision = standardFormatRegExp.exec(format);
	                if (formatAndPrecision) {
	                    format = formatAndPrecision[1].toLowerCase();
	                    isCurrency = format === 'c';
	                    isPercent = format === 'p';
	                    if (isCurrency || isPercent) {
	                        numberFormat = isCurrency ? numberFormat.currency : numberFormat.percent;
	                        decimal = numberFormat[POINT];
	                        precision = numberFormat.decimals;
	                        symbol = numberFormat.symbol;
	                        pattern = numberFormat.pattern[negative ? 0 : 1];
	                    }
	                    customPrecision = formatAndPrecision[2];
	                    if (customPrecision) {
	                        precision = +customPrecision;
	                    }
	                    if (format === 'e') {
	                        return customPrecision ? number.toExponential(precision) : number.toExponential();
	                    }
	                    if (isPercent) {
	                        number *= 100;
	                    }
	                    number = round(number, precision);
	                    negative = number < 0;
	                    number = number.split(POINT);
	                    integer = number[0];
	                    fraction = number[1];
	                    if (negative) {
	                        integer = integer.substring(1);
	                    }
	                    value = groupInteger(integer, 0, integer.length, numberFormat);
	                    if (fraction) {
	                        value += decimal + fraction;
	                    }
	                    if (format === 'n' && !negative) {
	                        return value;
	                    }
	                    number = EMPTY;
	                    for (idx = 0, length = pattern.length; idx < length; idx++) {
	                        ch = pattern.charAt(idx);
	                        if (ch === 'n') {
	                            number += value;
	                        } else if (ch === '$' || ch === '%') {
	                            number += symbol;
	                        } else {
	                            number += ch;
	                        }
	                    }
	                    return number;
	                }
	                if (negative) {
	                    number = -number;
	                }
	                if (format.indexOf('\'') > -1 || format.indexOf('"') > -1 || format.indexOf('\\') > -1) {
	                    format = format.replace(literalRegExp, function (match) {
	                        var quoteChar = match.charAt(0).replace('\\', ''), literal = match.slice(1).replace(quoteChar, '');
	                        literals.push(literal);
	                        return PLACEHOLDER;
	                    });
	                }
	                format = format.split(';');
	                if (negative && format[1]) {
	                    format = format[1];
	                    hasNegativeFormat = true;
	                } else if (number === 0) {
	                    format = format[2] || format[0];
	                    if (format.indexOf(SHARP) == -1 && format.indexOf(ZERO) == -1) {
	                        return format;
	                    }
	                } else {
	                    format = format[0];
	                }
	                percentIndex = format.indexOf('%');
	                currencyIndex = format.indexOf('$');
	                isPercent = percentIndex != -1;
	                isCurrency = currencyIndex != -1;
	                if (isPercent) {
	                    number *= 100;
	                }
	                if (isCurrency && format[currencyIndex - 1] === '\\') {
	                    format = format.split('\\').join('');
	                    isCurrency = false;
	                }
	                if (isCurrency || isPercent) {
	                    numberFormat = isCurrency ? numberFormat.currency : numberFormat.percent;
	                    decimal = numberFormat[POINT];
	                    precision = numberFormat.decimals;
	                    symbol = numberFormat.symbol;
	                }
	                hasGroup = format.indexOf(COMMA) > -1;
	                if (hasGroup) {
	                    format = format.replace(commaRegExp, EMPTY);
	                }
	                decimalIndex = format.indexOf(POINT);
	                length = format.length;
	                if (decimalIndex != -1) {
	                    fraction = number.toString().split('e');
	                    if (fraction[1]) {
	                        fraction = round(number, Math.abs(fraction[1]));
	                    } else {
	                        fraction = fraction[0];
	                    }
	                    fraction = fraction.split(POINT)[1] || EMPTY;
	                    zeroIndex = format.lastIndexOf(ZERO) - decimalIndex;
	                    sharpIndex = format.lastIndexOf(SHARP) - decimalIndex;
	                    hasZero = zeroIndex > -1;
	                    hasSharp = sharpIndex > -1;
	                    idx = fraction.length;
	                    if (!hasZero && !hasSharp) {
	                        format = format.substring(0, decimalIndex) + format.substring(decimalIndex + 1);
	                        length = format.length;
	                        decimalIndex = -1;
	                        idx = 0;
	                    }
	                    if (hasZero && zeroIndex > sharpIndex) {
	                        idx = zeroIndex;
	                    } else if (sharpIndex > zeroIndex) {
	                        if (hasSharp && idx > sharpIndex) {
	                            idx = sharpIndex;
	                        } else if (hasZero && idx < zeroIndex) {
	                            idx = zeroIndex;
	                        }
	                    }
	                    if (idx > -1) {
	                        number = round(number, idx);
	                    }
	                } else {
	                    number = round(number);
	                }
	                sharpIndex = format.indexOf(SHARP);
	                startZeroIndex = zeroIndex = format.indexOf(ZERO);
	                if (sharpIndex == -1 && zeroIndex != -1) {
	                    start = zeroIndex;
	                } else if (sharpIndex != -1 && zeroIndex == -1) {
	                    start = sharpIndex;
	                } else {
	                    start = sharpIndex > zeroIndex ? zeroIndex : sharpIndex;
	                }
	                sharpIndex = format.lastIndexOf(SHARP);
	                zeroIndex = format.lastIndexOf(ZERO);
	                if (sharpIndex == -1 && zeroIndex != -1) {
	                    end = zeroIndex;
	                } else if (sharpIndex != -1 && zeroIndex == -1) {
	                    end = sharpIndex;
	                } else {
	                    end = sharpIndex > zeroIndex ? sharpIndex : zeroIndex;
	                }
	                if (start == length) {
	                    end = start;
	                }
	                if (start != -1) {
	                    value = number.toString().split(POINT);
	                    integer = value[0];
	                    fraction = value[1] || EMPTY;
	                    integerLength = integer.length;
	                    fractionLength = fraction.length;
	                    if (negative && number * -1 >= 0) {
	                        negative = false;
	                    }
	                    number = format.substring(0, start);
	                    if (negative && !hasNegativeFormat) {
	                        number += '-';
	                    }
	                    for (idx = start; idx < length; idx++) {
	                        ch = format.charAt(idx);
	                        if (decimalIndex == -1) {
	                            if (end - idx < integerLength) {
	                                number += integer;
	                                break;
	                            }
	                        } else {
	                            if (zeroIndex != -1 && zeroIndex < idx) {
	                                replacement = EMPTY;
	                            }
	                            if (decimalIndex - idx <= integerLength && decimalIndex - idx > -1) {
	                                number += integer;
	                                idx = decimalIndex;
	                            }
	                            if (decimalIndex === idx) {
	                                number += (fraction ? decimal : EMPTY) + fraction;
	                                idx += end - decimalIndex + 1;
	                                continue;
	                            }
	                        }
	                        if (ch === ZERO) {
	                            number += ch;
	                            replacement = ch;
	                        } else if (ch === SHARP) {
	                            number += replacement;
	                        }
	                    }
	                    if (hasGroup) {
	                        number = groupInteger(number, start + (negative ? 1 : 0), Math.max(end, integerLength + start), numberFormat);
	                    }
	                    if (end >= start) {
	                        number += format.substring(end + 1);
	                    }
	                    if (isCurrency || isPercent) {
	                        value = EMPTY;
	                        for (idx = 0, length = number.length; idx < length; idx++) {
	                            ch = number.charAt(idx);
	                            value += ch === '$' || ch === '%' ? symbol : ch;
	                        }
	                        number = value;
	                    }
	                    length = literals.length;
	                    if (length) {
	                        for (idx = 0; idx < length; idx++) {
	                            number = number.replace(PLACEHOLDER, literals[idx]);
	                        }
	                    }
	                }
	                return number;
	            }
	            var groupInteger = function (number, start, end, numberFormat) {
	                var decimalIndex = number.indexOf(numberFormat[POINT]);
	                var groupSizes = numberFormat.groupSize.slice();
	                var groupSize = groupSizes.shift();
	                var integer, integerLength;
	                var idx, parts, value;
	                var newGroupSize;
	                end = decimalIndex !== -1 ? decimalIndex : end + 1;
	                integer = number.substring(start, end);
	                integerLength = integer.length;
	                if (integerLength >= groupSize) {
	                    idx = integerLength;
	                    parts = [];
	                    while (idx > -1) {
	                        value = integer.substring(idx - groupSize, idx);
	                        if (value) {
	                            parts.push(value);
	                        }
	                        idx -= groupSize;
	                        newGroupSize = groupSizes.shift();
	                        groupSize = newGroupSize !== undefined ? newGroupSize : groupSize;
	                        if (groupSize === 0) {
	                            parts.push(integer.substring(0, idx));
	                            break;
	                        }
	                    }
	                    integer = parts.reverse().join(numberFormat[COMMA]);
	                    number = number.substring(0, start) + integer + number.substring(end);
	                }
	                return number;
	            };
	            var round = function (value, precision) {
	                precision = precision || 0;
	                value = value.toString().split('e');
	                value = Math.round(+(value[0] + 'e' + (value[1] ? +value[1] + precision : precision)));
	                value = value.toString().split('e');
	                value = +(value[0] + 'e' + (value[1] ? +value[1] - precision : -precision));
	                return value.toFixed(Math.min(precision, 20));
	            };
	            var toString = function (value, fmt, culture) {
	                if (fmt) {
	                    if (objectToString.call(value) === '[object Date]') {
	                        return formatDate(value, fmt, culture);
	                    } else if (typeof value === NUMBER) {
	                        return formatNumber(value, fmt, culture);
	                    }
	                }
	                return value !== undefined ? value : '';
	            };
	            kendo.format = function (fmt) {
	                var values = arguments;
	                return fmt.replace(formatRegExp, function (match, index, placeholderFormat) {
	                    var value = values[parseInt(index, 10) + 1];
	                    return toString(value, placeholderFormat ? placeholderFormat.substring(1) : '');
	                });
	            };
	            kendo._extractFormat = function (format) {
	                if (format.slice(0, 3) === '{0:') {
	                    format = format.slice(3, format.length - 1);
	                }
	                return format;
	            };
	            kendo._activeElement = function () {
	                try {
	                    return document.activeElement;
	                } catch (e) {
	                    return document.documentElement.activeElement;
	                }
	            };
	            kendo._round = round;
	            kendo.toString = toString;
	        }());
	        (function () {
	            var nonBreakingSpaceRegExp = /\u00A0/g, exponentRegExp = /[eE][\-+]?[0-9]+/, shortTimeZoneRegExp = /[+|\-]\d{1,2}/, longTimeZoneRegExp = /[+|\-]\d{1,2}:?\d{2}/, dateRegExp = /^\/Date\((.*?)\)\/$/, offsetRegExp = /[+-]\d*/, FORMATS_SEQUENCE = [
	                    [],
	                    [
	                        'G',
	                        'g',
	                        'F'
	                    ],
	                    [
	                        'D',
	                        'd',
	                        'y',
	                        'm',
	                        'T',
	                        't'
	                    ]
	                ], STANDARD_FORMATS = [
	                    [
	                        'yyyy-MM-ddTHH:mm:ss.fffffffzzz',
	                        'yyyy-MM-ddTHH:mm:ss.fffffff',
	                        'yyyy-MM-ddTHH:mm:ss.fffzzz',
	                        'yyyy-MM-ddTHH:mm:ss.fff',
	                        'ddd MMM dd yyyy HH:mm:ss',
	                        'yyyy-MM-ddTHH:mm:sszzz',
	                        'yyyy-MM-ddTHH:mmzzz',
	                        'yyyy-MM-ddTHH:mmzz',
	                        'yyyy-MM-ddTHH:mm:ss',
	                        'yyyy-MM-dd HH:mm:ss',
	                        'yyyy/MM/dd HH:mm:ss'
	                    ],
	                    [
	                        'yyyy-MM-ddTHH:mm',
	                        'yyyy-MM-dd HH:mm',
	                        'yyyy/MM/dd HH:mm'
	                    ],
	                    [
	                        'yyyy/MM/dd',
	                        'yyyy-MM-dd',
	                        'HH:mm:ss',
	                        'HH:mm'
	                    ]
	                ], numberRegExp = {
	                    2: /^\d{1,2}/,
	                    3: /^\d{1,3}/,
	                    4: /^\d{4}/
	                }, objectToString = {}.toString;
	            function outOfRange(value, start, end) {
	                return !(value >= start && value <= end);
	            }
	            function designatorPredicate(designator) {
	                return designator.charAt(0);
	            }
	            function mapDesignators(designators) {
	                return $.map(designators, designatorPredicate);
	            }
	            function adjustDST(date, hours) {
	                if (!hours && date.getHours() === 23) {
	                    date.setHours(date.getHours() + 2);
	                }
	            }
	            function lowerArray(data) {
	                var idx = 0, length = data.length, array = [];
	                for (; idx < length; idx++) {
	                    array[idx] = (data[idx] + '').toLowerCase();
	                }
	                return array;
	            }
	            function lowerLocalInfo(localInfo) {
	                var newLocalInfo = {}, property;
	                for (property in localInfo) {
	                    newLocalInfo[property] = lowerArray(localInfo[property]);
	                }
	                return newLocalInfo;
	            }
	            function parseExact(value, format, culture) {
	                if (!value) {
	                    return null;
	                }
	                var lookAhead = function (match) {
	                        var i = 0;
	                        while (format[idx] === match) {
	                            i++;
	                            idx++;
	                        }
	                        if (i > 0) {
	                            idx -= 1;
	                        }
	                        return i;
	                    }, getNumber = function (size) {
	                        var rg = numberRegExp[size] || new RegExp('^\\d{1,' + size + '}'), match = value.substr(valueIdx, size).match(rg);
	                        if (match) {
	                            match = match[0];
	                            valueIdx += match.length;
	                            return parseInt(match, 10);
	                        }
	                        return null;
	                    }, getIndexByName = function (names, lower) {
	                        var i = 0, length = names.length, name, nameLength, matchLength = 0, matchIdx = 0, subValue;
	                        for (; i < length; i++) {
	                            name = names[i];
	                            nameLength = name.length;
	                            subValue = value.substr(valueIdx, nameLength);
	                            if (lower) {
	                                subValue = subValue.toLowerCase();
	                            }
	                            if (subValue == name && nameLength > matchLength) {
	                                matchLength = nameLength;
	                                matchIdx = i;
	                            }
	                        }
	                        if (matchLength) {
	                            valueIdx += matchLength;
	                            return matchIdx + 1;
	                        }
	                        return null;
	                    }, checkLiteral = function () {
	                        var result = false;
	                        if (value.charAt(valueIdx) === format[idx]) {
	                            valueIdx++;
	                            result = true;
	                        }
	                        return result;
	                    }, calendar = culture.calendars.standard, year = null, month = null, day = null, hours = null, minutes = null, seconds = null, milliseconds = null, idx = 0, valueIdx = 0, literal = false, date = new Date(), twoDigitYearMax = calendar.twoDigitYearMax || 2029, defaultYear = date.getFullYear(), ch, count, length, pattern, pmHour, UTC, matches, amDesignators, pmDesignators, hoursOffset, minutesOffset, hasTime, match;
	                if (!format) {
	                    format = 'd';
	                }
	                pattern = calendar.patterns[format];
	                if (pattern) {
	                    format = pattern;
	                }
	                format = format.split('');
	                length = format.length;
	                for (; idx < length; idx++) {
	                    ch = format[idx];
	                    if (literal) {
	                        if (ch === '\'') {
	                            literal = false;
	                        } else {
	                            checkLiteral();
	                        }
	                    } else {
	                        if (ch === 'd') {
	                            count = lookAhead('d');
	                            if (!calendar._lowerDays) {
	                                calendar._lowerDays = lowerLocalInfo(calendar.days);
	                            }
	                            if (day !== null && count > 2) {
	                                continue;
	                            }
	                            day = count < 3 ? getNumber(2) : getIndexByName(calendar._lowerDays[count == 3 ? 'namesAbbr' : 'names'], true);
	                            if (day === null || outOfRange(day, 1, 31)) {
	                                return null;
	                            }
	                        } else if (ch === 'M') {
	                            count = lookAhead('M');
	                            if (!calendar._lowerMonths) {
	                                calendar._lowerMonths = lowerLocalInfo(calendar.months);
	                            }
	                            month = count < 3 ? getNumber(2) : getIndexByName(calendar._lowerMonths[count == 3 ? 'namesAbbr' : 'names'], true);
	                            if (month === null || outOfRange(month, 1, 12)) {
	                                return null;
	                            }
	                            month -= 1;
	                        } else if (ch === 'y') {
	                            count = lookAhead('y');
	                            year = getNumber(count);
	                            if (year === null) {
	                                return null;
	                            }
	                            if (count == 2) {
	                                if (typeof twoDigitYearMax === 'string') {
	                                    twoDigitYearMax = defaultYear + parseInt(twoDigitYearMax, 10);
	                                }
	                                year = defaultYear - defaultYear % 100 + year;
	                                if (year > twoDigitYearMax) {
	                                    year -= 100;
	                                }
	                            }
	                        } else if (ch === 'h') {
	                            lookAhead('h');
	                            hours = getNumber(2);
	                            if (hours == 12) {
	                                hours = 0;
	                            }
	                            if (hours === null || outOfRange(hours, 0, 11)) {
	                                return null;
	                            }
	                        } else if (ch === 'H') {
	                            lookAhead('H');
	                            hours = getNumber(2);
	                            if (hours === null || outOfRange(hours, 0, 23)) {
	                                return null;
	                            }
	                        } else if (ch === 'm') {
	                            lookAhead('m');
	                            minutes = getNumber(2);
	                            if (minutes === null || outOfRange(minutes, 0, 59)) {
	                                return null;
	                            }
	                        } else if (ch === 's') {
	                            lookAhead('s');
	                            seconds = getNumber(2);
	                            if (seconds === null || outOfRange(seconds, 0, 59)) {
	                                return null;
	                            }
	                        } else if (ch === 'f') {
	                            count = lookAhead('f');
	                            match = value.substr(valueIdx, count).match(numberRegExp[3]);
	                            milliseconds = getNumber(count);
	                            if (milliseconds !== null) {
	                                milliseconds = parseFloat('0.' + match[0], 10);
	                                milliseconds = kendo._round(milliseconds, 3);
	                                milliseconds *= 1000;
	                            }
	                            if (milliseconds === null || outOfRange(milliseconds, 0, 999)) {
	                                return null;
	                            }
	                        } else if (ch === 't') {
	                            count = lookAhead('t');
	                            amDesignators = calendar.AM;
	                            pmDesignators = calendar.PM;
	                            if (count === 1) {
	                                amDesignators = mapDesignators(amDesignators);
	                                pmDesignators = mapDesignators(pmDesignators);
	                            }
	                            pmHour = getIndexByName(pmDesignators);
	                            if (!pmHour && !getIndexByName(amDesignators)) {
	                                return null;
	                            }
	                        } else if (ch === 'z') {
	                            UTC = true;
	                            count = lookAhead('z');
	                            if (value.substr(valueIdx, 1) === 'Z') {
	                                checkLiteral();
	                                continue;
	                            }
	                            matches = value.substr(valueIdx, 6).match(count > 2 ? longTimeZoneRegExp : shortTimeZoneRegExp);
	                            if (!matches) {
	                                return null;
	                            }
	                            matches = matches[0].split(':');
	                            hoursOffset = matches[0];
	                            minutesOffset = matches[1];
	                            if (!minutesOffset && hoursOffset.length > 3) {
	                                valueIdx = hoursOffset.length - 2;
	                                minutesOffset = hoursOffset.substring(valueIdx);
	                                hoursOffset = hoursOffset.substring(0, valueIdx);
	                            }
	                            hoursOffset = parseInt(hoursOffset, 10);
	                            if (outOfRange(hoursOffset, -12, 13)) {
	                                return null;
	                            }
	                            if (count > 2) {
	                                minutesOffset = parseInt(minutesOffset, 10);
	                                if (isNaN(minutesOffset) || outOfRange(minutesOffset, 0, 59)) {
	                                    return null;
	                                }
	                            }
	                        } else if (ch === '\'') {
	                            literal = true;
	                            checkLiteral();
	                        } else if (!checkLiteral()) {
	                            return null;
	                        }
	                    }
	                }
	                hasTime = hours !== null || minutes !== null || seconds || null;
	                if (year === null && month === null && day === null && hasTime) {
	                    year = defaultYear;
	                    month = date.getMonth();
	                    day = date.getDate();
	                } else {
	                    if (year === null) {
	                        year = defaultYear;
	                    }
	                    if (day === null) {
	                        day = 1;
	                    }
	                }
	                if (pmHour && hours < 12) {
	                    hours += 12;
	                }
	                if (UTC) {
	                    if (hoursOffset) {
	                        hours += -hoursOffset;
	                    }
	                    if (minutesOffset) {
	                        minutes += -minutesOffset;
	                    }
	                    value = new Date(Date.UTC(year, month, day, hours, minutes, seconds, milliseconds));
	                } else {
	                    value = new Date(year, month, day, hours, minutes, seconds, milliseconds);
	                    adjustDST(value, hours);
	                }
	                if (year < 100) {
	                    value.setFullYear(year);
	                }
	                if (value.getDate() !== day && UTC === undefined) {
	                    return null;
	                }
	                return value;
	            }
	            function parseMicrosoftFormatOffset(offset) {
	                var sign = offset.substr(0, 1) === '-' ? -1 : 1;
	                offset = offset.substring(1);
	                offset = parseInt(offset.substr(0, 2), 10) * 60 + parseInt(offset.substring(2), 10);
	                return sign * offset;
	            }
	            function getDefaultFormats(culture) {
	                var length = math.max(FORMATS_SEQUENCE.length, STANDARD_FORMATS.length);
	                var patterns = culture.calendar.patterns;
	                var cultureFormats, formatIdx, idx;
	                var formats = [];
	                for (idx = 0; idx < length; idx++) {
	                    cultureFormats = FORMATS_SEQUENCE[idx];
	                    for (formatIdx = 0; formatIdx < cultureFormats.length; formatIdx++) {
	                        formats.push(patterns[cultureFormats[formatIdx]]);
	                    }
	                    formats = formats.concat(STANDARD_FORMATS[idx]);
	                }
	                return formats;
	            }
	            kendo.parseDate = function (value, formats, culture) {
	                if (objectToString.call(value) === '[object Date]') {
	                    return value;
	                }
	                var idx = 0;
	                var date = null;
	                var length;
	                var tzoffset;
	                if (value && value.indexOf('/D') === 0) {
	                    date = dateRegExp.exec(value);
	                    if (date) {
	                        date = date[1];
	                        tzoffset = offsetRegExp.exec(date.substring(1));
	                        date = new Date(parseInt(date, 10));
	                        if (tzoffset) {
	                            tzoffset = parseMicrosoftFormatOffset(tzoffset[0]);
	                            date = kendo.timezone.apply(date, 0);
	                            date = kendo.timezone.convert(date, 0, -1 * tzoffset);
	                        }
	                        return date;
	                    }
	                }
	                culture = kendo.getCulture(culture);
	                if (!formats) {
	                    formats = getDefaultFormats(culture);
	                }
	                formats = isArray(formats) ? formats : [formats];
	                length = formats.length;
	                for (; idx < length; idx++) {
	                    date = parseExact(value, formats[idx], culture);
	                    if (date) {
	                        return date;
	                    }
	                }
	                return date;
	            };
	            kendo.parseInt = function (value, culture) {
	                var result = kendo.parseFloat(value, culture);
	                if (result) {
	                    result = result | 0;
	                }
	                return result;
	            };
	            kendo.parseFloat = function (value, culture, format) {
	                if (!value && value !== 0) {
	                    return null;
	                }
	                if (typeof value === NUMBER) {
	                    return value;
	                }
	                value = value.toString();
	                culture = kendo.getCulture(culture);
	                var number = culture.numberFormat, percent = number.percent, currency = number.currency, symbol = currency.symbol, percentSymbol = percent.symbol, negative = value.indexOf('-'), parts, isPercent;
	                if (exponentRegExp.test(value)) {
	                    value = parseFloat(value.replace(number['.'], '.'));
	                    if (isNaN(value)) {
	                        value = null;
	                    }
	                    return value;
	                }
	                if (negative > 0) {
	                    return null;
	                } else {
	                    negative = negative > -1;
	                }
	                if (value.indexOf(symbol) > -1 || format && format.toLowerCase().indexOf('c') > -1) {
	                    number = currency;
	                    parts = number.pattern[0].replace('$', symbol).split('n');
	                    if (value.indexOf(parts[0]) > -1 && value.indexOf(parts[1]) > -1) {
	                        value = value.replace(parts[0], '').replace(parts[1], '');
	                        negative = true;
	                    }
	                } else if (value.indexOf(percentSymbol) > -1) {
	                    isPercent = true;
	                    number = percent;
	                    symbol = percentSymbol;
	                }
	                value = value.replace('-', '').replace(symbol, '').replace(nonBreakingSpaceRegExp, ' ').split(number[','].replace(nonBreakingSpaceRegExp, ' ')).join('').replace(number['.'], '.');
	                value = parseFloat(value);
	                if (isNaN(value)) {
	                    value = null;
	                } else if (negative) {
	                    value *= -1;
	                }
	                if (value && isPercent) {
	                    value /= 100;
	                }
	                return value;
	            };
	        }());
	        function getShadows(element) {
	            var shadow = element.css(kendo.support.transitions.css + 'box-shadow') || element.css('box-shadow'), radius = shadow ? shadow.match(boxShadowRegExp) || [
	                    0,
	                    0,
	                    0,
	                    0,
	                    0
	                ] : [
	                    0,
	                    0,
	                    0,
	                    0,
	                    0
	                ], blur = math.max(+radius[3], +(radius[4] || 0));
	            return {
	                left: -radius[1] + blur,
	                right: +radius[1] + blur,
	                bottom: +radius[2] + blur
	            };
	        }
	        function wrap(element, autosize) {
	            var browser = support.browser, percentage, isRtl = element.css('direction') == 'rtl';
	            if (!element.parent().hasClass('k-animation-container')) {
	                var shadows = getShadows(element), width = element[0].style.width, height = element[0].style.height, percentWidth = percentRegExp.test(width), percentHeight = percentRegExp.test(height);
	                if (browser.opera) {
	                    shadows.left = shadows.right = shadows.bottom = 5;
	                }
	                percentage = percentWidth || percentHeight;
	                if (!percentWidth && (!autosize || autosize && width)) {
	                    width = element.outerWidth();
	                }
	                if (!percentHeight && (!autosize || autosize && height)) {
	                    height = element.outerHeight();
	                }
	                element.wrap($('<div/>').addClass('k-animation-container').css({
	                    width: width,
	                    height: height,
	                    marginLeft: shadows.left * (isRtl ? 1 : -1),
	                    paddingLeft: shadows.left,
	                    paddingRight: shadows.right,
	                    paddingBottom: shadows.bottom
	                }));
	                if (percentage) {
	                    element.css({
	                        width: '100%',
	                        height: '100%',
	                        boxSizing: 'border-box',
	                        mozBoxSizing: 'border-box',
	                        webkitBoxSizing: 'border-box'
	                    });
	                }
	            } else {
	                var wrapper = element.parent('.k-animation-container'), wrapperStyle = wrapper[0].style;
	                if (wrapper.is(':hidden')) {
	                    wrapper.show();
	                }
	                percentage = percentRegExp.test(wrapperStyle.width) || percentRegExp.test(wrapperStyle.height);
	                if (!percentage) {
	                    wrapper.css({
	                        width: element.outerWidth(),
	                        height: element.outerHeight(),
	                        boxSizing: 'content-box',
	                        mozBoxSizing: 'content-box',
	                        webkitBoxSizing: 'content-box'
	                    });
	                }
	            }
	            if (browser.msie && math.floor(browser.version) <= 7) {
	                element.css({ zoom: 1 });
	                element.children('.k-menu').width(element.width());
	            }
	            return element.parent();
	        }
	        function deepExtend(destination) {
	            var i = 1, length = arguments.length;
	            for (i = 1; i < length; i++) {
	                deepExtendOne(destination, arguments[i]);
	            }
	            return destination;
	        }
	        function deepExtendOne(destination, source) {
	            var ObservableArray = kendo.data.ObservableArray, LazyObservableArray = kendo.data.LazyObservableArray, DataSource = kendo.data.DataSource, HierarchicalDataSource = kendo.data.HierarchicalDataSource, property, propValue, propType, propInit, destProp;
	            for (property in source) {
	                propValue = source[property];
	                propType = typeof propValue;
	                if (propType === OBJECT && propValue !== null) {
	                    propInit = propValue.constructor;
	                } else {
	                    propInit = null;
	                }
	                if (propInit && propInit !== Array && propInit !== ObservableArray && propInit !== LazyObservableArray && propInit !== DataSource && propInit !== HierarchicalDataSource) {
	                    if (propValue instanceof Date) {
	                        destination[property] = new Date(propValue.getTime());
	                    } else if (isFunction(propValue.clone)) {
	                        destination[property] = propValue.clone();
	                    } else {
	                        destProp = destination[property];
	                        if (typeof destProp === OBJECT) {
	                            destination[property] = destProp || {};
	                        } else {
	                            destination[property] = {};
	                        }
	                        deepExtendOne(destination[property], propValue);
	                    }
	                } else if (propType !== UNDEFINED) {
	                    destination[property] = propValue;
	                }
	            }
	            return destination;
	        }
	        function testRx(agent, rxs, dflt) {
	            for (var rx in rxs) {
	                if (rxs.hasOwnProperty(rx) && rxs[rx].test(agent)) {
	                    return rx;
	                }
	            }
	            return dflt !== undefined ? dflt : agent;
	        }
	        function toHyphens(str) {
	            return str.replace(/([a-z][A-Z])/g, function (g) {
	                return g.charAt(0) + '-' + g.charAt(1).toLowerCase();
	            });
	        }
	        function toCamelCase(str) {
	            return str.replace(/\-(\w)/g, function (strMatch, g1) {
	                return g1.toUpperCase();
	            });
	        }
	        function getComputedStyles(element, properties) {
	            var styles = {}, computedStyle;
	            if (document.defaultView && document.defaultView.getComputedStyle) {
	                computedStyle = document.defaultView.getComputedStyle(element, '');
	                if (properties) {
	                    $.each(properties, function (idx, value) {
	                        styles[value] = computedStyle.getPropertyValue(value);
	                    });
	                }
	            } else {
	                computedStyle = element.currentStyle;
	                if (properties) {
	                    $.each(properties, function (idx, value) {
	                        styles[value] = computedStyle[toCamelCase(value)];
	                    });
	                }
	            }
	            if (!kendo.size(styles)) {
	                styles = computedStyle;
	            }
	            return styles;
	        }
	        function isScrollable(element) {
	            if (element && element.className && typeof element.className === 'string' && element.className.indexOf('k-auto-scrollable') > -1) {
	                return true;
	            }
	            var overflow = getComputedStyles(element, ['overflow']).overflow;
	            return overflow == 'auto' || overflow == 'scroll';
	        }
	        function scrollLeft(element, value) {
	            var webkit = support.browser.webkit;
	            var mozila = support.browser.mozilla;
	            var el = element instanceof $ ? element[0] : element;
	            var isRtl;
	            if (!element) {
	                return;
	            }
	            isRtl = support.isRtl(element);
	            if (value !== undefined) {
	                if (isRtl && webkit) {
	                    el.scrollLeft = el.scrollWidth - el.clientWidth - value;
	                } else if (isRtl && mozila) {
	                    el.scrollLeft = -value;
	                } else {
	                    el.scrollLeft = value;
	                }
	            } else {
	                if (isRtl && webkit) {
	                    return el.scrollWidth - el.clientWidth - el.scrollLeft;
	                } else {
	                    return Math.abs(el.scrollLeft);
	                }
	            }
	        }
	        (function () {
	            support._scrollbar = undefined;
	            support.scrollbar = function (refresh) {
	                if (!isNaN(support._scrollbar) && !refresh) {
	                    return support._scrollbar;
	                } else {
	                    var div = document.createElement('div'), result;
	                    div.style.cssText = 'overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block';
	                    div.innerHTML = '&nbsp;';
	                    document.body.appendChild(div);
	                    support._scrollbar = result = div.offsetWidth - div.scrollWidth;
	                    document.body.removeChild(div);
	                    return result;
	                }
	            };
	            support.isRtl = function (element) {
	                return $(element).closest('.k-rtl').length > 0;
	            };
	            var table = document.createElement('table');
	            try {
	                table.innerHTML = '<tr><td></td></tr>';
	                support.tbodyInnerHtml = true;
	            } catch (e) {
	                support.tbodyInnerHtml = false;
	            }
	            support.touch = 'ontouchstart' in window;
	            support.msPointers = window.MSPointerEvent;
	            support.pointers = window.PointerEvent;
	            var transitions = support.transitions = false, transforms = support.transforms = false, elementProto = 'HTMLElement' in window ? HTMLElement.prototype : [];
	            support.hasHW3D = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() || 'MozPerspective' in document.documentElement.style || 'msPerspective' in document.documentElement.style;
	            each([
	                'Moz',
	                'webkit',
	                'O',
	                'ms'
	            ], function () {
	                var prefix = this.toString(), hasTransitions = typeof table.style[prefix + 'Transition'] === STRING;
	                if (hasTransitions || typeof table.style[prefix + 'Transform'] === STRING) {
	                    var lowPrefix = prefix.toLowerCase();
	                    transforms = {
	                        css: lowPrefix != 'ms' ? '-' + lowPrefix + '-' : '',
	                        prefix: prefix,
	                        event: lowPrefix === 'o' || lowPrefix === 'webkit' ? lowPrefix : ''
	                    };
	                    if (hasTransitions) {
	                        transitions = transforms;
	                        transitions.event = transitions.event ? transitions.event + 'TransitionEnd' : 'transitionend';
	                    }
	                    return false;
	                }
	            });
	            table = null;
	            support.transforms = transforms;
	            support.transitions = transitions;
	            support.devicePixelRatio = window.devicePixelRatio === undefined ? 1 : window.devicePixelRatio;
	            try {
	                support.screenWidth = window.outerWidth || window.screen ? window.screen.availWidth : window.innerWidth;
	                support.screenHeight = window.outerHeight || window.screen ? window.screen.availHeight : window.innerHeight;
	            } catch (e) {
	                support.screenWidth = window.screen.availWidth;
	                support.screenHeight = window.screen.availHeight;
	            }
	            support.detectOS = function (ua) {
	                var os = false, minorVersion, match = [], notAndroidPhone = !/mobile safari/i.test(ua), agentRxs = {
	                        wp: /(Windows Phone(?: OS)?)\s(\d+)\.(\d+(\.\d+)?)/,
	                        fire: /(Silk)\/(\d+)\.(\d+(\.\d+)?)/,
	                        android: /(Android|Android.*(?:Opera|Firefox).*?\/)\s*(\d+)\.(\d+(\.\d+)?)/,
	                        iphone: /(iPhone|iPod).*OS\s+(\d+)[\._]([\d\._]+)/,
	                        ipad: /(iPad).*OS\s+(\d+)[\._]([\d_]+)/,
	                        meego: /(MeeGo).+NokiaBrowser\/(\d+)\.([\d\._]+)/,
	                        webos: /(webOS)\/(\d+)\.(\d+(\.\d+)?)/,
	                        blackberry: /(BlackBerry|BB10).*?Version\/(\d+)\.(\d+(\.\d+)?)/,
	                        playbook: /(PlayBook).*?Tablet\s*OS\s*(\d+)\.(\d+(\.\d+)?)/,
	                        windows: /(MSIE)\s+(\d+)\.(\d+(\.\d+)?)/,
	                        tizen: /(tizen).*?Version\/(\d+)\.(\d+(\.\d+)?)/i,
	                        sailfish: /(sailfish).*rv:(\d+)\.(\d+(\.\d+)?).*firefox/i,
	                        ffos: /(Mobile).*rv:(\d+)\.(\d+(\.\d+)?).*Firefox/
	                    }, osRxs = {
	                        ios: /^i(phone|pad|pod)$/i,
	                        android: /^android|fire$/i,
	                        blackberry: /^blackberry|playbook/i,
	                        windows: /windows/,
	                        wp: /wp/,
	                        flat: /sailfish|ffos|tizen/i,
	                        meego: /meego/
	                    }, formFactorRxs = { tablet: /playbook|ipad|fire/i }, browserRxs = {
	                        omini: /Opera\sMini/i,
	                        omobile: /Opera\sMobi/i,
	                        firefox: /Firefox|Fennec/i,
	                        mobilesafari: /version\/.*safari/i,
	                        ie: /MSIE|Windows\sPhone/i,
	                        chrome: /chrome|crios/i,
	                        webkit: /webkit/i
	                    };
	                for (var agent in agentRxs) {
	                    if (agentRxs.hasOwnProperty(agent)) {
	                        match = ua.match(agentRxs[agent]);
	                        if (match) {
	                            if (agent == 'windows' && 'plugins' in navigator) {
	                                return false;
	                            }
	                            os = {};
	                            os.device = agent;
	                            os.tablet = testRx(agent, formFactorRxs, false);
	                            os.browser = testRx(ua, browserRxs, 'default');
	                            os.name = testRx(agent, osRxs);
	                            os[os.name] = true;
	                            os.majorVersion = match[2];
	                            os.minorVersion = match[3].replace('_', '.');
	                            minorVersion = os.minorVersion.replace('.', '').substr(0, 2);
	                            os.flatVersion = os.majorVersion + minorVersion + new Array(3 - (minorVersion.length < 3 ? minorVersion.length : 2)).join('0');
	                            os.cordova = typeof window.PhoneGap !== UNDEFINED || typeof window.cordova !== UNDEFINED;
	                            os.appMode = window.navigator.standalone || /file|local|wmapp/.test(window.location.protocol) || os.cordova;
	                            if (os.android && (support.devicePixelRatio < 1.5 && os.flatVersion < 400 || notAndroidPhone) && (support.screenWidth > 800 || support.screenHeight > 800)) {
	                                os.tablet = agent;
	                            }
	                            break;
	                        }
	                    }
	                }
	                return os;
	            };
	            var mobileOS = support.mobileOS = support.detectOS(navigator.userAgent);
	            support.wpDevicePixelRatio = mobileOS.wp ? screen.width / 320 : 0;
	            support.kineticScrollNeeded = mobileOS && (support.touch || support.msPointers || support.pointers);
	            support.hasNativeScrolling = false;
	            if (mobileOS.ios || mobileOS.android && mobileOS.majorVersion > 2 || mobileOS.wp) {
	                support.hasNativeScrolling = mobileOS;
	            }
	            support.delayedClick = function () {
	                if (support.touch) {
	                    if (mobileOS.ios) {
	                        return true;
	                    }
	                    if (mobileOS.android) {
	                        if (!support.browser.chrome) {
	                            return true;
	                        }
	                        if (support.browser.version < 32) {
	                            return false;
	                        }
	                        return !($('meta[name=viewport]').attr('content') || '').match(/user-scalable=no/i);
	                    }
	                }
	                return false;
	            };
	            support.mouseAndTouchPresent = support.touch && !(support.mobileOS.ios || support.mobileOS.android);
	            support.detectBrowser = function (ua) {
	                var browser = false, match = [], browserRxs = {
	                        edge: /(edge)[ \/]([\w.]+)/i,
	                        webkit: /(chrome)[ \/]([\w.]+)/i,
	                        safari: /(webkit)[ \/]([\w.]+)/i,
	                        opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
	                        msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
	                        mozilla: /(mozilla)(?:.*? rv:([\w.]+)|)/i
	                    };
	                for (var agent in browserRxs) {
	                    if (browserRxs.hasOwnProperty(agent)) {
	                        match = ua.match(browserRxs[agent]);
	                        if (match) {
	                            browser = {};
	                            browser[agent] = true;
	                            browser[match[1].toLowerCase().split(' ')[0].split('/')[0]] = true;
	                            browser.version = parseInt(document.documentMode || match[2], 10);
	                            break;
	                        }
	                    }
	                }
	                return browser;
	            };
	            support.browser = support.detectBrowser(navigator.userAgent);
	            support.detectClipboardAccess = function () {
	                var commands = {
	                    copy: document.queryCommandSupported ? document.queryCommandSupported('copy') : false,
	                    cut: document.queryCommandSupported ? document.queryCommandSupported('cut') : false,
	                    paste: document.queryCommandSupported ? document.queryCommandSupported('paste') : false
	                };
	                if (support.browser.chrome) {
	                    commands.paste = false;
	                    if (support.browser.version >= 43) {
	                        commands.copy = true;
	                        commands.cut = true;
	                    }
	                }
	                return commands;
	            };
	            support.clipboard = support.detectClipboardAccess();
	            support.zoomLevel = function () {
	                try {
	                    var browser = support.browser;
	                    var ie11WidthCorrection = 0;
	                    var docEl = document.documentElement;
	                    if (browser.msie && browser.version == 11 && docEl.scrollHeight > docEl.clientHeight && !support.touch) {
	                        ie11WidthCorrection = support.scrollbar();
	                    }
	                    return support.touch ? docEl.clientWidth / window.innerWidth : browser.msie && browser.version >= 10 ? ((top || window).document.documentElement.offsetWidth + ie11WidthCorrection) / (top || window).innerWidth : 1;
	                } catch (e) {
	                    return 1;
	                }
	            };
	            support.cssBorderSpacing = typeof document.documentElement.style.borderSpacing != 'undefined' && !(support.browser.msie && support.browser.version < 8);
	            (function (browser) {
	                var cssClass = '', docElement = $(document.documentElement), majorVersion = parseInt(browser.version, 10);
	                if (browser.msie) {
	                    cssClass = 'ie';
	                } else if (browser.mozilla) {
	                    cssClass = 'ff';
	                } else if (browser.safari) {
	                    cssClass = 'safari';
	                } else if (browser.webkit) {
	                    cssClass = 'webkit';
	                } else if (browser.opera) {
	                    cssClass = 'opera';
	                } else if (browser.edge) {
	                    cssClass = 'edge';
	                }
	                if (cssClass) {
	                    cssClass = 'k-' + cssClass + ' k-' + cssClass + majorVersion;
	                }
	                if (support.mobileOS) {
	                    cssClass += ' k-mobile';
	                }
	                docElement.addClass(cssClass);
	            }(support.browser));
	            support.eventCapture = document.documentElement.addEventListener;
	            var input = document.createElement('input');
	            support.placeholder = 'placeholder' in input;
	            support.propertyChangeEvent = 'onpropertychange' in input;
	            support.input = function () {
	                var types = [
	                    'number',
	                    'date',
	                    'time',
	                    'month',
	                    'week',
	                    'datetime',
	                    'datetime-local'
	                ];
	                var length = types.length;
	                var value = 'test';
	                var result = {};
	                var idx = 0;
	                var type;
	                for (; idx < length; idx++) {
	                    type = types[idx];
	                    input.setAttribute('type', type);
	                    input.value = value;
	                    result[type.replace('-', '')] = input.type !== 'text' && input.value !== value;
	                }
	                return result;
	            }();
	            input.style.cssText = 'float:left;';
	            support.cssFloat = !!input.style.cssFloat;
	            input = null;
	            support.stableSort = function () {
	                var threshold = 513;
	                var sorted = [{
	                        index: 0,
	                        field: 'b'
	                    }];
	                for (var i = 1; i < threshold; i++) {
	                    sorted.push({
	                        index: i,
	                        field: 'a'
	                    });
	                }
	                sorted.sort(function (a, b) {
	                    return a.field > b.field ? 1 : a.field < b.field ? -1 : 0;
	                });
	                return sorted[0].index === 1;
	            }();
	            support.matchesSelector = elementProto.webkitMatchesSelector || elementProto.mozMatchesSelector || elementProto.msMatchesSelector || elementProto.oMatchesSelector || elementProto.matchesSelector || elementProto.matches || function (selector) {
	                var nodeList = document.querySelectorAll ? (this.parentNode || document).querySelectorAll(selector) || [] : $(selector), i = nodeList.length;
	                while (i--) {
	                    if (nodeList[i] == this) {
	                        return true;
	                    }
	                }
	                return false;
	            };
	            support.pushState = window.history && window.history.pushState;
	            var documentMode = document.documentMode;
	            support.hashChange = 'onhashchange' in window && !(support.browser.msie && (!documentMode || documentMode <= 8));
	            support.customElements = 'registerElement' in window.document;
	        }());
	        function size(obj) {
	            var result = 0, key;
	            for (key in obj) {
	                if (obj.hasOwnProperty(key) && key != 'toJSON') {
	                    result++;
	                }
	            }
	            return result;
	        }
	        function getOffset(element, type, positioned) {
	            if (!type) {
	                type = 'offset';
	            }
	            var result = element[type]();
	            if (support.mobileOS.android) {
	                result.top -= window.scrollY;
	                result.left -= window.scrollX;
	            }
	            if (support.browser.msie && (support.pointers || support.msPointers) && !positioned) {
	                var sign = support.isRtl(element) ? 1 : -1;
	                result.top -= window.pageYOffset + sign * document.documentElement.scrollTop;
	                result.left -= window.pageXOffset + sign * document.documentElement.scrollLeft;
	            }
	            return result;
	        }
	        var directions = {
	            left: { reverse: 'right' },
	            right: { reverse: 'left' },
	            down: { reverse: 'up' },
	            up: { reverse: 'down' },
	            top: { reverse: 'bottom' },
	            bottom: { reverse: 'top' },
	            'in': { reverse: 'out' },
	            out: { reverse: 'in' }
	        };
	        function parseEffects(input) {
	            var effects = {};
	            each(typeof input === 'string' ? input.split(' ') : input, function (idx) {
	                effects[idx] = this;
	            });
	            return effects;
	        }
	        function fx(element) {
	            return new kendo.effects.Element(element);
	        }
	        var effects = {};
	        $.extend(effects, {
	            enabled: true,
	            Element: function (element) {
	                this.element = $(element);
	            },
	            promise: function (element, options) {
	                if (!element.is(':visible')) {
	                    element.css({ display: element.data('olddisplay') || 'block' }).css('display');
	                }
	                if (options.hide) {
	                    element.data('olddisplay', element.css('display')).hide();
	                }
	                if (options.init) {
	                    options.init();
	                }
	                if (options.completeCallback) {
	                    options.completeCallback(element);
	                }
	                element.dequeue();
	            },
	            disable: function () {
	                this.enabled = false;
	                this.promise = this.promiseShim;
	            },
	            enable: function () {
	                this.enabled = true;
	                this.promise = this.animatedPromise;
	            }
	        });
	        effects.promiseShim = effects.promise;
	        function prepareAnimationOptions(options, duration, reverse, complete) {
	            if (typeof options === STRING) {
	                if (isFunction(duration)) {
	                    complete = duration;
	                    duration = 400;
	                    reverse = false;
	                }
	                if (isFunction(reverse)) {
	                    complete = reverse;
	                    reverse = false;
	                }
	                if (typeof duration === BOOLEAN) {
	                    reverse = duration;
	                    duration = 400;
	                }
	                options = {
	                    effects: options,
	                    duration: duration,
	                    reverse: reverse,
	                    complete: complete
	                };
	            }
	            return extend({
	                effects: {},
	                duration: 400,
	                reverse: false,
	                init: noop,
	                teardown: noop,
	                hide: false
	            }, options, {
	                completeCallback: options.complete,
	                complete: noop
	            });
	        }
	        function animate(element, options, duration, reverse, complete) {
	            var idx = 0, length = element.length, instance;
	            for (; idx < length; idx++) {
	                instance = $(element[idx]);
	                instance.queue(function () {
	                    effects.promise(instance, prepareAnimationOptions(options, duration, reverse, complete));
	                });
	            }
	            return element;
	        }
	        function toggleClass(element, classes, options, add) {
	            if (classes) {
	                classes = classes.split(' ');
	                each(classes, function (idx, value) {
	                    element.toggleClass(value, add);
	                });
	            }
	            return element;
	        }
	        if (!('kendoAnimate' in $.fn)) {
	            extend($.fn, {
	                kendoStop: function (clearQueue, gotoEnd) {
	                    return this.stop(clearQueue, gotoEnd);
	                },
	                kendoAnimate: function (options, duration, reverse, complete) {
	                    return animate(this, options, duration, reverse, complete);
	                },
	                kendoAddClass: function (classes, options) {
	                    return kendo.toggleClass(this, classes, options, true);
	                },
	                kendoRemoveClass: function (classes, options) {
	                    return kendo.toggleClass(this, classes, options, false);
	                },
	                kendoToggleClass: function (classes, options, toggle) {
	                    return kendo.toggleClass(this, classes, options, toggle);
	                }
	            });
	        }
	        var ampRegExp = /&/g, ltRegExp = /</g, quoteRegExp = /"/g, aposRegExp = /'/g, gtRegExp = />/g;
	        function htmlEncode(value) {
	            return ('' + value).replace(ampRegExp, '&amp;').replace(ltRegExp, '&lt;').replace(gtRegExp, '&gt;').replace(quoteRegExp, '&quot;').replace(aposRegExp, '&#39;');
	        }
	        var eventTarget = function (e) {
	            return e.target;
	        };
	        if (support.touch) {
	            eventTarget = function (e) {
	                var touches = 'originalEvent' in e ? e.originalEvent.changedTouches : 'changedTouches' in e ? e.changedTouches : null;
	                return touches ? document.elementFromPoint(touches[0].clientX, touches[0].clientY) : e.target;
	            };
	            each([
	                'swipe',
	                'swipeLeft',
	                'swipeRight',
	                'swipeUp',
	                'swipeDown',
	                'doubleTap',
	                'tap'
	            ], function (m, value) {
	                $.fn[value] = function (callback) {
	                    return this.bind(value, callback);
	                };
	            });
	        }
	        if (support.touch) {
	            if (!support.mobileOS) {
	                support.mousedown = 'mousedown touchstart';
	                support.mouseup = 'mouseup touchend';
	                support.mousemove = 'mousemove touchmove';
	                support.mousecancel = 'mouseleave touchcancel';
	                support.click = 'click';
	                support.resize = 'resize';
	            } else {
	                support.mousedown = 'touchstart';
	                support.mouseup = 'touchend';
	                support.mousemove = 'touchmove';
	                support.mousecancel = 'touchcancel';
	                support.click = 'touchend';
	                support.resize = 'orientationchange';
	            }
	        } else if (support.pointers) {
	            support.mousemove = 'pointermove';
	            support.mousedown = 'pointerdown';
	            support.mouseup = 'pointerup';
	            support.mousecancel = 'pointercancel';
	            support.click = 'pointerup';
	            support.resize = 'orientationchange resize';
	        } else if (support.msPointers) {
	            support.mousemove = 'MSPointerMove';
	            support.mousedown = 'MSPointerDown';
	            support.mouseup = 'MSPointerUp';
	            support.mousecancel = 'MSPointerCancel';
	            support.click = 'MSPointerUp';
	            support.resize = 'orientationchange resize';
	        } else {
	            support.mousemove = 'mousemove';
	            support.mousedown = 'mousedown';
	            support.mouseup = 'mouseup';
	            support.mousecancel = 'mouseleave';
	            support.click = 'click';
	            support.resize = 'resize';
	        }
	        var wrapExpression = function (members, paramName) {
	                var result = paramName || 'd', index, idx, length, member, count = 1;
	                for (idx = 0, length = members.length; idx < length; idx++) {
	                    member = members[idx];
	                    if (member !== '') {
	                        index = member.indexOf('[');
	                        if (index !== 0) {
	                            if (index == -1) {
	                                member = '.' + member;
	                            } else {
	                                count++;
	                                member = '.' + member.substring(0, index) + ' || {})' + member.substring(index);
	                            }
	                        }
	                        count++;
	                        result += member + (idx < length - 1 ? ' || {})' : ')');
	                    }
	                }
	                return new Array(count).join('(') + result;
	            }, localUrlRe = /^([a-z]+:)?\/\//i;
	        extend(kendo, {
	            widgets: [],
	            _widgetRegisteredCallbacks: [],
	            ui: kendo.ui || {},
	            fx: kendo.fx || fx,
	            effects: kendo.effects || effects,
	            mobile: kendo.mobile || {},
	            data: kendo.data || {},
	            dataviz: kendo.dataviz || {},
	            drawing: kendo.drawing || {},
	            spreadsheet: { messages: {} },
	            keys: {
	                INSERT: 45,
	                DELETE: 46,
	                BACKSPACE: 8,
	                TAB: 9,
	                ENTER: 13,
	                ESC: 27,
	                LEFT: 37,
	                UP: 38,
	                RIGHT: 39,
	                DOWN: 40,
	                END: 35,
	                HOME: 36,
	                SPACEBAR: 32,
	                PAGEUP: 33,
	                PAGEDOWN: 34,
	                F2: 113,
	                F10: 121,
	                F12: 123,
	                NUMPAD_PLUS: 107,
	                NUMPAD_MINUS: 109,
	                NUMPAD_DOT: 110
	            },
	            support: kendo.support || support,
	            animate: kendo.animate || animate,
	            ns: '',
	            attr: function (value) {
	                return 'data-' + kendo.ns + value;
	            },
	            getShadows: getShadows,
	            wrap: wrap,
	            deepExtend: deepExtend,
	            getComputedStyles: getComputedStyles,
	            webComponents: kendo.webComponents || [],
	            isScrollable: isScrollable,
	            scrollLeft: scrollLeft,
	            size: size,
	            toCamelCase: toCamelCase,
	            toHyphens: toHyphens,
	            getOffset: kendo.getOffset || getOffset,
	            parseEffects: kendo.parseEffects || parseEffects,
	            toggleClass: kendo.toggleClass || toggleClass,
	            directions: kendo.directions || directions,
	            Observable: Observable,
	            Class: Class,
	            Template: Template,
	            template: proxy(Template.compile, Template),
	            render: proxy(Template.render, Template),
	            stringify: proxy(JSON.stringify, JSON),
	            eventTarget: eventTarget,
	            htmlEncode: htmlEncode,
	            isLocalUrl: function (url) {
	                return url && !localUrlRe.test(url);
	            },
	            expr: function (expression, safe, paramName) {
	                expression = expression || '';
	                if (typeof safe == STRING) {
	                    paramName = safe;
	                    safe = false;
	                }
	                paramName = paramName || 'd';
	                if (expression && expression.charAt(0) !== '[') {
	                    expression = '.' + expression;
	                }
	                if (safe) {
	                    expression = expression.replace(/"([^.]*)\.([^"]*)"/g, '"$1_$DOT$_$2"');
	                    expression = expression.replace(/'([^.]*)\.([^']*)'/g, '\'$1_$DOT$_$2\'');
	                    expression = wrapExpression(expression.split('.'), paramName);
	                    expression = expression.replace(/_\$DOT\$_/g, '.');
	                } else {
	                    expression = paramName + expression;
	                }
	                return expression;
	            },
	            getter: function (expression, safe) {
	                var key = expression + safe;
	                return getterCache[key] = getterCache[key] || new Function('d', 'return ' + kendo.expr(expression, safe));
	            },
	            setter: function (expression) {
	                return setterCache[expression] = setterCache[expression] || new Function('d,value', kendo.expr(expression) + '=value');
	            },
	            accessor: function (expression) {
	                return {
	                    get: kendo.getter(expression),
	                    set: kendo.setter(expression)
	                };
	            },
	            guid: function () {
	                var id = '', i, random;
	                for (i = 0; i < 32; i++) {
	                    random = math.random() * 16 | 0;
	                    if (i == 8 || i == 12 || i == 16 || i == 20) {
	                        id += '-';
	                    }
	                    id += (i == 12 ? 4 : i == 16 ? random & 3 | 8 : random).toString(16);
	                }
	                return id;
	            },
	            roleSelector: function (role) {
	                return role.replace(/(\S+)/g, '[' + kendo.attr('role') + '=$1],').slice(0, -1);
	            },
	            directiveSelector: function (directives) {
	                var selectors = directives.split(' ');
	                if (selectors) {
	                    for (var i = 0; i < selectors.length; i++) {
	                        if (selectors[i] != 'view') {
	                            selectors[i] = selectors[i].replace(/(\w*)(view|bar|strip|over)$/, '$1-$2');
	                        }
	                    }
	                }
	                return selectors.join(' ').replace(/(\S+)/g, 'kendo-mobile-$1,').slice(0, -1);
	            },
	            triggeredByInput: function (e) {
	                return /^(label|input|textarea|select)$/i.test(e.target.tagName);
	            },
	            onWidgetRegistered: function (callback) {
	                for (var i = 0, len = kendo.widgets.length; i < len; i++) {
	                    callback(kendo.widgets[i]);
	                }
	                kendo._widgetRegisteredCallbacks.push(callback);
	            },
	            logToConsole: function (message, type) {
	                var console = window.console;
	                if (!kendo.suppressLog && typeof console != 'undefined' && console.log) {
	                    console[type || 'log'](message);
	                }
	            }
	        });
	        var Widget = Observable.extend({
	            init: function (element, options) {
	                var that = this;
	                that.element = kendo.jQuery(element).handler(that);
	                that.angular('init', options);
	                Observable.fn.init.call(that);
	                var dataSource = options ? options.dataSource : null;
	                if (dataSource) {
	                    options = extend({}, options, { dataSource: {} });
	                }
	                options = that.options = extend(true, {}, that.options, options);
	                if (dataSource) {
	                    options.dataSource = dataSource;
	                }
	                if (!that.element.attr(kendo.attr('role'))) {
	                    that.element.attr(kendo.attr('role'), (options.name || '').toLowerCase());
	                }
	                that.element.data('kendo' + options.prefix + options.name, that);
	                that.bind(that.events, options);
	            },
	            events: [],
	            options: { prefix: '' },
	            _hasBindingTarget: function () {
	                return !!this.element[0].kendoBindingTarget;
	            },
	            _tabindex: function (target) {
	                target = target || this.wrapper;
	                var element = this.element, TABINDEX = 'tabindex', tabindex = target.attr(TABINDEX) || element.attr(TABINDEX);
	                element.removeAttr(TABINDEX);
	                target.attr(TABINDEX, !isNaN(tabindex) ? tabindex : 0);
	            },
	            setOptions: function (options) {
	                this._setEvents(options);
	                $.extend(this.options, options);
	            },
	            _setEvents: function (options) {
	                var that = this, idx = 0, length = that.events.length, e;
	                for (; idx < length; idx++) {
	                    e = that.events[idx];
	                    if (that.options[e] && options[e]) {
	                        that.unbind(e, that.options[e]);
	                    }
	                }
	                that.bind(that.events, options);
	            },
	            resize: function (force) {
	                var size = this.getSize(), currentSize = this._size;
	                if (force || (size.width > 0 || size.height > 0) && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {
	                    this._size = size;
	                    this._resize(size, force);
	                    this.trigger('resize', size);
	                }
	            },
	            getSize: function () {
	                return kendo.dimensions(this.element);
	            },
	            size: function (size) {
	                if (!size) {
	                    return this.getSize();
	                } else {
	                    this.setSize(size);
	                }
	            },
	            setSize: $.noop,
	            _resize: $.noop,
	            destroy: function () {
	                var that = this;
	                that.element.removeData('kendo' + that.options.prefix + that.options.name);
	                that.element.removeData('handler');
	                that.unbind();
	            },
	            _destroy: function () {
	                this.destroy();
	            },
	            angular: function () {
	            },
	            _muteAngularRebind: function (callback) {
	                this._muteRebind = true;
	                callback.call(this);
	                this._muteRebind = false;
	            }
	        });
	        var DataBoundWidget = Widget.extend({
	            dataItems: function () {
	                return this.dataSource.flatView();
	            },
	            _angularItems: function (cmd) {
	                var that = this;
	                that.angular(cmd, function () {
	                    return {
	                        elements: that.items(),
	                        data: $.map(that.dataItems(), function (dataItem) {
	                            return { dataItem: dataItem };
	                        })
	                    };
	                });
	            }
	        });
	        kendo.dimensions = function (element, dimensions) {
	            var domElement = element[0];
	            if (dimensions) {
	                element.css(dimensions);
	            }
	            return {
	                width: domElement.offsetWidth,
	                height: domElement.offsetHeight
	            };
	        };
	        kendo.notify = noop;
	        var templateRegExp = /template$/i, jsonRegExp = /^\s*(?:\{(?:.|\r\n|\n)*\}|\[(?:.|\r\n|\n)*\])\s*$/, jsonFormatRegExp = /^\{(\d+)(:[^\}]+)?\}|^\[[A-Za-z_]*\]$/, dashRegExp = /([A-Z])/g;
	        function parseOption(element, option) {
	            var value;
	            if (option.indexOf('data') === 0) {
	                option = option.substring(4);
	                option = option.charAt(0).toLowerCase() + option.substring(1);
	            }
	            option = option.replace(dashRegExp, '-$1');
	            value = element.getAttribute('data-' + kendo.ns + option);
	            if (value === null) {
	                value = undefined;
	            } else if (value === 'null') {
	                value = null;
	            } else if (value === 'true') {
	                value = true;
	            } else if (value === 'false') {
	                value = false;
	            } else if (numberRegExp.test(value)) {
	                value = parseFloat(value);
	            } else if (jsonRegExp.test(value) && !jsonFormatRegExp.test(value)) {
	                value = new Function('return (' + value + ')')();
	            }
	            return value;
	        }
	        function parseOptions(element, options) {
	            var result = {}, option, value;
	            for (option in options) {
	                value = parseOption(element, option);
	                if (value !== undefined) {
	                    if (templateRegExp.test(option)) {
	                        value = kendo.template($('#' + value).html());
	                    }
	                    result[option] = value;
	                }
	            }
	            return result;
	        }
	        kendo.initWidget = function (element, options, roles) {
	            var result, option, widget, idx, length, role, value, dataSource, fullPath, widgetKeyRegExp;
	            if (!roles) {
	                roles = kendo.ui.roles;
	            } else if (roles.roles) {
	                roles = roles.roles;
	            }
	            element = element.nodeType ? element : element[0];
	            role = element.getAttribute('data-' + kendo.ns + 'role');
	            if (!role) {
	                return;
	            }
	            fullPath = role.indexOf('.') === -1;
	            if (fullPath) {
	                widget = roles[role];
	            } else {
	                widget = kendo.getter(role)(window);
	            }
	            var data = $(element).data(), widgetKey = widget ? 'kendo' + widget.fn.options.prefix + widget.fn.options.name : '';
	            if (fullPath) {
	                widgetKeyRegExp = new RegExp('^kendo.*' + role + '$', 'i');
	            } else {
	                widgetKeyRegExp = new RegExp('^' + widgetKey + '$', 'i');
	            }
	            for (var key in data) {
	                if (key.match(widgetKeyRegExp)) {
	                    if (key === widgetKey) {
	                        result = data[key];
	                    } else {
	                        return data[key];
	                    }
	                }
	            }
	            if (!widget) {
	                return;
	            }
	            dataSource = parseOption(element, 'dataSource');
	            options = $.extend({}, parseOptions(element, widget.fn.options), options);
	            if (dataSource) {
	                if (typeof dataSource === STRING) {
	                    options.dataSource = kendo.getter(dataSource)(window);
	                } else {
	                    options.dataSource = dataSource;
	                }
	            }
	            for (idx = 0, length = widget.fn.events.length; idx < length; idx++) {
	                option = widget.fn.events[idx];
	                value = parseOption(element, option);
	                if (value !== undefined) {
	                    options[option] = kendo.getter(value)(window);
	                }
	            }
	            if (!result) {
	                result = new widget(element, options);
	            } else if (!$.isEmptyObject(options)) {
	                result.setOptions(options);
	            }
	            return result;
	        };
	        kendo.rolesFromNamespaces = function (namespaces) {
	            var roles = [], idx, length;
	            if (!namespaces[0]) {
	                namespaces = [
	                    kendo.ui,
	                    kendo.dataviz.ui
	                ];
	            }
	            for (idx = 0, length = namespaces.length; idx < length; idx++) {
	                roles[idx] = namespaces[idx].roles;
	            }
	            return extend.apply(null, [{}].concat(roles.reverse()));
	        };
	        kendo.init = function (element) {
	            var roles = kendo.rolesFromNamespaces(slice.call(arguments, 1));
	            $(element).find('[data-' + kendo.ns + 'role]').addBack().each(function () {
	                kendo.initWidget(this, {}, roles);
	            });
	        };
	        kendo.destroy = function (element) {
	            $(element).find('[data-' + kendo.ns + 'role]').addBack().each(function () {
	                var data = $(this).data();
	                for (var key in data) {
	                    if (key.indexOf('kendo') === 0 && typeof data[key].destroy === FUNCTION) {
	                        data[key].destroy();
	                    }
	                }
	            });
	        };
	        function containmentComparer(a, b) {
	            return $.contains(a, b) ? -1 : 1;
	        }
	        function resizableWidget() {
	            var widget = $(this);
	            return $.inArray(widget.attr('data-' + kendo.ns + 'role'), [
	                'slider',
	                'rangeslider'
	            ]) > -1 || widget.is(':visible');
	        }
	        kendo.resize = function (element, force) {
	            var widgets = $(element).find('[data-' + kendo.ns + 'role]').addBack().filter(resizableWidget);
	            if (!widgets.length) {
	                return;
	            }
	            var widgetsArray = $.makeArray(widgets);
	            widgetsArray.sort(containmentComparer);
	            $.each(widgetsArray, function () {
	                var widget = kendo.widgetInstance($(this));
	                if (widget) {
	                    widget.resize(force);
	                }
	            });
	        };
	        kendo.parseOptions = parseOptions;
	        extend(kendo.ui, {
	            Widget: Widget,
	            DataBoundWidget: DataBoundWidget,
	            roles: {},
	            progress: function (container, toggle) {
	                var mask = container.find('.k-loading-mask'), support = kendo.support, browser = support.browser, isRtl, leftRight, webkitCorrection, containerScrollLeft;
	                if (toggle) {
	                    if (!mask.length) {
	                        isRtl = support.isRtl(container);
	                        leftRight = isRtl ? 'right' : 'left';
	                        containerScrollLeft = container.scrollLeft();
	                        webkitCorrection = browser.webkit ? !isRtl ? 0 : container[0].scrollWidth - container.width() - 2 * containerScrollLeft : 0;
	                        mask = $('<div class=\'k-loading-mask\'><span class=\'k-loading-text\'>' + kendo.ui.progress.messages.loading + '</span><div class=\'k-loading-image\'/><div class=\'k-loading-color\'/></div>').width('100%').height('100%').css('top', container.scrollTop()).css(leftRight, Math.abs(containerScrollLeft) + webkitCorrection).prependTo(container);
	                    }
	                } else if (mask) {
	                    mask.remove();
	                }
	            },
	            plugin: function (widget, register, prefix) {
	                var name = widget.fn.options.name, getter;
	                register = register || kendo.ui;
	                prefix = prefix || '';
	                register[name] = widget;
	                register.roles[name.toLowerCase()] = widget;
	                getter = 'getKendo' + prefix + name;
	                name = 'kendo' + prefix + name;
	                var widgetEntry = {
	                    name: name,
	                    widget: widget,
	                    prefix: prefix || ''
	                };
	                kendo.widgets.push(widgetEntry);
	                for (var i = 0, len = kendo._widgetRegisteredCallbacks.length; i < len; i++) {
	                    kendo._widgetRegisteredCallbacks[i](widgetEntry);
	                }
	                $.fn[name] = function (options) {
	                    var value = this, args;
	                    if (typeof options === STRING) {
	                        args = slice.call(arguments, 1);
	                        this.each(function () {
	                            var widget = $.data(this, name), method, result;
	                            if (!widget) {
	                                throw new Error(kendo.format('Cannot call method \'{0}\' of {1} before it is initialized', options, name));
	                            }
	                            method = widget[options];
	                            if (typeof method !== FUNCTION) {
	                                throw new Error(kendo.format('Cannot find method \'{0}\' of {1}', options, name));
	                            }
	                            result = method.apply(widget, args);
	                            if (result !== undefined) {
	                                value = result;
	                                return false;
	                            }
	                        });
	                    } else {
	                        this.each(function () {
	                            return new widget(this, options);
	                        });
	                    }
	                    return value;
	                };
	                $.fn[name].widget = widget;
	                $.fn[getter] = function () {
	                    return this.data(name);
	                };
	            }
	        });
	        kendo.ui.progress.messages = { loading: 'Loading...' };
	        var ContainerNullObject = {
	            bind: function () {
	                return this;
	            },
	            nullObject: true,
	            options: {}
	        };
	        var MobileWidget = Widget.extend({
	            init: function (element, options) {
	                Widget.fn.init.call(this, element, options);
	                this.element.autoApplyNS();
	                this.wrapper = this.element;
	                this.element.addClass('km-widget');
	            },
	            destroy: function () {
	                Widget.fn.destroy.call(this);
	                this.element.kendoDestroy();
	            },
	            options: { prefix: 'Mobile' },
	            events: [],
	            view: function () {
	                var viewElement = this.element.closest(kendo.roleSelector('view splitview modalview drawer'));
	                return kendo.widgetInstance(viewElement, kendo.mobile.ui) || ContainerNullObject;
	            },
	            viewHasNativeScrolling: function () {
	                var view = this.view();
	                return view && view.options.useNativeScrolling;
	            },
	            container: function () {
	                var element = this.element.closest(kendo.roleSelector('view layout modalview drawer splitview'));
	                return kendo.widgetInstance(element.eq(0), kendo.mobile.ui) || ContainerNullObject;
	            }
	        });
	        extend(kendo.mobile, {
	            init: function (element) {
	                kendo.init(element, kendo.mobile.ui, kendo.ui, kendo.dataviz.ui);
	            },
	            appLevelNativeScrolling: function () {
	                return kendo.mobile.application && kendo.mobile.application.options && kendo.mobile.application.options.useNativeScrolling;
	            },
	            roles: {},
	            ui: {
	                Widget: MobileWidget,
	                DataBoundWidget: DataBoundWidget.extend(MobileWidget.prototype),
	                roles: {},
	                plugin: function (widget) {
	                    kendo.ui.plugin(widget, kendo.mobile.ui, 'Mobile');
	                }
	            }
	        });
	        deepExtend(kendo.dataviz, {
	            init: function (element) {
	                kendo.init(element, kendo.dataviz.ui);
	            },
	            ui: {
	                roles: {},
	                themes: {},
	                views: [],
	                plugin: function (widget) {
	                    kendo.ui.plugin(widget, kendo.dataviz.ui);
	                }
	            },
	            roles: {}
	        });
	        kendo.touchScroller = function (elements, options) {
	            if (!options) {
	                options = {};
	            }
	            options.useNative = true;
	            return $(elements).map(function (idx, element) {
	                element = $(element);
	                if (support.kineticScrollNeeded && kendo.mobile.ui.Scroller && !element.data('kendoMobileScroller')) {
	                    element.kendoMobileScroller(options);
	                    return element.data('kendoMobileScroller');
	                } else {
	                    return false;
	                }
	            })[0];
	        };
	        kendo.preventDefault = function (e) {
	            e.preventDefault();
	        };
	        kendo.widgetInstance = function (element, suites) {
	            var role = element.data(kendo.ns + 'role'), widgets = [], i, length;
	            if (role) {
	                if (role === 'content') {
	                    role = 'scroller';
	                }
	                if (suites) {
	                    if (suites[0]) {
	                        for (i = 0, length = suites.length; i < length; i++) {
	                            widgets.push(suites[i].roles[role]);
	                        }
	                    } else {
	                        widgets.push(suites.roles[role]);
	                    }
	                } else {
	                    widgets = [
	                        kendo.ui.roles[role],
	                        kendo.dataviz.ui.roles[role],
	                        kendo.mobile.ui.roles[role]
	                    ];
	                }
	                if (role.indexOf('.') >= 0) {
	                    widgets = [kendo.getter(role)(window)];
	                }
	                for (i = 0, length = widgets.length; i < length; i++) {
	                    var widget = widgets[i];
	                    if (widget) {
	                        var instance = element.data('kendo' + widget.fn.options.prefix + widget.fn.options.name);
	                        if (instance) {
	                            return instance;
	                        }
	                    }
	                }
	            }
	        };
	        kendo.onResize = function (callback) {
	            var handler = callback;
	            if (support.mobileOS.android) {
	                handler = function () {
	                    setTimeout(callback, 600);
	                };
	            }
	            $(window).on(support.resize, handler);
	            return handler;
	        };
	        kendo.unbindResize = function (callback) {
	            $(window).off(support.resize, callback);
	        };
	        kendo.attrValue = function (element, key) {
	            return element.data(kendo.ns + key);
	        };
	        kendo.days = {
	            Sunday: 0,
	            Monday: 1,
	            Tuesday: 2,
	            Wednesday: 3,
	            Thursday: 4,
	            Friday: 5,
	            Saturday: 6
	        };
	        function focusable(element, isTabIndexNotNaN) {
	            var nodeName = element.nodeName.toLowerCase();
	            return (/input|select|textarea|button|object/.test(nodeName) ? !element.disabled : 'a' === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element);
	        }
	        function visible(element) {
	            return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function () {
	                return $.css(this, 'visibility') === 'hidden';
	            }).length;
	        }
	        $.extend($.expr[':'], {
	            kendoFocusable: function (element) {
	                var idx = $.attr(element, 'tabindex');
	                return focusable(element, !isNaN(idx) && idx > -1);
	            }
	        });
	        var MOUSE_EVENTS = [
	            'mousedown',
	            'mousemove',
	            'mouseenter',
	            'mouseleave',
	            'mouseover',
	            'mouseout',
	            'mouseup',
	            'click'
	        ];
	        var EXCLUDE_BUST_CLICK_SELECTOR = 'label, input, [data-rel=external]';
	        var MouseEventNormalizer = {
	            setupMouseMute: function () {
	                var idx = 0, length = MOUSE_EVENTS.length, element = document.documentElement;
	                if (MouseEventNormalizer.mouseTrap || !support.eventCapture) {
	                    return;
	                }
	                MouseEventNormalizer.mouseTrap = true;
	                MouseEventNormalizer.bustClick = false;
	                MouseEventNormalizer.captureMouse = false;
	                var handler = function (e) {
	                    if (MouseEventNormalizer.captureMouse) {
	                        if (e.type === 'click') {
	                            if (MouseEventNormalizer.bustClick && !$(e.target).is(EXCLUDE_BUST_CLICK_SELECTOR)) {
	                                e.preventDefault();
	                                e.stopPropagation();
	                            }
	                        } else {
	                            e.stopPropagation();
	                        }
	                    }
	                };
	                for (; idx < length; idx++) {
	                    element.addEventListener(MOUSE_EVENTS[idx], handler, true);
	                }
	            },
	            muteMouse: function (e) {
	                MouseEventNormalizer.captureMouse = true;
	                if (e.data.bustClick) {
	                    MouseEventNormalizer.bustClick = true;
	                }
	                clearTimeout(MouseEventNormalizer.mouseTrapTimeoutID);
	            },
	            unMuteMouse: function () {
	                clearTimeout(MouseEventNormalizer.mouseTrapTimeoutID);
	                MouseEventNormalizer.mouseTrapTimeoutID = setTimeout(function () {
	                    MouseEventNormalizer.captureMouse = false;
	                    MouseEventNormalizer.bustClick = false;
	                }, 400);
	            }
	        };
	        var eventMap = {
	            down: 'touchstart mousedown',
	            move: 'mousemove touchmove',
	            up: 'mouseup touchend touchcancel',
	            cancel: 'mouseleave touchcancel'
	        };
	        if (support.touch && (support.mobileOS.ios || support.mobileOS.android)) {
	            eventMap = {
	                down: 'touchstart',
	                move: 'touchmove',
	                up: 'touchend touchcancel',
	                cancel: 'touchcancel'
	            };
	        } else if (support.pointers) {
	            eventMap = {
	                down: 'pointerdown',
	                move: 'pointermove',
	                up: 'pointerup',
	                cancel: 'pointercancel pointerleave'
	            };
	        } else if (support.msPointers) {
	            eventMap = {
	                down: 'MSPointerDown',
	                move: 'MSPointerMove',
	                up: 'MSPointerUp',
	                cancel: 'MSPointerCancel MSPointerLeave'
	            };
	        }
	        if (support.msPointers && !('onmspointerenter' in window)) {
	            $.each({
	                MSPointerEnter: 'MSPointerOver',
	                MSPointerLeave: 'MSPointerOut'
	            }, function (orig, fix) {
	                $.event.special[orig] = {
	                    delegateType: fix,
	                    bindType: fix,
	                    handle: function (event) {
	                        var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
	                        if (!related || related !== target && !$.contains(target, related)) {
	                            event.type = handleObj.origType;
	                            ret = handleObj.handler.apply(this, arguments);
	                            event.type = fix;
	                        }
	                        return ret;
	                    }
	                };
	            });
	        }
	        var getEventMap = function (e) {
	                return eventMap[e] || e;
	            }, eventRegEx = /([^ ]+)/g;
	        kendo.applyEventMap = function (events, ns) {
	            events = events.replace(eventRegEx, getEventMap);
	            if (ns) {
	                events = events.replace(eventRegEx, '$1.' + ns);
	            }
	            return events;
	        };
	        var on = $.fn.on;
	        function kendoJQuery(selector, context) {
	            return new kendoJQuery.fn.init(selector, context);
	        }
	        extend(true, kendoJQuery, $);
	        kendoJQuery.fn = kendoJQuery.prototype = new $();
	        kendoJQuery.fn.constructor = kendoJQuery;
	        kendoJQuery.fn.init = function (selector, context) {
	            if (context && context instanceof $ && !(context instanceof kendoJQuery)) {
	                context = kendoJQuery(context);
	            }
	            return $.fn.init.call(this, selector, context, rootjQuery);
	        };
	        kendoJQuery.fn.init.prototype = kendoJQuery.fn;
	        var rootjQuery = kendoJQuery(document);
	        extend(kendoJQuery.fn, {
	            handler: function (handler) {
	                this.data('handler', handler);
	                return this;
	            },
	            autoApplyNS: function (ns) {
	                this.data('kendoNS', ns || kendo.guid());
	                return this;
	            },
	            on: function () {
	                var that = this, ns = that.data('kendoNS');
	                if (arguments.length === 1) {
	                    return on.call(that, arguments[0]);
	                }
	                var context = that, args = slice.call(arguments);
	                if (typeof args[args.length - 1] === UNDEFINED) {
	                    args.pop();
	                }
	                var callback = args[args.length - 1], events = kendo.applyEventMap(args[0], ns);
	                if (support.mouseAndTouchPresent && events.search(/mouse|click/) > -1 && this[0] !== document.documentElement) {
	                    MouseEventNormalizer.setupMouseMute();
	                    var selector = args.length === 2 ? null : args[1], bustClick = events.indexOf('click') > -1 && events.indexOf('touchend') > -1;
	                    on.call(this, {
	                        touchstart: MouseEventNormalizer.muteMouse,
	                        touchend: MouseEventNormalizer.unMuteMouse
	                    }, selector, { bustClick: bustClick });
	                }
	                if (typeof callback === STRING) {
	                    context = that.data('handler');
	                    callback = context[callback];
	                    args[args.length - 1] = function (e) {
	                        callback.call(context, e);
	                    };
	                }
	                args[0] = events;
	                on.apply(that, args);
	                return that;
	            },
	            kendoDestroy: function (ns) {
	                ns = ns || this.data('kendoNS');
	                if (ns) {
	                    this.off('.' + ns);
	                }
	                return this;
	            }
	        });
	        kendo.jQuery = kendoJQuery;
	        kendo.eventMap = eventMap;
	        kendo.timezone = function () {
	            var months = {
	                Jan: 0,
	                Feb: 1,
	                Mar: 2,
	                Apr: 3,
	                May: 4,
	                Jun: 5,
	                Jul: 6,
	                Aug: 7,
	                Sep: 8,
	                Oct: 9,
	                Nov: 10,
	                Dec: 11
	            };
	            var days = {
	                Sun: 0,
	                Mon: 1,
	                Tue: 2,
	                Wed: 3,
	                Thu: 4,
	                Fri: 5,
	                Sat: 6
	            };
	            function ruleToDate(year, rule) {
	                var date;
	                var targetDay;
	                var ourDay;
	                var month = rule[3];
	                var on = rule[4];
	                var time = rule[5];
	                var cache = rule[8];
	                if (!cache) {
	                    rule[8] = cache = {};
	                }
	                if (cache[year]) {
	                    return cache[year];
	                }
	                if (!isNaN(on)) {
	                    date = new Date(Date.UTC(year, months[month], on, time[0], time[1], time[2], 0));
	                } else if (on.indexOf('last') === 0) {
	                    date = new Date(Date.UTC(year, months[month] + 1, 1, time[0] - 24, time[1], time[2], 0));
	                    targetDay = days[on.substr(4, 3)];
	                    ourDay = date.getUTCDay();
	                    date.setUTCDate(date.getUTCDate() + targetDay - ourDay - (targetDay > ourDay ? 7 : 0));
	                } else if (on.indexOf('>=') >= 0) {
	                    date = new Date(Date.UTC(year, months[month], on.substr(5), time[0], time[1], time[2], 0));
	                    targetDay = days[on.substr(0, 3)];
	                    ourDay = date.getUTCDay();
	                    date.setUTCDate(date.getUTCDate() + targetDay - ourDay + (targetDay < ourDay ? 7 : 0));
	                }
	                return cache[year] = date;
	            }
	            function findRule(utcTime, rules, zone) {
	                rules = rules[zone];
	                if (!rules) {
	                    var time = zone.split(':');
	                    var offset = 0;
	                    if (time.length > 1) {
	                        offset = time[0] * 60 + Number(time[1]);
	                    }
	                    return [
	                        -1000000,
	                        'max',
	                        '-',
	                        'Jan',
	                        1,
	                        [
	                            0,
	                            0,
	                            0
	                        ],
	                        offset,
	                        '-'
	                    ];
	                }
	                var year = new Date(utcTime).getUTCFullYear();
	                rules = jQuery.grep(rules, function (rule) {
	                    var from = rule[0];
	                    var to = rule[1];
	                    return from <= year && (to >= year || from == year && to == 'only' || to == 'max');
	                });
	                rules.push(utcTime);
	                rules.sort(function (a, b) {
	                    if (typeof a != 'number') {
	                        a = Number(ruleToDate(year, a));
	                    }
	                    if (typeof b != 'number') {
	                        b = Number(ruleToDate(year, b));
	                    }
	                    return a - b;
	                });
	                var rule = rules[jQuery.inArray(utcTime, rules) - 1] || rules[rules.length - 1];
	                return isNaN(rule) ? rule : null;
	            }
	            function findZone(utcTime, zones, timezone) {
	                var zoneRules = zones[timezone];
	                if (typeof zoneRules === 'string') {
	                    zoneRules = zones[zoneRules];
	                }
	                if (!zoneRules) {
	                    throw new Error('Timezone "' + timezone + '" is either incorrect, or kendo.timezones.min.js is not included.');
	                }
	                for (var idx = zoneRules.length - 1; idx >= 0; idx--) {
	                    var until = zoneRules[idx][3];
	                    if (until && utcTime > until) {
	                        break;
	                    }
	                }
	                var zone = zoneRules[idx + 1];
	                if (!zone) {
	                    throw new Error('Timezone "' + timezone + '" not found on ' + utcTime + '.');
	                }
	                return zone;
	            }
	            function zoneAndRule(utcTime, zones, rules, timezone) {
	                if (typeof utcTime != NUMBER) {
	                    utcTime = Date.UTC(utcTime.getFullYear(), utcTime.getMonth(), utcTime.getDate(), utcTime.getHours(), utcTime.getMinutes(), utcTime.getSeconds(), utcTime.getMilliseconds());
	                }
	                var zone = findZone(utcTime, zones, timezone);
	                return {
	                    zone: zone,
	                    rule: findRule(utcTime, rules, zone[1])
	                };
	            }
	            function offset(utcTime, timezone) {
	                if (timezone == 'Etc/UTC' || timezone == 'Etc/GMT') {
	                    return 0;
	                }
	                var info = zoneAndRule(utcTime, this.zones, this.rules, timezone);
	                var zone = info.zone;
	                var rule = info.rule;
	                return kendo.parseFloat(rule ? zone[0] - rule[6] : zone[0]);
	            }
	            function abbr(utcTime, timezone) {
	                var info = zoneAndRule(utcTime, this.zones, this.rules, timezone);
	                var zone = info.zone;
	                var rule = info.rule;
	                var base = zone[2];
	                if (base.indexOf('/') >= 0) {
	                    return base.split('/')[rule && +rule[6] ? 1 : 0];
	                } else if (base.indexOf('%s') >= 0) {
	                    return base.replace('%s', !rule || rule[7] == '-' ? '' : rule[7]);
	                }
	                return base;
	            }
	            function convert(date, fromOffset, toOffset) {
	                if (typeof fromOffset == STRING) {
	                    fromOffset = this.offset(date, fromOffset);
	                }
	                if (typeof toOffset == STRING) {
	                    toOffset = this.offset(date, toOffset);
	                }
	                var fromLocalOffset = date.getTimezoneOffset();
	                date = new Date(date.getTime() + (fromOffset - toOffset) * 60000);
	                var toLocalOffset = date.getTimezoneOffset();
	                return new Date(date.getTime() + (toLocalOffset - fromLocalOffset) * 60000);
	            }
	            function apply(date, timezone) {
	                return this.convert(date, date.getTimezoneOffset(), timezone);
	            }
	            function remove(date, timezone) {
	                return this.convert(date, timezone, date.getTimezoneOffset());
	            }
	            function toLocalDate(time) {
	                return this.apply(new Date(time), 'Etc/UTC');
	            }
	            return {
	                zones: {},
	                rules: {},
	                offset: offset,
	                convert: convert,
	                apply: apply,
	                remove: remove,
	                abbr: abbr,
	                toLocalDate: toLocalDate
	            };
	        }();
	        kendo.date = function () {
	            var MS_PER_MINUTE = 60000, MS_PER_DAY = 86400000;
	            function adjustDST(date, hours) {
	                if (hours === 0 && date.getHours() === 23) {
	                    date.setHours(date.getHours() + 2);
	                    return true;
	                }
	                return false;
	            }
	            function setDayOfWeek(date, day, dir) {
	                var hours = date.getHours();
	                dir = dir || 1;
	                day = (day - date.getDay() + 7 * dir) % 7;
	                date.setDate(date.getDate() + day);
	                adjustDST(date, hours);
	            }
	            function dayOfWeek(date, day, dir) {
	                date = new Date(date);
	                setDayOfWeek(date, day, dir);
	                return date;
	            }
	            function firstDayOfMonth(date) {
	                return new Date(date.getFullYear(), date.getMonth(), 1);
	            }
	            function lastDayOfMonth(date) {
	                var last = new Date(date.getFullYear(), date.getMonth() + 1, 0), first = firstDayOfMonth(date), timeOffset = Math.abs(last.getTimezoneOffset() - first.getTimezoneOffset());
	                if (timeOffset) {
	                    last.setHours(first.getHours() + timeOffset / 60);
	                }
	                return last;
	            }
	            function getDate(date) {
	                date = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
	                adjustDST(date, 0);
	                return date;
	            }
	            function toUtcTime(date) {
	                return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
	            }
	            function getMilliseconds(date) {
	                return date.getTime() - getDate(date);
	            }
	            function isInTimeRange(value, min, max) {
	                var msMin = getMilliseconds(min), msMax = getMilliseconds(max), msValue;
	                if (!value || msMin == msMax) {
	                    return true;
	                }
	                if (min >= max) {
	                    max += MS_PER_DAY;
	                }
	                msValue = getMilliseconds(value);
	                if (msMin > msValue) {
	                    msValue += MS_PER_DAY;
	                }
	                if (msMax < msMin) {
	                    msMax += MS_PER_DAY;
	                }
	                return msValue >= msMin && msValue <= msMax;
	            }
	            function isInDateRange(value, min, max) {
	                var msMin = min.getTime(), msMax = max.getTime(), msValue;
	                if (msMin >= msMax) {
	                    msMax += MS_PER_DAY;
	                }
	                msValue = value.getTime();
	                return msValue >= msMin && msValue <= msMax;
	            }
	            function addDays(date, offset) {
	                var hours = date.getHours();
	                date = new Date(date);
	                setTime(date, offset * MS_PER_DAY);
	                adjustDST(date, hours);
	                return date;
	            }
	            function setTime(date, milliseconds, ignoreDST) {
	                var offset = date.getTimezoneOffset();
	                var difference;
	                date.setTime(date.getTime() + milliseconds);
	                if (!ignoreDST) {
	                    difference = date.getTimezoneOffset() - offset;
	                    date.setTime(date.getTime() + difference * MS_PER_MINUTE);
	                }
	            }
	            function setHours(date, time) {
	                date = new Date(kendo.date.getDate(date).getTime() + kendo.date.getMilliseconds(time));
	                adjustDST(date, time.getHours());
	                return date;
	            }
	            function today() {
	                return getDate(new Date());
	            }
	            function isToday(date) {
	                return getDate(date).getTime() == today().getTime();
	            }
	            function toInvariantTime(date) {
	                var staticDate = new Date(1980, 1, 1, 0, 0, 0);
	                if (date) {
	                    staticDate.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
	                }
	                return staticDate;
	            }
	            return {
	                adjustDST: adjustDST,
	                dayOfWeek: dayOfWeek,
	                setDayOfWeek: setDayOfWeek,
	                getDate: getDate,
	                isInDateRange: isInDateRange,
	                isInTimeRange: isInTimeRange,
	                isToday: isToday,
	                nextDay: function (date) {
	                    return addDays(date, 1);
	                },
	                previousDay: function (date) {
	                    return addDays(date, -1);
	                },
	                toUtcTime: toUtcTime,
	                MS_PER_DAY: MS_PER_DAY,
	                MS_PER_HOUR: 60 * MS_PER_MINUTE,
	                MS_PER_MINUTE: MS_PER_MINUTE,
	                setTime: setTime,
	                setHours: setHours,
	                addDays: addDays,
	                today: today,
	                toInvariantTime: toInvariantTime,
	                firstDayOfMonth: firstDayOfMonth,
	                lastDayOfMonth: lastDayOfMonth,
	                getMilliseconds: getMilliseconds
	            };
	        }();
	        kendo.stripWhitespace = function (element) {
	            if (document.createNodeIterator) {
	                var iterator = document.createNodeIterator(element, NodeFilter.SHOW_TEXT, function (node) {
	                    return node.parentNode == element ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
	                }, false);
	                while (iterator.nextNode()) {
	                    if (iterator.referenceNode && !iterator.referenceNode.textContent.trim()) {
	                        iterator.referenceNode.parentNode.removeChild(iterator.referenceNode);
	                    }
	                }
	            } else {
	                for (var i = 0; i < element.childNodes.length; i++) {
	                    var child = element.childNodes[i];
	                    if (child.nodeType == 3 && !/\S/.test(child.nodeValue)) {
	                        element.removeChild(child);
	                        i--;
	                    }
	                    if (child.nodeType == 1) {
	                        kendo.stripWhitespace(child);
	                    }
	                }
	            }
	        };
	        var animationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
	            setTimeout(callback, 1000 / 60);
	        };
	        kendo.animationFrame = function (callback) {
	            animationFrame.call(window, callback);
	        };
	        var animationQueue = [];
	        kendo.queueAnimation = function (callback) {
	            animationQueue[animationQueue.length] = callback;
	            if (animationQueue.length === 1) {
	                kendo.runNextAnimation();
	            }
	        };
	        kendo.runNextAnimation = function () {
	            kendo.animationFrame(function () {
	                if (animationQueue[0]) {
	                    animationQueue.shift()();
	                    if (animationQueue[0]) {
	                        kendo.runNextAnimation();
	                    }
	                }
	            });
	        };
	        kendo.parseQueryStringParams = function (url) {
	            var queryString = url.split('?')[1] || '', params = {}, paramParts = queryString.split(/&|=/), length = paramParts.length, idx = 0;
	            for (; idx < length; idx += 2) {
	                if (paramParts[idx] !== '') {
	                    params[decodeURIComponent(paramParts[idx])] = decodeURIComponent(paramParts[idx + 1]);
	                }
	            }
	            return params;
	        };
	        kendo.elementUnderCursor = function (e) {
	            if (typeof e.x.client != 'undefined') {
	                return document.elementFromPoint(e.x.client, e.y.client);
	            }
	        };
	        kendo.wheelDeltaY = function (jQueryEvent) {
	            var e = jQueryEvent.originalEvent, deltaY = e.wheelDeltaY, delta;
	            if (e.wheelDelta) {
	                if (deltaY === undefined || deltaY) {
	                    delta = e.wheelDelta;
	                }
	            } else if (e.detail && e.axis === e.VERTICAL_AXIS) {
	                delta = -e.detail * 10;
	            }
	            return delta;
	        };
	        kendo.throttle = function (fn, delay) {
	            var timeout;
	            var lastExecTime = 0;
	            if (!delay || delay <= 0) {
	                return fn;
	            }
	            var throttled = function () {
	                var that = this;
	                var elapsed = +new Date() - lastExecTime;
	                var args = arguments;
	                function exec() {
	                    fn.apply(that, args);
	                    lastExecTime = +new Date();
	                }
	                if (!lastExecTime) {
	                    return exec();
	                }
	                if (timeout) {
	                    clearTimeout(timeout);
	                }
	                if (elapsed > delay) {
	                    exec();
	                } else {
	                    timeout = setTimeout(exec, delay - elapsed);
	                }
	            };
	            throttled.cancel = function () {
	                clearTimeout(timeout);
	            };
	            return throttled;
	        };
	        kendo.caret = function (element, start, end) {
	            var rangeElement;
	            var isPosition = start !== undefined;
	            if (end === undefined) {
	                end = start;
	            }
	            if (element[0]) {
	                element = element[0];
	            }
	            if (isPosition && element.disabled) {
	                return;
	            }
	            try {
	                if (element.selectionStart !== undefined) {
	                    if (isPosition) {
	                        element.focus();
	                        element.setSelectionRange(start, end);
	                    } else {
	                        start = [
	                            element.selectionStart,
	                            element.selectionEnd
	                        ];
	                    }
	                } else if (document.selection) {
	                    if ($(element).is(':visible')) {
	                        element.focus();
	                    }
	                    rangeElement = element.createTextRange();
	                    if (isPosition) {
	                        rangeElement.collapse(true);
	                        rangeElement.moveStart('character', start);
	                        rangeElement.moveEnd('character', end - start);
	                        rangeElement.select();
	                    } else {
	                        var rangeDuplicated = rangeElement.duplicate(), selectionStart, selectionEnd;
	                        rangeElement.moveToBookmark(document.selection.createRange().getBookmark());
	                        rangeDuplicated.setEndPoint('EndToStart', rangeElement);
	                        selectionStart = rangeDuplicated.text.length;
	                        selectionEnd = selectionStart + rangeElement.text.length;
	                        start = [
	                            selectionStart,
	                            selectionEnd
	                        ];
	                    }
	                }
	            } catch (e) {
	                start = [];
	            }
	            return start;
	        };
	        kendo.compileMobileDirective = function (element, scope) {
	            var angular = window.angular;
	            element.attr('data-' + kendo.ns + 'role', element[0].tagName.toLowerCase().replace('kendo-mobile-', '').replace('-', ''));
	            angular.element(element).injector().invoke([
	                '$compile',
	                function ($compile) {
	                    $compile(element)(scope);
	                    if (!/^\$(digest|apply)$/.test(scope.$$phase)) {
	                        scope.$digest();
	                    }
	                }
	            ]);
	            return kendo.widgetInstance(element, kendo.mobile.ui);
	        };
	        kendo.antiForgeryTokens = function () {
	            var tokens = {}, csrf_token = $('meta[name=csrf-token],meta[name=_csrf]').attr('content'), csrf_param = $('meta[name=csrf-param],meta[name=_csrf_header]').attr('content');
	            $('input[name^=\'__RequestVerificationToken\']').each(function () {
	                tokens[this.name] = this.value;
	            });
	            if (csrf_param !== undefined && csrf_token !== undefined) {
	                tokens[csrf_param] = csrf_token;
	            }
	            return tokens;
	        };
	        kendo.cycleForm = function (form) {
	            var firstElement = form.find('input, .k-widget').first();
	            var lastElement = form.find('button, .k-button').last();
	            function focus(el) {
	                var widget = kendo.widgetInstance(el);
	                if (widget && widget.focus) {
	                    widget.focus();
	                } else {
	                    el.focus();
	                }
	            }
	            lastElement.on('keydown', function (e) {
	                if (e.keyCode == kendo.keys.TAB && !e.shiftKey) {
	                    e.preventDefault();
	                    focus(firstElement);
	                }
	            });
	            firstElement.on('keydown', function (e) {
	                if (e.keyCode == kendo.keys.TAB && e.shiftKey) {
	                    e.preventDefault();
	                    focus(lastElement);
	                }
	            });
	        };
	        (function () {
	            function postToProxy(dataURI, fileName, proxyURL, proxyTarget) {
	                var form = $('<form>').attr({
	                    action: proxyURL,
	                    method: 'POST',
	                    target: proxyTarget
	                });
	                var data = kendo.antiForgeryTokens();
	                data.fileName = fileName;
	                var parts = dataURI.split(';base64,');
	                data.contentType = parts[0].replace('data:', '');
	                data.base64 = parts[1];
	                for (var name in data) {
	                    if (data.hasOwnProperty(name)) {
	                        $('<input>').attr({
	                            value: data[name],
	                            name: name,
	                            type: 'hidden'
	                        }).appendTo(form);
	                    }
	                }
	                form.appendTo('body').submit().remove();
	            }
	            var fileSaver = document.createElement('a');
	            var downloadAttribute = 'download' in fileSaver && !kendo.support.browser.edge;
	            function saveAsBlob(dataURI, fileName) {
	                var blob = dataURI;
	                if (typeof dataURI == 'string') {
	                    var parts = dataURI.split(';base64,');
	                    var contentType = parts[0];
	                    var base64 = atob(parts[1]);
	                    var array = new Uint8Array(base64.length);
	                    for (var idx = 0; idx < base64.length; idx++) {
	                        array[idx] = base64.charCodeAt(idx);
	                    }
	                    blob = new Blob([array.buffer], { type: contentType });
	                }
	                navigator.msSaveBlob(blob, fileName);
	            }
	            function saveAsDataURI(dataURI, fileName) {
	                if (window.Blob && dataURI instanceof Blob) {
	                    dataURI = URL.createObjectURL(dataURI);
	                }
	                fileSaver.download = fileName;
	                fileSaver.href = dataURI;
	                var e = document.createEvent('MouseEvents');
	                e.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
	                fileSaver.dispatchEvent(e);
	                setTimeout(function () {
	                    URL.revokeObjectURL(dataURI);
	                });
	            }
	            kendo.saveAs = function (options) {
	                var save = postToProxy;
	                if (!options.forceProxy) {
	                    if (downloadAttribute) {
	                        save = saveAsDataURI;
	                    } else if (navigator.msSaveBlob) {
	                        save = saveAsBlob;
	                    }
	                }
	                save(options.dataURI, options.fileName, options.proxyURL, options.proxyTarget);
	            };
	        }());
	        kendo.proxyModelSetters = function proxyModelSetters(data) {
	            var observable = {};
	            Object.keys(data || {}).forEach(function (property) {
	                Object.defineProperty(observable, property, {
	                    get: function () {
	                        return data[property];
	                    },
	                    set: function (value) {
	                        data[property] = value;
	                        data.dirty = true;
	                    }
	                });
	            });
	            return observable;
	        };
	    }(jQuery, window));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 203 */
/***/ function(module, exports) {

	module.exports = jQuery;

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(202),
	        __webpack_require__(205),
	        __webpack_require__(206)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'data',
	        name: 'Data source',
	        category: 'framework',
	        description: 'Powerful component for using local and remote data.Fully supports CRUD, Sorting, Paging, Filtering, Grouping, and Aggregates.',
	        depends: ['core'],
	        features: [
	            {
	                id: 'data-odata',
	                name: 'OData',
	                description: 'Support for accessing Open Data Protocol (OData) services.',
	                depends: ['data.odata']
	            },
	            {
	                id: 'data-signalr',
	                name: 'SignalR',
	                description: 'Support for binding to SignalR hubs.',
	                depends: ['data.signalr']
	            },
	            {
	                id: 'data-XML',
	                name: 'XML',
	                description: 'Support for binding to XML.',
	                depends: ['data.xml']
	            }
	        ]
	    };
	    (function ($, undefined) {
	        var extend = $.extend, proxy = $.proxy, isPlainObject = $.isPlainObject, isEmptyObject = $.isEmptyObject, isArray = $.isArray, grep = $.grep, ajax = $.ajax, map, each = $.each, noop = $.noop, kendo = window.kendo, isFunction = kendo.isFunction, Observable = kendo.Observable, Class = kendo.Class, STRING = 'string', FUNCTION = 'function', CREATE = 'create', READ = 'read', UPDATE = 'update', DESTROY = 'destroy', CHANGE = 'change', SYNC = 'sync', GET = 'get', ERROR = 'error', REQUESTSTART = 'requestStart', PROGRESS = 'progress', REQUESTEND = 'requestEnd', crud = [
	                CREATE,
	                READ,
	                UPDATE,
	                DESTROY
	            ], identity = function (o) {
	                return o;
	            }, getter = kendo.getter, stringify = kendo.stringify, math = Math, push = [].push, join = [].join, pop = [].pop, splice = [].splice, shift = [].shift, slice = [].slice, unshift = [].unshift, toString = {}.toString, stableSort = kendo.support.stableSort, dateRegExp = /^\/Date\((.*?)\)\/$/, newLineRegExp = /(\r+|\n+)/g, quoteRegExp = /(?=['\\])/g;
	        var ObservableArray = Observable.extend({
	            init: function (array, type) {
	                var that = this;
	                that.type = type || ObservableObject;
	                Observable.fn.init.call(that);
	                that.length = array.length;
	                that.wrapAll(array, that);
	            },
	            at: function (index) {
	                return this[index];
	            },
	            toJSON: function () {
	                var idx, length = this.length, value, json = new Array(length);
	                for (idx = 0; idx < length; idx++) {
	                    value = this[idx];
	                    if (value instanceof ObservableObject) {
	                        value = value.toJSON();
	                    }
	                    json[idx] = value;
	                }
	                return json;
	            },
	            parent: noop,
	            wrapAll: function (source, target) {
	                var that = this, idx, length, parent = function () {
	                        return that;
	                    };
	                target = target || [];
	                for (idx = 0, length = source.length; idx < length; idx++) {
	                    target[idx] = that.wrap(source[idx], parent);
	                }
	                return target;
	            },
	            wrap: function (object, parent) {
	                var that = this, observable;
	                if (object !== null && toString.call(object) === '[object Object]') {
	                    observable = object instanceof that.type || object instanceof Model;
	                    if (!observable) {
	                        object = object instanceof ObservableObject ? object.toJSON() : object;
	                        object = new that.type(object);
	                    }
	                    object.parent = parent;
	                    object.bind(CHANGE, function (e) {
	                        that.trigger(CHANGE, {
	                            field: e.field,
	                            node: e.node,
	                            index: e.index,
	                            items: e.items || [this],
	                            action: e.node ? e.action || 'itemloaded' : 'itemchange'
	                        });
	                    });
	                }
	                return object;
	            },
	            push: function () {
	                var index = this.length, items = this.wrapAll(arguments), result;
	                result = push.apply(this, items);
	                this.trigger(CHANGE, {
	                    action: 'add',
	                    index: index,
	                    items: items
	                });
	                return result;
	            },
	            slice: slice,
	            sort: [].sort,
	            join: join,
	            pop: function () {
	                var length = this.length, result = pop.apply(this);
	                if (length) {
	                    this.trigger(CHANGE, {
	                        action: 'remove',
	                        index: length - 1,
	                        items: [result]
	                    });
	                }
	                return result;
	            },
	            splice: function (index, howMany, item) {
	                var items = this.wrapAll(slice.call(arguments, 2)), result, i, len;
	                result = splice.apply(this, [
	                    index,
	                    howMany
	                ].concat(items));
	                if (result.length) {
	                    this.trigger(CHANGE, {
	                        action: 'remove',
	                        index: index,
	                        items: result
	                    });
	                    for (i = 0, len = result.length; i < len; i++) {
	                        if (result[i] && result[i].children) {
	                            result[i].unbind(CHANGE);
	                        }
	                    }
	                }
	                if (item) {
	                    this.trigger(CHANGE, {
	                        action: 'add',
	                        index: index,
	                        items: items
	                    });
	                }
	                return result;
	            },
	            shift: function () {
	                var length = this.length, result = shift.apply(this);
	                if (length) {
	                    this.trigger(CHANGE, {
	                        action: 'remove',
	                        index: 0,
	                        items: [result]
	                    });
	                }
	                return result;
	            },
	            unshift: function () {
	                var items = this.wrapAll(arguments), result;
	                result = unshift.apply(this, items);
	                this.trigger(CHANGE, {
	                    action: 'add',
	                    index: 0,
	                    items: items
	                });
	                return result;
	            },
	            indexOf: function (item) {
	                var that = this, idx, length;
	                for (idx = 0, length = that.length; idx < length; idx++) {
	                    if (that[idx] === item) {
	                        return idx;
	                    }
	                }
	                return -1;
	            },
	            forEach: function (callback) {
	                var idx = 0, length = this.length;
	                for (; idx < length; idx++) {
	                    callback(this[idx], idx, this);
	                }
	            },
	            map: function (callback) {
	                var idx = 0, result = [], length = this.length;
	                for (; idx < length; idx++) {
	                    result[idx] = callback(this[idx], idx, this);
	                }
	                return result;
	            },
	            reduce: function (callback) {
	                var idx = 0, result, length = this.length;
	                if (arguments.length == 2) {
	                    result = arguments[1];
	                } else if (idx < length) {
	                    result = this[idx++];
	                }
	                for (; idx < length; idx++) {
	                    result = callback(result, this[idx], idx, this);
	                }
	                return result;
	            },
	            reduceRight: function (callback) {
	                var idx = this.length - 1, result;
	                if (arguments.length == 2) {
	                    result = arguments[1];
	                } else if (idx > 0) {
	                    result = this[idx--];
	                }
	                for (; idx >= 0; idx--) {
	                    result = callback(result, this[idx], idx, this);
	                }
	                return result;
	            },
	            filter: function (callback) {
	                var idx = 0, result = [], item, length = this.length;
	                for (; idx < length; idx++) {
	                    item = this[idx];
	                    if (callback(item, idx, this)) {
	                        result[result.length] = item;
	                    }
	                }
	                return result;
	            },
	            find: function (callback) {
	                var idx = 0, item, length = this.length;
	                for (; idx < length; idx++) {
	                    item = this[idx];
	                    if (callback(item, idx, this)) {
	                        return item;
	                    }
	                }
	            },
	            every: function (callback) {
	                var idx = 0, item, length = this.length;
	                for (; idx < length; idx++) {
	                    item = this[idx];
	                    if (!callback(item, idx, this)) {
	                        return false;
	                    }
	                }
	                return true;
	            },
	            some: function (callback) {
	                var idx = 0, item, length = this.length;
	                for (; idx < length; idx++) {
	                    item = this[idx];
	                    if (callback(item, idx, this)) {
	                        return true;
	                    }
	                }
	                return false;
	            },
	            remove: function (item) {
	                var idx = this.indexOf(item);
	                if (idx !== -1) {
	                    this.splice(idx, 1);
	                }
	            },
	            empty: function () {
	                this.splice(0, this.length);
	            }
	        });
	        if (typeof Symbol !== 'undefined' && Symbol.iterator && !ObservableArray.prototype[Symbol.iterator]) {
	            ObservableArray.prototype[Symbol.iterator] = [][Symbol.iterator];
	        }
	        var LazyObservableArray = ObservableArray.extend({
	            init: function (data, type) {
	                Observable.fn.init.call(this);
	                this.type = type || ObservableObject;
	                for (var idx = 0; idx < data.length; idx++) {
	                    this[idx] = data[idx];
	                }
	                this.length = idx;
	                this._parent = proxy(function () {
	                    return this;
	                }, this);
	            },
	            at: function (index) {
	                var item = this[index];
	                if (!(item instanceof this.type)) {
	                    item = this[index] = this.wrap(item, this._parent);
	                } else {
	                    item.parent = this._parent;
	                }
	                return item;
	            }
	        });
	        function eventHandler(context, type, field, prefix) {
	            return function (e) {
	                var event = {}, key;
	                for (key in e) {
	                    event[key] = e[key];
	                }
	                if (prefix) {
	                    event.field = field + '.' + e.field;
	                } else {
	                    event.field = field;
	                }
	                if (type == CHANGE && context._notifyChange) {
	                    context._notifyChange(event);
	                }
	                context.trigger(type, event);
	            };
	        }
	        var ObservableObject = Observable.extend({
	            init: function (value) {
	                var that = this, member, field, parent = function () {
	                        return that;
	                    };
	                Observable.fn.init.call(this);
	                this._handlers = {};
	                for (field in value) {
	                    member = value[field];
	                    if (typeof member === 'object' && member && !member.getTime && field.charAt(0) != '_') {
	                        member = that.wrap(member, field, parent);
	                    }
	                    that[field] = member;
	                }
	                that.uid = kendo.guid();
	            },
	            shouldSerialize: function (field) {
	                return this.hasOwnProperty(field) && field !== '_handlers' && field !== '_events' && typeof this[field] !== FUNCTION && field !== 'uid';
	            },
	            forEach: function (f) {
	                for (var i in this) {
	                    if (this.shouldSerialize(i)) {
	                        f(this[i], i);
	                    }
	                }
	            },
	            toJSON: function () {
	                var result = {}, value, field;
	                for (field in this) {
	                    if (this.shouldSerialize(field)) {
	                        value = this[field];
	                        if (value instanceof ObservableObject || value instanceof ObservableArray) {
	                            value = value.toJSON();
	                        }
	                        result[field] = value;
	                    }
	                }
	                return result;
	            },
	            get: function (field) {
	                var that = this, result;
	                that.trigger(GET, { field: field });
	                if (field === 'this') {
	                    result = that;
	                } else {
	                    result = kendo.getter(field, true)(that);
	                }
	                return result;
	            },
	            _set: function (field, value) {
	                var that = this;
	                var composite = field.indexOf('.') >= 0;
	                if (composite) {
	                    var paths = field.split('.'), path = '';
	                    while (paths.length > 1) {
	                        path += paths.shift();
	                        var obj = kendo.getter(path, true)(that);
	                        if (obj instanceof ObservableObject) {
	                            obj.set(paths.join('.'), value);
	                            return composite;
	                        }
	                        path += '.';
	                    }
	                }
	                kendo.setter(field)(that, value);
	                return composite;
	            },
	            set: function (field, value) {
	                var that = this, isSetPrevented = false, composite = field.indexOf('.') >= 0, current = kendo.getter(field, true)(that);
	                if (current !== value) {
	                    if (current instanceof Observable && this._handlers[field]) {
	                        if (this._handlers[field].get) {
	                            current.unbind(GET, this._handlers[field].get);
	                        }
	                        current.unbind(CHANGE, this._handlers[field].change);
	                    }
	                    isSetPrevented = that.trigger('set', {
	                        field: field,
	                        value: value
	                    });
	                    if (!isSetPrevented) {
	                        if (!composite) {
	                            value = that.wrap(value, field, function () {
	                                return that;
	                            });
	                        }
	                        if (!that._set(field, value) || field.indexOf('(') >= 0 || field.indexOf('[') >= 0) {
	                            that.trigger(CHANGE, { field: field });
	                        }
	                    }
	                }
	                return isSetPrevented;
	            },
	            parent: noop,
	            wrap: function (object, field, parent) {
	                var that = this;
	                var get;
	                var change;
	                var type = toString.call(object);
	                if (object != null && (type === '[object Object]' || type === '[object Array]')) {
	                    var isObservableArray = object instanceof ObservableArray;
	                    var isDataSource = object instanceof DataSource;
	                    if (type === '[object Object]' && !isDataSource && !isObservableArray) {
	                        if (!(object instanceof ObservableObject)) {
	                            object = new ObservableObject(object);
	                        }
	                        get = eventHandler(that, GET, field, true);
	                        object.bind(GET, get);
	                        change = eventHandler(that, CHANGE, field, true);
	                        object.bind(CHANGE, change);
	                        that._handlers[field] = {
	                            get: get,
	                            change: change
	                        };
	                    } else if (type === '[object Array]' || isObservableArray || isDataSource) {
	                        if (!isObservableArray && !isDataSource) {
	                            object = new ObservableArray(object);
	                        }
	                        change = eventHandler(that, CHANGE, field, false);
	                        object.bind(CHANGE, change);
	                        that._handlers[field] = { change: change };
	                    }
	                    object.parent = parent;
	                }
	                return object;
	            }
	        });
	        function equal(x, y) {
	            if (x === y) {
	                return true;
	            }
	            var xtype = $.type(x), ytype = $.type(y), field;
	            if (xtype !== ytype) {
	                return false;
	            }
	            if (xtype === 'date') {
	                return x.getTime() === y.getTime();
	            }
	            if (xtype !== 'object' && xtype !== 'array') {
	                return false;
	            }
	            for (field in x) {
	                if (!equal(x[field], y[field])) {
	                    return false;
	                }
	            }
	            return true;
	        }
	        var parsers = {
	            'number': function (value) {
	                return kendo.parseFloat(value);
	            },
	            'date': function (value) {
	                return kendo.parseDate(value);
	            },
	            'boolean': function (value) {
	                if (typeof value === STRING) {
	                    return value.toLowerCase() === 'true';
	                }
	                return value != null ? !!value : value;
	            },
	            'string': function (value) {
	                return value != null ? value + '' : value;
	            },
	            'default': function (value) {
	                return value;
	            }
	        };
	        var defaultValues = {
	            'string': '',
	            'number': 0,
	            'date': new Date(),
	            'boolean': false,
	            'default': ''
	        };
	        function getFieldByName(obj, name) {
	            var field, fieldName;
	            for (fieldName in obj) {
	                field = obj[fieldName];
	                if (isPlainObject(field) && field.field && field.field === name) {
	                    return field;
	                } else if (field === name) {
	                    return field;
	                }
	            }
	            return null;
	        }
	        var Model = ObservableObject.extend({
	            init: function (data) {
	                var that = this;
	                if (!data || $.isEmptyObject(data)) {
	                    data = $.extend({}, that.defaults, data);
	                    if (that._initializers) {
	                        for (var idx = 0; idx < that._initializers.length; idx++) {
	                            var name = that._initializers[idx];
	                            data[name] = that.defaults[name]();
	                        }
	                    }
	                }
	                ObservableObject.fn.init.call(that, data);
	                that.dirty = false;
	                if (that.idField) {
	                    that.id = that.get(that.idField);
	                    if (that.id === undefined) {
	                        that.id = that._defaultId;
	                    }
	                }
	            },
	            shouldSerialize: function (field) {
	                return ObservableObject.fn.shouldSerialize.call(this, field) && field !== 'uid' && !(this.idField !== 'id' && field === 'id') && field !== 'dirty' && field !== '_accessors';
	            },
	            _parse: function (field, value) {
	                var that = this, fieldName = field, fields = that.fields || {}, parse;
	                field = fields[field];
	                if (!field) {
	                    field = getFieldByName(fields, fieldName);
	                }
	                if (field) {
	                    parse = field.parse;
	                    if (!parse && field.type) {
	                        parse = parsers[field.type.toLowerCase()];
	                    }
	                }
	                return parse ? parse(value) : value;
	            },
	            _notifyChange: function (e) {
	                var action = e.action;
	                if (action == 'add' || action == 'remove') {
	                    this.dirty = true;
	                }
	            },
	            editable: function (field) {
	                field = (this.fields || {})[field];
	                return field ? field.editable !== false : true;
	            },
	            set: function (field, value, initiator) {
	                var that = this;
	                var dirty = that.dirty;
	                if (that.editable(field)) {
	                    value = that._parse(field, value);
	                    if (!equal(value, that.get(field))) {
	                        that.dirty = true;
	                        if (ObservableObject.fn.set.call(that, field, value, initiator) && !dirty) {
	                            that.dirty = dirty;
	                        }
	                    }
	                }
	            },
	            accept: function (data) {
	                var that = this, parent = function () {
	                        return that;
	                    }, field;
	                for (field in data) {
	                    var value = data[field];
	                    if (field.charAt(0) != '_') {
	                        value = that.wrap(data[field], field, parent);
	                    }
	                    that._set(field, value);
	                }
	                if (that.idField) {
	                    that.id = that.get(that.idField);
	                }
	                that.dirty = false;
	            },
	            isNew: function () {
	                return this.id === this._defaultId;
	            }
	        });
	        Model.define = function (base, options) {
	            if (options === undefined) {
	                options = base;
	                base = Model;
	            }
	            var model, proto = extend({ defaults: {} }, options), name, field, type, value, idx, length, fields = {}, originalName, id = proto.id, functionFields = [];
	            if (id) {
	                proto.idField = id;
	            }
	            if (proto.id) {
	                delete proto.id;
	            }
	            if (id) {
	                proto.defaults[id] = proto._defaultId = '';
	            }
	            if (toString.call(proto.fields) === '[object Array]') {
	                for (idx = 0, length = proto.fields.length; idx < length; idx++) {
	                    field = proto.fields[idx];
	                    if (typeof field === STRING) {
	                        fields[field] = {};
	                    } else if (field.field) {
	                        fields[field.field] = field;
	                    }
	                }
	                proto.fields = fields;
	            }
	            for (name in proto.fields) {
	                field = proto.fields[name];
	                type = field.type || 'default';
	                value = null;
	                originalName = name;
	                name = typeof field.field === STRING ? field.field : name;
	                if (!field.nullable) {
	                    value = proto.defaults[originalName !== name ? originalName : name] = field.defaultValue !== undefined ? field.defaultValue : defaultValues[type.toLowerCase()];
	                    if (typeof value === 'function') {
	                        functionFields.push(name);
	                    }
	                }
	                if (options.id === name) {
	                    proto._defaultId = value;
	                }
	                proto.defaults[originalName !== name ? originalName : name] = value;
	                field.parse = field.parse || parsers[type];
	            }
	            if (functionFields.length > 0) {
	                proto._initializers = functionFields;
	            }
	            model = base.extend(proto);
	            model.define = function (options) {
	                return Model.define(model, options);
	            };
	            if (proto.fields) {
	                model.fields = proto.fields;
	                model.idField = proto.idField;
	            }
	            return model;
	        };
	        var Comparer = {
	            selector: function (field) {
	                return isFunction(field) ? field : getter(field);
	            },
	            compare: function (field) {
	                var selector = this.selector(field);
	                return function (a, b) {
	                    a = selector(a);
	                    b = selector(b);
	                    if (a == null && b == null) {
	                        return 0;
	                    }
	                    if (a == null) {
	                        return -1;
	                    }
	                    if (b == null) {
	                        return 1;
	                    }
	                    if (a.localeCompare) {
	                        return a.localeCompare(b);
	                    }
	                    return a > b ? 1 : a < b ? -1 : 0;
	                };
	            },
	            create: function (sort) {
	                var compare = sort.compare || this.compare(sort.field);
	                if (sort.dir == 'desc') {
	                    return function (a, b) {
	                        return compare(b, a, true);
	                    };
	                }
	                return compare;
	            },
	            combine: function (comparers) {
	                return function (a, b) {
	                    var result = comparers[0](a, b), idx, length;
	                    for (idx = 1, length = comparers.length; idx < length; idx++) {
	                        result = result || comparers[idx](a, b);
	                    }
	                    return result;
	                };
	            }
	        };
	        var StableComparer = extend({}, Comparer, {
	            asc: function (field) {
	                var selector = this.selector(field);
	                return function (a, b) {
	                    var valueA = selector(a);
	                    var valueB = selector(b);
	                    if (valueA && valueA.getTime && valueB && valueB.getTime) {
	                        valueA = valueA.getTime();
	                        valueB = valueB.getTime();
	                    }
	                    if (valueA === valueB) {
	                        return a.__position - b.__position;
	                    }
	                    if (valueA == null) {
	                        return -1;
	                    }
	                    if (valueB == null) {
	                        return 1;
	                    }
	                    if (valueA.localeCompare) {
	                        return valueA.localeCompare(valueB);
	                    }
	                    return valueA > valueB ? 1 : -1;
	                };
	            },
	            desc: function (field) {
	                var selector = this.selector(field);
	                return function (a, b) {
	                    var valueA = selector(a);
	                    var valueB = selector(b);
	                    if (valueA && valueA.getTime && valueB && valueB.getTime) {
	                        valueA = valueA.getTime();
	                        valueB = valueB.getTime();
	                    }
	                    if (valueA === valueB) {
	                        return a.__position - b.__position;
	                    }
	                    if (valueA == null) {
	                        return 1;
	                    }
	                    if (valueB == null) {
	                        return -1;
	                    }
	                    if (valueB.localeCompare) {
	                        return valueB.localeCompare(valueA);
	                    }
	                    return valueA < valueB ? 1 : -1;
	                };
	            },
	            create: function (sort) {
	                return this[sort.dir](sort.field);
	            }
	        });
	        map = function (array, callback) {
	            var idx, length = array.length, result = new Array(length);
	            for (idx = 0; idx < length; idx++) {
	                result[idx] = callback(array[idx], idx, array);
	            }
	            return result;
	        };
	        var operators = function () {
	            function quote(value) {
	                return value.replace(quoteRegExp, '\\').replace(newLineRegExp, '');
	            }
	            function operator(op, a, b, ignore) {
	                var date;
	                if (b != null) {
	                    if (typeof b === STRING) {
	                        b = quote(b);
	                        date = dateRegExp.exec(b);
	                        if (date) {
	                            b = new Date(+date[1]);
	                        } else if (ignore) {
	                            b = '\'' + b.toLowerCase() + '\'';
	                            a = '((' + a + ' || \'\')+\'\').toLowerCase()';
	                        } else {
	                            b = '\'' + b + '\'';
	                        }
	                    }
	                    if (b.getTime) {
	                        a = '(' + a + '&&' + a + '.getTime?' + a + '.getTime():' + a + ')';
	                        b = b.getTime();
	                    }
	                }
	                return a + ' ' + op + ' ' + b;
	            }
	            return {
	                quote: function (value) {
	                    if (value && value.getTime) {
	                        return 'new Date(' + value.getTime() + ')';
	                    }
	                    if (typeof value == 'string') {
	                        return '\'' + quote(value) + '\'';
	                    }
	                    return '' + value;
	                },
	                eq: function (a, b, ignore) {
	                    return operator('==', a, b, ignore);
	                },
	                neq: function (a, b, ignore) {
	                    return operator('!=', a, b, ignore);
	                },
	                gt: function (a, b, ignore) {
	                    return operator('>', a, b, ignore);
	                },
	                gte: function (a, b, ignore) {
	                    return operator('>=', a, b, ignore);
	                },
	                lt: function (a, b, ignore) {
	                    return operator('<', a, b, ignore);
	                },
	                lte: function (a, b, ignore) {
	                    return operator('<=', a, b, ignore);
	                },
	                startswith: function (a, b, ignore) {
	                    if (ignore) {
	                        a = '(' + a + ' || \'\').toLowerCase()';
	                        if (b) {
	                            b = b.toLowerCase();
	                        }
	                    }
	                    if (b) {
	                        b = quote(b);
	                    }
	                    return a + '.lastIndexOf(\'' + b + '\', 0) == 0';
	                },
	                doesnotstartwith: function (a, b, ignore) {
	                    if (ignore) {
	                        a = '(' + a + ' || \'\').toLowerCase()';
	                        if (b) {
	                            b = b.toLowerCase();
	                        }
	                    }
	                    if (b) {
	                        b = quote(b);
	                    }
	                    return a + '.lastIndexOf(\'' + b + '\', 0) == -1';
	                },
	                endswith: function (a, b, ignore) {
	                    if (ignore) {
	                        a = '(' + a + ' || \'\').toLowerCase()';
	                        if (b) {
	                            b = b.toLowerCase();
	                        }
	                    }
	                    if (b) {
	                        b = quote(b);
	                    }
	                    return a + '.indexOf(\'' + b + '\', ' + a + '.length - ' + (b || '').length + ') >= 0';
	                },
	                doesnotendwith: function (a, b, ignore) {
	                    if (ignore) {
	                        a = '(' + a + ' || \'\').toLowerCase()';
	                        if (b) {
	                            b = b.toLowerCase();
	                        }
	                    }
	                    if (b) {
	                        b = quote(b);
	                    }
	                    return a + '.indexOf(\'' + b + '\', ' + a + '.length - ' + (b || '').length + ') < 0';
	                },
	                contains: function (a, b, ignore) {
	                    if (ignore) {
	                        a = '(' + a + ' || \'\').toLowerCase()';
	                        if (b) {
	                            b = b.toLowerCase();
	                        }
	                    }
	                    if (b) {
	                        b = quote(b);
	                    }
	                    return a + '.indexOf(\'' + b + '\') >= 0';
	                },
	                doesnotcontain: function (a, b, ignore) {
	                    if (ignore) {
	                        a = '(' + a + ' || \'\').toLowerCase()';
	                        if (b) {
	                            b = b.toLowerCase();
	                        }
	                    }
	                    if (b) {
	                        b = quote(b);
	                    }
	                    return a + '.indexOf(\'' + b + '\') == -1';
	                },
	                isempty: function (a) {
	                    return a + ' === \'\'';
	                },
	                isnotempty: function (a) {
	                    return a + ' !== \'\'';
	                },
	                isnull: function (a) {
	                    return '(' + a + ' === null || ' + a + ' === undefined)';
	                },
	                isnotnull: function (a) {
	                    return '(' + a + ' !== null && ' + a + ' !== undefined)';
	                }
	            };
	        }();
	        function Query(data) {
	            this.data = data || [];
	        }
	        Query.filterExpr = function (expression) {
	            var expressions = [], logic = {
	                    and: ' && ',
	                    or: ' || '
	                }, idx, length, filter, expr, fieldFunctions = [], operatorFunctions = [], field, operator, filters = expression.filters;
	            for (idx = 0, length = filters.length; idx < length; idx++) {
	                filter = filters[idx];
	                field = filter.field;
	                operator = filter.operator;
	                if (filter.filters) {
	                    expr = Query.filterExpr(filter);
	                    filter = expr.expression.replace(/__o\[(\d+)\]/g, function (match, index) {
	                        index = +index;
	                        return '__o[' + (operatorFunctions.length + index) + ']';
	                    }).replace(/__f\[(\d+)\]/g, function (match, index) {
	                        index = +index;
	                        return '__f[' + (fieldFunctions.length + index) + ']';
	                    });
	                    operatorFunctions.push.apply(operatorFunctions, expr.operators);
	                    fieldFunctions.push.apply(fieldFunctions, expr.fields);
	                } else {
	                    if (typeof field === FUNCTION) {
	                        expr = '__f[' + fieldFunctions.length + '](d)';
	                        fieldFunctions.push(field);
	                    } else {
	                        expr = kendo.expr(field);
	                    }
	                    if (typeof operator === FUNCTION) {
	                        filter = '__o[' + operatorFunctions.length + '](' + expr + ', ' + operators.quote(filter.value) + ')';
	                        operatorFunctions.push(operator);
	                    } else {
	                        filter = operators[(operator || 'eq').toLowerCase()](expr, filter.value, filter.ignoreCase !== undefined ? filter.ignoreCase : true);
	                    }
	                }
	                expressions.push(filter);
	            }
	            return {
	                expression: '(' + expressions.join(logic[expression.logic]) + ')',
	                fields: fieldFunctions,
	                operators: operatorFunctions
	            };
	        };
	        function normalizeSort(field, dir) {
	            if (field) {
	                var descriptor = typeof field === STRING ? {
	                        field: field,
	                        dir: dir
	                    } : field, descriptors = isArray(descriptor) ? descriptor : descriptor !== undefined ? [descriptor] : [];
	                return grep(descriptors, function (d) {
	                    return !!d.dir;
	                });
	            }
	        }
	        var operatorMap = {
	            '==': 'eq',
	            equals: 'eq',
	            isequalto: 'eq',
	            equalto: 'eq',
	            equal: 'eq',
	            '!=': 'neq',
	            ne: 'neq',
	            notequals: 'neq',
	            isnotequalto: 'neq',
	            notequalto: 'neq',
	            notequal: 'neq',
	            '<': 'lt',
	            islessthan: 'lt',
	            lessthan: 'lt',
	            less: 'lt',
	            '<=': 'lte',
	            le: 'lte',
	            islessthanorequalto: 'lte',
	            lessthanequal: 'lte',
	            '>': 'gt',
	            isgreaterthan: 'gt',
	            greaterthan: 'gt',
	            greater: 'gt',
	            '>=': 'gte',
	            isgreaterthanorequalto: 'gte',
	            greaterthanequal: 'gte',
	            ge: 'gte',
	            notsubstringof: 'doesnotcontain',
	            isnull: 'isnull',
	            isempty: 'isempty',
	            isnotempty: 'isnotempty'
	        };
	        function normalizeOperator(expression) {
	            var idx, length, filter, operator, filters = expression.filters;
	            if (filters) {
	                for (idx = 0, length = filters.length; idx < length; idx++) {
	                    filter = filters[idx];
	                    operator = filter.operator;
	                    if (operator && typeof operator === STRING) {
	                        filter.operator = operatorMap[operator.toLowerCase()] || operator;
	                    }
	                    normalizeOperator(filter);
	                }
	            }
	        }
	        function normalizeFilter(expression) {
	            if (expression && !isEmptyObject(expression)) {
	                if (isArray(expression) || !expression.filters) {
	                    expression = {
	                        logic: 'and',
	                        filters: isArray(expression) ? expression : [expression]
	                    };
	                }
	                normalizeOperator(expression);
	                return expression;
	            }
	        }
	        Query.normalizeFilter = normalizeFilter;
	        function compareDescriptor(f1, f2) {
	            if (f1.logic || f2.logic) {
	                return false;
	            }
	            return f1.field === f2.field && f1.value === f2.value && f1.operator === f2.operator;
	        }
	        function normalizeDescriptor(filter) {
	            filter = filter || {};
	            if (isEmptyObject(filter)) {
	                return {
	                    logic: 'and',
	                    filters: []
	                };
	            }
	            return normalizeFilter(filter);
	        }
	        function fieldComparer(a, b) {
	            if (b.logic || a.field > b.field) {
	                return 1;
	            } else if (a.field < b.field) {
	                return -1;
	            } else {
	                return 0;
	            }
	        }
	        function compareFilters(expr1, expr2) {
	            expr1 = normalizeDescriptor(expr1);
	            expr2 = normalizeDescriptor(expr2);
	            if (expr1.logic !== expr2.logic) {
	                return false;
	            }
	            var f1, f2;
	            var filters1 = (expr1.filters || []).slice();
	            var filters2 = (expr2.filters || []).slice();
	            if (filters1.length !== filters2.length) {
	                return false;
	            }
	            filters1 = filters1.sort(fieldComparer);
	            filters2 = filters2.sort(fieldComparer);
	            for (var idx = 0; idx < filters1.length; idx++) {
	                f1 = filters1[idx];
	                f2 = filters2[idx];
	                if (f1.logic && f2.logic) {
	                    if (!compareFilters(f1, f2)) {
	                        return false;
	                    }
	                } else if (!compareDescriptor(f1, f2)) {
	                    return false;
	                }
	            }
	            return true;
	        }
	        Query.compareFilters = compareFilters;
	        function normalizeAggregate(expressions) {
	            return isArray(expressions) ? expressions : [expressions];
	        }
	        function normalizeGroup(field, dir) {
	            var descriptor = typeof field === STRING ? {
	                    field: field,
	                    dir: dir
	                } : field, descriptors = isArray(descriptor) ? descriptor : descriptor !== undefined ? [descriptor] : [];
	            return map(descriptors, function (d) {
	                return {
	                    field: d.field,
	                    dir: d.dir || 'asc',
	                    aggregates: d.aggregates
	                };
	            });
	        }
	        Query.prototype = {
	            toArray: function () {
	                return this.data;
	            },
	            range: function (index, count) {
	                return new Query(this.data.slice(index, index + count));
	            },
	            skip: function (count) {
	                return new Query(this.data.slice(count));
	            },
	            take: function (count) {
	                return new Query(this.data.slice(0, count));
	            },
	            select: function (selector) {
	                return new Query(map(this.data, selector));
	            },
	            order: function (selector, dir) {
	                var sort = { dir: dir };
	                if (selector) {
	                    if (selector.compare) {
	                        sort.compare = selector.compare;
	                    } else {
	                        sort.field = selector;
	                    }
	                }
	                return new Query(this.data.slice(0).sort(Comparer.create(sort)));
	            },
	            orderBy: function (selector) {
	                return this.order(selector, 'asc');
	            },
	            orderByDescending: function (selector) {
	                return this.order(selector, 'desc');
	            },
	            sort: function (field, dir, comparer) {
	                var idx, length, descriptors = normalizeSort(field, dir), comparers = [];
	                comparer = comparer || Comparer;
	                if (descriptors.length) {
	                    for (idx = 0, length = descriptors.length; idx < length; idx++) {
	                        comparers.push(comparer.create(descriptors[idx]));
	                    }
	                    return this.orderBy({ compare: comparer.combine(comparers) });
	                }
	                return this;
	            },
	            filter: function (expressions) {
	                var idx, current, length, compiled, predicate, data = this.data, fields, operators, result = [], filter;
	                expressions = normalizeFilter(expressions);
	                if (!expressions || expressions.filters.length === 0) {
	                    return this;
	                }
	                compiled = Query.filterExpr(expressions);
	                fields = compiled.fields;
	                operators = compiled.operators;
	                predicate = filter = new Function('d, __f, __o', 'return ' + compiled.expression);
	                if (fields.length || operators.length) {
	                    filter = function (d) {
	                        return predicate(d, fields, operators);
	                    };
	                }
	                for (idx = 0, length = data.length; idx < length; idx++) {
	                    current = data[idx];
	                    if (filter(current)) {
	                        result.push(current);
	                    }
	                }
	                return new Query(result);
	            },
	            group: function (descriptors, allData) {
	                descriptors = normalizeGroup(descriptors || []);
	                allData = allData || this.data;
	                var that = this, result = new Query(that.data), descriptor;
	                if (descriptors.length > 0) {
	                    descriptor = descriptors[0];
	                    result = result.groupBy(descriptor).select(function (group) {
	                        var data = new Query(allData).filter([{
	                                field: group.field,
	                                operator: 'eq',
	                                value: group.value,
	                                ignoreCase: false
	                            }]);
	                        return {
	                            field: group.field,
	                            value: group.value,
	                            items: descriptors.length > 1 ? new Query(group.items).group(descriptors.slice(1), data.toArray()).toArray() : group.items,
	                            hasSubgroups: descriptors.length > 1,
	                            aggregates: data.aggregate(descriptor.aggregates)
	                        };
	                    });
	                }
	                return result;
	            },
	            groupBy: function (descriptor) {
	                if (isEmptyObject(descriptor) || !this.data.length) {
	                    return new Query([]);
	                }
	                var field = descriptor.field, sorted = this._sortForGrouping(field, descriptor.dir || 'asc'), accessor = kendo.accessor(field), item, groupValue = accessor.get(sorted[0], field), group = {
	                        field: field,
	                        value: groupValue,
	                        items: []
	                    }, currentValue, idx, len, result = [group];
	                for (idx = 0, len = sorted.length; idx < len; idx++) {
	                    item = sorted[idx];
	                    currentValue = accessor.get(item, field);
	                    if (!groupValueComparer(groupValue, currentValue)) {
	                        groupValue = currentValue;
	                        group = {
	                            field: field,
	                            value: groupValue,
	                            items: []
	                        };
	                        result.push(group);
	                    }
	                    group.items.push(item);
	                }
	                return new Query(result);
	            },
	            _sortForGrouping: function (field, dir) {
	                var idx, length, data = this.data;
	                if (!stableSort) {
	                    for (idx = 0, length = data.length; idx < length; idx++) {
	                        data[idx].__position = idx;
	                    }
	                    data = new Query(data).sort(field, dir, StableComparer).toArray();
	                    for (idx = 0, length = data.length; idx < length; idx++) {
	                        delete data[idx].__position;
	                    }
	                    return data;
	                }
	                return this.sort(field, dir).toArray();
	            },
	            aggregate: function (aggregates) {
	                var idx, len, result = {}, state = {};
	                if (aggregates && aggregates.length) {
	                    for (idx = 0, len = this.data.length; idx < len; idx++) {
	                        calculateAggregate(result, aggregates, this.data[idx], idx, len, state);
	                    }
	                }
	                return result;
	            }
	        };
	        function groupValueComparer(a, b) {
	            if (a && a.getTime && b && b.getTime) {
	                return a.getTime() === b.getTime();
	            }
	            return a === b;
	        }
	        function calculateAggregate(accumulator, aggregates, item, index, length, state) {
	            aggregates = aggregates || [];
	            var idx, aggr, functionName, len = aggregates.length;
	            for (idx = 0; idx < len; idx++) {
	                aggr = aggregates[idx];
	                functionName = aggr.aggregate;
	                var field = aggr.field;
	                accumulator[field] = accumulator[field] || {};
	                state[field] = state[field] || {};
	                state[field][functionName] = state[field][functionName] || {};
	                accumulator[field][functionName] = functions[functionName.toLowerCase()](accumulator[field][functionName], item, kendo.accessor(field), index, length, state[field][functionName]);
	            }
	        }
	        var functions = {
	            sum: function (accumulator, item, accessor) {
	                var value = accessor.get(item);
	                if (!isNumber(accumulator)) {
	                    accumulator = value;
	                } else if (isNumber(value)) {
	                    accumulator += value;
	                }
	                return accumulator;
	            },
	            count: function (accumulator) {
	                return (accumulator || 0) + 1;
	            },
	            average: function (accumulator, item, accessor, index, length, state) {
	                var value = accessor.get(item);
	                if (state.count === undefined) {
	                    state.count = 0;
	                }
	                if (!isNumber(accumulator)) {
	                    accumulator = value;
	                } else if (isNumber(value)) {
	                    accumulator += value;
	                }
	                if (isNumber(value)) {
	                    state.count++;
	                }
	                if (index == length - 1 && isNumber(accumulator)) {
	                    accumulator = accumulator / state.count;
	                }
	                return accumulator;
	            },
	            max: function (accumulator, item, accessor) {
	                var value = accessor.get(item);
	                if (!isNumber(accumulator) && !isDate(accumulator)) {
	                    accumulator = value;
	                }
	                if (accumulator < value && (isNumber(value) || isDate(value))) {
	                    accumulator = value;
	                }
	                return accumulator;
	            },
	            min: function (accumulator, item, accessor) {
	                var value = accessor.get(item);
	                if (!isNumber(accumulator) && !isDate(accumulator)) {
	                    accumulator = value;
	                }
	                if (accumulator > value && (isNumber(value) || isDate(value))) {
	                    accumulator = value;
	                }
	                return accumulator;
	            }
	        };
	        function isNumber(val) {
	            return typeof val === 'number' && !isNaN(val);
	        }
	        function isDate(val) {
	            return val && val.getTime;
	        }
	        function toJSON(array) {
	            var idx, length = array.length, result = new Array(length);
	            for (idx = 0; idx < length; idx++) {
	                result[idx] = array[idx].toJSON();
	            }
	            return result;
	        }
	        Query.process = function (data, options) {
	            options = options || {};
	            var query = new Query(data), group = options.group, sort = normalizeGroup(group || []).concat(normalizeSort(options.sort || [])), total, filterCallback = options.filterCallback, filter = options.filter, skip = options.skip, take = options.take;
	            if (filter) {
	                query = query.filter(filter);
	                if (filterCallback) {
	                    query = filterCallback(query);
	                }
	                total = query.toArray().length;
	            }
	            if (sort) {
	                query = query.sort(sort);
	                if (group) {
	                    data = query.toArray();
	                }
	            }
	            if (skip !== undefined && take !== undefined) {
	                query = query.range(skip, take);
	            }
	            if (group) {
	                query = query.group(group, data);
	            }
	            return {
	                total: total,
	                data: query.toArray()
	            };
	        };
	        var LocalTransport = Class.extend({
	            init: function (options) {
	                this.data = options.data;
	            },
	            read: function (options) {
	                options.success(this.data);
	            },
	            update: function (options) {
	                options.success(options.data);
	            },
	            create: function (options) {
	                options.success(options.data);
	            },
	            destroy: function (options) {
	                options.success(options.data);
	            }
	        });
	        var RemoteTransport = Class.extend({
	            init: function (options) {
	                var that = this, parameterMap;
	                options = that.options = extend({}, that.options, options);
	                each(crud, function (index, type) {
	                    if (typeof options[type] === STRING) {
	                        options[type] = { url: options[type] };
	                    }
	                });
	                that.cache = options.cache ? Cache.create(options.cache) : {
	                    find: noop,
	                    add: noop
	                };
	                parameterMap = options.parameterMap;
	                if (isFunction(options.push)) {
	                    that.push = options.push;
	                }
	                if (!that.push) {
	                    that.push = identity;
	                }
	                that.parameterMap = isFunction(parameterMap) ? parameterMap : function (options) {
	                    var result = {};
	                    each(options, function (option, value) {
	                        if (option in parameterMap) {
	                            option = parameterMap[option];
	                            if (isPlainObject(option)) {
	                                value = option.value(value);
	                                option = option.key;
	                            }
	                        }
	                        result[option] = value;
	                    });
	                    return result;
	                };
	            },
	            options: { parameterMap: identity },
	            create: function (options) {
	                return ajax(this.setup(options, CREATE));
	            },
	            read: function (options) {
	                var that = this, success, error, result, cache = that.cache;
	                options = that.setup(options, READ);
	                success = options.success || noop;
	                error = options.error || noop;
	                result = cache.find(options.data);
	                if (result !== undefined) {
	                    success(result);
	                } else {
	                    options.success = function (result) {
	                        cache.add(options.data, result);
	                        success(result);
	                    };
	                    $.ajax(options);
	                }
	            },
	            update: function (options) {
	                return ajax(this.setup(options, UPDATE));
	            },
	            destroy: function (options) {
	                return ajax(this.setup(options, DESTROY));
	            },
	            setup: function (options, type) {
	                options = options || {};
	                var that = this, parameters, operation = that.options[type], data = isFunction(operation.data) ? operation.data(options.data) : operation.data;
	                options = extend(true, {}, operation, options);
	                parameters = extend(true, {}, data, options.data);
	                options.data = that.parameterMap(parameters, type);
	                if (isFunction(options.url)) {
	                    options.url = options.url(parameters);
	                }
	                return options;
	            }
	        });
	        var Cache = Class.extend({
	            init: function () {
	                this._store = {};
	            },
	            add: function (key, data) {
	                if (key !== undefined) {
	                    this._store[stringify(key)] = data;
	                }
	            },
	            find: function (key) {
	                return this._store[stringify(key)];
	            },
	            clear: function () {
	                this._store = {};
	            },
	            remove: function (key) {
	                delete this._store[stringify(key)];
	            }
	        });
	        Cache.create = function (options) {
	            var store = {
	                'inmemory': function () {
	                    return new Cache();
	                }
	            };
	            if (isPlainObject(options) && isFunction(options.find)) {
	                return options;
	            }
	            if (options === true) {
	                return new Cache();
	            }
	            return store[options]();
	        };
	        function serializeRecords(data, getters, modelInstance, originalFieldNames, fieldNames) {
	            var record, getter, originalName, idx, setters = {}, length;
	            for (idx = 0, length = data.length; idx < length; idx++) {
	                record = data[idx];
	                for (getter in getters) {
	                    originalName = fieldNames[getter];
	                    if (originalName && originalName !== getter) {
	                        if (!setters[originalName]) {
	                            setters[originalName] = kendo.setter(originalName);
	                        }
	                        setters[originalName](record, getters[getter](record));
	                        delete record[getter];
	                    }
	                }
	            }
	        }
	        function convertRecords(data, getters, modelInstance, originalFieldNames, fieldNames) {
	            var record, getter, originalName, idx, length;
	            for (idx = 0, length = data.length; idx < length; idx++) {
	                record = data[idx];
	                for (getter in getters) {
	                    record[getter] = modelInstance._parse(getter, getters[getter](record));
	                    originalName = fieldNames[getter];
	                    if (originalName && originalName !== getter) {
	                        delete record[originalName];
	                    }
	                }
	            }
	        }
	        function convertGroup(data, getters, modelInstance, originalFieldNames, fieldNames) {
	            var record, idx, fieldName, length;
	            for (idx = 0, length = data.length; idx < length; idx++) {
	                record = data[idx];
	                fieldName = originalFieldNames[record.field];
	                if (fieldName && fieldName != record.field) {
	                    record.field = fieldName;
	                }
	                record.value = modelInstance._parse(record.field, record.value);
	                if (record.hasSubgroups) {
	                    convertGroup(record.items, getters, modelInstance, originalFieldNames, fieldNames);
	                } else {
	                    convertRecords(record.items, getters, modelInstance, originalFieldNames, fieldNames);
	                }
	            }
	        }
	        function wrapDataAccess(originalFunction, model, converter, getters, originalFieldNames, fieldNames) {
	            return function (data) {
	                data = originalFunction(data);
	                if (data && !isEmptyObject(getters)) {
	                    if (toString.call(data) !== '[object Array]' && !(data instanceof ObservableArray)) {
	                        data = [data];
	                    }
	                    converter(data, getters, new model(), originalFieldNames, fieldNames);
	                }
	                return data || [];
	            };
	        }
	        var DataReader = Class.extend({
	            init: function (schema) {
	                var that = this, member, get, model, base;
	                schema = schema || {};
	                for (member in schema) {
	                    get = schema[member];
	                    that[member] = typeof get === STRING ? getter(get) : get;
	                }
	                base = schema.modelBase || Model;
	                if (isPlainObject(that.model)) {
	                    that.model = model = base.define(that.model);
	                }
	                var dataFunction = proxy(that.data, that);
	                that._dataAccessFunction = dataFunction;
	                if (that.model) {
	                    var groupsFunction = proxy(that.groups, that), serializeFunction = proxy(that.serialize, that), originalFieldNames = {}, getters = {}, serializeGetters = {}, fieldNames = {}, shouldSerialize = false, fieldName;
	                    model = that.model;
	                    if (model.fields) {
	                        each(model.fields, function (field, value) {
	                            var fromName;
	                            fieldName = field;
	                            if (isPlainObject(value) && value.field) {
	                                fieldName = value.field;
	                            } else if (typeof value === STRING) {
	                                fieldName = value;
	                            }
	                            if (isPlainObject(value) && value.from) {
	                                fromName = value.from;
	                            }
	                            shouldSerialize = shouldSerialize || fromName && fromName !== field || fieldName !== field;
	                            getters[field] = getter(fromName || fieldName);
	                            serializeGetters[field] = getter(field);
	                            originalFieldNames[fromName || fieldName] = field;
	                            fieldNames[field] = fromName || fieldName;
	                        });
	                        if (!schema.serialize && shouldSerialize) {
	                            that.serialize = wrapDataAccess(serializeFunction, model, serializeRecords, serializeGetters, originalFieldNames, fieldNames);
	                        }
	                    }
	                    that._dataAccessFunction = dataFunction;
	                    that.data = wrapDataAccess(dataFunction, model, convertRecords, getters, originalFieldNames, fieldNames);
	                    that.groups = wrapDataAccess(groupsFunction, model, convertGroup, getters, originalFieldNames, fieldNames);
	                }
	            },
	            errors: function (data) {
	                return data ? data.errors : null;
	            },
	            parse: identity,
	            data: identity,
	            total: function (data) {
	                return data.length;
	            },
	            groups: identity,
	            aggregates: function () {
	                return {};
	            },
	            serialize: function (data) {
	                return data;
	            }
	        });
	        function mergeGroups(target, dest, skip, take) {
	            var group, idx = 0, items;
	            while (dest.length && take) {
	                group = dest[idx];
	                items = group.items;
	                var length = items.length;
	                if (target && target.field === group.field && target.value === group.value) {
	                    if (target.hasSubgroups && target.items.length) {
	                        mergeGroups(target.items[target.items.length - 1], group.items, skip, take);
	                    } else {
	                        items = items.slice(skip, skip + take);
	                        target.items = target.items.concat(items);
	                    }
	                    dest.splice(idx--, 1);
	                } else if (group.hasSubgroups && items.length) {
	                    mergeGroups(group, items, skip, take);
	                    if (!group.items.length) {
	                        dest.splice(idx--, 1);
	                    }
	                } else {
	                    items = items.slice(skip, skip + take);
	                    group.items = items;
	                    if (!group.items.length) {
	                        dest.splice(idx--, 1);
	                    }
	                }
	                if (items.length === 0) {
	                    skip -= length;
	                } else {
	                    skip = 0;
	                    take -= items.length;
	                }
	                if (++idx >= dest.length) {
	                    break;
	                }
	            }
	            if (idx < dest.length) {
	                dest.splice(idx, dest.length - idx);
	            }
	        }
	        function flattenGroups(data) {
	            var idx, result = [], length, items, itemIndex;
	            for (idx = 0, length = data.length; idx < length; idx++) {
	                var group = data.at(idx);
	                if (group.hasSubgroups) {
	                    result = result.concat(flattenGroups(group.items));
	                } else {
	                    items = group.items;
	                    for (itemIndex = 0; itemIndex < items.length; itemIndex++) {
	                        result.push(items.at(itemIndex));
	                    }
	                }
	            }
	            return result;
	        }
	        function wrapGroupItems(data, model) {
	            var idx, length, group;
	            if (model) {
	                for (idx = 0, length = data.length; idx < length; idx++) {
	                    group = data.at(idx);
	                    if (group.hasSubgroups) {
	                        wrapGroupItems(group.items, model);
	                    } else {
	                        group.items = new LazyObservableArray(group.items, model);
	                    }
	                }
	            }
	        }
	        function eachGroupItems(data, func) {
	            for (var idx = 0, length = data.length; idx < length; idx++) {
	                if (data[idx].hasSubgroups) {
	                    if (eachGroupItems(data[idx].items, func)) {
	                        return true;
	                    }
	                } else if (func(data[idx].items, data[idx])) {
	                    return true;
	                }
	            }
	        }
	        function replaceInRanges(ranges, data, item, observable) {
	            for (var idx = 0; idx < ranges.length; idx++) {
	                if (ranges[idx].data === data) {
	                    break;
	                }
	                if (replaceInRange(ranges[idx].data, item, observable)) {
	                    break;
	                }
	            }
	        }
	        function replaceInRange(items, item, observable) {
	            for (var idx = 0, length = items.length; idx < length; idx++) {
	                if (items[idx] && items[idx].hasSubgroups) {
	                    return replaceInRange(items[idx].items, item, observable);
	                } else if (items[idx] === item || items[idx] === observable) {
	                    items[idx] = observable;
	                    return true;
	                }
	            }
	        }
	        function replaceWithObservable(view, data, ranges, type, serverGrouping) {
	            for (var viewIndex = 0, length = view.length; viewIndex < length; viewIndex++) {
	                var item = view[viewIndex];
	                if (!item || item instanceof type) {
	                    continue;
	                }
	                if (item.hasSubgroups !== undefined && !serverGrouping) {
	                    replaceWithObservable(item.items, data, ranges, type, serverGrouping);
	                } else {
	                    for (var idx = 0; idx < data.length; idx++) {
	                        if (data[idx] === item) {
	                            view[viewIndex] = data.at(idx);
	                            replaceInRanges(ranges, data, item, view[viewIndex]);
	                            break;
	                        }
	                    }
	                }
	            }
	        }
	        function removeModel(data, model) {
	            var idx, length;
	            for (idx = 0, length = data.length; idx < length; idx++) {
	                var dataItem = data.at(idx);
	                if (dataItem.uid == model.uid) {
	                    data.splice(idx, 1);
	                    return dataItem;
	                }
	            }
	        }
	        function indexOfPristineModel(data, model) {
	            if (model) {
	                return indexOf(data, function (item) {
	                    return item.uid && item.uid == model.uid || item[model.idField] === model.id && model.id !== model._defaultId;
	                });
	            }
	            return -1;
	        }
	        function indexOfModel(data, model) {
	            if (model) {
	                return indexOf(data, function (item) {
	                    return item.uid == model.uid;
	                });
	            }
	            return -1;
	        }
	        function indexOf(data, comparer) {
	            var idx, length;
	            for (idx = 0, length = data.length; idx < length; idx++) {
	                if (comparer(data[idx])) {
	                    return idx;
	                }
	            }
	            return -1;
	        }
	        function fieldNameFromModel(fields, name) {
	            if (fields && !isEmptyObject(fields)) {
	                var descriptor = fields[name];
	                var fieldName;
	                if (isPlainObject(descriptor)) {
	                    fieldName = descriptor.from || descriptor.field || name;
	                } else {
	                    fieldName = fields[name] || name;
	                }
	                if (isFunction(fieldName)) {
	                    return name;
	                }
	                return fieldName;
	            }
	            return name;
	        }
	        function convertFilterDescriptorsField(descriptor, model) {
	            var idx, length, target = {};
	            for (var field in descriptor) {
	                if (field !== 'filters') {
	                    target[field] = descriptor[field];
	                }
	            }
	            if (descriptor.filters) {
	                target.filters = [];
	                for (idx = 0, length = descriptor.filters.length; idx < length; idx++) {
	                    target.filters[idx] = convertFilterDescriptorsField(descriptor.filters[idx], model);
	                }
	            } else {
	                target.field = fieldNameFromModel(model.fields, target.field);
	            }
	            return target;
	        }
	        function convertDescriptorsField(descriptors, model) {
	            var idx, length, result = [], target, descriptor;
	            for (idx = 0, length = descriptors.length; idx < length; idx++) {
	                target = {};
	                descriptor = descriptors[idx];
	                for (var field in descriptor) {
	                    target[field] = descriptor[field];
	                }
	                target.field = fieldNameFromModel(model.fields, target.field);
	                if (target.aggregates && isArray(target.aggregates)) {
	                    target.aggregates = convertDescriptorsField(target.aggregates, model);
	                }
	                result.push(target);
	            }
	            return result;
	        }
	        var DataSource = Observable.extend({
	            init: function (options) {
	                var that = this, model, data;
	                if (options) {
	                    data = options.data;
	                }
	                options = that.options = extend({}, that.options, options);
	                that._map = {};
	                that._prefetch = {};
	                that._data = [];
	                that._pristineData = [];
	                that._ranges = [];
	                that._view = [];
	                that._pristineTotal = 0;
	                that._destroyed = [];
	                that._pageSize = options.pageSize;
	                that._page = options.page || (options.pageSize ? 1 : undefined);
	                that._sort = normalizeSort(options.sort);
	                that._filter = normalizeFilter(options.filter);
	                that._group = normalizeGroup(options.group);
	                that._aggregate = options.aggregate;
	                that._total = options.total;
	                that._shouldDetachObservableParents = true;
	                Observable.fn.init.call(that);
	                that.transport = Transport.create(options, data, that);
	                if (isFunction(that.transport.push)) {
	                    that.transport.push({
	                        pushCreate: proxy(that._pushCreate, that),
	                        pushUpdate: proxy(that._pushUpdate, that),
	                        pushDestroy: proxy(that._pushDestroy, that)
	                    });
	                }
	                if (options.offlineStorage != null) {
	                    if (typeof options.offlineStorage == 'string') {
	                        var key = options.offlineStorage;
	                        that._storage = {
	                            getItem: function () {
	                                return JSON.parse(localStorage.getItem(key));
	                            },
	                            setItem: function (item) {
	                                localStorage.setItem(key, stringify(that.reader.serialize(item)));
	                            }
	                        };
	                    } else {
	                        that._storage = options.offlineStorage;
	                    }
	                }
	                that.reader = new kendo.data.readers[options.schema.type || 'json'](options.schema);
	                model = that.reader.model || {};
	                that._detachObservableParents();
	                that._data = that._observe(that._data);
	                that._online = true;
	                that.bind([
	                    'push',
	                    ERROR,
	                    CHANGE,
	                    REQUESTSTART,
	                    SYNC,
	                    REQUESTEND,
	                    PROGRESS
	                ], options);
	            },
	            options: {
	                data: null,
	                schema: { modelBase: Model },
	                offlineStorage: null,
	                serverSorting: false,
	                serverPaging: false,
	                serverFiltering: false,
	                serverGrouping: false,
	                serverAggregates: false,
	                batch: false
	            },
	            clone: function () {
	                return this;
	            },
	            online: function (value) {
	                if (value !== undefined) {
	                    if (this._online != value) {
	                        this._online = value;
	                        if (value) {
	                            return this.sync();
	                        }
	                    }
	                    return $.Deferred().resolve().promise();
	                } else {
	                    return this._online;
	                }
	            },
	            offlineData: function (state) {
	                if (this.options.offlineStorage == null) {
	                    return null;
	                }
	                if (state !== undefined) {
	                    return this._storage.setItem(state);
	                }
	                return this._storage.getItem() || [];
	            },
	            _isServerGrouped: function () {
	                var group = this.group() || [];
	                return this.options.serverGrouping && group.length;
	            },
	            _pushCreate: function (result) {
	                this._push(result, 'pushCreate');
	            },
	            _pushUpdate: function (result) {
	                this._push(result, 'pushUpdate');
	            },
	            _pushDestroy: function (result) {
	                this._push(result, 'pushDestroy');
	            },
	            _push: function (result, operation) {
	                var data = this._readData(result);
	                if (!data) {
	                    data = result;
	                }
	                this[operation](data);
	            },
	            _flatData: function (data, skip) {
	                if (data) {
	                    if (this._isServerGrouped()) {
	                        return flattenGroups(data);
	                    }
	                    if (!skip) {
	                        for (var idx = 0; idx < data.length; idx++) {
	                            data.at(idx);
	                        }
	                    }
	                }
	                return data;
	            },
	            parent: noop,
	            get: function (id) {
	                var idx, length, data = this._flatData(this._data);
	                for (idx = 0, length = data.length; idx < length; idx++) {
	                    if (data[idx].id == id) {
	                        return data[idx];
	                    }
	                }
	            },
	            getByUid: function (id) {
	                var idx, length, data = this._flatData(this._data);
	                if (!data) {
	                    return;
	                }
	                for (idx = 0, length = data.length; idx < length; idx++) {
	                    if (data[idx].uid == id) {
	                        return data[idx];
	                    }
	                }
	            },
	            indexOf: function (model) {
	                return indexOfModel(this._data, model);
	            },
	            at: function (index) {
	                return this._data.at(index);
	            },
	            data: function (value) {
	                var that = this;
	                if (value !== undefined) {
	                    that._detachObservableParents();
	                    that._data = this._observe(value);
	                    that._pristineData = value.slice(0);
	                    that._storeData();
	                    that._ranges = [];
	                    that.trigger('reset');
	                    that._addRange(that._data);
	                    that._total = that._data.length;
	                    that._pristineTotal = that._total;
	                    that._process(that._data);
	                } else {
	                    if (that._data) {
	                        for (var idx = 0; idx < that._data.length; idx++) {
	                            that._data.at(idx);
	                        }
	                    }
	                    return that._data;
	                }
	            },
	            view: function (value) {
	                if (value === undefined) {
	                    return this._view;
	                } else {
	                    this._view = this._observeView(value);
	                }
	            },
	            _observeView: function (data) {
	                var that = this;
	                replaceWithObservable(data, that._data, that._ranges, that.reader.model || ObservableObject, that._isServerGrouped());
	                var view = new LazyObservableArray(data, that.reader.model);
	                view.parent = function () {
	                    return that.parent();
	                };
	                return view;
	            },
	            flatView: function () {
	                var groups = this.group() || [];
	                if (groups.length) {
	                    return flattenGroups(this._view);
	                } else {
	                    return this._view;
	                }
	            },
	            add: function (model) {
	                return this.insert(this._data.length, model);
	            },
	            _createNewModel: function (model) {
	                if (this.reader.model) {
	                    return new this.reader.model(model);
	                }
	                if (model instanceof ObservableObject) {
	                    return model;
	                }
	                return new ObservableObject(model);
	            },
	            insert: function (index, model) {
	                if (!model) {
	                    model = index;
	                    index = 0;
	                }
	                if (!(model instanceof Model)) {
	                    model = this._createNewModel(model);
	                }
	                if (this._isServerGrouped()) {
	                    this._data.splice(index, 0, this._wrapInEmptyGroup(model));
	                } else {
	                    this._data.splice(index, 0, model);
	                }
	                return model;
	            },
	            pushCreate: function (items) {
	                if (!isArray(items)) {
	                    items = [items];
	                }
	                var pushed = [];
	                var autoSync = this.options.autoSync;
	                this.options.autoSync = false;
	                try {
	                    for (var idx = 0; idx < items.length; idx++) {
	                        var item = items[idx];
	                        var result = this.add(item);
	                        pushed.push(result);
	                        var pristine = result.toJSON();
	                        if (this._isServerGrouped()) {
	                            pristine = this._wrapInEmptyGroup(pristine);
	                        }
	                        this._pristineData.push(pristine);
	                    }
	                } finally {
	                    this.options.autoSync = autoSync;
	                }
	                if (pushed.length) {
	                    this.trigger('push', {
	                        type: 'create',
	                        items: pushed
	                    });
	                }
	            },
	            pushUpdate: function (items) {
	                if (!isArray(items)) {
	                    items = [items];
	                }
	                var pushed = [];
	                for (var idx = 0; idx < items.length; idx++) {
	                    var item = items[idx];
	                    var model = this._createNewModel(item);
	                    var target = this.get(model.id);
	                    if (target) {
	                        pushed.push(target);
	                        target.accept(item);
	                        target.trigger(CHANGE);
	                        this._updatePristineForModel(target, item);
	                    } else {
	                        this.pushCreate(item);
	                    }
	                }
	                if (pushed.length) {
	                    this.trigger('push', {
	                        type: 'update',
	                        items: pushed
	                    });
	                }
	            },
	            pushDestroy: function (items) {
	                var pushed = this._removeItems(items);
	                if (pushed.length) {
	                    this.trigger('push', {
	                        type: 'destroy',
	                        items: pushed
	                    });
	                }
	            },
	            _removeItems: function (items) {
	                if (!isArray(items)) {
	                    items = [items];
	                }
	                var destroyed = [];
	                var autoSync = this.options.autoSync;
	                this.options.autoSync = false;
	                try {
	                    for (var idx = 0; idx < items.length; idx++) {
	                        var item = items[idx];
	                        var model = this._createNewModel(item);
	                        var found = false;
	                        this._eachItem(this._data, function (items) {
	                            for (var idx = 0; idx < items.length; idx++) {
	                                var item = items.at(idx);
	                                if (item.id === model.id) {
	                                    destroyed.push(item);
	                                    items.splice(idx, 1);
	                                    found = true;
	                                    break;
	                                }
	                            }
	                        });
	                        if (found) {
	                            this._removePristineForModel(model);
	                            this._destroyed.pop();
	                        }
	                    }
	                } finally {
	                    this.options.autoSync = autoSync;
	                }
	                return destroyed;
	            },
	            remove: function (model) {
	                var result, that = this, hasGroups = that._isServerGrouped();
	                this._eachItem(that._data, function (items) {
	                    result = removeModel(items, model);
	                    if (result && hasGroups) {
	                        if (!result.isNew || !result.isNew()) {
	                            that._destroyed.push(result);
	                        }
	                        return true;
	                    }
	                });
	                this._removeModelFromRanges(model);
	                this._updateRangesLength();
	                return model;
	            },
	            destroyed: function () {
	                return this._destroyed;
	            },
	            created: function () {
	                var idx, length, result = [], data = this._flatData(this._data);
	                for (idx = 0, length = data.length; idx < length; idx++) {
	                    if (data[idx].isNew && data[idx].isNew()) {
	                        result.push(data[idx]);
	                    }
	                }
	                return result;
	            },
	            updated: function () {
	                var idx, length, result = [], data = this._flatData(this._data);
	                for (idx = 0, length = data.length; idx < length; idx++) {
	                    if (data[idx].isNew && !data[idx].isNew() && data[idx].dirty) {
	                        result.push(data[idx]);
	                    }
	                }
	                return result;
	            },
	            sync: function () {
	                var that = this, created = [], updated = [], destroyed = that._destroyed;
	                var promise = $.Deferred().resolve().promise();
	                if (that.online()) {
	                    if (!that.reader.model) {
	                        return promise;
	                    }
	                    created = that.created();
	                    updated = that.updated();
	                    var promises = [];
	                    if (that.options.batch && that.transport.submit) {
	                        promises = that._sendSubmit(created, updated, destroyed);
	                    } else {
	                        promises.push.apply(promises, that._send('create', created));
	                        promises.push.apply(promises, that._send('update', updated));
	                        promises.push.apply(promises, that._send('destroy', destroyed));
	                    }
	                    promise = $.when.apply(null, promises).then(function () {
	                        var idx, length;
	                        for (idx = 0, length = arguments.length; idx < length; idx++) {
	                            that._accept(arguments[idx]);
	                        }
	                        that._storeData(true);
	                        that._change({ action: 'sync' });
	                        that.trigger(SYNC);
	                    });
	                } else {
	                    that._storeData(true);
	                    that._change({ action: 'sync' });
	                }
	                return promise;
	            },
	            cancelChanges: function (model) {
	                var that = this;
	                if (model instanceof kendo.data.Model) {
	                    that._cancelModel(model);
	                } else {
	                    that._destroyed = [];
	                    that._detachObservableParents();
	                    that._data = that._observe(that._pristineData);
	                    if (that.options.serverPaging) {
	                        that._total = that._pristineTotal;
	                    }
	                    that._ranges = [];
	                    that._addRange(that._data);
	                    that._change();
	                    that._markOfflineUpdatesAsDirty();
	                }
	            },
	            _markOfflineUpdatesAsDirty: function () {
	                var that = this;
	                if (that.options.offlineStorage != null) {
	                    that._eachItem(that._data, function (items) {
	                        for (var idx = 0; idx < items.length; idx++) {
	                            var item = items.at(idx);
	                            if (item.__state__ == 'update' || item.__state__ == 'create') {
	                                item.dirty = true;
	                            }
	                        }
	                    });
	                }
	            },
	            hasChanges: function () {
	                var idx, length, data = this._flatData(this._data);
	                if (this._destroyed.length) {
	                    return true;
	                }
	                for (idx = 0, length = data.length; idx < length; idx++) {
	                    if (data[idx].isNew && data[idx].isNew() || data[idx].dirty) {
	                        return true;
	                    }
	                }
	                return false;
	            },
	            _accept: function (result) {
	                var that = this, models = result.models, response = result.response, idx = 0, serverGroup = that._isServerGrouped(), pristine = that._pristineData, type = result.type, length;
	                that.trigger(REQUESTEND, {
	                    response: response,
	                    type: type
	                });
	                if (response && !isEmptyObject(response)) {
	                    response = that.reader.parse(response);
	                    if (that._handleCustomErrors(response)) {
	                        return;
	                    }
	                    response = that.reader.data(response);
	                    if (!isArray(response)) {
	                        response = [response];
	                    }
	                } else {
	                    response = $.map(models, function (model) {
	                        return model.toJSON();
	                    });
	                }
	                if (type === 'destroy') {
	                    that._destroyed = [];
	                }
	                for (idx = 0, length = models.length; idx < length; idx++) {
	                    if (type !== 'destroy') {
	                        models[idx].accept(response[idx]);
	                        if (type === 'create') {
	                            pristine.push(serverGroup ? that._wrapInEmptyGroup(models[idx]) : response[idx]);
	                        } else if (type === 'update') {
	                            that._updatePristineForModel(models[idx], response[idx]);
	                        }
	                    } else {
	                        that._removePristineForModel(models[idx]);
	                    }
	                }
	            },
	            _updatePristineForModel: function (model, values) {
	                this._executeOnPristineForModel(model, function (index, items) {
	                    kendo.deepExtend(items[index], values);
	                });
	            },
	            _executeOnPristineForModel: function (model, callback) {
	                this._eachPristineItem(function (items) {
	                    var index = indexOfPristineModel(items, model);
	                    if (index > -1) {
	                        callback(index, items);
	                        return true;
	                    }
	                });
	            },
	            _removePristineForModel: function (model) {
	                this._executeOnPristineForModel(model, function (index, items) {
	                    items.splice(index, 1);
	                });
	            },
	            _readData: function (data) {
	                var read = !this._isServerGrouped() ? this.reader.data : this.reader.groups;
	                return read.call(this.reader, data);
	            },
	            _eachPristineItem: function (callback) {
	                this._eachItem(this._pristineData, callback);
	            },
	            _eachItem: function (data, callback) {
	                if (data && data.length) {
	                    if (this._isServerGrouped()) {
	                        eachGroupItems(data, callback);
	                    } else {
	                        callback(data);
	                    }
	                }
	            },
	            _pristineForModel: function (model) {
	                var pristine, idx, callback = function (items) {
	                        idx = indexOfPristineModel(items, model);
	                        if (idx > -1) {
	                            pristine = items[idx];
	                            return true;
	                        }
	                    };
	                this._eachPristineItem(callback);
	                return pristine;
	            },
	            _cancelModel: function (model) {
	                var pristine = this._pristineForModel(model);
	                this._eachItem(this._data, function (items) {
	                    var idx = indexOfModel(items, model);
	                    if (idx >= 0) {
	                        if (pristine && (!model.isNew() || pristine.__state__)) {
	                            items[idx].accept(pristine);
	                            if (pristine.__state__ == 'update') {
	                                items[idx].dirty = true;
	                            }
	                        } else {
	                            items.splice(idx, 1);
	                        }
	                    }
	                });
	            },
	            _submit: function (promises, data) {
	                var that = this;
	                that.trigger(REQUESTSTART, { type: 'submit' });
	                that.transport.submit(extend({
	                    success: function (response, type) {
	                        var promise = $.grep(promises, function (x) {
	                            return x.type == type;
	                        })[0];
	                        if (promise) {
	                            promise.resolve({
	                                response: response,
	                                models: promise.models,
	                                type: type
	                            });
	                        }
	                    },
	                    error: function (response, status, error) {
	                        for (var idx = 0; idx < promises.length; idx++) {
	                            promises[idx].reject(response);
	                        }
	                        that.error(response, status, error);
	                    }
	                }, data));
	            },
	            _sendSubmit: function (created, updated, destroyed) {
	                var that = this, promises = [];
	                if (that.options.batch) {
	                    if (created.length) {
	                        promises.push($.Deferred(function (deferred) {
	                            deferred.type = 'create';
	                            deferred.models = created;
	                        }));
	                    }
	                    if (updated.length) {
	                        promises.push($.Deferred(function (deferred) {
	                            deferred.type = 'update';
	                            deferred.models = updated;
	                        }));
	                    }
	                    if (destroyed.length) {
	                        promises.push($.Deferred(function (deferred) {
	                            deferred.type = 'destroy';
	                            deferred.models = destroyed;
	                        }));
	                    }
	                    that._submit(promises, {
	                        data: {
	                            created: that.reader.serialize(toJSON(created)),
	                            updated: that.reader.serialize(toJSON(updated)),
	                            destroyed: that.reader.serialize(toJSON(destroyed))
	                        }
	                    });
	                }
	                return promises;
	            },
	            _promise: function (data, models, type) {
	                var that = this;
	                return $.Deferred(function (deferred) {
	                    that.trigger(REQUESTSTART, { type: type });
	                    that.transport[type].call(that.transport, extend({
	                        success: function (response) {
	                            deferred.resolve({
	                                response: response,
	                                models: models,
	                                type: type
	                            });
	                        },
	                        error: function (response, status, error) {
	                            deferred.reject(response);
	                            that.error(response, status, error);
	                        }
	                    }, data));
	                }).promise();
	            },
	            _send: function (method, data) {
	                var that = this, idx, length, promises = [], converted = that.reader.serialize(toJSON(data));
	                if (that.options.batch) {
	                    if (data.length) {
	                        promises.push(that._promise({ data: { models: converted } }, data, method));
	                    }
	                } else {
	                    for (idx = 0, length = data.length; idx < length; idx++) {
	                        promises.push(that._promise({ data: converted[idx] }, [data[idx]], method));
	                    }
	                }
	                return promises;
	            },
	            read: function (data) {
	                var that = this, params = that._params(data);
	                var deferred = $.Deferred();
	                that._queueRequest(params, function () {
	                    var isPrevented = that.trigger(REQUESTSTART, { type: 'read' });
	                    if (!isPrevented) {
	                        that.trigger(PROGRESS);
	                        that._ranges = [];
	                        that.trigger('reset');
	                        if (that.online()) {
	                            that.transport.read({
	                                data: params,
	                                success: function (data) {
	                                    that._ranges = [];
	                                    that.success(data, params);
	                                    deferred.resolve();
	                                },
	                                error: function () {
	                                    var args = slice.call(arguments);
	                                    that.error.apply(that, args);
	                                    deferred.reject.apply(deferred, args);
	                                }
	                            });
	                        } else if (that.options.offlineStorage != null) {
	                            that.success(that.offlineData(), params);
	                            deferred.resolve();
	                        }
	                    } else {
	                        that._dequeueRequest();
	                        deferred.resolve(isPrevented);
	                    }
	                });
	                return deferred.promise();
	            },
	            _readAggregates: function (data) {
	                return this.reader.aggregates(data);
	            },
	            success: function (data) {
	                var that = this, options = that.options;
	                that.trigger(REQUESTEND, {
	                    response: data,
	                    type: 'read'
	                });
	                if (that.online()) {
	                    data = that.reader.parse(data);
	                    if (that._handleCustomErrors(data)) {
	                        that._dequeueRequest();
	                        return;
	                    }
	                    that._total = that.reader.total(data);
	                    if (that._aggregate && options.serverAggregates) {
	                        that._aggregateResult = that._readAggregates(data);
	                    }
	                    data = that._readData(data);
	                    that._destroyed = [];
	                } else {
	                    data = that._readData(data);
	                    var items = [];
	                    var itemIds = {};
	                    var model = that.reader.model;
	                    var idField = model ? model.idField : 'id';
	                    var idx;
	                    for (idx = 0; idx < this._destroyed.length; idx++) {
	                        var id = this._destroyed[idx][idField];
	                        itemIds[id] = id;
	                    }
	                    for (idx = 0; idx < data.length; idx++) {
	                        var item = data[idx];
	                        var state = item.__state__;
	                        if (state == 'destroy') {
	                            if (!itemIds[item[idField]]) {
	                                this._destroyed.push(this._createNewModel(item));
	                            }
	                        } else {
	                            items.push(item);
	                        }
	                    }
	                    data = items;
	                    that._total = data.length;
	                }
	                that._pristineTotal = that._total;
	                that._pristineData = data.slice(0);
	                that._detachObservableParents();
	                that._data = that._observe(data);
	                that._markOfflineUpdatesAsDirty();
	                that._storeData();
	                that._addRange(that._data);
	                that._process(that._data);
	                that._dequeueRequest();
	            },
	            _detachObservableParents: function () {
	                if (this._data && this._shouldDetachObservableParents) {
	                    for (var idx = 0; idx < this._data.length; idx++) {
	                        if (this._data[idx].parent) {
	                            this._data[idx].parent = noop;
	                        }
	                    }
	                }
	            },
	            _storeData: function (updatePristine) {
	                var serverGrouping = this._isServerGrouped();
	                var model = this.reader.model;
	                function items(data) {
	                    var state = [];
	                    for (var idx = 0; idx < data.length; idx++) {
	                        var dataItem = data.at(idx);
	                        var item = dataItem.toJSON();
	                        if (serverGrouping && dataItem.items) {
	                            item.items = items(dataItem.items);
	                        } else {
	                            item.uid = dataItem.uid;
	                            if (model) {
	                                if (dataItem.isNew()) {
	                                    item.__state__ = 'create';
	                                } else if (dataItem.dirty) {
	                                    item.__state__ = 'update';
	                                }
	                            }
	                        }
	                        state.push(item);
	                    }
	                    return state;
	                }
	                if (this.options.offlineStorage != null) {
	                    var state = items(this._data);
	                    var destroyed = [];
	                    for (var idx = 0; idx < this._destroyed.length; idx++) {
	                        var item = this._destroyed[idx].toJSON();
	                        item.__state__ = 'destroy';
	                        destroyed.push(item);
	                    }
	                    this.offlineData(state.concat(destroyed));
	                    if (updatePristine) {
	                        this._pristineData = this._readData(state);
	                    }
	                }
	            },
	            _addRange: function (data) {
	                var that = this, start = that._skip || 0, end = start + that._flatData(data, true).length;
	                that._ranges.push({
	                    start: start,
	                    end: end,
	                    data: data,
	                    timestamp: new Date().getTime()
	                });
	                that._ranges.sort(function (x, y) {
	                    return x.start - y.start;
	                });
	            },
	            error: function (xhr, status, errorThrown) {
	                this._dequeueRequest();
	                this.trigger(REQUESTEND, {});
	                this.trigger(ERROR, {
	                    xhr: xhr,
	                    status: status,
	                    errorThrown: errorThrown
	                });
	            },
	            _params: function (data) {
	                var that = this, options = extend({
	                        take: that.take(),
	                        skip: that.skip(),
	                        page: that.page(),
	                        pageSize: that.pageSize(),
	                        sort: that._sort,
	                        filter: that._filter,
	                        group: that._group,
	                        aggregate: that._aggregate
	                    }, data);
	                if (!that.options.serverPaging) {
	                    delete options.take;
	                    delete options.skip;
	                    delete options.page;
	                    delete options.pageSize;
	                }
	                if (!that.options.serverGrouping) {
	                    delete options.group;
	                } else if (that.reader.model && options.group) {
	                    options.group = convertDescriptorsField(options.group, that.reader.model);
	                }
	                if (!that.options.serverFiltering) {
	                    delete options.filter;
	                } else if (that.reader.model && options.filter) {
	                    options.filter = convertFilterDescriptorsField(options.filter, that.reader.model);
	                }
	                if (!that.options.serverSorting) {
	                    delete options.sort;
	                } else if (that.reader.model && options.sort) {
	                    options.sort = convertDescriptorsField(options.sort, that.reader.model);
	                }
	                if (!that.options.serverAggregates) {
	                    delete options.aggregate;
	                } else if (that.reader.model && options.aggregate) {
	                    options.aggregate = convertDescriptorsField(options.aggregate, that.reader.model);
	                }
	                return options;
	            },
	            _queueRequest: function (options, callback) {
	                var that = this;
	                if (!that._requestInProgress) {
	                    that._requestInProgress = true;
	                    that._pending = undefined;
	                    callback();
	                } else {
	                    that._pending = {
	                        callback: proxy(callback, that),
	                        options: options
	                    };
	                }
	            },
	            _dequeueRequest: function () {
	                var that = this;
	                that._requestInProgress = false;
	                if (that._pending) {
	                    that._queueRequest(that._pending.options, that._pending.callback);
	                }
	            },
	            _handleCustomErrors: function (response) {
	                if (this.reader.errors) {
	                    var errors = this.reader.errors(response);
	                    if (errors) {
	                        this.trigger(ERROR, {
	                            xhr: null,
	                            status: 'customerror',
	                            errorThrown: 'custom error',
	                            errors: errors
	                        });
	                        return true;
	                    }
	                }
	                return false;
	            },
	            _shouldWrap: function (data) {
	                var model = this.reader.model;
	                if (model && data.length) {
	                    return !(data[0] instanceof model);
	                }
	                return false;
	            },
	            _observe: function (data) {
	                var that = this, model = that.reader.model;
	                that._shouldDetachObservableParents = true;
	                if (data instanceof ObservableArray) {
	                    that._shouldDetachObservableParents = false;
	                    if (that._shouldWrap(data)) {
	                        data.type = that.reader.model;
	                        data.wrapAll(data, data);
	                    }
	                } else {
	                    var arrayType = that.pageSize() && !that.options.serverPaging ? LazyObservableArray : ObservableArray;
	                    data = new arrayType(data, that.reader.model);
	                    data.parent = function () {
	                        return that.parent();
	                    };
	                }
	                if (that._isServerGrouped()) {
	                    wrapGroupItems(data, model);
	                }
	                if (that._changeHandler && that._data && that._data instanceof ObservableArray) {
	                    that._data.unbind(CHANGE, that._changeHandler);
	                } else {
	                    that._changeHandler = proxy(that._change, that);
	                }
	                return data.bind(CHANGE, that._changeHandler);
	            },
	            _updateTotalForAction: function (action, items) {
	                var that = this;
	                var total = parseInt(that._total, 10);
	                if (!isNumber(that._total)) {
	                    total = parseInt(that._pristineTotal, 10);
	                }
	                if (action === 'add') {
	                    total += items.length;
	                } else if (action === 'remove') {
	                    total -= items.length;
	                } else if (action !== 'itemchange' && action !== 'sync' && !that.options.serverPaging) {
	                    total = that._pristineTotal;
	                } else if (action === 'sync') {
	                    total = that._pristineTotal = parseInt(that._total, 10);
	                }
	                that._total = total;
	            },
	            _change: function (e) {
	                var that = this, idx, length, action = e ? e.action : '';
	                if (action === 'remove') {
	                    for (idx = 0, length = e.items.length; idx < length; idx++) {
	                        if (!e.items[idx].isNew || !e.items[idx].isNew()) {
	                            that._destroyed.push(e.items[idx]);
	                        }
	                    }
	                }
	                if (that.options.autoSync && (action === 'add' || action === 'remove' || action === 'itemchange')) {
	                    var handler = function (args) {
	                        if (args.action === 'sync') {
	                            that.unbind('change', handler);
	                            that._updateTotalForAction(action, e.items);
	                        }
	                    };
	                    that.first('change', handler);
	                    that.sync();
	                } else {
	                    that._updateTotalForAction(action, e ? e.items : []);
	                    that._process(that._data, e);
	                }
	            },
	            _calculateAggregates: function (data, options) {
	                options = options || {};
	                var query = new Query(data), aggregates = options.aggregate, filter = options.filter;
	                if (filter) {
	                    query = query.filter(filter);
	                }
	                return query.aggregate(aggregates);
	            },
	            _process: function (data, e) {
	                var that = this, options = {}, result;
	                if (that.options.serverPaging !== true) {
	                    options.skip = that._skip;
	                    options.take = that._take || that._pageSize;
	                    if (options.skip === undefined && that._page !== undefined && that._pageSize !== undefined) {
	                        options.skip = (that._page - 1) * that._pageSize;
	                    }
	                }
	                if (that.options.serverSorting !== true) {
	                    options.sort = that._sort;
	                }
	                if (that.options.serverFiltering !== true) {
	                    options.filter = that._filter;
	                }
	                if (that.options.serverGrouping !== true) {
	                    options.group = that._group;
	                }
	                if (that.options.serverAggregates !== true) {
	                    options.aggregate = that._aggregate;
	                    that._aggregateResult = that._calculateAggregates(data, options);
	                }
	                result = that._queryProcess(data, options);
	                that.view(result.data);
	                if (result.total !== undefined && !that.options.serverFiltering) {
	                    that._total = result.total;
	                }
	                e = e || {};
	                e.items = e.items || that._view;
	                that.trigger(CHANGE, e);
	            },
	            _queryProcess: function (data, options) {
	                return Query.process(data, options);
	            },
	            _mergeState: function (options) {
	                var that = this;
	                if (options !== undefined) {
	                    that._pageSize = options.pageSize;
	                    that._page = options.page;
	                    that._sort = options.sort;
	                    that._filter = options.filter;
	                    that._group = options.group;
	                    that._aggregate = options.aggregate;
	                    that._skip = that._currentRangeStart = options.skip;
	                    that._take = options.take;
	                    if (that._skip === undefined) {
	                        that._skip = that._currentRangeStart = that.skip();
	                        options.skip = that.skip();
	                    }
	                    if (that._take === undefined && that._pageSize !== undefined) {
	                        that._take = that._pageSize;
	                        options.take = that._take;
	                    }
	                    if (options.sort) {
	                        that._sort = options.sort = normalizeSort(options.sort);
	                    }
	                    if (options.filter) {
	                        that._filter = options.filter = normalizeFilter(options.filter);
	                    }
	                    if (options.group) {
	                        that._group = options.group = normalizeGroup(options.group);
	                    }
	                    if (options.aggregate) {
	                        that._aggregate = options.aggregate = normalizeAggregate(options.aggregate);
	                    }
	                }
	                return options;
	            },
	            query: function (options) {
	                var result;
	                var remote = this.options.serverSorting || this.options.serverPaging || this.options.serverFiltering || this.options.serverGrouping || this.options.serverAggregates;
	                if (remote || (this._data === undefined || this._data.length === 0) && !this._destroyed.length) {
	                    return this.read(this._mergeState(options));
	                }
	                var isPrevented = this.trigger(REQUESTSTART, { type: 'read' });
	                if (!isPrevented) {
	                    this.trigger(PROGRESS);
	                    result = this._queryProcess(this._data, this._mergeState(options));
	                    if (!this.options.serverFiltering) {
	                        if (result.total !== undefined) {
	                            this._total = result.total;
	                        } else {
	                            this._total = this._data.length;
	                        }
	                    }
	                    this._aggregateResult = this._calculateAggregates(this._data, options);
	                    this.view(result.data);
	                    this.trigger(REQUESTEND, { type: 'read' });
	                    this.trigger(CHANGE, { items: result.data });
	                }
	                return $.Deferred().resolve(isPrevented).promise();
	            },
	            fetch: function (callback) {
	                var that = this;
	                var fn = function (isPrevented) {
	                    if (isPrevented !== true && isFunction(callback)) {
	                        callback.call(that);
	                    }
	                };
	                return this._query().then(fn);
	            },
	            _query: function (options) {
	                var that = this;
	                return that.query(extend({}, {
	                    page: that.page(),
	                    pageSize: that.pageSize(),
	                    sort: that.sort(),
	                    filter: that.filter(),
	                    group: that.group(),
	                    aggregate: that.aggregate()
	                }, options));
	            },
	            next: function (options) {
	                var that = this, page = that.page(), total = that.total();
	                options = options || {};
	                if (!page || total && page + 1 > that.totalPages()) {
	                    return;
	                }
	                that._skip = that._currentRangeStart = page * that.take();
	                page += 1;
	                options.page = page;
	                that._query(options);
	                return page;
	            },
	            prev: function (options) {
	                var that = this, page = that.page();
	                options = options || {};
	                if (!page || page === 1) {
	                    return;
	                }
	                that._skip = that._currentRangeStart = that._skip - that.take();
	                page -= 1;
	                options.page = page;
	                that._query(options);
	                return page;
	            },
	            page: function (val) {
	                var that = this, skip;
	                if (val !== undefined) {
	                    val = math.max(math.min(math.max(val, 1), that.totalPages()), 1);
	                    that._query({ page: val });
	                    return;
	                }
	                skip = that.skip();
	                return skip !== undefined ? math.round((skip || 0) / (that.take() || 1)) + 1 : undefined;
	            },
	            pageSize: function (val) {
	                var that = this;
	                if (val !== undefined) {
	                    that._query({
	                        pageSize: val,
	                        page: 1
	                    });
	                    return;
	                }
	                return that.take();
	            },
	            sort: function (val) {
	                var that = this;
	                if (val !== undefined) {
	                    that._query({ sort: val });
	                    return;
	                }
	                return that._sort;
	            },
	            filter: function (val) {
	                var that = this;
	                if (val === undefined) {
	                    return that._filter;
	                }
	                that.trigger('reset');
	                that._query({
	                    filter: val,
	                    page: 1
	                });
	            },
	            group: function (val) {
	                var that = this;
	                if (val !== undefined) {
	                    that._query({ group: val });
	                    return;
	                }
	                return that._group;
	            },
	            total: function () {
	                return parseInt(this._total || 0, 10);
	            },
	            aggregate: function (val) {
	                var that = this;
	                if (val !== undefined) {
	                    that._query({ aggregate: val });
	                    return;
	                }
	                return that._aggregate;
	            },
	            aggregates: function () {
	                var result = this._aggregateResult;
	                if (isEmptyObject(result)) {
	                    result = this._emptyAggregates(this.aggregate());
	                }
	                return result;
	            },
	            _emptyAggregates: function (aggregates) {
	                var result = {};
	                if (!isEmptyObject(aggregates)) {
	                    var aggregate = {};
	                    if (!isArray(aggregates)) {
	                        aggregates = [aggregates];
	                    }
	                    for (var idx = 0; idx < aggregates.length; idx++) {
	                        aggregate[aggregates[idx].aggregate] = 0;
	                        result[aggregates[idx].field] = aggregate;
	                    }
	                }
	                return result;
	            },
	            _wrapInEmptyGroup: function (model) {
	                var groups = this.group(), parent, group, idx, length;
	                for (idx = groups.length - 1, length = 0; idx >= length; idx--) {
	                    group = groups[idx];
	                    parent = {
	                        value: model.get(group.field),
	                        field: group.field,
	                        items: parent ? [parent] : [model],
	                        hasSubgroups: !!parent,
	                        aggregates: this._emptyAggregates(group.aggregates)
	                    };
	                }
	                return parent;
	            },
	            totalPages: function () {
	                var that = this, pageSize = that.pageSize() || that.total();
	                return math.ceil((that.total() || 0) / pageSize);
	            },
	            inRange: function (skip, take) {
	                var that = this, end = math.min(skip + take, that.total());
	                if (!that.options.serverPaging && that._data.length > 0) {
	                    return true;
	                }
	                return that._findRange(skip, end).length > 0;
	            },
	            lastRange: function () {
	                var ranges = this._ranges;
	                return ranges[ranges.length - 1] || {
	                    start: 0,
	                    end: 0,
	                    data: []
	                };
	            },
	            firstItemUid: function () {
	                var ranges = this._ranges;
	                return ranges.length && ranges[0].data.length && ranges[0].data[0].uid;
	            },
	            enableRequestsInProgress: function () {
	                this._skipRequestsInProgress = false;
	            },
	            _timeStamp: function () {
	                return new Date().getTime();
	            },
	            range: function (skip, take) {
	                this._currentRequestTimeStamp = this._timeStamp();
	                this._skipRequestsInProgress = true;
	                skip = math.min(skip || 0, this.total());
	                var that = this, pageSkip = math.max(math.floor(skip / take), 0) * take, size = math.min(pageSkip + take, that.total()), data;
	                data = that._findRange(skip, math.min(skip + take, that.total()));
	                if (data.length) {
	                    that._pending = undefined;
	                    that._skip = skip > that.skip() ? math.min(size, (that.totalPages() - 1) * that.take()) : pageSkip;
	                    that._currentRangeStart = skip;
	                    that._take = take;
	                    var paging = that.options.serverPaging;
	                    var sorting = that.options.serverSorting;
	                    var filtering = that.options.serverFiltering;
	                    var aggregates = that.options.serverAggregates;
	                    try {
	                        that.options.serverPaging = true;
	                        if (!that._isServerGrouped() && !(that.group() && that.group().length)) {
	                            that.options.serverSorting = true;
	                        }
	                        that.options.serverFiltering = true;
	                        that.options.serverPaging = true;
	                        that.options.serverAggregates = true;
	                        if (paging) {
	                            that._detachObservableParents();
	                            that._data = data = that._observe(data);
	                        }
	                        that._process(data);
	                    } finally {
	                        that.options.serverPaging = paging;
	                        that.options.serverSorting = sorting;
	                        that.options.serverFiltering = filtering;
	                        that.options.serverAggregates = aggregates;
	                    }
	                    return;
	                }
	                if (take !== undefined) {
	                    if (!that._rangeExists(pageSkip, size)) {
	                        that.prefetch(pageSkip, take, function () {
	                            if (skip > pageSkip && size < that.total() && !that._rangeExists(size, math.min(size + take, that.total()))) {
	                                that.prefetch(size, take, function () {
	                                    that.range(skip, take);
	                                });
	                            } else {
	                                that.range(skip, take);
	                            }
	                        });
	                    } else if (pageSkip < skip) {
	                        that.prefetch(size, take, function () {
	                            that.range(skip, take);
	                        });
	                    }
	                }
	            },
	            _findRange: function (start, end) {
	                var that = this, ranges = that._ranges, range, data = [], skipIdx, takeIdx, startIndex, endIndex, rangeData, rangeEnd, processed, options = that.options, remote = options.serverSorting || options.serverPaging || options.serverFiltering || options.serverGrouping || options.serverAggregates, flatData, count, length;
	                for (skipIdx = 0, length = ranges.length; skipIdx < length; skipIdx++) {
	                    range = ranges[skipIdx];
	                    if (start >= range.start && start <= range.end) {
	                        count = 0;
	                        for (takeIdx = skipIdx; takeIdx < length; takeIdx++) {
	                            range = ranges[takeIdx];
	                            flatData = that._flatData(range.data, true);
	                            if (flatData.length && start + count >= range.start) {
	                                rangeData = range.data;
	                                rangeEnd = range.end;
	                                if (!remote) {
	                                    var sort = normalizeGroup(that.group() || []).concat(normalizeSort(that.sort() || []));
	                                    processed = that._queryProcess(range.data, {
	                                        sort: sort,
	                                        filter: that.filter()
	                                    });
	                                    flatData = rangeData = processed.data;
	                                    if (processed.total !== undefined) {
	                                        rangeEnd = processed.total;
	                                    }
	                                }
	                                startIndex = 0;
	                                if (start + count > range.start) {
	                                    startIndex = start + count - range.start;
	                                }
	                                endIndex = flatData.length;
	                                if (rangeEnd > end) {
	                                    endIndex = endIndex - (rangeEnd - end);
	                                }
	                                count += endIndex - startIndex;
	                                data = that._mergeGroups(data, rangeData, startIndex, endIndex);
	                                if (end <= range.end && count == end - start) {
	                                    return data;
	                                }
	                            }
	                        }
	                        break;
	                    }
	                }
	                return [];
	            },
	            _mergeGroups: function (data, range, skip, take) {
	                if (this._isServerGrouped()) {
	                    var temp = range.toJSON(), prevGroup;
	                    if (data.length) {
	                        prevGroup = data[data.length - 1];
	                    }
	                    mergeGroups(prevGroup, temp, skip, take);
	                    return data.concat(temp);
	                }
	                return data.concat(range.slice(skip, take));
	            },
	            skip: function () {
	                var that = this;
	                if (that._skip === undefined) {
	                    return that._page !== undefined ? (that._page - 1) * (that.take() || 1) : undefined;
	                }
	                return that._skip;
	            },
	            currentRangeStart: function () {
	                return this._currentRangeStart || 0;
	            },
	            take: function () {
	                return this._take || this._pageSize;
	            },
	            _prefetchSuccessHandler: function (skip, size, callback, force) {
	                var that = this;
	                var timestamp = that._timeStamp();
	                return function (data) {
	                    var found = false, range = {
	                            start: skip,
	                            end: size,
	                            data: [],
	                            timestamp: that._timeStamp()
	                        }, idx, length, temp;
	                    that._dequeueRequest();
	                    that.trigger(REQUESTEND, {
	                        response: data,
	                        type: 'read'
	                    });
	                    data = that.reader.parse(data);
	                    temp = that._readData(data);
	                    if (temp.length) {
	                        for (idx = 0, length = that._ranges.length; idx < length; idx++) {
	                            if (that._ranges[idx].start === skip) {
	                                found = true;
	                                range = that._ranges[idx];
	                                break;
	                            }
	                        }
	                        if (!found) {
	                            that._ranges.push(range);
	                        }
	                    }
	                    range.data = that._observe(temp);
	                    range.end = range.start + that._flatData(range.data, true).length;
	                    that._ranges.sort(function (x, y) {
	                        return x.start - y.start;
	                    });
	                    that._total = that.reader.total(data);
	                    if (force || (timestamp >= that._currentRequestTimeStamp || !that._skipRequestsInProgress)) {
	                        if (callback && temp.length) {
	                            callback();
	                        } else {
	                            that.trigger(CHANGE, {});
	                        }
	                    }
	                };
	            },
	            prefetch: function (skip, take, callback) {
	                var that = this, size = math.min(skip + take, that.total()), options = {
	                        take: take,
	                        skip: skip,
	                        page: skip / take + 1,
	                        pageSize: take,
	                        sort: that._sort,
	                        filter: that._filter,
	                        group: that._group,
	                        aggregate: that._aggregate
	                    };
	                if (!that._rangeExists(skip, size)) {
	                    clearTimeout(that._timeout);
	                    that._timeout = setTimeout(function () {
	                        that._queueRequest(options, function () {
	                            if (!that.trigger(REQUESTSTART, { type: 'read' })) {
	                                that.transport.read({
	                                    data: that._params(options),
	                                    success: that._prefetchSuccessHandler(skip, size, callback),
	                                    error: function () {
	                                        var args = slice.call(arguments);
	                                        that.error.apply(that, args);
	                                    }
	                                });
	                            } else {
	                                that._dequeueRequest();
	                            }
	                        });
	                    }, 100);
	                } else if (callback) {
	                    callback();
	                }
	            },
	            _multiplePrefetch: function (skip, take, callback) {
	                var that = this, size = math.min(skip + take, that.total()), options = {
	                        take: take,
	                        skip: skip,
	                        page: skip / take + 1,
	                        pageSize: take,
	                        sort: that._sort,
	                        filter: that._filter,
	                        group: that._group,
	                        aggregate: that._aggregate
	                    };
	                if (!that._rangeExists(skip, size)) {
	                    if (!that.trigger(REQUESTSTART, { type: 'read' })) {
	                        that.transport.read({
	                            data: that._params(options),
	                            success: that._prefetchSuccessHandler(skip, size, callback, true)
	                        });
	                    }
	                } else if (callback) {
	                    callback();
	                }
	            },
	            _rangeExists: function (start, end) {
	                var that = this, ranges = that._ranges, idx, length;
	                for (idx = 0, length = ranges.length; idx < length; idx++) {
	                    if (ranges[idx].start <= start && ranges[idx].end >= end) {
	                        return true;
	                    }
	                }
	                return false;
	            },
	            _removeModelFromRanges: function (model) {
	                var result, found, range;
	                for (var idx = 0, length = this._ranges.length; idx < length; idx++) {
	                    range = this._ranges[idx];
	                    this._eachItem(range.data, function (items) {
	                        result = removeModel(items, model);
	                        if (result) {
	                            found = true;
	                        }
	                    });
	                    if (found) {
	                        break;
	                    }
	                }
	            },
	            _updateRangesLength: function () {
	                var startOffset = 0, range, rangeLength;
	                for (var idx = 0, length = this._ranges.length; idx < length; idx++) {
	                    range = this._ranges[idx];
	                    range.start = range.start - startOffset;
	                    rangeLength = this._flatData(range.data, true).length;
	                    startOffset = range.end - rangeLength;
	                    range.end = range.start + rangeLength;
	                }
	            }
	        });
	        var Transport = {};
	        Transport.create = function (options, data, dataSource) {
	            var transport, transportOptions = options.transport ? $.extend({}, options.transport) : null;
	            if (transportOptions) {
	                transportOptions.read = typeof transportOptions.read === STRING ? { url: transportOptions.read } : transportOptions.read;
	                if (options.type === 'jsdo') {
	                    transportOptions.dataSource = dataSource;
	                }
	                if (options.type) {
	                    kendo.data.transports = kendo.data.transports || {};
	                    kendo.data.schemas = kendo.data.schemas || {};
	                    if (!kendo.data.transports[options.type]) {
	                        kendo.logToConsole('Unknown DataSource transport type \'' + options.type + '\'.\nVerify that registration scripts for this type are included after Kendo UI on the page.', 'warn');
	                    } else if (!isPlainObject(kendo.data.transports[options.type])) {
	                        transport = new kendo.data.transports[options.type](extend(transportOptions, { data: data }));
	                    } else {
	                        transportOptions = extend(true, {}, kendo.data.transports[options.type], transportOptions);
	                    }
	                    options.schema = extend(true, {}, kendo.data.schemas[options.type], options.schema);
	                }
	                if (!transport) {
	                    transport = isFunction(transportOptions.read) ? transportOptions : new RemoteTransport(transportOptions);
	                }
	            } else {
	                transport = new LocalTransport({ data: options.data || [] });
	            }
	            return transport;
	        };
	        DataSource.create = function (options) {
	            if (isArray(options) || options instanceof ObservableArray) {
	                options = { data: options };
	            }
	            var dataSource = options || {}, data = dataSource.data, fields = dataSource.fields, table = dataSource.table, select = dataSource.select, idx, length, model = {}, field;
	            if (!data && fields && !dataSource.transport) {
	                if (table) {
	                    data = inferTable(table, fields);
	                } else if (select) {
	                    data = inferSelect(select, fields);
	                    if (dataSource.group === undefined && data[0] && data[0].optgroup !== undefined) {
	                        dataSource.group = 'optgroup';
	                    }
	                }
	            }
	            if (kendo.data.Model && fields && (!dataSource.schema || !dataSource.schema.model)) {
	                for (idx = 0, length = fields.length; idx < length; idx++) {
	                    field = fields[idx];
	                    if (field.type) {
	                        model[field.field] = field;
	                    }
	                }
	                if (!isEmptyObject(model)) {
	                    dataSource.schema = extend(true, dataSource.schema, { model: { fields: model } });
	                }
	            }
	            dataSource.data = data;
	            select = null;
	            dataSource.select = null;
	            table = null;
	            dataSource.table = null;
	            return dataSource instanceof DataSource ? dataSource : new DataSource(dataSource);
	        };
	        function inferSelect(select, fields) {
	            select = $(select)[0];
	            var options = select.options;
	            var firstField = fields[0];
	            var secondField = fields[1];
	            var data = [];
	            var idx, length;
	            var optgroup;
	            var option;
	            var record;
	            var value;
	            for (idx = 0, length = options.length; idx < length; idx++) {
	                record = {};
	                option = options[idx];
	                optgroup = option.parentNode;
	                if (optgroup === select) {
	                    optgroup = null;
	                }
	                if (option.disabled || optgroup && optgroup.disabled) {
	                    continue;
	                }
	                if (optgroup) {
	                    record.optgroup = optgroup.label;
	                }
	                record[firstField.field] = option.text;
	                value = option.attributes.value;
	                if (value && value.specified) {
	                    value = option.value;
	                } else {
	                    value = option.text;
	                }
	                record[secondField.field] = value;
	                data.push(record);
	            }
	            return data;
	        }
	        function inferTable(table, fields) {
	            var tbody = $(table)[0].tBodies[0], rows = tbody ? tbody.rows : [], idx, length, fieldIndex, fieldCount = fields.length, data = [], cells, record, cell, empty;
	            for (idx = 0, length = rows.length; idx < length; idx++) {
	                record = {};
	                empty = true;
	                cells = rows[idx].cells;
	                for (fieldIndex = 0; fieldIndex < fieldCount; fieldIndex++) {
	                    cell = cells[fieldIndex];
	                    if (cell.nodeName.toLowerCase() !== 'th') {
	                        empty = false;
	                        record[fields[fieldIndex].field] = cell.innerHTML;
	                    }
	                }
	                if (!empty) {
	                    data.push(record);
	                }
	            }
	            return data;
	        }
	        var Node = Model.define({
	            idField: 'id',
	            init: function (value) {
	                var that = this, hasChildren = that.hasChildren || value && value.hasChildren, childrenField = 'items', childrenOptions = {};
	                kendo.data.Model.fn.init.call(that, value);
	                if (typeof that.children === STRING) {
	                    childrenField = that.children;
	                }
	                childrenOptions = {
	                    schema: {
	                        data: childrenField,
	                        model: {
	                            hasChildren: hasChildren,
	                            id: that.idField,
	                            fields: that.fields
	                        }
	                    }
	                };
	                if (typeof that.children !== STRING) {
	                    extend(childrenOptions, that.children);
	                }
	                childrenOptions.data = value;
	                if (!hasChildren) {
	                    hasChildren = childrenOptions.schema.data;
	                }
	                if (typeof hasChildren === STRING) {
	                    hasChildren = kendo.getter(hasChildren);
	                }
	                if (isFunction(hasChildren)) {
	                    that.hasChildren = !!hasChildren.call(that, that);
	                }
	                that._childrenOptions = childrenOptions;
	                if (that.hasChildren) {
	                    that._initChildren();
	                }
	                that._loaded = !!(value && value._loaded);
	            },
	            _initChildren: function () {
	                var that = this;
	                var children, transport, parameterMap;
	                if (!(that.children instanceof HierarchicalDataSource)) {
	                    children = that.children = new HierarchicalDataSource(that._childrenOptions);
	                    transport = children.transport;
	                    parameterMap = transport.parameterMap;
	                    transport.parameterMap = function (data, type) {
	                        data[that.idField || 'id'] = that.id;
	                        if (parameterMap) {
	                            data = parameterMap(data, type);
	                        }
	                        return data;
	                    };
	                    children.parent = function () {
	                        return that;
	                    };
	                    children.bind(CHANGE, function (e) {
	                        e.node = e.node || that;
	                        that.trigger(CHANGE, e);
	                    });
	                    children.bind(ERROR, function (e) {
	                        var collection = that.parent();
	                        if (collection) {
	                            e.node = e.node || that;
	                            collection.trigger(ERROR, e);
	                        }
	                    });
	                    that._updateChildrenField();
	                }
	            },
	            append: function (model) {
	                this._initChildren();
	                this.loaded(true);
	                this.children.add(model);
	            },
	            hasChildren: false,
	            level: function () {
	                var parentNode = this.parentNode(), level = 0;
	                while (parentNode && parentNode.parentNode) {
	                    level++;
	                    parentNode = parentNode.parentNode ? parentNode.parentNode() : null;
	                }
	                return level;
	            },
	            _updateChildrenField: function () {
	                var fieldName = this._childrenOptions.schema.data;
	                this[fieldName || 'items'] = this.children.data();
	            },
	            _childrenLoaded: function () {
	                this._loaded = true;
	                this._updateChildrenField();
	            },
	            load: function () {
	                var options = {};
	                var method = '_query';
	                var children, promise;
	                if (this.hasChildren) {
	                    this._initChildren();
	                    children = this.children;
	                    options[this.idField || 'id'] = this.id;
	                    if (!this._loaded) {
	                        children._data = undefined;
	                        method = 'read';
	                    }
	                    children.one(CHANGE, proxy(this._childrenLoaded, this));
	                    promise = children[method](options);
	                } else {
	                    this.loaded(true);
	                }
	                return promise || $.Deferred().resolve().promise();
	            },
	            parentNode: function () {
	                var array = this.parent();
	                return array.parent();
	            },
	            loaded: function (value) {
	                if (value !== undefined) {
	                    this._loaded = value;
	                } else {
	                    return this._loaded;
	                }
	            },
	            shouldSerialize: function (field) {
	                return Model.fn.shouldSerialize.call(this, field) && field !== 'children' && field !== '_loaded' && field !== 'hasChildren' && field !== '_childrenOptions';
	            }
	        });
	        function dataMethod(name) {
	            return function () {
	                var data = this._data, result = DataSource.fn[name].apply(this, slice.call(arguments));
	                if (this._data != data) {
	                    this._attachBubbleHandlers();
	                }
	                return result;
	            };
	        }
	        var HierarchicalDataSource = DataSource.extend({
	            init: function (options) {
	                var node = Node.define({ children: options });
	                DataSource.fn.init.call(this, extend(true, {}, {
	                    schema: {
	                        modelBase: node,
	                        model: node
	                    }
	                }, options));
	                this._attachBubbleHandlers();
	            },
	            _attachBubbleHandlers: function () {
	                var that = this;
	                that._data.bind(ERROR, function (e) {
	                    that.trigger(ERROR, e);
	                });
	            },
	            remove: function (node) {
	                var parentNode = node.parentNode(), dataSource = this, result;
	                if (parentNode && parentNode._initChildren) {
	                    dataSource = parentNode.children;
	                }
	                result = DataSource.fn.remove.call(dataSource, node);
	                if (parentNode && !dataSource.data().length) {
	                    parentNode.hasChildren = false;
	                }
	                return result;
	            },
	            success: dataMethod('success'),
	            data: dataMethod('data'),
	            insert: function (index, model) {
	                var parentNode = this.parent();
	                if (parentNode && parentNode._initChildren) {
	                    parentNode.hasChildren = true;
	                    parentNode._initChildren();
	                }
	                return DataSource.fn.insert.call(this, index, model);
	            },
	            _find: function (method, value) {
	                var idx, length, node, children;
	                var data = this._data;
	                if (!data) {
	                    return;
	                }
	                node = DataSource.fn[method].call(this, value);
	                if (node) {
	                    return node;
	                }
	                data = this._flatData(this._data);
	                for (idx = 0, length = data.length; idx < length; idx++) {
	                    children = data[idx].children;
	                    if (!(children instanceof HierarchicalDataSource)) {
	                        continue;
	                    }
	                    node = children[method](value);
	                    if (node) {
	                        return node;
	                    }
	                }
	            },
	            get: function (id) {
	                return this._find('get', id);
	            },
	            getByUid: function (uid) {
	                return this._find('getByUid', uid);
	            }
	        });
	        function inferList(list, fields) {
	            var items = $(list).children(), idx, length, data = [], record, textField = fields[0].field, urlField = fields[1] && fields[1].field, spriteCssClassField = fields[2] && fields[2].field, imageUrlField = fields[3] && fields[3].field, item, id, textChild, className, children;
	            function elements(collection, tagName) {
	                return collection.filter(tagName).add(collection.find(tagName));
	            }
	            for (idx = 0, length = items.length; idx < length; idx++) {
	                record = { _loaded: true };
	                item = items.eq(idx);
	                textChild = item[0].firstChild;
	                children = item.children();
	                list = children.filter('ul');
	                children = children.filter(':not(ul)');
	                id = item.attr('data-id');
	                if (id) {
	                    record.id = id;
	                }
	                if (textChild) {
	                    record[textField] = textChild.nodeType == 3 ? textChild.nodeValue : children.text();
	                }
	                if (urlField) {
	                    record[urlField] = elements(children, 'a').attr('href');
	                }
	                if (imageUrlField) {
	                    record[imageUrlField] = elements(children, 'img').attr('src');
	                }
	                if (spriteCssClassField) {
	                    className = elements(children, '.k-sprite').prop('className');
	                    record[spriteCssClassField] = className && $.trim(className.replace('k-sprite', ''));
	                }
	                if (list.length) {
	                    record.items = inferList(list.eq(0), fields);
	                }
	                if (item.attr('data-hasChildren') == 'true') {
	                    record.hasChildren = true;
	                }
	                data.push(record);
	            }
	            return data;
	        }
	        HierarchicalDataSource.create = function (options) {
	            options = options && options.push ? { data: options } : options;
	            var dataSource = options || {}, data = dataSource.data, fields = dataSource.fields, list = dataSource.list;
	            if (data && data._dataSource) {
	                return data._dataSource;
	            }
	            if (!data && fields && !dataSource.transport) {
	                if (list) {
	                    data = inferList(list, fields);
	                }
	            }
	            dataSource.data = data;
	            return dataSource instanceof HierarchicalDataSource ? dataSource : new HierarchicalDataSource(dataSource);
	        };
	        var Buffer = kendo.Observable.extend({
	            init: function (dataSource, viewSize, disablePrefetch) {
	                kendo.Observable.fn.init.call(this);
	                this._prefetching = false;
	                this.dataSource = dataSource;
	                this.prefetch = !disablePrefetch;
	                var buffer = this;
	                dataSource.bind('change', function () {
	                    buffer._change();
	                });
	                dataSource.bind('reset', function () {
	                    buffer._reset();
	                });
	                this._syncWithDataSource();
	                this.setViewSize(viewSize);
	            },
	            setViewSize: function (viewSize) {
	                this.viewSize = viewSize;
	                this._recalculate();
	            },
	            at: function (index) {
	                var pageSize = this.pageSize, itemPresent = true;
	                if (index >= this.total()) {
	                    this.trigger('endreached', { index: index });
	                    return null;
	                }
	                if (!this.useRanges) {
	                    return this.dataSource.view()[index];
	                }
	                if (this.useRanges) {
	                    if (index < this.dataOffset || index >= this.skip + pageSize) {
	                        itemPresent = this.range(Math.floor(index / pageSize) * pageSize);
	                    }
	                    if (index === this.prefetchThreshold) {
	                        this._prefetch();
	                    }
	                    if (index === this.midPageThreshold) {
	                        this.range(this.nextMidRange, true);
	                    } else if (index === this.nextPageThreshold) {
	                        this.range(this.nextFullRange);
	                    } else if (index === this.pullBackThreshold) {
	                        if (this.offset === this.skip) {
	                            this.range(this.previousMidRange);
	                        } else {
	                            this.range(this.previousFullRange);
	                        }
	                    }
	                    if (itemPresent) {
	                        return this.dataSource.at(index - this.dataOffset);
	                    } else {
	                        this.trigger('endreached', { index: index });
	                        return null;
	                    }
	                }
	            },
	            indexOf: function (item) {
	                return this.dataSource.data().indexOf(item) + this.dataOffset;
	            },
	            total: function () {
	                return parseInt(this.dataSource.total(), 10);
	            },
	            next: function () {
	                var buffer = this, pageSize = buffer.pageSize, offset = buffer.skip - buffer.viewSize + pageSize, pageSkip = math.max(math.floor(offset / pageSize), 0) * pageSize;
	                this.offset = offset;
	                this.dataSource.prefetch(pageSkip, pageSize, function () {
	                    buffer._goToRange(offset, true);
	                });
	            },
	            range: function (offset, nextRange) {
	                if (this.offset === offset) {
	                    return true;
	                }
	                var buffer = this, pageSize = this.pageSize, pageSkip = math.max(math.floor(offset / pageSize), 0) * pageSize, dataSource = this.dataSource;
	                if (nextRange) {
	                    pageSkip += pageSize;
	                }
	                if (dataSource.inRange(offset, pageSize)) {
	                    this.offset = offset;
	                    this._recalculate();
	                    this._goToRange(offset);
	                    return true;
	                } else if (this.prefetch) {
	                    dataSource.prefetch(pageSkip, pageSize, function () {
	                        buffer.offset = offset;
	                        buffer._recalculate();
	                        buffer._goToRange(offset, true);
	                    });
	                    return false;
	                }
	                return true;
	            },
	            syncDataSource: function () {
	                var offset = this.offset;
	                this.offset = null;
	                this.range(offset);
	            },
	            destroy: function () {
	                this.unbind();
	            },
	            _prefetch: function () {
	                var buffer = this, pageSize = this.pageSize, prefetchOffset = this.skip + pageSize, dataSource = this.dataSource;
	                if (!dataSource.inRange(prefetchOffset, pageSize) && !this._prefetching && this.prefetch) {
	                    this._prefetching = true;
	                    this.trigger('prefetching', {
	                        skip: prefetchOffset,
	                        take: pageSize
	                    });
	                    dataSource.prefetch(prefetchOffset, pageSize, function () {
	                        buffer._prefetching = false;
	                        buffer.trigger('prefetched', {
	                            skip: prefetchOffset,
	                            take: pageSize
	                        });
	                    });
	                }
	            },
	            _goToRange: function (offset, expanding) {
	                if (this.offset !== offset) {
	                    return;
	                }
	                this.dataOffset = offset;
	                this._expanding = expanding;
	                this.dataSource.range(offset, this.pageSize);
	                this.dataSource.enableRequestsInProgress();
	            },
	            _reset: function () {
	                this._syncPending = true;
	            },
	            _change: function () {
	                var dataSource = this.dataSource;
	                this.length = this.useRanges ? dataSource.lastRange().end : dataSource.view().length;
	                if (this._syncPending) {
	                    this._syncWithDataSource();
	                    this._recalculate();
	                    this._syncPending = false;
	                    this.trigger('reset', { offset: this.offset });
	                }
	                this.trigger('resize');
	                if (this._expanding) {
	                    this.trigger('expand');
	                }
	                delete this._expanding;
	            },
	            _syncWithDataSource: function () {
	                var dataSource = this.dataSource;
	                this._firstItemUid = dataSource.firstItemUid();
	                this.dataOffset = this.offset = dataSource.skip() || 0;
	                this.pageSize = dataSource.pageSize();
	                this.useRanges = dataSource.options.serverPaging;
	            },
	            _recalculate: function () {
	                var pageSize = this.pageSize, offset = this.offset, viewSize = this.viewSize, skip = Math.ceil(offset / pageSize) * pageSize;
	                this.skip = skip;
	                this.midPageThreshold = skip + pageSize - 1;
	                this.nextPageThreshold = skip + viewSize - 1;
	                this.prefetchThreshold = skip + Math.floor(pageSize / 3 * 2);
	                this.pullBackThreshold = this.offset - 1;
	                this.nextMidRange = skip + pageSize - viewSize;
	                this.nextFullRange = skip;
	                this.previousMidRange = offset - viewSize;
	                this.previousFullRange = skip - pageSize;
	            }
	        });
	        var BatchBuffer = kendo.Observable.extend({
	            init: function (dataSource, batchSize) {
	                var batchBuffer = this;
	                kendo.Observable.fn.init.call(batchBuffer);
	                this.dataSource = dataSource;
	                this.batchSize = batchSize;
	                this._total = 0;
	                this.buffer = new Buffer(dataSource, batchSize * 3);
	                this.buffer.bind({
	                    'endreached': function (e) {
	                        batchBuffer.trigger('endreached', { index: e.index });
	                    },
	                    'prefetching': function (e) {
	                        batchBuffer.trigger('prefetching', {
	                            skip: e.skip,
	                            take: e.take
	                        });
	                    },
	                    'prefetched': function (e) {
	                        batchBuffer.trigger('prefetched', {
	                            skip: e.skip,
	                            take: e.take
	                        });
	                    },
	                    'reset': function () {
	                        batchBuffer._total = 0;
	                        batchBuffer.trigger('reset');
	                    },
	                    'resize': function () {
	                        batchBuffer._total = Math.ceil(this.length / batchBuffer.batchSize);
	                        batchBuffer.trigger('resize', {
	                            total: batchBuffer.total(),
	                            offset: this.offset
	                        });
	                    }
	                });
	            },
	            syncDataSource: function () {
	                this.buffer.syncDataSource();
	            },
	            at: function (index) {
	                var buffer = this.buffer, skip = index * this.batchSize, take = this.batchSize, view = [], item;
	                if (buffer.offset > skip) {
	                    buffer.at(buffer.offset - 1);
	                }
	                for (var i = 0; i < take; i++) {
	                    item = buffer.at(skip + i);
	                    if (item === null) {
	                        break;
	                    }
	                    view.push(item);
	                }
	                return view;
	            },
	            total: function () {
	                return this._total;
	            },
	            destroy: function () {
	                this.buffer.destroy();
	                this.unbind();
	            }
	        });
	        extend(true, kendo.data, {
	            readers: { json: DataReader },
	            Query: Query,
	            DataSource: DataSource,
	            HierarchicalDataSource: HierarchicalDataSource,
	            Node: Node,
	            ObservableObject: ObservableObject,
	            ObservableArray: ObservableArray,
	            LazyObservableArray: LazyObservableArray,
	            LocalTransport: LocalTransport,
	            RemoteTransport: RemoteTransport,
	            Cache: Cache,
	            DataReader: DataReader,
	            Model: Model,
	            Buffer: Buffer,
	            BatchBuffer: BatchBuffer
	        });
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(202)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'data.odata',
	        name: 'OData',
	        category: 'framework',
	        depends: ['core'],
	        hidden: true
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, extend = $.extend, odataFilters = {
	                eq: 'eq',
	                neq: 'ne',
	                gt: 'gt',
	                gte: 'ge',
	                lt: 'lt',
	                lte: 'le',
	                contains: 'substringof',
	                doesnotcontain: 'substringof',
	                endswith: 'endswith',
	                startswith: 'startswith',
	                isnull: 'eq',
	                isnotnull: 'ne',
	                isempty: 'eq',
	                isnotempty: 'ne'
	            }, odataFiltersVersionFour = extend({}, odataFilters, { contains: 'contains' }), mappers = {
	                pageSize: $.noop,
	                page: $.noop,
	                filter: function (params, filter, useVersionFour) {
	                    if (filter) {
	                        filter = toOdataFilter(filter, useVersionFour);
	                        if (filter) {
	                            params.$filter = filter;
	                        }
	                    }
	                },
	                sort: function (params, orderby) {
	                    var expr = $.map(orderby, function (value) {
	                        var order = value.field.replace(/\./g, '/');
	                        if (value.dir === 'desc') {
	                            order += ' desc';
	                        }
	                        return order;
	                    }).join(',');
	                    if (expr) {
	                        params.$orderby = expr;
	                    }
	                },
	                skip: function (params, skip) {
	                    if (skip) {
	                        params.$skip = skip;
	                    }
	                },
	                take: function (params, take) {
	                    if (take) {
	                        params.$top = take;
	                    }
	                }
	            }, defaultDataType = { read: { dataType: 'jsonp' } };
	        function toOdataFilter(filter, useOdataFour) {
	            var result = [], logic = filter.logic || 'and', idx, length, field, type, format, operator, value, ignoreCase, filters = filter.filters;
	            for (idx = 0, length = filters.length; idx < length; idx++) {
	                filter = filters[idx];
	                field = filter.field;
	                value = filter.value;
	                operator = filter.operator;
	                if (filter.filters) {
	                    filter = toOdataFilter(filter, useOdataFour);
	                } else {
	                    ignoreCase = filter.ignoreCase;
	                    field = field.replace(/\./g, '/');
	                    filter = odataFilters[operator];
	                    if (useOdataFour) {
	                        filter = odataFiltersVersionFour[operator];
	                    }
	                    if (operator === 'isnull' || operator === 'isnotnull') {
	                        filter = kendo.format('{0} {1} null', field, filter);
	                    } else if (operator === 'isempty' || operator === 'isnotempty') {
	                        filter = kendo.format('{0} {1} \'\'', field, filter);
	                    } else if (filter && value !== undefined) {
	                        type = $.type(value);
	                        if (type === 'string') {
	                            format = '\'{1}\'';
	                            value = value.replace(/'/g, '\'\'');
	                            if (ignoreCase === true) {
	                                field = 'tolower(' + field + ')';
	                            }
	                        } else if (type === 'date') {
	                            if (useOdataFour) {
	                                format = '{1:yyyy-MM-ddTHH:mm:ss+00:00}';
	                                value = kendo.timezone.apply(value, 'Etc/UTC');
	                            } else {
	                                format = 'datetime\'{1:yyyy-MM-ddTHH:mm:ss}\'';
	                            }
	                        } else {
	                            format = '{1}';
	                        }
	                        if (filter.length > 3) {
	                            if (filter !== 'substringof') {
	                                format = '{0}({2},' + format + ')';
	                            } else {
	                                format = '{0}(' + format + ',{2})';
	                                if (operator === 'doesnotcontain') {
	                                    if (useOdataFour) {
	                                        format = '{0}({2},\'{1}\') eq -1';
	                                        filter = 'indexof';
	                                    } else {
	                                        format += ' eq false';
	                                    }
	                                }
	                            }
	                        } else {
	                            format = '{2} {0} ' + format;
	                        }
	                        filter = kendo.format(format, filter, value, field);
	                    }
	                }
	                result.push(filter);
	            }
	            filter = result.join(' ' + logic + ' ');
	            if (result.length > 1) {
	                filter = '(' + filter + ')';
	            }
	            return filter;
	        }
	        function stripMetadata(obj) {
	            for (var name in obj) {
	                if (name.indexOf('@odata') === 0) {
	                    delete obj[name];
	                }
	            }
	        }
	        extend(true, kendo.data, {
	            schemas: {
	                odata: {
	                    type: 'json',
	                    data: function (data) {
	                        return data.d.results || [data.d];
	                    },
	                    total: 'd.__count'
	                }
	            },
	            transports: {
	                odata: {
	                    read: {
	                        cache: true,
	                        dataType: 'jsonp',
	                        jsonp: '$callback'
	                    },
	                    update: {
	                        cache: true,
	                        dataType: 'json',
	                        contentType: 'application/json',
	                        type: 'PUT'
	                    },
	                    create: {
	                        cache: true,
	                        dataType: 'json',
	                        contentType: 'application/json',
	                        type: 'POST'
	                    },
	                    destroy: {
	                        cache: true,
	                        dataType: 'json',
	                        type: 'DELETE'
	                    },
	                    parameterMap: function (options, type, useVersionFour) {
	                        var params, value, option, dataType;
	                        options = options || {};
	                        type = type || 'read';
	                        dataType = (this.options || defaultDataType)[type];
	                        dataType = dataType ? dataType.dataType : 'json';
	                        if (type === 'read') {
	                            params = { $inlinecount: 'allpages' };
	                            if (dataType != 'json') {
	                                params.$format = 'json';
	                            }
	                            for (option in options) {
	                                if (mappers[option]) {
	                                    mappers[option](params, options[option], useVersionFour);
	                                } else {
	                                    params[option] = options[option];
	                                }
	                            }
	                        } else {
	                            if (dataType !== 'json') {
	                                throw new Error('Only json dataType can be used for ' + type + ' operation.');
	                            }
	                            if (type !== 'destroy') {
	                                for (option in options) {
	                                    value = options[option];
	                                    if (typeof value === 'number') {
	                                        options[option] = value + '';
	                                    }
	                                }
	                                params = kendo.stringify(options);
	                            }
	                        }
	                        return params;
	                    }
	                }
	            }
	        });
	        extend(true, kendo.data, {
	            schemas: {
	                'odata-v4': {
	                    type: 'json',
	                    data: function (data) {
	                        data = $.extend({}, data);
	                        stripMetadata(data);
	                        if (data.value) {
	                            return data.value;
	                        }
	                        return [data];
	                    },
	                    total: function (data) {
	                        return data['@odata.count'];
	                    }
	                }
	            },
	            transports: {
	                'odata-v4': {
	                    read: {
	                        cache: true,
	                        dataType: 'json'
	                    },
	                    update: {
	                        cache: true,
	                        dataType: 'json',
	                        contentType: 'application/json;IEEE754Compatible=true',
	                        type: 'PUT'
	                    },
	                    create: {
	                        cache: true,
	                        dataType: 'json',
	                        contentType: 'application/json;IEEE754Compatible=true',
	                        type: 'POST'
	                    },
	                    destroy: {
	                        cache: true,
	                        dataType: 'json',
	                        type: 'DELETE'
	                    },
	                    parameterMap: function (options, type) {
	                        var result = kendo.data.transports.odata.parameterMap(options, type, true);
	                        if (type == 'read') {
	                            result.$count = true;
	                            delete result.$inlinecount;
	                        }
	                        return result;
	                    }
	                }
	            }
	        });
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(202)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'data.xml',
	        name: 'XML',
	        category: 'framework',
	        depends: ['core'],
	        hidden: true
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, isArray = $.isArray, isPlainObject = $.isPlainObject, map = $.map, each = $.each, extend = $.extend, getter = kendo.getter, Class = kendo.Class;
	        var XmlDataReader = Class.extend({
	            init: function (options) {
	                var that = this, total = options.total, model = options.model, parse = options.parse, errors = options.errors, serialize = options.serialize, data = options.data;
	                if (model) {
	                    if (isPlainObject(model)) {
	                        var base = options.modelBase || kendo.data.Model;
	                        if (model.fields) {
	                            each(model.fields, function (field, value) {
	                                if (isPlainObject(value) && value.field) {
	                                    if (!$.isFunction(value.field)) {
	                                        value = extend(value, { field: that.getter(value.field) });
	                                    }
	                                } else {
	                                    value = { field: that.getter(value) };
	                                }
	                                model.fields[field] = value;
	                            });
	                        }
	                        var id = model.id;
	                        if (id) {
	                            var idField = {};
	                            idField[that.xpathToMember(id, true)] = { field: that.getter(id) };
	                            model.fields = extend(idField, model.fields);
	                            model.id = that.xpathToMember(id);
	                        }
	                        model = base.define(model);
	                    }
	                    that.model = model;
	                }
	                if (total) {
	                    if (typeof total == 'string') {
	                        total = that.getter(total);
	                        that.total = function (data) {
	                            return parseInt(total(data), 10);
	                        };
	                    } else if (typeof total == 'function') {
	                        that.total = total;
	                    }
	                }
	                if (errors) {
	                    if (typeof errors == 'string') {
	                        errors = that.getter(errors);
	                        that.errors = function (data) {
	                            return errors(data) || null;
	                        };
	                    } else if (typeof errors == 'function') {
	                        that.errors = errors;
	                    }
	                }
	                if (data) {
	                    if (typeof data == 'string') {
	                        data = that.xpathToMember(data);
	                        that.data = function (value) {
	                            var result = that.evaluate(value, data), modelInstance;
	                            result = isArray(result) ? result : [result];
	                            if (that.model && model.fields) {
	                                modelInstance = new that.model();
	                                return map(result, function (value) {
	                                    if (value) {
	                                        var record = {}, field;
	                                        for (field in model.fields) {
	                                            record[field] = modelInstance._parse(field, model.fields[field].field(value));
	                                        }
	                                        return record;
	                                    }
	                                });
	                            }
	                            return result;
	                        };
	                    } else if (typeof data == 'function') {
	                        that.data = data;
	                    }
	                }
	                if (typeof parse == 'function') {
	                    var xmlParse = that.parse;
	                    that.parse = function (data) {
	                        var xml = parse.call(that, data);
	                        return xmlParse.call(that, xml);
	                    };
	                }
	                if (typeof serialize == 'function') {
	                    that.serialize = serialize;
	                }
	            },
	            total: function (result) {
	                return this.data(result).length;
	            },
	            errors: function (data) {
	                return data ? data.errors : null;
	            },
	            serialize: function (data) {
	                return data;
	            },
	            parseDOM: function (element) {
	                var result = {}, parsedNode, node, nodeType, nodeName, member, attribute, attributes = element.attributes, attributeCount = attributes.length, idx;
	                for (idx = 0; idx < attributeCount; idx++) {
	                    attribute = attributes[idx];
	                    result['@' + attribute.nodeName] = attribute.nodeValue;
	                }
	                for (node = element.firstChild; node; node = node.nextSibling) {
	                    nodeType = node.nodeType;
	                    if (nodeType === 3 || nodeType === 4) {
	                        result['#text'] = node.nodeValue;
	                    } else if (nodeType === 1) {
	                        parsedNode = this.parseDOM(node);
	                        nodeName = node.nodeName;
	                        member = result[nodeName];
	                        if (isArray(member)) {
	                            member.push(parsedNode);
	                        } else if (member !== undefined) {
	                            member = [
	                                member,
	                                parsedNode
	                            ];
	                        } else {
	                            member = parsedNode;
	                        }
	                        result[nodeName] = member;
	                    }
	                }
	                return result;
	            },
	            evaluate: function (value, expression) {
	                var members = expression.split('.'), member, result, length, intermediateResult, idx;
	                while (member = members.shift()) {
	                    value = value[member];
	                    if (isArray(value)) {
	                        result = [];
	                        expression = members.join('.');
	                        for (idx = 0, length = value.length; idx < length; idx++) {
	                            intermediateResult = this.evaluate(value[idx], expression);
	                            intermediateResult = isArray(intermediateResult) ? intermediateResult : [intermediateResult];
	                            result.push.apply(result, intermediateResult);
	                        }
	                        return result;
	                    }
	                }
	                return value;
	            },
	            parse: function (xml) {
	                var documentElement, tree, result = {};
	                documentElement = xml.documentElement || $.parseXML(xml).documentElement;
	                tree = this.parseDOM(documentElement);
	                result[documentElement.nodeName] = tree;
	                return result;
	            },
	            xpathToMember: function (member, raw) {
	                if (!member) {
	                    return '';
	                }
	                member = member.replace(/^\//, '').replace(/\//g, '.');
	                if (member.indexOf('@') >= 0) {
	                    return member.replace(/\.?(@.*)/, raw ? '$1' : '["$1"]');
	                }
	                if (member.indexOf('text()') >= 0) {
	                    return member.replace(/(\.?text\(\))/, raw ? '#text' : '["#text"]');
	                }
	                return member;
	            },
	            getter: function (member) {
	                return getter(this.xpathToMember(member), true);
	            }
	        });
	        $.extend(true, kendo.data, {
	            XmlDataReader: XmlDataReader,
	            readers: { xml: XmlDataReader }
	        });
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(202),
	        __webpack_require__(204)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'binder',
	        name: 'MVVM',
	        category: 'framework',
	        description: 'Model View ViewModel (MVVM) is a design pattern which helps developers separate the Model (the data) from the View (the UI).',
	        depends: [
	            'core',
	            'data'
	        ]
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, Observable = kendo.Observable, ObservableObject = kendo.data.ObservableObject, ObservableArray = kendo.data.ObservableArray, toString = {}.toString, binders = {}, Class = kendo.Class, proxy = $.proxy, VALUE = 'value', SOURCE = 'source', EVENTS = 'events', CHECKED = 'checked', CSS = 'css', deleteExpando = true, FUNCTION = 'function', CHANGE = 'change';
	        (function () {
	            var a = document.createElement('a');
	            try {
	                delete a.test;
	            } catch (e) {
	                deleteExpando = false;
	            }
	        }());
	        var Binding = Observable.extend({
	            init: function (parents, path) {
	                var that = this;
	                Observable.fn.init.call(that);
	                that.source = parents[0];
	                that.parents = parents;
	                that.path = path;
	                that.dependencies = {};
	                that.dependencies[path] = true;
	                that.observable = that.source instanceof Observable;
	                that._access = function (e) {
	                    that.dependencies[e.field] = true;
	                };
	                if (that.observable) {
	                    that._change = function (e) {
	                        that.change(e);
	                    };
	                    that.source.bind(CHANGE, that._change);
	                }
	            },
	            _parents: function () {
	                var parents = this.parents;
	                var value = this.get();
	                if (value && typeof value.parent == 'function') {
	                    var parent = value.parent();
	                    if ($.inArray(parent, parents) < 0) {
	                        parents = [parent].concat(parents);
	                    }
	                }
	                return parents;
	            },
	            change: function (e) {
	                var dependency, ch, field = e.field, that = this;
	                if (that.path === 'this') {
	                    that.trigger(CHANGE, e);
	                } else {
	                    for (dependency in that.dependencies) {
	                        if (dependency.indexOf(field) === 0) {
	                            ch = dependency.charAt(field.length);
	                            if (!ch || ch === '.' || ch === '[') {
	                                that.trigger(CHANGE, e);
	                                break;
	                            }
	                        }
	                    }
	                }
	            },
	            start: function (source) {
	                source.bind('get', this._access);
	            },
	            stop: function (source) {
	                source.unbind('get', this._access);
	            },
	            get: function () {
	                var that = this, source = that.source, index = 0, path = that.path, result = source;
	                if (!that.observable) {
	                    return result;
	                }
	                that.start(that.source);
	                result = source.get(path);
	                while (result === undefined && source) {
	                    source = that.parents[++index];
	                    if (source instanceof ObservableObject) {
	                        result = source.get(path);
	                    }
	                }
	                if (result === undefined) {
	                    source = that.source;
	                    while (result === undefined && source) {
	                        source = source.parent();
	                        if (source instanceof ObservableObject) {
	                            result = source.get(path);
	                        }
	                    }
	                }
	                if (typeof result === 'function') {
	                    index = path.lastIndexOf('.');
	                    if (index > 0) {
	                        source = source.get(path.substring(0, index));
	                    }
	                    that.start(source);
	                    if (source !== that.source) {
	                        result = result.call(source, that.source);
	                    } else {
	                        result = result.call(source);
	                    }
	                    that.stop(source);
	                }
	                if (source && source !== that.source) {
	                    that.currentSource = source;
	                    source.unbind(CHANGE, that._change).bind(CHANGE, that._change);
	                }
	                that.stop(that.source);
	                return result;
	            },
	            set: function (value) {
	                var source = this.currentSource || this.source;
	                var field = kendo.getter(this.path)(source);
	                if (typeof field === 'function') {
	                    if (source !== this.source) {
	                        field.call(source, this.source, value);
	                    } else {
	                        field.call(source, value);
	                    }
	                } else {
	                    source.set(this.path, value);
	                }
	            },
	            destroy: function () {
	                if (this.observable) {
	                    this.source.unbind(CHANGE, this._change);
	                    if (this.currentSource) {
	                        this.currentSource.unbind(CHANGE, this._change);
	                    }
	                }
	                this.unbind();
	            }
	        });
	        var EventBinding = Binding.extend({
	            get: function () {
	                var source = this.source, path = this.path, index = 0, handler;
	                handler = source.get(path);
	                while (!handler && source) {
	                    source = this.parents[++index];
	                    if (source instanceof ObservableObject) {
	                        handler = source.get(path);
	                    }
	                }
	                return proxy(handler, source);
	            }
	        });
	        var TemplateBinding = Binding.extend({
	            init: function (source, path, template) {
	                var that = this;
	                Binding.fn.init.call(that, source, path);
	                that.template = template;
	            },
	            render: function (value) {
	                var html;
	                this.start(this.source);
	                html = kendo.render(this.template, value);
	                this.stop(this.source);
	                return html;
	            }
	        });
	        var Binder = Class.extend({
	            init: function (element, bindings, options) {
	                this.element = element;
	                this.bindings = bindings;
	                this.options = options;
	            },
	            bind: function (binding, attribute) {
	                var that = this;
	                binding = attribute ? binding[attribute] : binding;
	                binding.bind(CHANGE, function (e) {
	                    that.refresh(attribute || e);
	                });
	                that.refresh(attribute);
	            },
	            destroy: function () {
	            }
	        });
	        var TypedBinder = Binder.extend({
	            dataType: function () {
	                var dataType = this.element.getAttribute('data-type') || this.element.type || 'text';
	                return dataType.toLowerCase();
	            },
	            parsedValue: function () {
	                return this._parseValue(this.element.value, this.dataType());
	            },
	            _parseValue: function (value, dataType) {
	                if (dataType == 'date') {
	                    value = kendo.parseDate(value, 'yyyy-MM-dd');
	                } else if (dataType == 'datetime-local') {
	                    value = kendo.parseDate(value, [
	                        'yyyy-MM-ddTHH:mm:ss',
	                        'yyyy-MM-ddTHH:mm'
	                    ]);
	                } else if (dataType == 'number') {
	                    value = kendo.parseFloat(value);
	                } else if (dataType == 'boolean') {
	                    value = value.toLowerCase();
	                    if (kendo.parseFloat(value) !== null) {
	                        value = Boolean(kendo.parseFloat(value));
	                    } else {
	                        value = value.toLowerCase() === 'true';
	                    }
	                }
	                return value;
	            }
	        });
	        binders.attr = Binder.extend({
	            refresh: function (key) {
	                this.element.setAttribute(key, this.bindings.attr[key].get());
	            }
	        });
	        binders.css = Binder.extend({
	            init: function (element, bindings, options) {
	                Binder.fn.init.call(this, element, bindings, options);
	                this.classes = {};
	            },
	            refresh: function (className) {
	                var element = $(this.element), binding = this.bindings.css[className], hasClass = this.classes[className] = binding.get();
	                if (hasClass) {
	                    element.addClass(className);
	                } else {
	                    element.removeClass(className);
	                }
	            }
	        });
	        binders.style = Binder.extend({
	            refresh: function (key) {
	                this.element.style[key] = this.bindings.style[key].get() || '';
	            }
	        });
	        binders.enabled = Binder.extend({
	            refresh: function () {
	                if (this.bindings.enabled.get()) {
	                    this.element.removeAttribute('disabled');
	                } else {
	                    this.element.setAttribute('disabled', 'disabled');
	                }
	            }
	        });
	        binders.readonly = Binder.extend({
	            refresh: function () {
	                if (this.bindings.readonly.get()) {
	                    this.element.setAttribute('readonly', 'readonly');
	                } else {
	                    this.element.removeAttribute('readonly');
	                }
	            }
	        });
	        binders.disabled = Binder.extend({
	            refresh: function () {
	                if (this.bindings.disabled.get()) {
	                    this.element.setAttribute('disabled', 'disabled');
	                } else {
	                    this.element.removeAttribute('disabled');
	                }
	            }
	        });
	        binders.events = Binder.extend({
	            init: function (element, bindings, options) {
	                Binder.fn.init.call(this, element, bindings, options);
	                this.handlers = {};
	            },
	            refresh: function (key) {
	                var element = $(this.element), binding = this.bindings.events[key], handler = this.handlers[key];
	                if (handler) {
	                    element.off(key, handler);
	                }
	                handler = this.handlers[key] = binding.get();
	                element.on(key, binding.source, handler);
	            },
	            destroy: function () {
	                var element = $(this.element), handler;
	                for (handler in this.handlers) {
	                    element.off(handler, this.handlers[handler]);
	                }
	            }
	        });
	        binders.text = Binder.extend({
	            refresh: function () {
	                var text = this.bindings.text.get();
	                var dataFormat = this.element.getAttribute('data-format') || '';
	                if (text == null) {
	                    text = '';
	                }
	                $(this.element).text(kendo.toString(text, dataFormat));
	            }
	        });
	        binders.visible = Binder.extend({
	            refresh: function () {
	                if (this.bindings.visible.get()) {
	                    this.element.style.display = '';
	                } else {
	                    this.element.style.display = 'none';
	                }
	            }
	        });
	        binders.invisible = Binder.extend({
	            refresh: function () {
	                if (!this.bindings.invisible.get()) {
	                    this.element.style.display = '';
	                } else {
	                    this.element.style.display = 'none';
	                }
	            }
	        });
	        binders.html = Binder.extend({
	            refresh: function () {
	                this.element.innerHTML = this.bindings.html.get();
	            }
	        });
	        binders.value = TypedBinder.extend({
	            init: function (element, bindings, options) {
	                TypedBinder.fn.init.call(this, element, bindings, options);
	                this._change = proxy(this.change, this);
	                this.eventName = options.valueUpdate || CHANGE;
	                $(this.element).on(this.eventName, this._change);
	                this._initChange = false;
	            },
	            change: function () {
	                this._initChange = this.eventName != CHANGE;
	                this.bindings[VALUE].set(this.parsedValue());
	                this._initChange = false;
	            },
	            refresh: function () {
	                if (!this._initChange) {
	                    var value = this.bindings[VALUE].get();
	                    if (value == null) {
	                        value = '';
	                    }
	                    var type = this.dataType();
	                    if (type == 'date') {
	                        value = kendo.toString(value, 'yyyy-MM-dd');
	                    } else if (type == 'datetime-local') {
	                        value = kendo.toString(value, 'yyyy-MM-ddTHH:mm:ss');
	                    }
	                    this.element.value = value;
	                }
	                this._initChange = false;
	            },
	            destroy: function () {
	                $(this.element).off(this.eventName, this._change);
	            }
	        });
	        binders.source = Binder.extend({
	            init: function (element, bindings, options) {
	                Binder.fn.init.call(this, element, bindings, options);
	                var source = this.bindings.source.get();
	                if (source instanceof kendo.data.DataSource && options.autoBind !== false) {
	                    source.fetch();
	                }
	            },
	            refresh: function (e) {
	                var that = this, source = that.bindings.source.get();
	                if (source instanceof ObservableArray || source instanceof kendo.data.DataSource) {
	                    e = e || {};
	                    if (e.action == 'add') {
	                        that.add(e.index, e.items);
	                    } else if (e.action == 'remove') {
	                        that.remove(e.index, e.items);
	                    } else if (e.action != 'itemchange') {
	                        that.render();
	                    }
	                } else {
	                    that.render();
	                }
	            },
	            container: function () {
	                var element = this.element;
	                if (element.nodeName.toLowerCase() == 'table') {
	                    if (!element.tBodies[0]) {
	                        element.appendChild(document.createElement('tbody'));
	                    }
	                    element = element.tBodies[0];
	                }
	                return element;
	            },
	            template: function () {
	                var options = this.options, template = options.template, nodeName = this.container().nodeName.toLowerCase();
	                if (!template) {
	                    if (nodeName == 'select') {
	                        if (options.valueField || options.textField) {
	                            template = kendo.format('<option value="#:{0}#">#:{1}#</option>', options.valueField || options.textField, options.textField || options.valueField);
	                        } else {
	                            template = '<option>#:data#</option>';
	                        }
	                    } else if (nodeName == 'tbody') {
	                        template = '<tr><td>#:data#</td></tr>';
	                    } else if (nodeName == 'ul' || nodeName == 'ol') {
	                        template = '<li>#:data#</li>';
	                    } else {
	                        template = '#:data#';
	                    }
	                    template = kendo.template(template);
	                }
	                return template;
	            },
	            add: function (index, items) {
	                var element = this.container(), parents, idx, length, child, clone = element.cloneNode(false), reference = element.children[index];
	                $(clone).html(kendo.render(this.template(), items));
	                if (clone.children.length) {
	                    parents = this.bindings.source._parents();
	                    for (idx = 0, length = items.length; idx < length; idx++) {
	                        child = clone.children[0];
	                        element.insertBefore(child, reference || null);
	                        bindElement(child, items[idx], this.options.roles, [items[idx]].concat(parents));
	                    }
	                }
	            },
	            remove: function (index, items) {
	                var idx, element = this.container();
	                for (idx = 0; idx < items.length; idx++) {
	                    var child = element.children[index];
	                    unbindElementTree(child, true);
	                    if (child.parentNode == element) {
	                        element.removeChild(child);
	                    }
	                }
	            },
	            render: function () {
	                var source = this.bindings.source.get(), parents, idx, length, element = this.container(), template = this.template();
	                if (source == null) {
	                    return;
	                }
	                if (source instanceof kendo.data.DataSource) {
	                    source = source.view();
	                }
	                if (!(source instanceof ObservableArray) && toString.call(source) !== '[object Array]') {
	                    source = [source];
	                }
	                if (this.bindings.template) {
	                    unbindElementChildren(element, true);
	                    $(element).html(this.bindings.template.render(source));
	                    if (element.children.length) {
	                        parents = this.bindings.source._parents();
	                        for (idx = 0, length = source.length; idx < length; idx++) {
	                            bindElement(element.children[idx], source[idx], this.options.roles, [source[idx]].concat(parents));
	                        }
	                    }
	                } else {
	                    $(element).html(kendo.render(template, source));
	                }
	            }
	        });
	        binders.input = {
	            checked: TypedBinder.extend({
	                init: function (element, bindings, options) {
	                    TypedBinder.fn.init.call(this, element, bindings, options);
	                    this._change = proxy(this.change, this);
	                    $(this.element).change(this._change);
	                },
	                change: function () {
	                    var element = this.element;
	                    var value = this.value();
	                    if (element.type == 'radio') {
	                        value = this.parsedValue();
	                        this.bindings[CHECKED].set(value);
	                    } else if (element.type == 'checkbox') {
	                        var source = this.bindings[CHECKED].get();
	                        var index;
	                        if (source instanceof ObservableArray) {
	                            value = this.parsedValue();
	                            if (value instanceof Date) {
	                                for (var i = 0; i < source.length; i++) {
	                                    if (source[i] instanceof Date && +source[i] === +value) {
	                                        index = i;
	                                        break;
	                                    }
	                                }
	                            } else {
	                                index = source.indexOf(value);
	                            }
	                            if (index > -1) {
	                                source.splice(index, 1);
	                            } else {
	                                source.push(value);
	                            }
	                        } else {
	                            this.bindings[CHECKED].set(value);
	                        }
	                    }
	                },
	                refresh: function () {
	                    var value = this.bindings[CHECKED].get(), source = value, type = this.dataType(), element = this.element;
	                    if (element.type == 'checkbox') {
	                        if (source instanceof ObservableArray) {
	                            var index = -1;
	                            value = this.parsedValue();
	                            if (value instanceof Date) {
	                                for (var i = 0; i < source.length; i++) {
	                                    if (source[i] instanceof Date && +source[i] === +value) {
	                                        index = i;
	                                        break;
	                                    }
	                                }
	                            } else {
	                                index = source.indexOf(value);
	                            }
	                            element.checked = index >= 0;
	                        } else {
	                            element.checked = source;
	                        }
	                    } else if (element.type == 'radio' && value != null) {
	                        if (type == 'date') {
	                            value = kendo.toString(value, 'yyyy-MM-dd');
	                        } else if (type == 'datetime-local') {
	                            value = kendo.toString(value, 'yyyy-MM-ddTHH:mm:ss');
	                        }
	                        if (element.value === value.toString()) {
	                            element.checked = true;
	                        } else {
	                            element.checked = false;
	                        }
	                    }
	                },
	                value: function () {
	                    var element = this.element, value = element.value;
	                    if (element.type == 'checkbox') {
	                        value = element.checked;
	                    }
	                    return value;
	                },
	                destroy: function () {
	                    $(this.element).off(CHANGE, this._change);
	                }
	            })
	        };
	        binders.select = {
	            source: binders.source.extend({
	                refresh: function (e) {
	                    var that = this, source = that.bindings.source.get();
	                    if (source instanceof ObservableArray || source instanceof kendo.data.DataSource) {
	                        e = e || {};
	                        if (e.action == 'add') {
	                            that.add(e.index, e.items);
	                        } else if (e.action == 'remove') {
	                            that.remove(e.index, e.items);
	                        } else if (e.action == 'itemchange' || e.action === undefined) {
	                            that.render();
	                            if (that.bindings.value) {
	                                if (that.bindings.value) {
	                                    var val = retrievePrimitiveValues(that.bindings.value.get(), $(that.element).data('valueField'));
	                                    if (val === null) {
	                                        that.element.selectedIndex = -1;
	                                    } else {
	                                        that.element.value = val;
	                                    }
	                                }
	                            }
	                        }
	                    } else {
	                        that.render();
	                    }
	                }
	            }),
	            value: TypedBinder.extend({
	                init: function (target, bindings, options) {
	                    TypedBinder.fn.init.call(this, target, bindings, options);
	                    this._change = proxy(this.change, this);
	                    $(this.element).change(this._change);
	                },
	                parsedValue: function () {
	                    var dataType = this.dataType();
	                    var values = [];
	                    var value, option, idx, length;
	                    for (idx = 0, length = this.element.options.length; idx < length; idx++) {
	                        option = this.element.options[idx];
	                        if (option.selected) {
	                            value = option.attributes.value;
	                            if (value && value.specified) {
	                                value = option.value;
	                            } else {
	                                value = option.text;
	                            }
	                            values.push(this._parseValue(value, dataType));
	                        }
	                    }
	                    return values;
	                },
	                change: function () {
	                    var values = [], element = this.element, source, field = this.options.valueField || this.options.textField, valuePrimitive = this.options.valuePrimitive, option, valueIndex, value, idx, length;
	                    for (idx = 0, length = element.options.length; idx < length; idx++) {
	                        option = element.options[idx];
	                        if (option.selected) {
	                            value = option.attributes.value;
	                            if (value && value.specified) {
	                                value = option.value;
	                            } else {
	                                value = option.text;
	                            }
	                            if (field) {
	                                values.push(value);
	                            } else {
	                                values.push(this._parseValue(value, this.dataType()));
	                            }
	                        }
	                    }
	                    if (field) {
	                        source = this.bindings.source.get();
	                        if (source instanceof kendo.data.DataSource) {
	                            source = source.view();
	                        }
	                        for (valueIndex = 0; valueIndex < values.length; valueIndex++) {
	                            for (idx = 0, length = source.length; idx < length; idx++) {
	                                var sourceValue = source[idx].get(field);
	                                var match = String(sourceValue) === values[valueIndex];
	                                if (match) {
	                                    values[valueIndex] = source[idx];
	                                    break;
	                                }
	                            }
	                        }
	                    }
	                    value = this.bindings[VALUE].get();
	                    if (value instanceof ObservableArray) {
	                        value.splice.apply(value, [
	                            0,
	                            value.length
	                        ].concat(values));
	                    } else if (!valuePrimitive && (value instanceof ObservableObject || value === null || value === undefined || !field)) {
	                        this.bindings[VALUE].set(values[0]);
	                    } else {
	                        this.bindings[VALUE].set(values[0].get(field));
	                    }
	                },
	                refresh: function () {
	                    var optionIndex, element = this.element, options = element.options, value = this.bindings[VALUE].get(), values = value, field = this.options.valueField || this.options.textField, found = false, type = this.dataType(), optionValue;
	                    if (!(values instanceof ObservableArray)) {
	                        values = new ObservableArray([value]);
	                    }
	                    element.selectedIndex = -1;
	                    for (var valueIndex = 0; valueIndex < values.length; valueIndex++) {
	                        value = values[valueIndex];
	                        if (field && value instanceof ObservableObject) {
	                            value = value.get(field);
	                        }
	                        if (type == 'date') {
	                            value = kendo.toString(values[valueIndex], 'yyyy-MM-dd');
	                        } else if (type == 'datetime-local') {
	                            value = kendo.toString(values[valueIndex], 'yyyy-MM-ddTHH:mm:ss');
	                        }
	                        for (optionIndex = 0; optionIndex < options.length; optionIndex++) {
	                            optionValue = options[optionIndex].value;
	                            if (optionValue === '' && value !== '') {
	                                optionValue = options[optionIndex].text;
	                            }
	                            if (value != null && optionValue == value.toString()) {
	                                options[optionIndex].selected = true;
	                                found = true;
	                            }
	                        }
	                    }
	                },
	                destroy: function () {
	                    $(this.element).off(CHANGE, this._change);
	                }
	            })
	        };
	        function dataSourceBinding(bindingName, fieldName, setter) {
	            return Binder.extend({
	                init: function (widget, bindings, options) {
	                    var that = this;
	                    Binder.fn.init.call(that, widget.element[0], bindings, options);
	                    that.widget = widget;
	                    that._dataBinding = proxy(that.dataBinding, that);
	                    that._dataBound = proxy(that.dataBound, that);
	                    that._itemChange = proxy(that.itemChange, that);
	                },
	                itemChange: function (e) {
	                    bindElement(e.item[0], e.data, this._ns(e.ns), [e.data].concat(this.bindings[bindingName]._parents()));
	                },
	                dataBinding: function (e) {
	                    var idx, length, widget = this.widget, items = e.removedItems || widget.items();
	                    for (idx = 0, length = items.length; idx < length; idx++) {
	                        unbindElementTree(items[idx], false);
	                    }
	                },
	                _ns: function (ns) {
	                    ns = ns || kendo.ui;
	                    var all = [
	                        kendo.ui,
	                        kendo.dataviz.ui,
	                        kendo.mobile.ui
	                    ];
	                    all.splice($.inArray(ns, all), 1);
	                    all.unshift(ns);
	                    return kendo.rolesFromNamespaces(all);
	                },
	                dataBound: function (e) {
	                    var idx, length, widget = this.widget, items = e.addedItems || widget.items(), dataSource = widget[fieldName], view, parents, hds = kendo.data.HierarchicalDataSource;
	                    if (hds && dataSource instanceof hds) {
	                        return;
	                    }
	                    if (items.length) {
	                        view = e.addedDataItems || dataSource.flatView();
	                        parents = this.bindings[bindingName]._parents();
	                        for (idx = 0, length = view.length; idx < length; idx++) {
	                            bindElement(items[idx], view[idx], this._ns(e.ns), [view[idx]].concat(parents));
	                        }
	                    }
	                },
	                refresh: function (e) {
	                    var that = this, source, widget = that.widget, select, multiselect;
	                    e = e || {};
	                    if (!e.action) {
	                        that.destroy();
	                        widget.bind('dataBinding', that._dataBinding);
	                        widget.bind('dataBound', that._dataBound);
	                        widget.bind('itemChange', that._itemChange);
	                        source = that.bindings[bindingName].get();
	                        if (widget[fieldName] instanceof kendo.data.DataSource && widget[fieldName] != source) {
	                            if (source instanceof kendo.data.DataSource) {
	                                widget[setter](source);
	                            } else if (source && source._dataSource) {
	                                widget[setter](source._dataSource);
	                            } else {
	                                widget[fieldName].data(source);
	                                select = kendo.ui.Select && widget instanceof kendo.ui.Select;
	                                multiselect = kendo.ui.MultiSelect && widget instanceof kendo.ui.MultiSelect;
	                                if (that.bindings.value && (select || multiselect)) {
	                                    widget.value(retrievePrimitiveValues(that.bindings.value.get(), widget.options.dataValueField));
	                                }
	                            }
	                        }
	                    }
	                },
	                destroy: function () {
	                    var widget = this.widget;
	                    widget.unbind('dataBinding', this._dataBinding);
	                    widget.unbind('dataBound', this._dataBound);
	                    widget.unbind('itemChange', this._itemChange);
	                }
	            });
	        }
	        binders.widget = {
	            events: Binder.extend({
	                init: function (widget, bindings, options) {
	                    Binder.fn.init.call(this, widget.element[0], bindings, options);
	                    this.widget = widget;
	                    this.handlers = {};
	                },
	                refresh: function (key) {
	                    var binding = this.bindings.events[key], handler = this.handlers[key];
	                    if (handler) {
	                        this.widget.unbind(key, handler);
	                    }
	                    handler = binding.get();
	                    this.handlers[key] = function (e) {
	                        e.data = binding.source;
	                        handler(e);
	                        if (e.data === binding.source) {
	                            delete e.data;
	                        }
	                    };
	                    this.widget.bind(key, this.handlers[key]);
	                },
	                destroy: function () {
	                    var handler;
	                    for (handler in this.handlers) {
	                        this.widget.unbind(handler, this.handlers[handler]);
	                    }
	                }
	            }),
	            checked: Binder.extend({
	                init: function (widget, bindings, options) {
	                    Binder.fn.init.call(this, widget.element[0], bindings, options);
	                    this.widget = widget;
	                    this._change = proxy(this.change, this);
	                    this.widget.bind(CHANGE, this._change);
	                },
	                change: function () {
	                    this.bindings[CHECKED].set(this.value());
	                },
	                refresh: function () {
	                    this.widget.check(this.bindings[CHECKED].get() === true);
	                },
	                value: function () {
	                    var element = this.element, value = element.value;
	                    if (value == 'on' || value == 'off') {
	                        value = element.checked;
	                    }
	                    return value;
	                },
	                destroy: function () {
	                    this.widget.unbind(CHANGE, this._change);
	                }
	            }),
	            visible: Binder.extend({
	                init: function (widget, bindings, options) {
	                    Binder.fn.init.call(this, widget.element[0], bindings, options);
	                    this.widget = widget;
	                },
	                refresh: function () {
	                    var visible = this.bindings.visible.get();
	                    this.widget.wrapper[0].style.display = visible ? '' : 'none';
	                }
	            }),
	            invisible: Binder.extend({
	                init: function (widget, bindings, options) {
	                    Binder.fn.init.call(this, widget.element[0], bindings, options);
	                    this.widget = widget;
	                },
	                refresh: function () {
	                    var invisible = this.bindings.invisible.get();
	                    this.widget.wrapper[0].style.display = invisible ? 'none' : '';
	                }
	            }),
	            enabled: Binder.extend({
	                init: function (widget, bindings, options) {
	                    Binder.fn.init.call(this, widget.element[0], bindings, options);
	                    this.widget = widget;
	                },
	                refresh: function () {
	                    if (this.widget.enable) {
	                        this.widget.enable(this.bindings.enabled.get());
	                    }
	                }
	            }),
	            disabled: Binder.extend({
	                init: function (widget, bindings, options) {
	                    Binder.fn.init.call(this, widget.element[0], bindings, options);
	                    this.widget = widget;
	                },
	                refresh: function () {
	                    if (this.widget.enable) {
	                        this.widget.enable(!this.bindings.disabled.get());
	                    }
	                }
	            }),
	            source: dataSourceBinding('source', 'dataSource', 'setDataSource'),
	            value: Binder.extend({
	                init: function (widget, bindings, options) {
	                    Binder.fn.init.call(this, widget.element[0], bindings, options);
	                    this.widget = widget;
	                    this._change = $.proxy(this.change, this);
	                    this.widget.first(CHANGE, this._change);
	                    var value = this.bindings.value.get();
	                    this._valueIsObservableObject = !options.valuePrimitive && (value == null || value instanceof ObservableObject);
	                    this._valueIsObservableArray = value instanceof ObservableArray;
	                    this._initChange = false;
	                },
	                _source: function () {
	                    var source;
	                    if (this.widget.dataItem) {
	                        source = this.widget.dataItem();
	                        if (source && source instanceof ObservableObject) {
	                            return [source];
	                        }
	                    }
	                    if (this.bindings.source) {
	                        source = this.bindings.source.get();
	                    }
	                    if (!source || source instanceof kendo.data.DataSource) {
	                        source = this.widget.dataSource.flatView();
	                    }
	                    return source;
	                },
	                change: function () {
	                    var value = this.widget.value(), field = this.options.dataValueField || this.options.dataTextField, isArray = toString.call(value) === '[object Array]', isObservableObject = this._valueIsObservableObject, valueIndex, valueLength, values = [], sourceItem, sourceValue, idx, length, source;
	                    this._initChange = true;
	                    if (field) {
	                        if (value === '' && (isObservableObject || this.options.valuePrimitive)) {
	                            value = null;
	                        } else {
	                            source = this._source();
	                            if (isArray) {
	                                valueLength = value.length;
	                                values = value.slice(0);
	                            }
	                            for (idx = 0, length = source.length; idx < length; idx++) {
	                                sourceItem = source[idx];
	                                sourceValue = sourceItem.get(field);
	                                if (isArray) {
	                                    for (valueIndex = 0; valueIndex < valueLength; valueIndex++) {
	                                        if (sourceValue == values[valueIndex]) {
	                                            values[valueIndex] = sourceItem;
	                                            break;
	                                        }
	                                    }
	                                } else if (sourceValue == value) {
	                                    value = isObservableObject ? sourceItem : sourceValue;
	                                    break;
	                                }
	                            }
	                            if (values[0]) {
	                                if (this._valueIsObservableArray) {
	                                    value = values;
	                                } else if (isObservableObject || !field) {
	                                    value = values[0];
	                                } else {
	                                    value = values[0].get(field);
	                                }
	                            }
	                        }
	                    }
	                    this.bindings.value.set(value);
	                    this._initChange = false;
	                },
	                refresh: function () {
	                    if (!this._initChange) {
	                        var widget = this.widget;
	                        var options = widget.options;
	                        var textField = options.dataTextField;
	                        var valueField = options.dataValueField || textField;
	                        var value = this.bindings.value.get();
	                        var text = options.text || '';
	                        var idx = 0, length;
	                        var values = [];
	                        if (value === undefined) {
	                            value = null;
	                        }
	                        if (valueField) {
	                            if (value instanceof ObservableArray) {
	                                for (length = value.length; idx < length; idx++) {
	                                    values[idx] = value[idx].get(valueField);
	                                }
	                                value = values;
	                            } else if (value instanceof ObservableObject) {
	                                text = value.get(textField);
	                                value = value.get(valueField);
	                            }
	                        }
	                        if (options.autoBind === false && !options.cascadeFrom && widget.listView && !widget.listView.bound()) {
	                            if (textField === valueField && !text) {
	                                text = value;
	                            }
	                            if (!text && (value || value === 0) && options.valuePrimitive) {
	                                widget.value(value);
	                            } else {
	                                widget._preselect(value, text);
	                            }
	                        } else {
	                            widget.value(value);
	                        }
	                    }
	                    this._initChange = false;
	                },
	                destroy: function () {
	                    this.widget.unbind(CHANGE, this._change);
	                }
	            }),
	            gantt: { dependencies: dataSourceBinding('dependencies', 'dependencies', 'setDependenciesDataSource') },
	            multiselect: {
	                value: Binder.extend({
	                    init: function (widget, bindings, options) {
	                        Binder.fn.init.call(this, widget.element[0], bindings, options);
	                        this.widget = widget;
	                        this._change = $.proxy(this.change, this);
	                        this.widget.first(CHANGE, this._change);
	                        this._initChange = false;
	                    },
	                    change: function () {
	                        var that = this, oldValues = that.bindings[VALUE].get(), valuePrimitive = that.options.valuePrimitive, newValues = valuePrimitive ? that.widget.value() : that.widget.dataItems();
	                        var field = this.options.dataValueField || this.options.dataTextField;
	                        newValues = newValues.slice(0);
	                        that._initChange = true;
	                        if (oldValues instanceof ObservableArray) {
	                            var remove = [];
	                            var newLength = newValues.length;
	                            var i = 0, j = 0;
	                            var old = oldValues[i];
	                            var same = false;
	                            var removeIndex;
	                            var newValue;
	                            var found;
	                            while (old !== undefined) {
	                                found = false;
	                                for (j = 0; j < newLength; j++) {
	                                    if (valuePrimitive) {
	                                        same = newValues[j] == old;
	                                    } else {
	                                        newValue = newValues[j];
	                                        newValue = newValue.get ? newValue.get(field) : newValue;
	                                        same = newValue == (old.get ? old.get(field) : old);
	                                    }
	                                    if (same) {
	                                        newValues.splice(j, 1);
	                                        newLength -= 1;
	                                        found = true;
	                                        break;
	                                    }
	                                }
	                                if (!found) {
	                                    remove.push(old);
	                                    arraySplice(oldValues, i, 1);
	                                    removeIndex = i;
	                                } else {
	                                    i += 1;
	                                }
	                                old = oldValues[i];
	                            }
	                            arraySplice(oldValues, oldValues.length, 0, newValues);
	                            if (remove.length) {
	                                oldValues.trigger('change', {
	                                    action: 'remove',
	                                    items: remove,
	                                    index: removeIndex
	                                });
	                            }
	                            if (newValues.length) {
	                                oldValues.trigger('change', {
	                                    action: 'add',
	                                    items: newValues,
	                                    index: oldValues.length - 1
	                                });
	                            }
	                        } else {
	                            that.bindings[VALUE].set(newValues);
	                        }
	                        that._initChange = false;
	                    },
	                    refresh: function () {
	                        if (!this._initChange) {
	                            var options = this.options, widget = this.widget, field = options.dataValueField || options.dataTextField, value = this.bindings.value.get(), data = value, idx = 0, length, values = [], selectedValue;
	                            if (value === undefined) {
	                                value = null;
	                            }
	                            if (field) {
	                                if (value instanceof ObservableArray) {
	                                    for (length = value.length; idx < length; idx++) {
	                                        selectedValue = value[idx];
	                                        values[idx] = selectedValue.get ? selectedValue.get(field) : selectedValue;
	                                    }
	                                    value = values;
	                                } else if (value instanceof ObservableObject) {
	                                    value = value.get(field);
	                                }
	                            }
	                            if (options.autoBind === false && options.valuePrimitive !== true && !widget._isBound()) {
	                                widget._preselect(data, value);
	                            } else {
	                                widget.value(value);
	                            }
	                        }
	                    },
	                    destroy: function () {
	                        this.widget.unbind(CHANGE, this._change);
	                    }
	                })
	            },
	            scheduler: {
	                source: dataSourceBinding('source', 'dataSource', 'setDataSource').extend({
	                    dataBound: function (e) {
	                        var idx;
	                        var length;
	                        var widget = this.widget;
	                        var elements = e.addedItems || widget.items();
	                        var data, parents;
	                        if (elements.length) {
	                            data = e.addedDataItems || widget.dataItems();
	                            parents = this.bindings.source._parents();
	                            for (idx = 0, length = data.length; idx < length; idx++) {
	                                bindElement(elements[idx], data[idx], this._ns(e.ns), [data[idx]].concat(parents));
	                            }
	                        }
	                    }
	                })
	            }
	        };
	        var arraySplice = function (arr, idx, remove, add) {
	            add = add || [];
	            remove = remove || 0;
	            var addLength = add.length;
	            var oldLength = arr.length;
	            var shifted = [].slice.call(arr, idx + remove);
	            var shiftedLength = shifted.length;
	            var index;
	            if (addLength) {
	                addLength = idx + addLength;
	                index = 0;
	                for (; idx < addLength; idx++) {
	                    arr[idx] = add[index];
	                    index++;
	                }
	                arr.length = addLength;
	            } else if (remove) {
	                arr.length = idx;
	                remove += idx;
	                while (idx < remove) {
	                    delete arr[--remove];
	                }
	            }
	            if (shiftedLength) {
	                shiftedLength = idx + shiftedLength;
	                index = 0;
	                for (; idx < shiftedLength; idx++) {
	                    arr[idx] = shifted[index];
	                    index++;
	                }
	                arr.length = shiftedLength;
	            }
	            idx = arr.length;
	            while (idx < oldLength) {
	                delete arr[idx];
	                idx++;
	            }
	        };
	        var BindingTarget = Class.extend({
	            init: function (target, options) {
	                this.target = target;
	                this.options = options;
	                this.toDestroy = [];
	            },
	            bind: function (bindings) {
	                var key, hasValue, hasSource, hasEvents, hasChecked, hasCss, widgetBinding = this instanceof WidgetBindingTarget, specificBinders = this.binders();
	                for (key in bindings) {
	                    if (key == VALUE) {
	                        hasValue = true;
	                    } else if (key == SOURCE) {
	                        hasSource = true;
	                    } else if (key == EVENTS && !widgetBinding) {
	                        hasEvents = true;
	                    } else if (key == CHECKED) {
	                        hasChecked = true;
	                    } else if (key == CSS) {
	                        hasCss = true;
	                    } else {
	                        this.applyBinding(key, bindings, specificBinders);
	                    }
	                }
	                if (hasSource) {
	                    this.applyBinding(SOURCE, bindings, specificBinders);
	                }
	                if (hasValue) {
	                    this.applyBinding(VALUE, bindings, specificBinders);
	                }
	                if (hasChecked) {
	                    this.applyBinding(CHECKED, bindings, specificBinders);
	                }
	                if (hasEvents && !widgetBinding) {
	                    this.applyBinding(EVENTS, bindings, specificBinders);
	                }
	                if (hasCss && !widgetBinding) {
	                    this.applyBinding(CSS, bindings, specificBinders);
	                }
	            },
	            binders: function () {
	                return binders[this.target.nodeName.toLowerCase()] || {};
	            },
	            applyBinding: function (name, bindings, specificBinders) {
	                var binder = specificBinders[name] || binders[name], toDestroy = this.toDestroy, attribute, binding = bindings[name];
	                if (binder) {
	                    binder = new binder(this.target, bindings, this.options);
	                    toDestroy.push(binder);
	                    if (binding instanceof Binding) {
	                        binder.bind(binding);
	                        toDestroy.push(binding);
	                    } else {
	                        for (attribute in binding) {
	                            binder.bind(binding, attribute);
	                            toDestroy.push(binding[attribute]);
	                        }
	                    }
	                } else if (name !== 'template') {
	                    throw new Error('The ' + name + ' binding is not supported by the ' + this.target.nodeName.toLowerCase() + ' element');
	                }
	            },
	            destroy: function () {
	                var idx, length, toDestroy = this.toDestroy;
	                for (idx = 0, length = toDestroy.length; idx < length; idx++) {
	                    toDestroy[idx].destroy();
	                }
	            }
	        });
	        var WidgetBindingTarget = BindingTarget.extend({
	            binders: function () {
	                return binders.widget[this.target.options.name.toLowerCase()] || {};
	            },
	            applyBinding: function (name, bindings, specificBinders) {
	                var binder = specificBinders[name] || binders.widget[name], toDestroy = this.toDestroy, attribute, binding = bindings[name];
	                if (binder) {
	                    binder = new binder(this.target, bindings, this.target.options);
	                    toDestroy.push(binder);
	                    if (binding instanceof Binding) {
	                        binder.bind(binding);
	                        toDestroy.push(binding);
	                    } else {
	                        for (attribute in binding) {
	                            binder.bind(binding, attribute);
	                            toDestroy.push(binding[attribute]);
	                        }
	                    }
	                } else {
	                    throw new Error('The ' + name + ' binding is not supported by the ' + this.target.options.name + ' widget');
	                }
	            }
	        });
	        function bindingTargetForRole(element, roles) {
	            var widget = kendo.initWidget(element, {}, roles);
	            if (widget) {
	                return new WidgetBindingTarget(widget);
	            }
	        }
	        var keyValueRegExp = /[A-Za-z0-9_\-]+:(\{([^}]*)\}|[^,}]+)/g, whiteSpaceRegExp = /\s/g;
	        function parseBindings(bind) {
	            var result = {}, idx, length, token, colonIndex, key, value, tokens;
	            tokens = bind.match(keyValueRegExp);
	            for (idx = 0, length = tokens.length; idx < length; idx++) {
	                token = tokens[idx];
	                colonIndex = token.indexOf(':');
	                key = token.substring(0, colonIndex);
	                value = token.substring(colonIndex + 1);
	                if (value.charAt(0) == '{') {
	                    value = parseBindings(value);
	                }
	                result[key] = value;
	            }
	            return result;
	        }
	        function createBindings(bindings, source, type) {
	            var binding, result = {};
	            for (binding in bindings) {
	                result[binding] = new type(source, bindings[binding]);
	            }
	            return result;
	        }
	        function bindElement(element, source, roles, parents) {
	            var role = element.getAttribute('data-' + kendo.ns + 'role'), idx, bind = element.getAttribute('data-' + kendo.ns + 'bind'), childrenCopy = [], deep = true, bindings, options = {}, target;
	            parents = parents || [source];
	            if (role || bind) {
	                unbindElement(element, false);
	            }
	            if (role) {
	                target = bindingTargetForRole(element, roles);
	            }
	            if (bind) {
	                bind = parseBindings(bind.replace(whiteSpaceRegExp, ''));
	                if (!target) {
	                    options = kendo.parseOptions(element, {
	                        textField: '',
	                        valueField: '',
	                        template: '',
	                        valueUpdate: CHANGE,
	                        valuePrimitive: false,
	                        autoBind: true
	                    });
	                    options.roles = roles;
	                    target = new BindingTarget(element, options);
	                }
	                target.source = source;
	                bindings = createBindings(bind, parents, Binding);
	                if (options.template) {
	                    bindings.template = new TemplateBinding(parents, '', options.template);
	                }
	                if (bindings.click) {
	                    bind.events = bind.events || {};
	                    bind.events.click = bind.click;
	                    bindings.click.destroy();
	                    delete bindings.click;
	                }
	                if (bindings.source) {
	                    deep = false;
	                }
	                if (bind.attr) {
	                    bindings.attr = createBindings(bind.attr, parents, Binding);
	                }
	                if (bind.style) {
	                    bindings.style = createBindings(bind.style, parents, Binding);
	                }
	                if (bind.events) {
	                    bindings.events = createBindings(bind.events, parents, EventBinding);
	                }
	                if (bind.css) {
	                    bindings.css = createBindings(bind.css, parents, Binding);
	                }
	                target.bind(bindings);
	            }
	            if (target) {
	                element.kendoBindingTarget = target;
	            }
	            var children = element.children;
	            if (deep && children) {
	                for (idx = 0; idx < children.length; idx++) {
	                    childrenCopy[idx] = children[idx];
	                }
	                for (idx = 0; idx < childrenCopy.length; idx++) {
	                    bindElement(childrenCopy[idx], source, roles, parents);
	                }
	            }
	        }
	        function bind(dom, object) {
	            var idx, length, node, roles = kendo.rolesFromNamespaces([].slice.call(arguments, 2));
	            object = kendo.observable(object);
	            dom = $(dom);
	            for (idx = 0, length = dom.length; idx < length; idx++) {
	                node = dom[idx];
	                if (node.nodeType === 1) {
	                    bindElement(node, object, roles);
	                }
	            }
	        }
	        function unbindElement(element, destroyWidget) {
	            var bindingTarget = element.kendoBindingTarget;
	            if (bindingTarget) {
	                bindingTarget.destroy();
	                if (deleteExpando) {
	                    delete element.kendoBindingTarget;
	                } else if (element.removeAttribute) {
	                    element.removeAttribute('kendoBindingTarget');
	                } else {
	                    element.kendoBindingTarget = null;
	                }
	            }
	            if (destroyWidget) {
	                var widget = kendo.widgetInstance($(element));
	                if (widget && typeof widget.destroy === FUNCTION) {
	                    widget.destroy();
	                }
	            }
	        }
	        function unbindElementTree(element, destroyWidgets) {
	            unbindElement(element, destroyWidgets);
	            unbindElementChildren(element, destroyWidgets);
	        }
	        function unbindElementChildren(element, destroyWidgets) {
	            var children = element.children;
	            if (children) {
	                for (var idx = 0, length = children.length; idx < length; idx++) {
	                    unbindElementTree(children[idx], destroyWidgets);
	                }
	            }
	        }
	        function unbind(dom) {
	            var idx, length;
	            dom = $(dom);
	            for (idx = 0, length = dom.length; idx < length; idx++) {
	                unbindElementTree(dom[idx], false);
	            }
	        }
	        function notify(widget, namespace) {
	            var element = widget.element, bindingTarget = element[0].kendoBindingTarget;
	            if (bindingTarget) {
	                bind(element, bindingTarget.source, namespace);
	            }
	        }
	        function retrievePrimitiveValues(value, valueField) {
	            var values = [];
	            var idx = 0;
	            var length;
	            var item;
	            if (!valueField) {
	                return value;
	            }
	            if (value instanceof ObservableArray) {
	                for (length = value.length; idx < length; idx++) {
	                    item = value[idx];
	                    values[idx] = item.get ? item.get(valueField) : item[valueField];
	                }
	                value = values;
	            } else if (value instanceof ObservableObject) {
	                value = value.get(valueField);
	            }
	            return value;
	        }
	        kendo.unbind = unbind;
	        kendo.bind = bind;
	        kendo.data.binders = binders;
	        kendo.data.Binder = Binder;
	        kendo.notify = notify;
	        kendo.observable = function (object) {
	            if (!(object instanceof ObservableObject)) {
	                object = new ObservableObject(object);
	            }
	            return object;
	        };
	        kendo.observableHierarchy = function (array) {
	            var dataSource = kendo.data.HierarchicalDataSource.create(array);
	            function recursiveRead(data) {
	                var i, children;
	                for (i = 0; i < data.length; i++) {
	                    data[i]._initChildren();
	                    children = data[i].children;
	                    children.fetch();
	                    data[i].items = children.data();
	                    recursiveRead(data[i].items);
	                }
	            }
	            dataSource.fetch();
	            recursiveRead(dataSource.data());
	            dataSource._data._dataSource = dataSource;
	            return dataSource._data;
	        };
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(202)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'fx',
	        name: 'Effects',
	        category: 'framework',
	        description: 'Required for animation effects in all Kendo UI widgets.',
	        depends: ['core']
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, fx = kendo.effects, each = $.each, extend = $.extend, proxy = $.proxy, support = kendo.support, browser = support.browser, transforms = support.transforms, transitions = support.transitions, scaleProperties = {
	                scale: 0,
	                scalex: 0,
	                scaley: 0,
	                scale3d: 0
	            }, translateProperties = {
	                translate: 0,
	                translatex: 0,
	                translatey: 0,
	                translate3d: 0
	            }, hasZoom = typeof document.documentElement.style.zoom !== 'undefined' && !transforms, matrix3dRegExp = /matrix3?d?\s*\(.*,\s*([\d\.\-]+)\w*?,\s*([\d\.\-]+)\w*?,\s*([\d\.\-]+)\w*?,\s*([\d\.\-]+)\w*?/i, cssParamsRegExp = /^(-?[\d\.\-]+)?[\w\s]*,?\s*(-?[\d\.\-]+)?[\w\s]*/i, translateXRegExp = /translatex?$/i, oldEffectsRegExp = /(zoom|fade|expand)(\w+)/, singleEffectRegExp = /(zoom|fade|expand)/, unitRegExp = /[xy]$/i, transformProps = [
	                'perspective',
	                'rotate',
	                'rotatex',
	                'rotatey',
	                'rotatez',
	                'rotate3d',
	                'scale',
	                'scalex',
	                'scaley',
	                'scalez',
	                'scale3d',
	                'skew',
	                'skewx',
	                'skewy',
	                'translate',
	                'translatex',
	                'translatey',
	                'translatez',
	                'translate3d',
	                'matrix',
	                'matrix3d'
	            ], transform2d = [
	                'rotate',
	                'scale',
	                'scalex',
	                'scaley',
	                'skew',
	                'skewx',
	                'skewy',
	                'translate',
	                'translatex',
	                'translatey',
	                'matrix'
	            ], transform2units = {
	                'rotate': 'deg',
	                scale: '',
	                skew: 'px',
	                translate: 'px'
	            }, cssPrefix = transforms.css, round = Math.round, BLANK = '', PX = 'px', NONE = 'none', AUTO = 'auto', WIDTH = 'width', HEIGHT = 'height', HIDDEN = 'hidden', ORIGIN = 'origin', ABORT_ID = 'abortId', OVERFLOW = 'overflow', TRANSLATE = 'translate', POSITION = 'position', COMPLETE_CALLBACK = 'completeCallback', TRANSITION = cssPrefix + 'transition', TRANSFORM = cssPrefix + 'transform', BACKFACE = cssPrefix + 'backface-visibility', PERSPECTIVE = cssPrefix + 'perspective', DEFAULT_PERSPECTIVE = '1500px', TRANSFORM_PERSPECTIVE = 'perspective(' + DEFAULT_PERSPECTIVE + ')', directions = {
	                left: {
	                    reverse: 'right',
	                    property: 'left',
	                    transition: 'translatex',
	                    vertical: false,
	                    modifier: -1
	                },
	                right: {
	                    reverse: 'left',
	                    property: 'left',
	                    transition: 'translatex',
	                    vertical: false,
	                    modifier: 1
	                },
	                down: {
	                    reverse: 'up',
	                    property: 'top',
	                    transition: 'translatey',
	                    vertical: true,
	                    modifier: 1
	                },
	                up: {
	                    reverse: 'down',
	                    property: 'top',
	                    transition: 'translatey',
	                    vertical: true,
	                    modifier: -1
	                },
	                top: { reverse: 'bottom' },
	                bottom: { reverse: 'top' },
	                'in': {
	                    reverse: 'out',
	                    modifier: -1
	                },
	                out: {
	                    reverse: 'in',
	                    modifier: 1
	                },
	                vertical: { reverse: 'vertical' },
	                horizontal: { reverse: 'horizontal' }
	            };
	        kendo.directions = directions;
	        extend($.fn, {
	            kendoStop: function (clearQueue, gotoEnd) {
	                if (transitions) {
	                    return fx.stopQueue(this, clearQueue || false, gotoEnd || false);
	                } else {
	                    return this.stop(clearQueue, gotoEnd);
	                }
	            }
	        });
	        if (transforms && !transitions) {
	            each(transform2d, function (idx, value) {
	                $.fn[value] = function (val) {
	                    if (typeof val == 'undefined') {
	                        return animationProperty(this, value);
	                    } else {
	                        var that = $(this)[0], transformValue = value + '(' + val + transform2units[value.replace(unitRegExp, '')] + ')';
	                        if (that.style.cssText.indexOf(TRANSFORM) == -1) {
	                            $(this).css(TRANSFORM, transformValue);
	                        } else {
	                            that.style.cssText = that.style.cssText.replace(new RegExp(value + '\\(.*?\\)', 'i'), transformValue);
	                        }
	                    }
	                    return this;
	                };
	                $.fx.step[value] = function (fx) {
	                    $(fx.elem)[value](fx.now);
	                };
	            });
	            var curProxy = $.fx.prototype.cur;
	            $.fx.prototype.cur = function () {
	                if (transform2d.indexOf(this.prop) != -1) {
	                    return parseFloat($(this.elem)[this.prop]());
	                }
	                return curProxy.apply(this, arguments);
	            };
	        }
	        kendo.toggleClass = function (element, classes, options, add) {
	            if (classes) {
	                classes = classes.split(' ');
	                if (transitions) {
	                    options = extend({
	                        exclusive: 'all',
	                        duration: 400,
	                        ease: 'ease-out'
	                    }, options);
	                    element.css(TRANSITION, options.exclusive + ' ' + options.duration + 'ms ' + options.ease);
	                    setTimeout(function () {
	                        element.css(TRANSITION, '').css(HEIGHT);
	                    }, options.duration);
	                }
	                each(classes, function (idx, value) {
	                    element.toggleClass(value, add);
	                });
	            }
	            return element;
	        };
	        kendo.parseEffects = function (input, mirror) {
	            var effects = {};
	            if (typeof input === 'string') {
	                each(input.split(' '), function (idx, value) {
	                    var redirectedEffect = !singleEffectRegExp.test(value), resolved = value.replace(oldEffectsRegExp, function (match, $1, $2) {
	                            return $1 + ':' + $2.toLowerCase();
	                        }), effect = resolved.split(':'), direction = effect[1], effectBody = {};
	                    if (effect.length > 1) {
	                        effectBody.direction = mirror && redirectedEffect ? directions[direction].reverse : direction;
	                    }
	                    effects[effect[0]] = effectBody;
	                });
	            } else {
	                each(input, function (idx) {
	                    var direction = this.direction;
	                    if (direction && mirror && !singleEffectRegExp.test(idx)) {
	                        this.direction = directions[direction].reverse;
	                    }
	                    effects[idx] = this;
	                });
	            }
	            return effects;
	        };
	        function parseInteger(value) {
	            return parseInt(value, 10);
	        }
	        function parseCSS(element, property) {
	            return parseInteger(element.css(property));
	        }
	        function keys(obj) {
	            var acc = [];
	            for (var propertyName in obj) {
	                acc.push(propertyName);
	            }
	            return acc;
	        }
	        function strip3DTransforms(properties) {
	            for (var key in properties) {
	                if (transformProps.indexOf(key) != -1 && transform2d.indexOf(key) == -1) {
	                    delete properties[key];
	                }
	            }
	            return properties;
	        }
	        function normalizeCSS(element, properties) {
	            var transformation = [], cssValues = {}, lowerKey, key, value, isTransformed;
	            for (key in properties) {
	                lowerKey = key.toLowerCase();
	                isTransformed = transforms && transformProps.indexOf(lowerKey) != -1;
	                if (!support.hasHW3D && isTransformed && transform2d.indexOf(lowerKey) == -1) {
	                    delete properties[key];
	                } else {
	                    value = properties[key];
	                    if (isTransformed) {
	                        transformation.push(key + '(' + value + ')');
	                    } else {
	                        cssValues[key] = value;
	                    }
	                }
	            }
	            if (transformation.length) {
	                cssValues[TRANSFORM] = transformation.join(' ');
	            }
	            return cssValues;
	        }
	        if (transitions) {
	            extend(fx, {
	                transition: function (element, properties, options) {
	                    var css, delay = 0, oldKeys = element.data('keys') || [], timeoutID;
	                    options = extend({
	                        duration: 200,
	                        ease: 'ease-out',
	                        complete: null,
	                        exclusive: 'all'
	                    }, options);
	                    var stopTransitionCalled = false;
	                    var stopTransition = function () {
	                        if (!stopTransitionCalled) {
	                            stopTransitionCalled = true;
	                            if (timeoutID) {
	                                clearTimeout(timeoutID);
	                                timeoutID = null;
	                            }
	                            element.removeData(ABORT_ID).dequeue().css(TRANSITION, '').css(TRANSITION);
	                            options.complete.call(element);
	                        }
	                    };
	                    options.duration = $.fx ? $.fx.speeds[options.duration] || options.duration : options.duration;
	                    css = normalizeCSS(element, properties);
	                    $.merge(oldKeys, keys(css));
	                    element.data('keys', $.unique(oldKeys)).height();
	                    element.css(TRANSITION, options.exclusive + ' ' + options.duration + 'ms ' + options.ease).css(TRANSITION);
	                    element.css(css).css(TRANSFORM);
	                    if (transitions.event) {
	                        element.one(transitions.event, stopTransition);
	                        if (options.duration !== 0) {
	                            delay = 500;
	                        }
	                    }
	                    timeoutID = setTimeout(stopTransition, options.duration + delay);
	                    element.data(ABORT_ID, timeoutID);
	                    element.data(COMPLETE_CALLBACK, stopTransition);
	                },
	                stopQueue: function (element, clearQueue, gotoEnd) {
	                    var cssValues, taskKeys = element.data('keys'), retainPosition = !gotoEnd && taskKeys, completeCallback = element.data(COMPLETE_CALLBACK);
	                    if (retainPosition) {
	                        cssValues = kendo.getComputedStyles(element[0], taskKeys);
	                    }
	                    if (completeCallback) {
	                        completeCallback();
	                    }
	                    if (retainPosition) {
	                        element.css(cssValues);
	                    }
	                    return element.removeData('keys').stop(clearQueue);
	                }
	            });
	        }
	        function animationProperty(element, property) {
	            if (transforms) {
	                var transform = element.css(TRANSFORM);
	                if (transform == NONE) {
	                    return property == 'scale' ? 1 : 0;
	                }
	                var match = transform.match(new RegExp(property + '\\s*\\(([\\d\\w\\.]+)')), computed = 0;
	                if (match) {
	                    computed = parseInteger(match[1]);
	                } else {
	                    match = transform.match(matrix3dRegExp) || [
	                        0,
	                        0,
	                        0,
	                        0,
	                        0
	                    ];
	                    property = property.toLowerCase();
	                    if (translateXRegExp.test(property)) {
	                        computed = parseFloat(match[3] / match[2]);
	                    } else if (property == 'translatey') {
	                        computed = parseFloat(match[4] / match[2]);
	                    } else if (property == 'scale') {
	                        computed = parseFloat(match[2]);
	                    } else if (property == 'rotate') {
	                        computed = parseFloat(Math.atan2(match[2], match[1]));
	                    }
	                }
	                return computed;
	            } else {
	                return parseFloat(element.css(property));
	            }
	        }
	        var EffectSet = kendo.Class.extend({
	            init: function (element, options) {
	                var that = this;
	                that.element = element;
	                that.effects = [];
	                that.options = options;
	                that.restore = [];
	            },
	            run: function (effects) {
	                var that = this, effect, idx, jdx, length = effects.length, element = that.element, options = that.options, deferred = $.Deferred(), start = {}, end = {}, target, children, childrenLength;
	                that.effects = effects;
	                deferred.then($.proxy(that, 'complete'));
	                element.data('animating', true);
	                for (idx = 0; idx < length; idx++) {
	                    effect = effects[idx];
	                    effect.setReverse(options.reverse);
	                    effect.setOptions(options);
	                    that.addRestoreProperties(effect.restore);
	                    effect.prepare(start, end);
	                    children = effect.children();
	                    for (jdx = 0, childrenLength = children.length; jdx < childrenLength; jdx++) {
	                        children[jdx].duration(options.duration).run();
	                    }
	                }
	                for (var effectName in options.effects) {
	                    extend(end, options.effects[effectName].properties);
	                }
	                if (!element.is(':visible')) {
	                    extend(start, { display: element.data('olddisplay') || 'block' });
	                }
	                if (transforms && !options.reset) {
	                    target = element.data('targetTransform');
	                    if (target) {
	                        start = extend(target, start);
	                    }
	                }
	                start = normalizeCSS(element, start);
	                if (transforms && !transitions) {
	                    start = strip3DTransforms(start);
	                }
	                element.css(start).css(TRANSFORM);
	                for (idx = 0; idx < length; idx++) {
	                    effects[idx].setup();
	                }
	                if (options.init) {
	                    options.init();
	                }
	                element.data('targetTransform', end);
	                fx.animate(element, end, extend({}, options, { complete: deferred.resolve }));
	                return deferred.promise();
	            },
	            stop: function () {
	                $(this.element).kendoStop(true, true);
	            },
	            addRestoreProperties: function (restore) {
	                var element = this.element, value, i = 0, length = restore.length;
	                for (; i < length; i++) {
	                    value = restore[i];
	                    this.restore.push(value);
	                    if (!element.data(value)) {
	                        element.data(value, element.css(value));
	                    }
	                }
	            },
	            restoreCallback: function () {
	                var element = this.element;
	                for (var i = 0, length = this.restore.length; i < length; i++) {
	                    var value = this.restore[i];
	                    element.css(value, element.data(value));
	                }
	            },
	            complete: function () {
	                var that = this, idx = 0, element = that.element, options = that.options, effects = that.effects, length = effects.length;
	                element.removeData('animating').dequeue();
	                if (options.hide) {
	                    element.data('olddisplay', element.css('display')).hide();
	                }
	                this.restoreCallback();
	                if (hasZoom && !transforms) {
	                    setTimeout($.proxy(this, 'restoreCallback'), 0);
	                }
	                for (; idx < length; idx++) {
	                    effects[idx].teardown();
	                }
	                if (options.completeCallback) {
	                    options.completeCallback(element);
	                }
	            }
	        });
	        fx.promise = function (element, options) {
	            var effects = [], effectClass, effectSet = new EffectSet(element, options), parsedEffects = kendo.parseEffects(options.effects), effect;
	            options.effects = parsedEffects;
	            for (var effectName in parsedEffects) {
	                effectClass = fx[capitalize(effectName)];
	                if (effectClass) {
	                    effect = new effectClass(element, parsedEffects[effectName].direction);
	                    effects.push(effect);
	                }
	            }
	            if (effects[0]) {
	                effectSet.run(effects);
	            } else {
	                if (!element.is(':visible')) {
	                    element.css({ display: element.data('olddisplay') || 'block' }).css('display');
	                }
	                if (options.init) {
	                    options.init();
	                }
	                element.dequeue();
	                effectSet.complete();
	            }
	        };
	        extend(fx, {
	            animate: function (elements, properties, options) {
	                var useTransition = options.transition !== false;
	                delete options.transition;
	                if (transitions && 'transition' in fx && useTransition) {
	                    fx.transition(elements, properties, options);
	                } else {
	                    if (transforms) {
	                        elements.animate(strip3DTransforms(properties), {
	                            queue: false,
	                            show: false,
	                            hide: false,
	                            duration: options.duration,
	                            complete: options.complete
	                        });
	                    } else {
	                        elements.each(function () {
	                            var element = $(this), multiple = {};
	                            each(transformProps, function (idx, value) {
	                                var params, currentValue = properties ? properties[value] + ' ' : null;
	                                if (currentValue) {
	                                    var single = properties;
	                                    if (value in scaleProperties && properties[value] !== undefined) {
	                                        params = currentValue.match(cssParamsRegExp);
	                                        if (transforms) {
	                                            extend(single, { scale: +params[0] });
	                                        }
	                                    } else {
	                                        if (value in translateProperties && properties[value] !== undefined) {
	                                            var position = element.css(POSITION), isFixed = position == 'absolute' || position == 'fixed';
	                                            if (!element.data(TRANSLATE)) {
	                                                if (isFixed) {
	                                                    element.data(TRANSLATE, {
	                                                        top: parseCSS(element, 'top') || 0,
	                                                        left: parseCSS(element, 'left') || 0,
	                                                        bottom: parseCSS(element, 'bottom'),
	                                                        right: parseCSS(element, 'right')
	                                                    });
	                                                } else {
	                                                    element.data(TRANSLATE, {
	                                                        top: parseCSS(element, 'marginTop') || 0,
	                                                        left: parseCSS(element, 'marginLeft') || 0
	                                                    });
	                                                }
	                                            }
	                                            var originalPosition = element.data(TRANSLATE);
	                                            params = currentValue.match(cssParamsRegExp);
	                                            if (params) {
	                                                var dX = value == TRANSLATE + 'y' ? +null : +params[1], dY = value == TRANSLATE + 'y' ? +params[1] : +params[2];
	                                                if (isFixed) {
	                                                    if (!isNaN(originalPosition.right)) {
	                                                        if (!isNaN(dX)) {
	                                                            extend(single, { right: originalPosition.right - dX });
	                                                        }
	                                                    } else {
	                                                        if (!isNaN(dX)) {
	                                                            extend(single, { left: originalPosition.left + dX });
	                                                        }
	                                                    }
	                                                    if (!isNaN(originalPosition.bottom)) {
	                                                        if (!isNaN(dY)) {
	                                                            extend(single, { bottom: originalPosition.bottom - dY });
	                                                        }
	                                                    } else {
	                                                        if (!isNaN(dY)) {
	                                                            extend(single, { top: originalPosition.top + dY });
	                                                        }
	                                                    }
	                                                } else {
	                                                    if (!isNaN(dX)) {
	                                                        extend(single, { marginLeft: originalPosition.left + dX });
	                                                    }
	                                                    if (!isNaN(dY)) {
	                                                        extend(single, { marginTop: originalPosition.top + dY });
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                    if (!transforms && value != 'scale' && value in single) {
	                                        delete single[value];
	                                    }
	                                    if (single) {
	                                        extend(multiple, single);
	                                    }
	                                }
	                            });
	                            if (browser.msie) {
	                                delete multiple.scale;
	                            }
	                            element.animate(multiple, {
	                                queue: false,
	                                show: false,
	                                hide: false,
	                                duration: options.duration,
	                                complete: options.complete
	                            });
	                        });
	                    }
	                }
	            }
	        });
	        fx.animatedPromise = fx.promise;
	        var Effect = kendo.Class.extend({
	            init: function (element, direction) {
	                var that = this;
	                that.element = element;
	                that._direction = direction;
	                that.options = {};
	                that._additionalEffects = [];
	                if (!that.restore) {
	                    that.restore = [];
	                }
	            },
	            reverse: function () {
	                this._reverse = true;
	                return this.run();
	            },
	            play: function () {
	                this._reverse = false;
	                return this.run();
	            },
	            add: function (additional) {
	                this._additionalEffects.push(additional);
	                return this;
	            },
	            direction: function (value) {
	                this._direction = value;
	                return this;
	            },
	            duration: function (duration) {
	                this._duration = duration;
	                return this;
	            },
	            compositeRun: function () {
	                var that = this, effectSet = new EffectSet(that.element, {
	                        reverse: that._reverse,
	                        duration: that._duration
	                    }), effects = that._additionalEffects.concat([that]);
	                return effectSet.run(effects);
	            },
	            run: function () {
	                if (this._additionalEffects && this._additionalEffects[0]) {
	                    return this.compositeRun();
	                }
	                var that = this, element = that.element, idx = 0, restore = that.restore, length = restore.length, value, deferred = $.Deferred(), start = {}, end = {}, target, children = that.children(), childrenLength = children.length;
	                deferred.then($.proxy(that, '_complete'));
	                element.data('animating', true);
	                for (idx = 0; idx < length; idx++) {
	                    value = restore[idx];
	                    if (!element.data(value)) {
	                        element.data(value, element.css(value));
	                    }
	                }
	                for (idx = 0; idx < childrenLength; idx++) {
	                    children[idx].duration(that._duration).run();
	                }
	                that.prepare(start, end);
	                if (!element.is(':visible')) {
	                    extend(start, { display: element.data('olddisplay') || 'block' });
	                }
	                if (transforms) {
	                    target = element.data('targetTransform');
	                    if (target) {
	                        start = extend(target, start);
	                    }
	                }
	                start = normalizeCSS(element, start);
	                if (transforms && !transitions) {
	                    start = strip3DTransforms(start);
	                }
	                element.css(start).css(TRANSFORM);
	                that.setup();
	                element.data('targetTransform', end);
	                fx.animate(element, end, {
	                    duration: that._duration,
	                    complete: deferred.resolve
	                });
	                return deferred.promise();
	            },
	            stop: function () {
	                var idx = 0, children = this.children(), childrenLength = children.length;
	                for (idx = 0; idx < childrenLength; idx++) {
	                    children[idx].stop();
	                }
	                $(this.element).kendoStop(true, true);
	                return this;
	            },
	            restoreCallback: function () {
	                var element = this.element;
	                for (var i = 0, length = this.restore.length; i < length; i++) {
	                    var value = this.restore[i];
	                    element.css(value, element.data(value));
	                }
	            },
	            _complete: function () {
	                var that = this, element = that.element;
	                element.removeData('animating').dequeue();
	                that.restoreCallback();
	                if (that.shouldHide()) {
	                    element.data('olddisplay', element.css('display')).hide();
	                }
	                if (hasZoom && !transforms) {
	                    setTimeout($.proxy(that, 'restoreCallback'), 0);
	                }
	                that.teardown();
	            },
	            setOptions: function (options) {
	                extend(true, this.options, options);
	            },
	            children: function () {
	                return [];
	            },
	            shouldHide: $.noop,
	            setup: $.noop,
	            prepare: $.noop,
	            teardown: $.noop,
	            directions: [],
	            setReverse: function (reverse) {
	                this._reverse = reverse;
	                return this;
	            }
	        });
	        function capitalize(word) {
	            return word.charAt(0).toUpperCase() + word.substring(1);
	        }
	        function createEffect(name, definition) {
	            var effectClass = Effect.extend(definition), directions = effectClass.prototype.directions;
	            fx[capitalize(name)] = effectClass;
	            fx.Element.prototype[name] = function (direction, opt1, opt2, opt3) {
	                return new effectClass(this.element, direction, opt1, opt2, opt3);
	            };
	            each(directions, function (idx, theDirection) {
	                fx.Element.prototype[name + capitalize(theDirection)] = function (opt1, opt2, opt3) {
	                    return new effectClass(this.element, theDirection, opt1, opt2, opt3);
	                };
	            });
	        }
	        var FOUR_DIRECTIONS = [
	                'left',
	                'right',
	                'up',
	                'down'
	            ], IN_OUT = [
	                'in',
	                'out'
	            ];
	        createEffect('slideIn', {
	            directions: FOUR_DIRECTIONS,
	            divisor: function (value) {
	                this.options.divisor = value;
	                return this;
	            },
	            prepare: function (start, end) {
	                var that = this, tmp, element = that.element, direction = directions[that._direction], offset = -direction.modifier * (direction.vertical ? element.outerHeight() : element.outerWidth()), startValue = offset / (that.options && that.options.divisor || 1) + PX, endValue = '0px';
	                if (that._reverse) {
	                    tmp = start;
	                    start = end;
	                    end = tmp;
	                }
	                if (transforms) {
	                    start[direction.transition] = startValue;
	                    end[direction.transition] = endValue;
	                } else {
	                    start[direction.property] = startValue;
	                    end[direction.property] = endValue;
	                }
	            }
	        });
	        createEffect('tile', {
	            directions: FOUR_DIRECTIONS,
	            init: function (element, direction, previous) {
	                Effect.prototype.init.call(this, element, direction);
	                this.options = { previous: previous };
	            },
	            previousDivisor: function (value) {
	                this.options.previousDivisor = value;
	                return this;
	            },
	            children: function () {
	                var that = this, reverse = that._reverse, previous = that.options.previous, divisor = that.options.previousDivisor || 1, dir = that._direction;
	                var children = [kendo.fx(that.element).slideIn(dir).setReverse(reverse)];
	                if (previous) {
	                    children.push(kendo.fx(previous).slideIn(directions[dir].reverse).divisor(divisor).setReverse(!reverse));
	                }
	                return children;
	            }
	        });
	        function createToggleEffect(name, property, defaultStart, defaultEnd) {
	            createEffect(name, {
	                directions: IN_OUT,
	                startValue: function (value) {
	                    this._startValue = value;
	                    return this;
	                },
	                endValue: function (value) {
	                    this._endValue = value;
	                    return this;
	                },
	                shouldHide: function () {
	                    return this._shouldHide;
	                },
	                prepare: function (start, end) {
	                    var that = this, startValue, endValue, out = this._direction === 'out', startDataValue = that.element.data(property), startDataValueIsSet = !(isNaN(startDataValue) || startDataValue == defaultStart);
	                    if (startDataValueIsSet) {
	                        startValue = startDataValue;
	                    } else if (typeof this._startValue !== 'undefined') {
	                        startValue = this._startValue;
	                    } else {
	                        startValue = out ? defaultStart : defaultEnd;
	                    }
	                    if (typeof this._endValue !== 'undefined') {
	                        endValue = this._endValue;
	                    } else {
	                        endValue = out ? defaultEnd : defaultStart;
	                    }
	                    if (this._reverse) {
	                        start[property] = endValue;
	                        end[property] = startValue;
	                    } else {
	                        start[property] = startValue;
	                        end[property] = endValue;
	                    }
	                    that._shouldHide = end[property] === defaultEnd;
	                }
	            });
	        }
	        createToggleEffect('fade', 'opacity', 1, 0);
	        createToggleEffect('zoom', 'scale', 1, 0.01);
	        createEffect('slideMargin', {
	            prepare: function (start, end) {
	                var that = this, element = that.element, options = that.options, origin = element.data(ORIGIN), offset = options.offset, margin, reverse = that._reverse;
	                if (!reverse && origin === null) {
	                    element.data(ORIGIN, parseFloat(element.css('margin-' + options.axis)));
	                }
	                margin = element.data(ORIGIN) || 0;
	                end['margin-' + options.axis] = !reverse ? margin + offset : margin;
	            }
	        });
	        createEffect('slideTo', {
	            prepare: function (start, end) {
	                var that = this, element = that.element, options = that.options, offset = options.offset.split(','), reverse = that._reverse;
	                if (transforms) {
	                    end.translatex = !reverse ? offset[0] : 0;
	                    end.translatey = !reverse ? offset[1] : 0;
	                } else {
	                    end.left = !reverse ? offset[0] : 0;
	                    end.top = !reverse ? offset[1] : 0;
	                }
	                element.css('left');
	            }
	        });
	        createEffect('expand', {
	            directions: [
	                'horizontal',
	                'vertical'
	            ],
	            restore: [OVERFLOW],
	            prepare: function (start, end) {
	                var that = this, element = that.element, options = that.options, reverse = that._reverse, property = that._direction === 'vertical' ? HEIGHT : WIDTH, setLength = element[0].style[property], oldLength = element.data(property), length = parseFloat(oldLength || setLength), realLength = round(element.css(property, AUTO)[property]());
	                start.overflow = HIDDEN;
	                length = options && options.reset ? realLength || length : length || realLength;
	                end[property] = (reverse ? 0 : length) + PX;
	                start[property] = (reverse ? length : 0) + PX;
	                if (oldLength === undefined) {
	                    element.data(property, setLength);
	                }
	            },
	            shouldHide: function () {
	                return this._reverse;
	            },
	            teardown: function () {
	                var that = this, element = that.element, property = that._direction === 'vertical' ? HEIGHT : WIDTH, length = element.data(property);
	                if (length == AUTO || length === BLANK) {
	                    setTimeout(function () {
	                        element.css(property, AUTO).css(property);
	                    }, 0);
	                }
	            }
	        });
	        var TRANSFER_START_STATE = {
	            position: 'absolute',
	            marginLeft: 0,
	            marginTop: 0,
	            scale: 1
	        };
	        createEffect('transfer', {
	            init: function (element, target) {
	                this.element = element;
	                this.options = { target: target };
	                this.restore = [];
	            },
	            setup: function () {
	                this.element.appendTo(document.body);
	            },
	            prepare: function (start, end) {
	                var that = this, element = that.element, outerBox = fx.box(element), innerBox = fx.box(that.options.target), currentScale = animationProperty(element, 'scale'), scale = fx.fillScale(innerBox, outerBox), transformOrigin = fx.transformOrigin(innerBox, outerBox);
	                extend(start, TRANSFER_START_STATE);
	                end.scale = 1;
	                element.css(TRANSFORM, 'scale(1)').css(TRANSFORM);
	                element.css(TRANSFORM, 'scale(' + currentScale + ')');
	                start.top = outerBox.top;
	                start.left = outerBox.left;
	                start.transformOrigin = transformOrigin.x + PX + ' ' + transformOrigin.y + PX;
	                if (that._reverse) {
	                    start.scale = scale;
	                } else {
	                    end.scale = scale;
	                }
	            }
	        });
	        var CLIPS = {
	            top: 'rect(auto auto $size auto)',
	            bottom: 'rect($size auto auto auto)',
	            left: 'rect(auto $size auto auto)',
	            right: 'rect(auto auto auto $size)'
	        };
	        var ROTATIONS = {
	            top: {
	                start: 'rotatex(0deg)',
	                end: 'rotatex(180deg)'
	            },
	            bottom: {
	                start: 'rotatex(-180deg)',
	                end: 'rotatex(0deg)'
	            },
	            left: {
	                start: 'rotatey(0deg)',
	                end: 'rotatey(-180deg)'
	            },
	            right: {
	                start: 'rotatey(180deg)',
	                end: 'rotatey(0deg)'
	            }
	        };
	        function clipInHalf(container, direction) {
	            var vertical = kendo.directions[direction].vertical, size = container[vertical ? HEIGHT : WIDTH]() / 2 + 'px';
	            return CLIPS[direction].replace('$size', size);
	        }
	        createEffect('turningPage', {
	            directions: FOUR_DIRECTIONS,
	            init: function (element, direction, container) {
	                Effect.prototype.init.call(this, element, direction);
	                this._container = container;
	            },
	            prepare: function (start, end) {
	                var that = this, reverse = that._reverse, direction = reverse ? directions[that._direction].reverse : that._direction, rotation = ROTATIONS[direction];
	                start.zIndex = 1;
	                if (that._clipInHalf) {
	                    start.clip = clipInHalf(that._container, kendo.directions[direction].reverse);
	                }
	                start[BACKFACE] = HIDDEN;
	                end[TRANSFORM] = TRANSFORM_PERSPECTIVE + (reverse ? rotation.start : rotation.end);
	                start[TRANSFORM] = TRANSFORM_PERSPECTIVE + (reverse ? rotation.end : rotation.start);
	            },
	            setup: function () {
	                this._container.append(this.element);
	            },
	            face: function (value) {
	                this._face = value;
	                return this;
	            },
	            shouldHide: function () {
	                var that = this, reverse = that._reverse, face = that._face;
	                return reverse && !face || !reverse && face;
	            },
	            clipInHalf: function (value) {
	                this._clipInHalf = value;
	                return this;
	            },
	            temporary: function () {
	                this.element.addClass('temp-page');
	                return this;
	            }
	        });
	        createEffect('staticPage', {
	            directions: FOUR_DIRECTIONS,
	            init: function (element, direction, container) {
	                Effect.prototype.init.call(this, element, direction);
	                this._container = container;
	            },
	            restore: ['clip'],
	            prepare: function (start, end) {
	                var that = this, direction = that._reverse ? directions[that._direction].reverse : that._direction;
	                start.clip = clipInHalf(that._container, direction);
	                start.opacity = 0.999;
	                end.opacity = 1;
	            },
	            shouldHide: function () {
	                var that = this, reverse = that._reverse, face = that._face;
	                return reverse && !face || !reverse && face;
	            },
	            face: function (value) {
	                this._face = value;
	                return this;
	            }
	        });
	        createEffect('pageturn', {
	            directions: [
	                'horizontal',
	                'vertical'
	            ],
	            init: function (element, direction, face, back) {
	                Effect.prototype.init.call(this, element, direction);
	                this.options = {};
	                this.options.face = face;
	                this.options.back = back;
	            },
	            children: function () {
	                var that = this, options = that.options, direction = that._direction === 'horizontal' ? 'left' : 'top', reverseDirection = kendo.directions[direction].reverse, reverse = that._reverse, temp, faceClone = options.face.clone(true).removeAttr('id'), backClone = options.back.clone(true).removeAttr('id'), element = that.element;
	                if (reverse) {
	                    temp = direction;
	                    direction = reverseDirection;
	                    reverseDirection = temp;
	                }
	                return [
	                    kendo.fx(options.face).staticPage(direction, element).face(true).setReverse(reverse),
	                    kendo.fx(options.back).staticPage(reverseDirection, element).setReverse(reverse),
	                    kendo.fx(faceClone).turningPage(direction, element).face(true).clipInHalf(true).temporary().setReverse(reverse),
	                    kendo.fx(backClone).turningPage(reverseDirection, element).clipInHalf(true).temporary().setReverse(reverse)
	                ];
	            },
	            prepare: function (start, end) {
	                start[PERSPECTIVE] = DEFAULT_PERSPECTIVE;
	                start.transformStyle = 'preserve-3d';
	                start.opacity = 0.999;
	                end.opacity = 1;
	            },
	            teardown: function () {
	                this.element.find('.temp-page').remove();
	            }
	        });
	        createEffect('flip', {
	            directions: [
	                'horizontal',
	                'vertical'
	            ],
	            init: function (element, direction, face, back) {
	                Effect.prototype.init.call(this, element, direction);
	                this.options = {};
	                this.options.face = face;
	                this.options.back = back;
	            },
	            children: function () {
	                var that = this, options = that.options, direction = that._direction === 'horizontal' ? 'left' : 'top', reverseDirection = kendo.directions[direction].reverse, reverse = that._reverse, temp, element = that.element;
	                if (reverse) {
	                    temp = direction;
	                    direction = reverseDirection;
	                    reverseDirection = temp;
	                }
	                return [
	                    kendo.fx(options.face).turningPage(direction, element).face(true).setReverse(reverse),
	                    kendo.fx(options.back).turningPage(reverseDirection, element).setReverse(reverse)
	                ];
	            },
	            prepare: function (start) {
	                start[PERSPECTIVE] = DEFAULT_PERSPECTIVE;
	                start.transformStyle = 'preserve-3d';
	            }
	        });
	        var RESTORE_OVERFLOW = !support.mobileOS.android;
	        var IGNORE_TRANSITION_EVENT_SELECTOR = '.km-touch-scrollbar, .km-actionsheet-wrapper';
	        createEffect('replace', {
	            _before: $.noop,
	            _after: $.noop,
	            init: function (element, previous, transitionClass) {
	                Effect.prototype.init.call(this, element);
	                this._previous = $(previous);
	                this._transitionClass = transitionClass;
	            },
	            duration: function () {
	                throw new Error('The replace effect does not support duration setting; the effect duration may be customized through the transition class rule');
	            },
	            beforeTransition: function (callback) {
	                this._before = callback;
	                return this;
	            },
	            afterTransition: function (callback) {
	                this._after = callback;
	                return this;
	            },
	            _both: function () {
	                return $().add(this._element).add(this._previous);
	            },
	            _containerClass: function () {
	                var direction = this._direction, containerClass = 'k-fx k-fx-start k-fx-' + this._transitionClass;
	                if (direction) {
	                    containerClass += ' k-fx-' + direction;
	                }
	                if (this._reverse) {
	                    containerClass += ' k-fx-reverse';
	                }
	                return containerClass;
	            },
	            complete: function (e) {
	                if (!this.deferred || e && $(e.target).is(IGNORE_TRANSITION_EVENT_SELECTOR)) {
	                    return;
	                }
	                var container = this.container;
	                container.removeClass('k-fx-end').removeClass(this._containerClass()).off(transitions.event, this.completeProxy);
	                this._previous.hide().removeClass('k-fx-current');
	                this.element.removeClass('k-fx-next');
	                if (RESTORE_OVERFLOW) {
	                    container.css(OVERFLOW, '');
	                }
	                if (!this.isAbsolute) {
	                    this._both().css(POSITION, '');
	                }
	                this.deferred.resolve();
	                delete this.deferred;
	            },
	            run: function () {
	                if (this._additionalEffects && this._additionalEffects[0]) {
	                    return this.compositeRun();
	                }
	                var that = this, element = that.element, previous = that._previous, container = element.parents().filter(previous.parents()).first(), both = that._both(), deferred = $.Deferred(), originalPosition = element.css(POSITION), originalOverflow;
	                if (!container.length) {
	                    container = element.parent();
	                }
	                this.container = container;
	                this.deferred = deferred;
	                this.isAbsolute = originalPosition == 'absolute';
	                if (!this.isAbsolute) {
	                    both.css(POSITION, 'absolute');
	                }
	                if (RESTORE_OVERFLOW) {
	                    originalOverflow = container.css(OVERFLOW);
	                    container.css(OVERFLOW, 'hidden');
	                }
	                if (!transitions) {
	                    this.complete();
	                } else {
	                    element.addClass('k-fx-hidden');
	                    container.addClass(this._containerClass());
	                    this.completeProxy = $.proxy(this, 'complete');
	                    container.on(transitions.event, this.completeProxy);
	                    kendo.animationFrame(function () {
	                        element.removeClass('k-fx-hidden').addClass('k-fx-next');
	                        previous.css('display', '').addClass('k-fx-current');
	                        that._before(previous, element);
	                        kendo.animationFrame(function () {
	                            container.removeClass('k-fx-start').addClass('k-fx-end');
	                            that._after(previous, element);
	                        });
	                    });
	                }
	                return deferred.promise();
	            },
	            stop: function () {
	                this.complete();
	            }
	        });
	        var Animation = kendo.Class.extend({
	            init: function () {
	                var that = this;
	                that._tickProxy = proxy(that._tick, that);
	                that._started = false;
	            },
	            tick: $.noop,
	            done: $.noop,
	            onEnd: $.noop,
	            onCancel: $.noop,
	            start: function () {
	                if (!this.enabled()) {
	                    return;
	                }
	                if (!this.done()) {
	                    this._started = true;
	                    kendo.animationFrame(this._tickProxy);
	                } else {
	                    this.onEnd();
	                }
	            },
	            enabled: function () {
	                return true;
	            },
	            cancel: function () {
	                this._started = false;
	                this.onCancel();
	            },
	            _tick: function () {
	                var that = this;
	                if (!that._started) {
	                    return;
	                }
	                that.tick();
	                if (!that.done()) {
	                    kendo.animationFrame(that._tickProxy);
	                } else {
	                    that._started = false;
	                    that.onEnd();
	                }
	            }
	        });
	        var Transition = Animation.extend({
	            init: function (options) {
	                var that = this;
	                extend(that, options);
	                Animation.fn.init.call(that);
	            },
	            done: function () {
	                return this.timePassed() >= this.duration;
	            },
	            timePassed: function () {
	                return Math.min(this.duration, new Date() - this.startDate);
	            },
	            moveTo: function (options) {
	                var that = this, movable = that.movable;
	                that.initial = movable[that.axis];
	                that.delta = options.location - that.initial;
	                that.duration = typeof options.duration == 'number' ? options.duration : 300;
	                that.tick = that._easeProxy(options.ease);
	                that.startDate = new Date();
	                that.start();
	            },
	            _easeProxy: function (ease) {
	                var that = this;
	                return function () {
	                    that.movable.moveAxis(that.axis, ease(that.timePassed(), that.initial, that.delta, that.duration));
	                };
	            }
	        });
	        extend(Transition, {
	            easeOutExpo: function (t, b, c, d) {
	                return t == d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
	            },
	            easeOutBack: function (t, b, c, d, s) {
	                s = 1.70158;
	                return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
	            }
	        });
	        fx.Animation = Animation;
	        fx.Transition = Transition;
	        fx.createEffect = createEffect;
	        fx.box = function (element) {
	            element = $(element);
	            var result = element.offset();
	            result.width = element.outerWidth();
	            result.height = element.outerHeight();
	            return result;
	        };
	        fx.transformOrigin = function (inner, outer) {
	            var x = (inner.left - outer.left) * outer.width / (outer.width - inner.width), y = (inner.top - outer.top) * outer.height / (outer.height - inner.height);
	            return {
	                x: isNaN(x) ? 0 : x,
	                y: isNaN(y) ? 0 : y
	            };
	        };
	        fx.fillScale = function (inner, outer) {
	            return Math.min(inner.width / outer.width, inner.height / outer.height);
	        };
	        fx.fitScale = function (inner, outer) {
	            return Math.max(inner.width / outer.width, inner.height / outer.height);
	        };
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(202)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'userevents',
	        name: 'User Events',
	        category: 'framework',
	        depends: ['core'],
	        hidden: true
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, support = kendo.support, Class = kendo.Class, Observable = kendo.Observable, now = $.now, extend = $.extend, OS = support.mobileOS, invalidZeroEvents = OS && OS.android, DEFAULT_MIN_HOLD = 800, DEFAULT_THRESHOLD = support.browser.msie ? 5 : 0, PRESS = 'press', HOLD = 'hold', SELECT = 'select', START = 'start', MOVE = 'move', END = 'end', CANCEL = 'cancel', TAP = 'tap', RELEASE = 'release', GESTURESTART = 'gesturestart', GESTURECHANGE = 'gesturechange', GESTUREEND = 'gestureend', GESTURETAP = 'gesturetap';
	        var THRESHOLD = {
	            'api': 0,
	            'touch': 0,
	            'mouse': 9,
	            'pointer': 9
	        };
	        var ENABLE_GLOBAL_SURFACE = !support.touch || support.mouseAndTouchPresent;
	        function touchDelta(touch1, touch2) {
	            var x1 = touch1.x.location, y1 = touch1.y.location, x2 = touch2.x.location, y2 = touch2.y.location, dx = x1 - x2, dy = y1 - y2;
	            return {
	                center: {
	                    x: (x1 + x2) / 2,
	                    y: (y1 + y2) / 2
	                },
	                distance: Math.sqrt(dx * dx + dy * dy)
	            };
	        }
	        function getTouches(e) {
	            var touches = [], originalEvent = e.originalEvent, currentTarget = e.currentTarget, idx = 0, length, changedTouches, touch;
	            if (e.api) {
	                touches.push({
	                    id: 2,
	                    event: e,
	                    target: e.target,
	                    currentTarget: e.target,
	                    location: e,
	                    type: 'api'
	                });
	            } else if (e.type.match(/touch/)) {
	                changedTouches = originalEvent ? originalEvent.changedTouches : [];
	                for (length = changedTouches.length; idx < length; idx++) {
	                    touch = changedTouches[idx];
	                    touches.push({
	                        location: touch,
	                        event: e,
	                        target: touch.target,
	                        currentTarget: currentTarget,
	                        id: touch.identifier,
	                        type: 'touch'
	                    });
	                }
	            } else if (support.pointers || support.msPointers) {
	                touches.push({
	                    location: originalEvent,
	                    event: e,
	                    target: e.target,
	                    currentTarget: currentTarget,
	                    id: originalEvent.pointerId,
	                    type: 'pointer'
	                });
	            } else {
	                touches.push({
	                    id: 1,
	                    event: e,
	                    target: e.target,
	                    currentTarget: currentTarget,
	                    location: e,
	                    type: 'mouse'
	                });
	            }
	            return touches;
	        }
	        var TouchAxis = Class.extend({
	            init: function (axis, location) {
	                var that = this;
	                that.axis = axis;
	                that._updateLocationData(location);
	                that.startLocation = that.location;
	                that.velocity = that.delta = 0;
	                that.timeStamp = now();
	            },
	            move: function (location) {
	                var that = this, offset = location['page' + that.axis], timeStamp = now(), timeDelta = timeStamp - that.timeStamp || 1;
	                if (!offset && invalidZeroEvents) {
	                    return;
	                }
	                that.delta = offset - that.location;
	                that._updateLocationData(location);
	                that.initialDelta = offset - that.startLocation;
	                that.velocity = that.delta / timeDelta;
	                that.timeStamp = timeStamp;
	            },
	            _updateLocationData: function (location) {
	                var that = this, axis = that.axis;
	                that.location = location['page' + axis];
	                that.client = location['client' + axis];
	                that.screen = location['screen' + axis];
	            }
	        });
	        var Touch = Class.extend({
	            init: function (userEvents, target, touchInfo) {
	                extend(this, {
	                    x: new TouchAxis('X', touchInfo.location),
	                    y: new TouchAxis('Y', touchInfo.location),
	                    type: touchInfo.type,
	                    useClickAsTap: userEvents.useClickAsTap,
	                    threshold: userEvents.threshold || THRESHOLD[touchInfo.type],
	                    userEvents: userEvents,
	                    target: target,
	                    currentTarget: touchInfo.currentTarget,
	                    initialTouch: touchInfo.target,
	                    id: touchInfo.id,
	                    pressEvent: touchInfo,
	                    _moved: false,
	                    _finished: false
	                });
	            },
	            press: function () {
	                this._holdTimeout = setTimeout($.proxy(this, '_hold'), this.userEvents.minHold);
	                this._trigger(PRESS, this.pressEvent);
	            },
	            _hold: function () {
	                this._trigger(HOLD, this.pressEvent);
	            },
	            move: function (touchInfo) {
	                var that = this;
	                if (that._finished) {
	                    return;
	                }
	                that.x.move(touchInfo.location);
	                that.y.move(touchInfo.location);
	                if (!that._moved) {
	                    if (that._withinIgnoreThreshold()) {
	                        return;
	                    }
	                    if (!UserEvents.current || UserEvents.current === that.userEvents) {
	                        that._start(touchInfo);
	                    } else {
	                        return that.dispose();
	                    }
	                }
	                if (!that._finished) {
	                    that._trigger(MOVE, touchInfo);
	                }
	            },
	            end: function (touchInfo) {
	                this.endTime = now();
	                if (this._finished) {
	                    return;
	                }
	                this._finished = true;
	                this._trigger(RELEASE, touchInfo);
	                if (this._moved) {
	                    this._trigger(END, touchInfo);
	                } else {
	                    if (!this.useClickAsTap) {
	                        this._trigger(TAP, touchInfo);
	                    }
	                }
	                clearTimeout(this._holdTimeout);
	                this.dispose();
	            },
	            dispose: function () {
	                var userEvents = this.userEvents, activeTouches = userEvents.touches;
	                this._finished = true;
	                this.pressEvent = null;
	                clearTimeout(this._holdTimeout);
	                activeTouches.splice($.inArray(this, activeTouches), 1);
	            },
	            skip: function () {
	                this.dispose();
	            },
	            cancel: function () {
	                this.dispose();
	            },
	            isMoved: function () {
	                return this._moved;
	            },
	            _start: function (touchInfo) {
	                clearTimeout(this._holdTimeout);
	                this.startTime = now();
	                this._moved = true;
	                this._trigger(START, touchInfo);
	            },
	            _trigger: function (name, touchInfo) {
	                var that = this, jQueryEvent = touchInfo.event, data = {
	                        touch: that,
	                        x: that.x,
	                        y: that.y,
	                        target: that.target,
	                        event: jQueryEvent
	                    };
	                if (that.userEvents.notify(name, data)) {
	                    jQueryEvent.preventDefault();
	                }
	            },
	            _withinIgnoreThreshold: function () {
	                var xDelta = this.x.initialDelta, yDelta = this.y.initialDelta;
	                return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.threshold;
	            }
	        });
	        function withEachUpEvent(callback) {
	            var downEvents = kendo.eventMap.up.split(' '), idx = 0, length = downEvents.length;
	            for (; idx < length; idx++) {
	                callback(downEvents[idx]);
	            }
	        }
	        var UserEvents = Observable.extend({
	            init: function (element, options) {
	                var that = this, filter, ns = kendo.guid();
	                options = options || {};
	                filter = that.filter = options.filter;
	                that.threshold = options.threshold || DEFAULT_THRESHOLD;
	                that.minHold = options.minHold || DEFAULT_MIN_HOLD;
	                that.touches = [];
	                that._maxTouches = options.multiTouch ? 2 : 1;
	                that.allowSelection = options.allowSelection;
	                that.captureUpIfMoved = options.captureUpIfMoved;
	                that.useClickAsTap = !options.fastTap && !support.delayedClick();
	                that.eventNS = ns;
	                element = $(element).handler(that);
	                Observable.fn.init.call(that);
	                extend(that, {
	                    element: element,
	                    surface: options.global && ENABLE_GLOBAL_SURFACE ? $(element[0].ownerDocument.documentElement) : $(options.surface || element),
	                    stopPropagation: options.stopPropagation,
	                    pressed: false
	                });
	                that.surface.handler(that).on(kendo.applyEventMap('move', ns), '_move').on(kendo.applyEventMap('up cancel', ns), '_end');
	                element.on(kendo.applyEventMap('down', ns), filter, '_start');
	                if (that.useClickAsTap) {
	                    element.on(kendo.applyEventMap('click', ns), filter, '_click');
	                }
	                if (support.pointers || support.msPointers) {
	                    if (support.browser.version < 11) {
	                        element.css('-ms-touch-action', 'pinch-zoom double-tap-zoom');
	                    } else {
	                        element.css('touch-action', options.touchAction || 'none');
	                    }
	                }
	                if (options.preventDragEvent) {
	                    element.on(kendo.applyEventMap('dragstart', ns), kendo.preventDefault);
	                }
	                element.on(kendo.applyEventMap('mousedown', ns), filter, { root: element }, '_select');
	                if (that.captureUpIfMoved && support.eventCapture) {
	                    var surfaceElement = that.surface[0], preventIfMovingProxy = $.proxy(that.preventIfMoving, that);
	                    withEachUpEvent(function (eventName) {
	                        surfaceElement.addEventListener(eventName, preventIfMovingProxy, true);
	                    });
	                }
	                that.bind([
	                    PRESS,
	                    HOLD,
	                    TAP,
	                    START,
	                    MOVE,
	                    END,
	                    RELEASE,
	                    CANCEL,
	                    GESTURESTART,
	                    GESTURECHANGE,
	                    GESTUREEND,
	                    GESTURETAP,
	                    SELECT
	                ], options);
	            },
	            preventIfMoving: function (e) {
	                if (this._isMoved()) {
	                    e.preventDefault();
	                }
	            },
	            destroy: function () {
	                var that = this;
	                if (that._destroyed) {
	                    return;
	                }
	                that._destroyed = true;
	                if (that.captureUpIfMoved && support.eventCapture) {
	                    var surfaceElement = that.surface[0];
	                    withEachUpEvent(function (eventName) {
	                        surfaceElement.removeEventListener(eventName, that.preventIfMoving);
	                    });
	                }
	                that.element.kendoDestroy(that.eventNS);
	                that.surface.kendoDestroy(that.eventNS);
	                that.element.removeData('handler');
	                that.surface.removeData('handler');
	                that._disposeAll();
	                that.unbind();
	                delete that.surface;
	                delete that.element;
	                delete that.currentTarget;
	            },
	            capture: function () {
	                UserEvents.current = this;
	            },
	            cancel: function () {
	                this._disposeAll();
	                this.trigger(CANCEL);
	            },
	            notify: function (eventName, data) {
	                var that = this, touches = that.touches;
	                if (this._isMultiTouch()) {
	                    switch (eventName) {
	                    case MOVE:
	                        eventName = GESTURECHANGE;
	                        break;
	                    case END:
	                        eventName = GESTUREEND;
	                        break;
	                    case TAP:
	                        eventName = GESTURETAP;
	                        break;
	                    }
	                    extend(data, { touches: touches }, touchDelta(touches[0], touches[1]));
	                }
	                return this.trigger(eventName, extend(data, { type: eventName }));
	            },
	            press: function (x, y, target) {
	                this._apiCall('_start', x, y, target);
	            },
	            move: function (x, y) {
	                this._apiCall('_move', x, y);
	            },
	            end: function (x, y) {
	                this._apiCall('_end', x, y);
	            },
	            _isMultiTouch: function () {
	                return this.touches.length > 1;
	            },
	            _maxTouchesReached: function () {
	                return this.touches.length >= this._maxTouches;
	            },
	            _disposeAll: function () {
	                var touches = this.touches;
	                while (touches.length > 0) {
	                    touches.pop().dispose();
	                }
	            },
	            _isMoved: function () {
	                return $.grep(this.touches, function (touch) {
	                    return touch.isMoved();
	                }).length;
	            },
	            _select: function (e) {
	                if (!this.allowSelection || this.trigger(SELECT, { event: e })) {
	                    e.preventDefault();
	                }
	            },
	            _start: function (e) {
	                var that = this, idx = 0, filter = that.filter, target, touches = getTouches(e), length = touches.length, touch, which = e.which;
	                if (which && which > 1 || that._maxTouchesReached()) {
	                    return;
	                }
	                UserEvents.current = null;
	                that.currentTarget = e.currentTarget;
	                if (that.stopPropagation) {
	                    e.stopPropagation();
	                }
	                for (; idx < length; idx++) {
	                    if (that._maxTouchesReached()) {
	                        break;
	                    }
	                    touch = touches[idx];
	                    if (filter) {
	                        target = $(touch.currentTarget);
	                    } else {
	                        target = that.element;
	                    }
	                    if (!target.length) {
	                        continue;
	                    }
	                    touch = new Touch(that, target, touch);
	                    that.touches.push(touch);
	                    touch.press();
	                    if (that._isMultiTouch()) {
	                        that.notify('gesturestart', {});
	                    }
	                }
	            },
	            _move: function (e) {
	                this._eachTouch('move', e);
	            },
	            _end: function (e) {
	                this._eachTouch('end', e);
	            },
	            _click: function (e) {
	                var data = {
	                    touch: {
	                        initialTouch: e.target,
	                        target: $(e.currentTarget),
	                        endTime: now(),
	                        x: {
	                            location: e.pageX,
	                            client: e.clientX
	                        },
	                        y: {
	                            location: e.pageY,
	                            client: e.clientY
	                        }
	                    },
	                    x: e.pageX,
	                    y: e.pageY,
	                    target: $(e.currentTarget),
	                    event: e,
	                    type: 'tap'
	                };
	                if (this.trigger('tap', data)) {
	                    e.preventDefault();
	                }
	            },
	            _eachTouch: function (methodName, e) {
	                var that = this, dict = {}, touches = getTouches(e), activeTouches = that.touches, idx, touch, touchInfo, matchingTouch;
	                for (idx = 0; idx < activeTouches.length; idx++) {
	                    touch = activeTouches[idx];
	                    dict[touch.id] = touch;
	                }
	                for (idx = 0; idx < touches.length; idx++) {
	                    touchInfo = touches[idx];
	                    matchingTouch = dict[touchInfo.id];
	                    if (matchingTouch) {
	                        matchingTouch[methodName](touchInfo);
	                    }
	                }
	            },
	            _apiCall: function (type, x, y, target) {
	                this[type]({
	                    api: true,
	                    pageX: x,
	                    pageY: y,
	                    clientX: x,
	                    clientY: y,
	                    target: $(target || this.element)[0],
	                    stopPropagation: $.noop,
	                    preventDefault: $.noop
	                });
	            }
	        });
	        UserEvents.defaultThreshold = function (value) {
	            DEFAULT_THRESHOLD = value;
	        };
	        UserEvents.minHold = function (value) {
	            DEFAULT_MIN_HOLD = value;
	        };
	        kendo.getTouches = getTouches;
	        kendo.touchDelta = touchDelta;
	        kendo.UserEvents = UserEvents;
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(202),
	        __webpack_require__(209)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'draganddrop',
	        name: 'Drag & drop',
	        category: 'framework',
	        description: 'Drag & drop functionality for any DOM element.',
	        depends: [
	            'core',
	            'userevents'
	        ]
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, support = kendo.support, document = window.document, $window = $(window), Class = kendo.Class, Widget = kendo.ui.Widget, Observable = kendo.Observable, UserEvents = kendo.UserEvents, proxy = $.proxy, extend = $.extend, getOffset = kendo.getOffset, draggables = {}, dropTargets = {}, dropAreas = {}, lastDropTarget, elementUnderCursor = kendo.elementUnderCursor, KEYUP = 'keyup', CHANGE = 'change', DRAGSTART = 'dragstart', HOLD = 'hold', DRAG = 'drag', DRAGEND = 'dragend', DRAGCANCEL = 'dragcancel', HINTDESTROYED = 'hintDestroyed', DRAGENTER = 'dragenter', DRAGLEAVE = 'dragleave', DROP = 'drop';
	        function contains(parent, child) {
	            try {
	                return $.contains(parent, child) || parent == child;
	            } catch (e) {
	                return false;
	            }
	        }
	        function numericCssPropery(element, property) {
	            return parseInt(element.css(property), 10) || 0;
	        }
	        function within(value, range) {
	            return Math.min(Math.max(value, range.min), range.max);
	        }
	        function containerBoundaries(container, element) {
	            var offset = getOffset(container), minX = offset.left + numericCssPropery(container, 'borderLeftWidth') + numericCssPropery(container, 'paddingLeft'), minY = offset.top + numericCssPropery(container, 'borderTopWidth') + numericCssPropery(container, 'paddingTop'), maxX = minX + container.width() - element.outerWidth(true), maxY = minY + container.height() - element.outerHeight(true);
	            return {
	                x: {
	                    min: minX,
	                    max: maxX
	                },
	                y: {
	                    min: minY,
	                    max: maxY
	                }
	            };
	        }
	        function checkTarget(target, targets, areas) {
	            var theTarget, theFilter, i = 0, targetLen = targets && targets.length, areaLen = areas && areas.length;
	            while (target && target.parentNode) {
	                for (i = 0; i < targetLen; i++) {
	                    theTarget = targets[i];
	                    if (theTarget.element[0] === target) {
	                        return {
	                            target: theTarget,
	                            targetElement: target
	                        };
	                    }
	                }
	                for (i = 0; i < areaLen; i++) {
	                    theFilter = areas[i];
	                    if ($.contains(theFilter.element[0], target) && support.matchesSelector.call(target, theFilter.options.filter)) {
	                        return {
	                            target: theFilter,
	                            targetElement: target
	                        };
	                    }
	                }
	                target = target.parentNode;
	            }
	            return undefined;
	        }
	        var TapCapture = Observable.extend({
	            init: function (element, options) {
	                var that = this, domElement = element[0];
	                that.capture = false;
	                if (domElement.addEventListener) {
	                    $.each(kendo.eventMap.down.split(' '), function () {
	                        domElement.addEventListener(this, proxy(that._press, that), true);
	                    });
	                    $.each(kendo.eventMap.up.split(' '), function () {
	                        domElement.addEventListener(this, proxy(that._release, that), true);
	                    });
	                } else {
	                    $.each(kendo.eventMap.down.split(' '), function () {
	                        domElement.attachEvent(this, proxy(that._press, that));
	                    });
	                    $.each(kendo.eventMap.up.split(' '), function () {
	                        domElement.attachEvent(this, proxy(that._release, that));
	                    });
	                }
	                Observable.fn.init.call(that);
	                that.bind([
	                    'press',
	                    'release'
	                ], options || {});
	            },
	            captureNext: function () {
	                this.capture = true;
	            },
	            cancelCapture: function () {
	                this.capture = false;
	            },
	            _press: function (e) {
	                var that = this;
	                that.trigger('press');
	                if (that.capture) {
	                    e.preventDefault();
	                }
	            },
	            _release: function (e) {
	                var that = this;
	                that.trigger('release');
	                if (that.capture) {
	                    e.preventDefault();
	                    that.cancelCapture();
	                }
	            }
	        });
	        var PaneDimension = Observable.extend({
	            init: function (options) {
	                var that = this;
	                Observable.fn.init.call(that);
	                that.forcedEnabled = false;
	                $.extend(that, options);
	                that.scale = 1;
	                if (that.horizontal) {
	                    that.measure = 'offsetWidth';
	                    that.scrollSize = 'scrollWidth';
	                    that.axis = 'x';
	                } else {
	                    that.measure = 'offsetHeight';
	                    that.scrollSize = 'scrollHeight';
	                    that.axis = 'y';
	                }
	            },
	            makeVirtual: function () {
	                $.extend(this, {
	                    virtual: true,
	                    forcedEnabled: true,
	                    _virtualMin: 0,
	                    _virtualMax: 0
	                });
	            },
	            virtualSize: function (min, max) {
	                if (this._virtualMin !== min || this._virtualMax !== max) {
	                    this._virtualMin = min;
	                    this._virtualMax = max;
	                    this.update();
	                }
	            },
	            outOfBounds: function (offset) {
	                return offset > this.max || offset < this.min;
	            },
	            forceEnabled: function () {
	                this.forcedEnabled = true;
	            },
	            getSize: function () {
	                return this.container[0][this.measure];
	            },
	            getTotal: function () {
	                return this.element[0][this.scrollSize];
	            },
	            rescale: function (scale) {
	                this.scale = scale;
	            },
	            update: function (silent) {
	                var that = this, total = that.virtual ? that._virtualMax : that.getTotal(), scaledTotal = total * that.scale, size = that.getSize();
	                if (total === 0 && !that.forcedEnabled) {
	                    return;
	                }
	                that.max = that.virtual ? -that._virtualMin : 0;
	                that.size = size;
	                that.total = scaledTotal;
	                that.min = Math.min(that.max, size - scaledTotal);
	                that.minScale = size / total;
	                that.centerOffset = (scaledTotal - size) / 2;
	                that.enabled = that.forcedEnabled || scaledTotal > size;
	                if (!silent) {
	                    that.trigger(CHANGE, that);
	                }
	            }
	        });
	        var PaneDimensions = Observable.extend({
	            init: function (options) {
	                var that = this;
	                Observable.fn.init.call(that);
	                that.x = new PaneDimension(extend({ horizontal: true }, options));
	                that.y = new PaneDimension(extend({ horizontal: false }, options));
	                that.container = options.container;
	                that.forcedMinScale = options.minScale;
	                that.maxScale = options.maxScale || 100;
	                that.bind(CHANGE, options);
	            },
	            rescale: function (newScale) {
	                this.x.rescale(newScale);
	                this.y.rescale(newScale);
	                this.refresh();
	            },
	            centerCoordinates: function () {
	                return {
	                    x: Math.min(0, -this.x.centerOffset),
	                    y: Math.min(0, -this.y.centerOffset)
	                };
	            },
	            refresh: function () {
	                var that = this;
	                that.x.update();
	                that.y.update();
	                that.enabled = that.x.enabled || that.y.enabled;
	                that.minScale = that.forcedMinScale || Math.min(that.x.minScale, that.y.minScale);
	                that.fitScale = Math.max(that.x.minScale, that.y.minScale);
	                that.trigger(CHANGE);
	            }
	        });
	        var PaneAxis = Observable.extend({
	            init: function (options) {
	                var that = this;
	                extend(that, options);
	                Observable.fn.init.call(that);
	            },
	            outOfBounds: function () {
	                return this.dimension.outOfBounds(this.movable[this.axis]);
	            },
	            dragMove: function (delta) {
	                var that = this, dimension = that.dimension, axis = that.axis, movable = that.movable, position = movable[axis] + delta;
	                if (!dimension.enabled) {
	                    return;
	                }
	                if (position < dimension.min && delta < 0 || position > dimension.max && delta > 0) {
	                    delta *= that.resistance;
	                }
	                movable.translateAxis(axis, delta);
	                that.trigger(CHANGE, that);
	            }
	        });
	        var Pane = Class.extend({
	            init: function (options) {
	                var that = this, x, y, resistance, movable;
	                extend(that, { elastic: true }, options);
	                resistance = that.elastic ? 0.5 : 0;
	                movable = that.movable;
	                that.x = x = new PaneAxis({
	                    axis: 'x',
	                    dimension: that.dimensions.x,
	                    resistance: resistance,
	                    movable: movable
	                });
	                that.y = y = new PaneAxis({
	                    axis: 'y',
	                    dimension: that.dimensions.y,
	                    resistance: resistance,
	                    movable: movable
	                });
	                that.userEvents.bind([
	                    'press',
	                    'move',
	                    'end',
	                    'gesturestart',
	                    'gesturechange'
	                ], {
	                    gesturestart: function (e) {
	                        that.gesture = e;
	                        that.offset = that.dimensions.container.offset();
	                    },
	                    press: function (e) {
	                        if ($(e.event.target).closest('a').is('[data-navigate-on-press=true]')) {
	                            e.sender.cancel();
	                        }
	                    },
	                    gesturechange: function (e) {
	                        var previousGesture = that.gesture, previousCenter = previousGesture.center, center = e.center, scaleDelta = e.distance / previousGesture.distance, minScale = that.dimensions.minScale, maxScale = that.dimensions.maxScale, coordinates;
	                        if (movable.scale <= minScale && scaleDelta < 1) {
	                            scaleDelta += (1 - scaleDelta) * 0.8;
	                        }
	                        if (movable.scale * scaleDelta >= maxScale) {
	                            scaleDelta = maxScale / movable.scale;
	                        }
	                        var offsetX = movable.x + that.offset.left, offsetY = movable.y + that.offset.top;
	                        coordinates = {
	                            x: (offsetX - previousCenter.x) * scaleDelta + center.x - offsetX,
	                            y: (offsetY - previousCenter.y) * scaleDelta + center.y - offsetY
	                        };
	                        movable.scaleWith(scaleDelta);
	                        x.dragMove(coordinates.x);
	                        y.dragMove(coordinates.y);
	                        that.dimensions.rescale(movable.scale);
	                        that.gesture = e;
	                        e.preventDefault();
	                    },
	                    move: function (e) {
	                        if (e.event.target.tagName.match(/textarea|input/i)) {
	                            return;
	                        }
	                        if (x.dimension.enabled || y.dimension.enabled) {
	                            x.dragMove(e.x.delta);
	                            y.dragMove(e.y.delta);
	                            e.preventDefault();
	                        } else {
	                            e.touch.skip();
	                        }
	                    },
	                    end: function (e) {
	                        e.preventDefault();
	                    }
	                });
	            }
	        });
	        var TRANSFORM_STYLE = support.transitions.prefix + 'Transform', translate;
	        if (support.hasHW3D) {
	            translate = function (x, y, scale) {
	                return 'translate3d(' + x + 'px,' + y + 'px,0) scale(' + scale + ')';
	            };
	        } else {
	            translate = function (x, y, scale) {
	                return 'translate(' + x + 'px,' + y + 'px) scale(' + scale + ')';
	            };
	        }
	        var Movable = Observable.extend({
	            init: function (element) {
	                var that = this;
	                Observable.fn.init.call(that);
	                that.element = $(element);
	                that.element[0].style.webkitTransformOrigin = 'left top';
	                that.x = 0;
	                that.y = 0;
	                that.scale = 1;
	                that._saveCoordinates(translate(that.x, that.y, that.scale));
	            },
	            translateAxis: function (axis, by) {
	                this[axis] += by;
	                this.refresh();
	            },
	            scaleTo: function (scale) {
	                this.scale = scale;
	                this.refresh();
	            },
	            scaleWith: function (scaleDelta) {
	                this.scale *= scaleDelta;
	                this.refresh();
	            },
	            translate: function (coordinates) {
	                this.x += coordinates.x;
	                this.y += coordinates.y;
	                this.refresh();
	            },
	            moveAxis: function (axis, value) {
	                this[axis] = value;
	                this.refresh();
	            },
	            moveTo: function (coordinates) {
	                extend(this, coordinates);
	                this.refresh();
	            },
	            refresh: function () {
	                var that = this, x = that.x, y = that.y, newCoordinates;
	                if (that.round) {
	                    x = Math.round(x);
	                    y = Math.round(y);
	                }
	                newCoordinates = translate(x, y, that.scale);
	                if (newCoordinates != that.coordinates) {
	                    if (kendo.support.browser.msie && kendo.support.browser.version < 10) {
	                        that.element[0].style.position = 'absolute';
	                        that.element[0].style.left = that.x + 'px';
	                        that.element[0].style.top = that.y + 'px';
	                    } else {
	                        that.element[0].style[TRANSFORM_STYLE] = newCoordinates;
	                    }
	                    that._saveCoordinates(newCoordinates);
	                    that.trigger(CHANGE);
	                }
	            },
	            _saveCoordinates: function (coordinates) {
	                this.coordinates = coordinates;
	            }
	        });
	        function destroyDroppable(collection, widget) {
	            var groupName = widget.options.group, droppables = collection[groupName], i;
	            Widget.fn.destroy.call(widget);
	            if (droppables.length > 1) {
	                for (i = 0; i < droppables.length; i++) {
	                    if (droppables[i] == widget) {
	                        droppables.splice(i, 1);
	                        break;
	                    }
	                }
	            } else {
	                droppables.length = 0;
	                delete collection[groupName];
	            }
	        }
	        var DropTarget = Widget.extend({
	            init: function (element, options) {
	                var that = this;
	                Widget.fn.init.call(that, element, options);
	                var group = that.options.group;
	                if (!(group in dropTargets)) {
	                    dropTargets[group] = [that];
	                } else {
	                    dropTargets[group].push(that);
	                }
	            },
	            events: [
	                DRAGENTER,
	                DRAGLEAVE,
	                DROP
	            ],
	            options: {
	                name: 'DropTarget',
	                group: 'default'
	            },
	            destroy: function () {
	                destroyDroppable(dropTargets, this);
	            },
	            _trigger: function (eventName, e) {
	                var that = this, draggable = draggables[that.options.group];
	                if (draggable) {
	                    return that.trigger(eventName, extend({}, e.event, {
	                        draggable: draggable,
	                        dropTarget: e.dropTarget
	                    }));
	                }
	            },
	            _over: function (e) {
	                this._trigger(DRAGENTER, e);
	            },
	            _out: function (e) {
	                this._trigger(DRAGLEAVE, e);
	            },
	            _drop: function (e) {
	                var that = this, draggable = draggables[that.options.group];
	                if (draggable) {
	                    draggable.dropped = !that._trigger(DROP, e);
	                }
	            }
	        });
	        DropTarget.destroyGroup = function (groupName) {
	            var group = dropTargets[groupName] || dropAreas[groupName], i;
	            if (group) {
	                for (i = 0; i < group.length; i++) {
	                    Widget.fn.destroy.call(group[i]);
	                }
	                group.length = 0;
	                delete dropTargets[groupName];
	                delete dropAreas[groupName];
	            }
	        };
	        DropTarget._cache = dropTargets;
	        var DropTargetArea = DropTarget.extend({
	            init: function (element, options) {
	                var that = this;
	                Widget.fn.init.call(that, element, options);
	                var group = that.options.group;
	                if (!(group in dropAreas)) {
	                    dropAreas[group] = [that];
	                } else {
	                    dropAreas[group].push(that);
	                }
	            },
	            destroy: function () {
	                destroyDroppable(dropAreas, this);
	            },
	            options: {
	                name: 'DropTargetArea',
	                group: 'default',
	                filter: null
	            }
	        });
	        var Draggable = Widget.extend({
	            init: function (element, options) {
	                var that = this;
	                Widget.fn.init.call(that, element, options);
	                that._activated = false;
	                that.userEvents = new UserEvents(that.element, {
	                    global: true,
	                    allowSelection: true,
	                    filter: that.options.filter,
	                    threshold: that.options.distance,
	                    start: proxy(that._start, that),
	                    hold: proxy(that._hold, that),
	                    move: proxy(that._drag, that),
	                    end: proxy(that._end, that),
	                    cancel: proxy(that._cancel, that),
	                    select: proxy(that._select, that)
	                });
	                that._afterEndHandler = proxy(that._afterEnd, that);
	                that._captureEscape = proxy(that._captureEscape, that);
	            },
	            events: [
	                HOLD,
	                DRAGSTART,
	                DRAG,
	                DRAGEND,
	                DRAGCANCEL,
	                HINTDESTROYED
	            ],
	            options: {
	                name: 'Draggable',
	                distance: kendo.support.touch ? 0 : 5,
	                group: 'default',
	                cursorOffset: null,
	                axis: null,
	                container: null,
	                filter: null,
	                ignore: null,
	                holdToDrag: false,
	                autoScroll: false,
	                dropped: false
	            },
	            cancelHold: function () {
	                this._activated = false;
	            },
	            _captureEscape: function (e) {
	                var that = this;
	                if (e.keyCode === kendo.keys.ESC) {
	                    that._trigger(DRAGCANCEL, { event: e });
	                    that.userEvents.cancel();
	                }
	            },
	            _updateHint: function (e) {
	                var that = this, coordinates, options = that.options, boundaries = that.boundaries, axis = options.axis, cursorOffset = that.options.cursorOffset;
	                if (cursorOffset) {
	                    coordinates = {
	                        left: e.x.location + cursorOffset.left,
	                        top: e.y.location + cursorOffset.top
	                    };
	                } else {
	                    that.hintOffset.left += e.x.delta;
	                    that.hintOffset.top += e.y.delta;
	                    coordinates = $.extend({}, that.hintOffset);
	                }
	                if (boundaries) {
	                    coordinates.top = within(coordinates.top, boundaries.y);
	                    coordinates.left = within(coordinates.left, boundaries.x);
	                }
	                if (axis === 'x') {
	                    delete coordinates.top;
	                } else if (axis === 'y') {
	                    delete coordinates.left;
	                }
	                that.hint.css(coordinates);
	            },
	            _shouldIgnoreTarget: function (target) {
	                var ignoreSelector = this.options.ignore;
	                return ignoreSelector && $(target).is(ignoreSelector);
	            },
	            _select: function (e) {
	                if (!this._shouldIgnoreTarget(e.event.target)) {
	                    e.preventDefault();
	                }
	            },
	            _start: function (e) {
	                var that = this, options = that.options, container = options.container, hint = options.hint;
	                if (this._shouldIgnoreTarget(e.touch.initialTouch) || options.holdToDrag && !that._activated) {
	                    that.userEvents.cancel();
	                    return;
	                }
	                that.currentTarget = e.target;
	                that.currentTargetOffset = getOffset(that.currentTarget);
	                if (hint) {
	                    if (that.hint) {
	                        that.hint.stop(true, true).remove();
	                    }
	                    that.hint = kendo.isFunction(hint) ? $(hint.call(that, that.currentTarget)) : hint;
	                    var offset = getOffset(that.currentTarget);
	                    that.hintOffset = offset;
	                    that.hint.css({
	                        position: 'absolute',
	                        zIndex: 20000,
	                        left: offset.left,
	                        top: offset.top
	                    }).appendTo(document.body);
	                    that.angular('compile', function () {
	                        that.hint.removeAttr('ng-repeat');
	                        var scopeTarget = $(e.target);
	                        while (!scopeTarget.data('$$kendoScope') && scopeTarget.length) {
	                            scopeTarget = scopeTarget.parent();
	                        }
	                        return {
	                            elements: that.hint.get(),
	                            scopeFrom: scopeTarget.data('$$kendoScope')
	                        };
	                    });
	                }
	                draggables[options.group] = that;
	                that.dropped = false;
	                if (container) {
	                    that.boundaries = containerBoundaries(container, that.hint);
	                }
	                $(document).on(KEYUP, that._captureEscape);
	                if (that._trigger(DRAGSTART, e)) {
	                    that.userEvents.cancel();
	                    that._afterEnd();
	                }
	                that.userEvents.capture();
	            },
	            _hold: function (e) {
	                this.currentTarget = e.target;
	                if (this._trigger(HOLD, e)) {
	                    this.userEvents.cancel();
	                } else {
	                    this._activated = true;
	                }
	            },
	            _drag: function (e) {
	                e.preventDefault();
	                var cursorElement = this._elementUnderCursor(e);
	                if (this.options.autoScroll && this._cursorElement !== cursorElement) {
	                    this._scrollableParent = findScrollableParent(cursorElement);
	                    this._cursorElement = cursorElement;
	                }
	                this._lastEvent = e;
	                this._processMovement(e, cursorElement);
	                if (this.options.autoScroll) {
	                    if (this._scrollableParent[0]) {
	                        var velocity = autoScrollVelocity(e.x.location, e.y.location, scrollableViewPort(this._scrollableParent));
	                        this._scrollCompenstation = $.extend({}, this.hintOffset);
	                        this._scrollVelocity = velocity;
	                        if (velocity.y === 0 && velocity.x === 0) {
	                            clearInterval(this._scrollInterval);
	                            this._scrollInterval = null;
	                        } else if (!this._scrollInterval) {
	                            this._scrollInterval = setInterval($.proxy(this, '_autoScroll'), 50);
	                        }
	                    }
	                }
	                if (this.hint) {
	                    this._updateHint(e);
	                }
	            },
	            _processMovement: function (e, cursorElement) {
	                this._withDropTarget(cursorElement, function (target, targetElement) {
	                    if (!target) {
	                        if (lastDropTarget) {
	                            lastDropTarget._trigger(DRAGLEAVE, extend(e, { dropTarget: $(lastDropTarget.targetElement) }));
	                            lastDropTarget = null;
	                        }
	                        return;
	                    }
	                    if (lastDropTarget) {
	                        if (targetElement === lastDropTarget.targetElement) {
	                            return;
	                        }
	                        lastDropTarget._trigger(DRAGLEAVE, extend(e, { dropTarget: $(lastDropTarget.targetElement) }));
	                    }
	                    target._trigger(DRAGENTER, extend(e, { dropTarget: $(targetElement) }));
	                    lastDropTarget = extend(target, { targetElement: targetElement });
	                });
	                this._trigger(DRAG, extend(e, {
	                    dropTarget: lastDropTarget,
	                    elementUnderCursor: cursorElement
	                }));
	            },
	            _autoScroll: function () {
	                var parent = this._scrollableParent[0], velocity = this._scrollVelocity, compensation = this._scrollCompenstation;
	                if (!parent) {
	                    return;
	                }
	                var cursorElement = this._elementUnderCursor(this._lastEvent);
	                this._processMovement(this._lastEvent, cursorElement);
	                var yIsScrollable, xIsScrollable;
	                var isRootNode = parent === scrollableRoot()[0];
	                if (isRootNode) {
	                    yIsScrollable = document.body.scrollHeight > $window.height();
	                    xIsScrollable = document.body.scrollWidth > $window.width();
	                } else {
	                    yIsScrollable = parent.offsetHeight <= parent.scrollHeight;
	                    xIsScrollable = parent.offsetWidth <= parent.scrollWidth;
	                }
	                var yDelta = parent.scrollTop + velocity.y;
	                var yInBounds = yIsScrollable && yDelta > 0 && yDelta < parent.scrollHeight;
	                var xDelta = parent.scrollLeft + velocity.x;
	                var xInBounds = xIsScrollable && xDelta > 0 && xDelta < parent.scrollWidth;
	                if (yInBounds) {
	                    parent.scrollTop += velocity.y;
	                }
	                if (xInBounds) {
	                    parent.scrollLeft += velocity.x;
	                }
	                if (isRootNode && (xInBounds || yInBounds)) {
	                    if (yInBounds) {
	                        compensation.top += velocity.y;
	                    }
	                    if (xInBounds) {
	                        compensation.left += velocity.x;
	                    }
	                    this.hint.css(compensation);
	                }
	            },
	            _end: function (e) {
	                this._withDropTarget(this._elementUnderCursor(e), function (target, targetElement) {
	                    if (target) {
	                        target._drop(extend({}, e, { dropTarget: $(targetElement) }));
	                        lastDropTarget = null;
	                    }
	                });
	                this._cancel(this._trigger(DRAGEND, e));
	            },
	            _cancel: function (isDefaultPrevented) {
	                var that = this;
	                that._scrollableParent = null;
	                this._cursorElement = null;
	                clearInterval(this._scrollInterval);
	                that._activated = false;
	                if (that.hint && !that.dropped) {
	                    setTimeout(function () {
	                        that.hint.stop(true, true);
	                        if (isDefaultPrevented) {
	                            that._afterEndHandler();
	                        } else {
	                            that.hint.animate(that.currentTargetOffset, 'fast', that._afterEndHandler);
	                        }
	                    }, 0);
	                } else {
	                    that._afterEnd();
	                }
	            },
	            _trigger: function (eventName, e) {
	                var that = this;
	                return that.trigger(eventName, extend({}, e.event, {
	                    x: e.x,
	                    y: e.y,
	                    currentTarget: that.currentTarget,
	                    initialTarget: e.touch ? e.touch.initialTouch : null,
	                    dropTarget: e.dropTarget,
	                    elementUnderCursor: e.elementUnderCursor
	                }));
	            },
	            _elementUnderCursor: function (e) {
	                var target = elementUnderCursor(e), hint = this.hint;
	                if (hint && contains(hint[0], target)) {
	                    hint.hide();
	                    target = elementUnderCursor(e);
	                    if (!target) {
	                        target = elementUnderCursor(e);
	                    }
	                    hint.show();
	                }
	                return target;
	            },
	            _withDropTarget: function (element, callback) {
	                var result, group = this.options.group, targets = dropTargets[group], areas = dropAreas[group];
	                if (targets && targets.length || areas && areas.length) {
	                    result = checkTarget(element, targets, areas);
	                    if (result) {
	                        callback(result.target, result.targetElement);
	                    } else {
	                        callback();
	                    }
	                }
	            },
	            destroy: function () {
	                var that = this;
	                Widget.fn.destroy.call(that);
	                that._afterEnd();
	                that.userEvents.destroy();
	                this._scrollableParent = null;
	                this._cursorElement = null;
	                clearInterval(this._scrollInterval);
	                that.currentTarget = null;
	            },
	            _afterEnd: function () {
	                var that = this;
	                if (that.hint) {
	                    that.hint.remove();
	                }
	                delete draggables[that.options.group];
	                that.trigger('destroy');
	                that.trigger(HINTDESTROYED);
	                $(document).off(KEYUP, that._captureEscape);
	            }
	        });
	        kendo.ui.plugin(DropTarget);
	        kendo.ui.plugin(DropTargetArea);
	        kendo.ui.plugin(Draggable);
	        kendo.TapCapture = TapCapture;
	        kendo.containerBoundaries = containerBoundaries;
	        extend(kendo.ui, {
	            Pane: Pane,
	            PaneDimensions: PaneDimensions,
	            Movable: Movable
	        });
	        function scrollableViewPort(element) {
	            var root = scrollableRoot()[0], offset, top, left;
	            if (element[0] === root) {
	                top = root.scrollTop;
	                left = root.scrollLeft;
	                return {
	                    top: top,
	                    left: left,
	                    bottom: top + $window.height(),
	                    right: left + $window.width()
	                };
	            } else {
	                offset = element.offset();
	                offset.bottom = offset.top + element.height();
	                offset.right = offset.left + element.width();
	                return offset;
	            }
	        }
	        function scrollableRoot() {
	            return $(kendo.support.browser.chrome ? document.body : document.documentElement);
	        }
	        function findScrollableParent(element) {
	            var root = scrollableRoot();
	            if (!element || element === document.body || element === document.documentElement) {
	                return root;
	            }
	            var parent = $(element)[0];
	            while (parent && !kendo.isScrollable(parent) && parent !== document.body) {
	                parent = parent.parentNode;
	            }
	            if (parent === document.body) {
	                return root;
	            }
	            return $(parent);
	        }
	        function autoScrollVelocity(mouseX, mouseY, rect) {
	            var velocity = {
	                x: 0,
	                y: 0
	            };
	            var AUTO_SCROLL_AREA = 50;
	            if (mouseX - rect.left < AUTO_SCROLL_AREA) {
	                velocity.x = -(AUTO_SCROLL_AREA - (mouseX - rect.left));
	            } else if (rect.right - mouseX < AUTO_SCROLL_AREA) {
	                velocity.x = AUTO_SCROLL_AREA - (rect.right - mouseX);
	            }
	            if (mouseY - rect.top < AUTO_SCROLL_AREA) {
	                velocity.y = -(AUTO_SCROLL_AREA - (mouseY - rect.top));
	            } else if (rect.bottom - mouseY < AUTO_SCROLL_AREA) {
	                velocity.y = AUTO_SCROLL_AREA - (rect.bottom - mouseY);
	            }
	            return velocity;
	        }
	        kendo.ui.Draggable.utils = {
	            autoScrollVelocity: autoScrollVelocity,
	            scrollableViewPort: scrollableViewPort,
	            findScrollableParent: findScrollableParent
	        };
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(208),
	        __webpack_require__(210)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'mobile.scroller',
	        name: 'Scroller',
	        category: 'mobile',
	        description: 'The Kendo Mobile Scroller widget enables touch friendly kinetic scrolling for the contents of a given DOM element.',
	        depends: [
	            'fx',
	            'draganddrop'
	        ]
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, mobile = kendo.mobile, fx = kendo.effects, ui = mobile.ui, proxy = $.proxy, extend = $.extend, Widget = ui.Widget, Class = kendo.Class, Movable = kendo.ui.Movable, Pane = kendo.ui.Pane, PaneDimensions = kendo.ui.PaneDimensions, Transition = fx.Transition, Animation = fx.Animation, abs = Math.abs, SNAPBACK_DURATION = 500, SCROLLBAR_OPACITY = 0.7, FRICTION = 0.96, VELOCITY_MULTIPLIER = 10, MAX_VELOCITY = 55, OUT_OF_BOUNDS_FRICTION = 0.5, ANIMATED_SCROLLER_PRECISION = 5, RELEASECLASS = 'km-scroller-release', REFRESHCLASS = 'km-scroller-refresh', PULL = 'pull', CHANGE = 'change', RESIZE = 'resize', SCROLL = 'scroll', MOUSE_WHEEL_ID = 2;
	        var ZoomSnapBack = Animation.extend({
	            init: function (options) {
	                var that = this;
	                Animation.fn.init.call(that);
	                extend(that, options);
	                that.userEvents.bind('gestureend', proxy(that.start, that));
	                that.tapCapture.bind('press', proxy(that.cancel, that));
	            },
	            enabled: function () {
	                return this.movable.scale < this.dimensions.minScale;
	            },
	            done: function () {
	                return this.dimensions.minScale - this.movable.scale < 0.01;
	            },
	            tick: function () {
	                var movable = this.movable;
	                movable.scaleWith(1.1);
	                this.dimensions.rescale(movable.scale);
	            },
	            onEnd: function () {
	                var movable = this.movable;
	                movable.scaleTo(this.dimensions.minScale);
	                this.dimensions.rescale(movable.scale);
	            }
	        });
	        var DragInertia = Animation.extend({
	            init: function (options) {
	                var that = this;
	                Animation.fn.init.call(that);
	                extend(that, options, {
	                    transition: new Transition({
	                        axis: options.axis,
	                        movable: options.movable,
	                        onEnd: function () {
	                            that._end();
	                        }
	                    })
	                });
	                that.tapCapture.bind('press', function () {
	                    that.cancel();
	                });
	                that.userEvents.bind('end', proxy(that.start, that));
	                that.userEvents.bind('gestureend', proxy(that.start, that));
	                that.userEvents.bind('tap', proxy(that.onEnd, that));
	            },
	            onCancel: function () {
	                this.transition.cancel();
	            },
	            freeze: function (location) {
	                var that = this;
	                that.cancel();
	                that._moveTo(location);
	            },
	            onEnd: function () {
	                var that = this;
	                if (that.paneAxis.outOfBounds()) {
	                    that._snapBack();
	                } else {
	                    that._end();
	                }
	            },
	            done: function () {
	                return abs(this.velocity) < 1;
	            },
	            start: function (e) {
	                var that = this, velocity;
	                if (!that.dimension.enabled) {
	                    return;
	                }
	                if (that.paneAxis.outOfBounds()) {
	                    that._snapBack();
	                } else {
	                    velocity = e.touch.id === MOUSE_WHEEL_ID ? 0 : e.touch[that.axis].velocity;
	                    that.velocity = Math.max(Math.min(velocity * that.velocityMultiplier, MAX_VELOCITY), -MAX_VELOCITY);
	                    that.tapCapture.captureNext();
	                    Animation.fn.start.call(that);
	                }
	            },
	            tick: function () {
	                var that = this, dimension = that.dimension, friction = that.paneAxis.outOfBounds() ? OUT_OF_BOUNDS_FRICTION : that.friction, delta = that.velocity *= friction, location = that.movable[that.axis] + delta;
	                if (!that.elastic && dimension.outOfBounds(location)) {
	                    location = Math.max(Math.min(location, dimension.max), dimension.min);
	                    that.velocity = 0;
	                }
	                that.movable.moveAxis(that.axis, location);
	            },
	            _end: function () {
	                this.tapCapture.cancelCapture();
	                this.end();
	            },
	            _snapBack: function () {
	                var that = this, dimension = that.dimension, snapBack = that.movable[that.axis] > dimension.max ? dimension.max : dimension.min;
	                that._moveTo(snapBack);
	            },
	            _moveTo: function (location) {
	                this.transition.moveTo({
	                    location: location,
	                    duration: SNAPBACK_DURATION,
	                    ease: Transition.easeOutExpo
	                });
	            }
	        });
	        var AnimatedScroller = Animation.extend({
	            init: function (options) {
	                var that = this;
	                kendo.effects.Animation.fn.init.call(this);
	                extend(that, options, {
	                    origin: {},
	                    destination: {},
	                    offset: {}
	                });
	            },
	            tick: function () {
	                this._updateCoordinates();
	                this.moveTo(this.origin);
	            },
	            done: function () {
	                return abs(this.offset.y) < ANIMATED_SCROLLER_PRECISION && abs(this.offset.x) < ANIMATED_SCROLLER_PRECISION;
	            },
	            onEnd: function () {
	                this.moveTo(this.destination);
	                if (this.callback) {
	                    this.callback.call();
	                }
	            },
	            setCoordinates: function (from, to) {
	                this.offset = {};
	                this.origin = from;
	                this.destination = to;
	            },
	            setCallback: function (callback) {
	                if (callback && kendo.isFunction(callback)) {
	                    this.callback = callback;
	                } else {
	                    callback = undefined;
	                }
	            },
	            _updateCoordinates: function () {
	                this.offset = {
	                    x: (this.destination.x - this.origin.x) / 4,
	                    y: (this.destination.y - this.origin.y) / 4
	                };
	                this.origin = {
	                    y: this.origin.y + this.offset.y,
	                    x: this.origin.x + this.offset.x
	                };
	            }
	        });
	        var ScrollBar = Class.extend({
	            init: function (options) {
	                var that = this, horizontal = options.axis === 'x', element = $('<div class="km-touch-scrollbar km-' + (horizontal ? 'horizontal' : 'vertical') + '-scrollbar" />');
	                extend(that, options, {
	                    element: element,
	                    elementSize: 0,
	                    movable: new Movable(element),
	                    scrollMovable: options.movable,
	                    alwaysVisible: options.alwaysVisible,
	                    size: horizontal ? 'width' : 'height'
	                });
	                that.scrollMovable.bind(CHANGE, proxy(that.refresh, that));
	                that.container.append(element);
	                if (options.alwaysVisible) {
	                    that.show();
	                }
	            },
	            refresh: function () {
	                var that = this, axis = that.axis, dimension = that.dimension, paneSize = dimension.size, scrollMovable = that.scrollMovable, sizeRatio = paneSize / dimension.total, position = Math.round(-scrollMovable[axis] * sizeRatio), size = Math.round(paneSize * sizeRatio);
	                if (sizeRatio >= 1) {
	                    this.element.css('display', 'none');
	                } else {
	                    this.element.css('display', '');
	                }
	                if (position + size > paneSize) {
	                    size = paneSize - position;
	                } else if (position < 0) {
	                    size += position;
	                    position = 0;
	                }
	                if (that.elementSize != size) {
	                    that.element.css(that.size, size + 'px');
	                    that.elementSize = size;
	                }
	                that.movable.moveAxis(axis, position);
	            },
	            show: function () {
	                this.element.css({
	                    opacity: SCROLLBAR_OPACITY,
	                    visibility: 'visible'
	                });
	            },
	            hide: function () {
	                if (!this.alwaysVisible) {
	                    this.element.css({ opacity: 0 });
	                }
	            }
	        });
	        var Scroller = Widget.extend({
	            init: function (element, options) {
	                var that = this;
	                Widget.fn.init.call(that, element, options);
	                element = that.element;
	                that._native = that.options.useNative && kendo.support.hasNativeScrolling;
	                if (that._native) {
	                    element.addClass('km-native-scroller').prepend('<div class="km-scroll-header"/>');
	                    extend(that, {
	                        scrollElement: element,
	                        fixedContainer: element.children().first()
	                    });
	                    return;
	                }
	                element.css('overflow', 'hidden').addClass('km-scroll-wrapper').wrapInner('<div class="km-scroll-container"/>').prepend('<div class="km-scroll-header"/>');
	                var inner = element.children().eq(1), tapCapture = new kendo.TapCapture(element), movable = new Movable(inner), dimensions = new PaneDimensions({
	                        element: inner,
	                        container: element,
	                        forcedEnabled: that.options.zoom
	                    }), avoidScrolling = this.options.avoidScrolling, userEvents = new kendo.UserEvents(element, {
	                        touchAction: 'pan-y',
	                        fastTap: true,
	                        allowSelection: true,
	                        preventDragEvent: true,
	                        captureUpIfMoved: true,
	                        multiTouch: that.options.zoom,
	                        start: function (e) {
	                            dimensions.refresh();
	                            var velocityX = abs(e.x.velocity), velocityY = abs(e.y.velocity), horizontalSwipe = velocityX * 2 >= velocityY, originatedFromFixedContainer = $.contains(that.fixedContainer[0], e.event.target), verticalSwipe = velocityY * 2 >= velocityX;
	                            if (!originatedFromFixedContainer && !avoidScrolling(e) && that.enabled && (dimensions.x.enabled && horizontalSwipe || dimensions.y.enabled && verticalSwipe)) {
	                                userEvents.capture();
	                            } else {
	                                userEvents.cancel();
	                            }
	                        }
	                    }), pane = new Pane({
	                        movable: movable,
	                        dimensions: dimensions,
	                        userEvents: userEvents,
	                        elastic: that.options.elastic
	                    }), zoomSnapBack = new ZoomSnapBack({
	                        movable: movable,
	                        dimensions: dimensions,
	                        userEvents: userEvents,
	                        tapCapture: tapCapture
	                    }), animatedScroller = new AnimatedScroller({
	                        moveTo: function (coordinates) {
	                            that.scrollTo(coordinates.x, coordinates.y);
	                        }
	                    });
	                movable.bind(CHANGE, function () {
	                    that.scrollTop = -movable.y;
	                    that.scrollLeft = -movable.x;
	                    that.trigger(SCROLL, {
	                        scrollTop: that.scrollTop,
	                        scrollLeft: that.scrollLeft
	                    });
	                });
	                if (that.options.mousewheelScrolling) {
	                    element.on('DOMMouseScroll mousewheel', proxy(this, '_wheelScroll'));
	                }
	                extend(that, {
	                    movable: movable,
	                    dimensions: dimensions,
	                    zoomSnapBack: zoomSnapBack,
	                    animatedScroller: animatedScroller,
	                    userEvents: userEvents,
	                    pane: pane,
	                    tapCapture: tapCapture,
	                    pulled: false,
	                    enabled: true,
	                    scrollElement: inner,
	                    scrollTop: 0,
	                    scrollLeft: 0,
	                    fixedContainer: element.children().first()
	                });
	                that._initAxis('x');
	                that._initAxis('y');
	                that._wheelEnd = function () {
	                    that._wheel = false;
	                    that.userEvents.end(0, that._wheelY);
	                };
	                dimensions.refresh();
	                if (that.options.pullToRefresh) {
	                    that._initPullToRefresh();
	                }
	            },
	            _wheelScroll: function (e) {
	                if (!this._wheel) {
	                    this._wheel = true;
	                    this._wheelY = 0;
	                    this.userEvents.press(0, this._wheelY);
	                }
	                clearTimeout(this._wheelTimeout);
	                this._wheelTimeout = setTimeout(this._wheelEnd, 50);
	                var delta = kendo.wheelDeltaY(e);
	                if (delta) {
	                    this._wheelY += delta;
	                    this.userEvents.move(0, this._wheelY);
	                }
	                e.preventDefault();
	            },
	            makeVirtual: function () {
	                this.dimensions.y.makeVirtual();
	            },
	            virtualSize: function (min, max) {
	                this.dimensions.y.virtualSize(min, max);
	            },
	            height: function () {
	                return this.dimensions.y.size;
	            },
	            scrollHeight: function () {
	                return this.scrollElement[0].scrollHeight;
	            },
	            scrollWidth: function () {
	                return this.scrollElement[0].scrollWidth;
	            },
	            options: {
	                name: 'Scroller',
	                zoom: false,
	                pullOffset: 140,
	                visibleScrollHints: false,
	                elastic: true,
	                useNative: false,
	                mousewheelScrolling: true,
	                avoidScrolling: function () {
	                    return false;
	                },
	                pullToRefresh: false,
	                messages: {
	                    pullTemplate: 'Pull to refresh',
	                    releaseTemplate: 'Release to refresh',
	                    refreshTemplate: 'Refreshing'
	                }
	            },
	            events: [
	                PULL,
	                SCROLL,
	                RESIZE
	            ],
	            _resize: function () {
	                if (!this._native) {
	                    this.contentResized();
	                }
	            },
	            setOptions: function (options) {
	                var that = this;
	                Widget.fn.setOptions.call(that, options);
	                if (options.pullToRefresh) {
	                    that._initPullToRefresh();
	                }
	            },
	            reset: function () {
	                if (this._native) {
	                    this.scrollElement.scrollTop(0);
	                } else {
	                    this.movable.moveTo({
	                        x: 0,
	                        y: 0
	                    });
	                    this._scale(1);
	                }
	            },
	            contentResized: function () {
	                this.dimensions.refresh();
	                if (this.pane.x.outOfBounds()) {
	                    this.movable.moveAxis('x', this.dimensions.x.min);
	                }
	                if (this.pane.y.outOfBounds()) {
	                    this.movable.moveAxis('y', this.dimensions.y.min);
	                }
	            },
	            zoomOut: function () {
	                var dimensions = this.dimensions;
	                dimensions.refresh();
	                this._scale(dimensions.fitScale);
	                this.movable.moveTo(dimensions.centerCoordinates());
	            },
	            enable: function () {
	                this.enabled = true;
	            },
	            disable: function () {
	                this.enabled = false;
	            },
	            scrollTo: function (x, y) {
	                if (this._native) {
	                    this.scrollElement.scrollLeft(abs(x));
	                    this.scrollElement.scrollTop(abs(y));
	                } else {
	                    this.dimensions.refresh();
	                    this.movable.moveTo({
	                        x: x,
	                        y: y
	                    });
	                }
	            },
	            animatedScrollTo: function (x, y, callback) {
	                var from, to;
	                if (this._native) {
	                    this.scrollTo(x, y);
	                } else {
	                    from = {
	                        x: this.movable.x,
	                        y: this.movable.y
	                    };
	                    to = {
	                        x: x,
	                        y: y
	                    };
	                    this.animatedScroller.setCoordinates(from, to);
	                    this.animatedScroller.setCallback(callback);
	                    this.animatedScroller.start();
	                }
	            },
	            pullHandled: function () {
	                var that = this;
	                that.refreshHint.removeClass(REFRESHCLASS);
	                that.hintContainer.html(that.pullTemplate({}));
	                that.yinertia.onEnd();
	                that.xinertia.onEnd();
	                that.userEvents.cancel();
	            },
	            destroy: function () {
	                Widget.fn.destroy.call(this);
	                if (this.userEvents) {
	                    this.userEvents.destroy();
	                }
	            },
	            _scale: function (scale) {
	                this.dimensions.rescale(scale);
	                this.movable.scaleTo(scale);
	            },
	            _initPullToRefresh: function () {
	                var that = this;
	                that.dimensions.y.forceEnabled();
	                that.pullTemplate = kendo.template(that.options.messages.pullTemplate);
	                that.releaseTemplate = kendo.template(that.options.messages.releaseTemplate);
	                that.refreshTemplate = kendo.template(that.options.messages.refreshTemplate);
	                that.scrollElement.prepend('<span class="km-scroller-pull"><span class="km-icon"></span><span class="km-loading-left"></span><span class="km-loading-right"></span><span class="km-template">' + that.pullTemplate({}) + '</span></span>');
	                that.refreshHint = that.scrollElement.children().first();
	                that.hintContainer = that.refreshHint.children('.km-template');
	                that.pane.y.bind('change', proxy(that._paneChange, that));
	                that.userEvents.bind('end', proxy(that._dragEnd, that));
	            },
	            _dragEnd: function () {
	                var that = this;
	                if (!that.pulled) {
	                    return;
	                }
	                that.pulled = false;
	                that.refreshHint.removeClass(RELEASECLASS).addClass(REFRESHCLASS);
	                that.hintContainer.html(that.refreshTemplate({}));
	                that.yinertia.freeze(that.options.pullOffset / 2);
	                that.trigger('pull');
	            },
	            _paneChange: function () {
	                var that = this;
	                if (that.movable.y / OUT_OF_BOUNDS_FRICTION > that.options.pullOffset) {
	                    if (!that.pulled) {
	                        that.pulled = true;
	                        that.refreshHint.removeClass(REFRESHCLASS).addClass(RELEASECLASS);
	                        that.hintContainer.html(that.releaseTemplate({}));
	                    }
	                } else if (that.pulled) {
	                    that.pulled = false;
	                    that.refreshHint.removeClass(RELEASECLASS);
	                    that.hintContainer.html(that.pullTemplate({}));
	                }
	            },
	            _initAxis: function (axis) {
	                var that = this, movable = that.movable, dimension = that.dimensions[axis], tapCapture = that.tapCapture, paneAxis = that.pane[axis], scrollBar = new ScrollBar({
	                        axis: axis,
	                        movable: movable,
	                        dimension: dimension,
	                        container: that.element,
	                        alwaysVisible: that.options.visibleScrollHints
	                    });
	                dimension.bind(CHANGE, function () {
	                    scrollBar.refresh();
	                });
	                paneAxis.bind(CHANGE, function () {
	                    scrollBar.show();
	                });
	                that[axis + 'inertia'] = new DragInertia({
	                    axis: axis,
	                    paneAxis: paneAxis,
	                    movable: movable,
	                    tapCapture: tapCapture,
	                    userEvents: that.userEvents,
	                    dimension: dimension,
	                    elastic: that.options.elastic,
	                    friction: that.options.friction || FRICTION,
	                    velocityMultiplier: that.options.velocityMultiplier || VELOCITY_MULTIPLIER,
	                    end: function () {
	                        scrollBar.hide();
	                        that.trigger('scrollEnd', {
	                            axis: axis,
	                            scrollTop: that.scrollTop,
	                            scrollLeft: that.scrollLeft
	                        });
	                    }
	                });
	            }
	        });
	        ui.plugin(Scroller);
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(202)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'popup',
	        name: 'Pop-up',
	        category: 'framework',
	        depends: ['core'],
	        advanced: true
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, ui = kendo.ui, Widget = ui.Widget, support = kendo.support, getOffset = kendo.getOffset, OPEN = 'open', CLOSE = 'close', DEACTIVATE = 'deactivate', ACTIVATE = 'activate', CENTER = 'center', LEFT = 'left', RIGHT = 'right', TOP = 'top', BOTTOM = 'bottom', ABSOLUTE = 'absolute', HIDDEN = 'hidden', BODY = 'body', LOCATION = 'location', POSITION = 'position', VISIBLE = 'visible', EFFECTS = 'effects', ACTIVE = 'k-state-active', ACTIVEBORDER = 'k-state-border', ACTIVEBORDERREGEXP = /k-state-border-(\w+)/, ACTIVECHILDREN = '.k-picker-wrap, .k-dropdown-wrap, .k-link', MOUSEDOWN = 'down', DOCUMENT_ELEMENT = $(document.documentElement), WINDOW = $(window), SCROLL = 'scroll', cssPrefix = support.transitions.css, TRANSFORM = cssPrefix + 'transform', extend = $.extend, NS = '.kendoPopup', styles = [
	                'font-size',
	                'font-family',
	                'font-stretch',
	                'font-style',
	                'font-weight',
	                'line-height'
	            ];
	        function contains(container, target) {
	            if (!container || !target) {
	                return false;
	            }
	            return container === target || $.contains(container, target);
	        }
	        var Popup = Widget.extend({
	            init: function (element, options) {
	                var that = this, parentPopup;
	                options = options || {};
	                if (options.isRtl) {
	                    options.origin = options.origin || BOTTOM + ' ' + RIGHT;
	                    options.position = options.position || TOP + ' ' + RIGHT;
	                }
	                Widget.fn.init.call(that, element, options);
	                element = that.element;
	                options = that.options;
	                that.collisions = options.collision ? options.collision.split(' ') : [];
	                that.downEvent = kendo.applyEventMap(MOUSEDOWN, kendo.guid());
	                if (that.collisions.length === 1) {
	                    that.collisions.push(that.collisions[0]);
	                }
	                parentPopup = $(that.options.anchor).closest('.k-popup,.k-group').filter(':not([class^=km-])');
	                options.appendTo = $($(options.appendTo)[0] || parentPopup[0] || BODY);
	                that.element.hide().addClass('k-popup k-group k-reset').toggleClass('k-rtl', !!options.isRtl).css({ position: ABSOLUTE }).appendTo(options.appendTo).on('mouseenter' + NS, function () {
	                    that._hovered = true;
	                }).on('mouseleave' + NS, function () {
	                    that._hovered = false;
	                });
	                that.wrapper = $();
	                if (options.animation === false) {
	                    options.animation = {
	                        open: { effects: {} },
	                        close: {
	                            hide: true,
	                            effects: {}
	                        }
	                    };
	                }
	                extend(options.animation.open, {
	                    complete: function () {
	                        that.wrapper.css({ overflow: VISIBLE });
	                        that._activated = true;
	                        that._trigger(ACTIVATE);
	                    }
	                });
	                extend(options.animation.close, {
	                    complete: function () {
	                        that._animationClose();
	                    }
	                });
	                that._mousedownProxy = function (e) {
	                    that._mousedown(e);
	                };
	                if (support.mobileOS.android) {
	                    that._resizeProxy = function (e) {
	                        setTimeout(function () {
	                            that._resize(e);
	                        }, 600);
	                    };
	                } else {
	                    that._resizeProxy = function (e) {
	                        that._resize(e);
	                    };
	                }
	                if (options.toggleTarget) {
	                    $(options.toggleTarget).on(options.toggleEvent + NS, $.proxy(that.toggle, that));
	                }
	            },
	            events: [
	                OPEN,
	                ACTIVATE,
	                CLOSE,
	                DEACTIVATE
	            ],
	            options: {
	                name: 'Popup',
	                toggleEvent: 'click',
	                origin: BOTTOM + ' ' + LEFT,
	                position: TOP + ' ' + LEFT,
	                anchor: BODY,
	                appendTo: null,
	                collision: 'flip fit',
	                viewport: window,
	                copyAnchorStyles: true,
	                autosize: false,
	                modal: false,
	                adjustSize: {
	                    width: 0,
	                    height: 0
	                },
	                animation: {
	                    open: {
	                        effects: 'slideIn:down',
	                        transition: true,
	                        duration: 200
	                    },
	                    close: {
	                        duration: 100,
	                        hide: true
	                    }
	                }
	            },
	            _animationClose: function () {
	                var that = this;
	                var location = that.wrapper.data(LOCATION);
	                that.wrapper.hide();
	                if (location) {
	                    that.wrapper.css(location);
	                }
	                if (that.options.anchor != BODY) {
	                    that._hideDirClass();
	                }
	                that._closing = false;
	                that._trigger(DEACTIVATE);
	            },
	            destroy: function () {
	                var that = this, options = that.options, element = that.element.off(NS), parent;
	                Widget.fn.destroy.call(that);
	                if (options.toggleTarget) {
	                    $(options.toggleTarget).off(NS);
	                }
	                if (!options.modal) {
	                    DOCUMENT_ELEMENT.unbind(that.downEvent, that._mousedownProxy);
	                    that._toggleResize(false);
	                }
	                kendo.destroy(that.element.children());
	                element.removeData();
	                if (options.appendTo[0] === document.body) {
	                    parent = element.parent('.k-animation-container');
	                    if (parent[0]) {
	                        parent.remove();
	                    } else {
	                        element.remove();
	                    }
	                }
	            },
	            open: function (x, y) {
	                var that = this, fixed = {
	                        isFixed: !isNaN(parseInt(y, 10)),
	                        x: x,
	                        y: y
	                    }, element = that.element, options = that.options, animation, wrapper, anchor = $(options.anchor), mobile = element[0] && element.hasClass('km-widget');
	                if (!that.visible()) {
	                    if (options.copyAnchorStyles) {
	                        if (mobile && styles[0] == 'font-size') {
	                            styles.shift();
	                        }
	                        element.css(kendo.getComputedStyles(anchor[0], styles));
	                    }
	                    if (element.data('animating') || that._trigger(OPEN)) {
	                        return;
	                    }
	                    that._activated = false;
	                    if (!options.modal) {
	                        DOCUMENT_ELEMENT.unbind(that.downEvent, that._mousedownProxy).bind(that.downEvent, that._mousedownProxy);
	                        that._toggleResize(false);
	                        that._toggleResize(true);
	                    }
	                    that.wrapper = wrapper = kendo.wrap(element, options.autosize).css({
	                        overflow: HIDDEN,
	                        display: 'block',
	                        position: ABSOLUTE
	                    });
	                    if (support.mobileOS.android) {
	                        wrapper.css(TRANSFORM, 'translatez(0)');
	                    }
	                    wrapper.css(POSITION);
	                    if ($(options.appendTo)[0] == document.body) {
	                        wrapper.css(TOP, '-10000px');
	                    }
	                    that.flipped = that._position(fixed);
	                    animation = that._openAnimation();
	                    if (options.anchor != BODY) {
	                        that._showDirClass(animation);
	                    }
	                    element.data(EFFECTS, animation.effects).kendoStop(true).kendoAnimate(animation);
	                }
	            },
	            _openAnimation: function () {
	                var animation = extend(true, {}, this.options.animation.open);
	                animation.effects = kendo.parseEffects(animation.effects, this.flipped);
	                return animation;
	            },
	            _hideDirClass: function () {
	                var anchor = $(this.options.anchor);
	                var direction = ((anchor.attr('class') || '').match(ACTIVEBORDERREGEXP) || [
	                    '',
	                    'down'
	                ])[1];
	                var dirClass = ACTIVEBORDER + '-' + direction;
	                anchor.removeClass(dirClass).children(ACTIVECHILDREN).removeClass(ACTIVE).removeClass(dirClass);
	                this.element.removeClass(ACTIVEBORDER + '-' + kendo.directions[direction].reverse);
	            },
	            _showDirClass: function (animation) {
	                var direction = animation.effects.slideIn ? animation.effects.slideIn.direction : 'down';
	                var dirClass = ACTIVEBORDER + '-' + direction;
	                $(this.options.anchor).addClass(dirClass).children(ACTIVECHILDREN).addClass(ACTIVE).addClass(dirClass);
	                this.element.addClass(ACTIVEBORDER + '-' + kendo.directions[direction].reverse);
	            },
	            position: function () {
	                if (this.visible()) {
	                    this.flipped = this._position();
	                }
	            },
	            toggle: function () {
	                var that = this;
	                that[that.visible() ? CLOSE : OPEN]();
	            },
	            visible: function () {
	                return this.element.is(':' + VISIBLE);
	            },
	            close: function (skipEffects) {
	                var that = this, options = that.options, wrap, animation, openEffects, closeEffects;
	                if (that.visible()) {
	                    wrap = that.wrapper[0] ? that.wrapper : kendo.wrap(that.element).hide();
	                    that._toggleResize(false);
	                    if (that._closing || that._trigger(CLOSE)) {
	                        that._toggleResize(true);
	                        return;
	                    }
	                    that.element.find('.k-popup').each(function () {
	                        var that = $(this), popup = that.data('kendoPopup');
	                        if (popup) {
	                            popup.close(skipEffects);
	                        }
	                    });
	                    DOCUMENT_ELEMENT.unbind(that.downEvent, that._mousedownProxy);
	                    if (skipEffects) {
	                        animation = {
	                            hide: true,
	                            effects: {}
	                        };
	                    } else {
	                        animation = extend(true, {}, options.animation.close);
	                        openEffects = that.element.data(EFFECTS);
	                        closeEffects = animation.effects;
	                        if (!closeEffects && !kendo.size(closeEffects) && openEffects && kendo.size(openEffects)) {
	                            animation.effects = openEffects;
	                            animation.reverse = true;
	                        }
	                        that._closing = true;
	                    }
	                    that.element.kendoStop(true);
	                    wrap.css({ overflow: HIDDEN });
	                    that.element.kendoAnimate(animation);
	                    if (skipEffects) {
	                        that._animationClose();
	                    }
	                }
	            },
	            _trigger: function (ev) {
	                return this.trigger(ev, { type: ev });
	            },
	            _resize: function (e) {
	                var that = this;
	                if (support.resize.indexOf(e.type) !== -1) {
	                    clearTimeout(that._resizeTimeout);
	                    that._resizeTimeout = setTimeout(function () {
	                        that._position();
	                        that._resizeTimeout = null;
	                    }, 50);
	                } else {
	                    if (!that._hovered || that._activated && that.element.hasClass('k-list-container')) {
	                        that.close();
	                    }
	                }
	            },
	            _toggleResize: function (toggle) {
	                var method = toggle ? 'on' : 'off';
	                var eventNames = support.resize;
	                if (!(support.mobileOS.ios || support.mobileOS.android)) {
	                    eventNames += ' ' + SCROLL;
	                }
	                this._scrollableParents()[method](SCROLL, this._resizeProxy);
	                WINDOW[method](eventNames, this._resizeProxy);
	            },
	            _mousedown: function (e) {
	                var that = this, container = that.element[0], options = that.options, anchor = $(options.anchor)[0], toggleTarget = options.toggleTarget, target = kendo.eventTarget(e), popup = $(target).closest('.k-popup'), mobile = popup.parent().parent('.km-shim').length;
	                popup = popup[0];
	                if (!mobile && popup && popup !== that.element[0]) {
	                    return;
	                }
	                if ($(e.target).closest('a').data('rel') === 'popover') {
	                    return;
	                }
	                if (!contains(container, target) && !contains(anchor, target) && !(toggleTarget && contains($(toggleTarget)[0], target))) {
	                    that.close();
	                }
	            },
	            _fit: function (position, size, viewPortSize) {
	                var output = 0;
	                if (position + size > viewPortSize) {
	                    output = viewPortSize - (position + size);
	                }
	                if (position < 0) {
	                    output = -position;
	                }
	                return output;
	            },
	            _flip: function (offset, size, anchorSize, viewPortSize, origin, position, boxSize) {
	                var output = 0;
	                boxSize = boxSize || size;
	                if (position !== origin && position !== CENTER && origin !== CENTER) {
	                    if (offset + boxSize > viewPortSize) {
	                        output += -(anchorSize + size);
	                    }
	                    if (offset + output < 0) {
	                        output += anchorSize + size;
	                    }
	                }
	                return output;
	            },
	            _scrollableParents: function () {
	                return $(this.options.anchor).parentsUntil('body').filter(function (index, element) {
	                    return kendo.isScrollable(element);
	                });
	            },
	            _position: function (fixed) {
	                var that = this, element = that.element, wrapper = that.wrapper, options = that.options, viewport = $(options.viewport), zoomLevel = support.zoomLevel(), isWindow = !!(viewport[0] == window && window.innerWidth && zoomLevel <= 1.02), anchor = $(options.anchor), origins = options.origin.toLowerCase().split(' '), positions = options.position.toLowerCase().split(' '), collisions = that.collisions, siblingContainer, parents, parentZIndex, zIndex = 10002, idx = 0, docEl = document.documentElement, length, viewportOffset, viewportWidth, viewportHeight;
	                if (options.viewport === window) {
	                    viewportOffset = {
	                        top: window.pageYOffset || document.documentElement.scrollTop || 0,
	                        left: window.pageXOffset || document.documentElement.scrollLeft || 0
	                    };
	                } else {
	                    viewportOffset = viewport.offset();
	                }
	                if (isWindow) {
	                    viewportWidth = window.innerWidth;
	                    viewportHeight = window.innerHeight;
	                } else {
	                    viewportWidth = viewport.width();
	                    viewportHeight = viewport.height();
	                }
	                if (isWindow && docEl.scrollHeight - docEl.clientHeight > 0) {
	                    viewportWidth -= kendo.support.scrollbar();
	                }
	                siblingContainer = anchor.parents().filter(wrapper.siblings());
	                if (siblingContainer[0]) {
	                    parentZIndex = Math.max(Number(siblingContainer.css('zIndex')), 0);
	                    if (parentZIndex) {
	                        zIndex = parentZIndex + 10;
	                    } else {
	                        parents = anchor.parentsUntil(siblingContainer);
	                        for (length = parents.length; idx < length; idx++) {
	                            parentZIndex = Number($(parents[idx]).css('zIndex'));
	                            if (parentZIndex && zIndex < parentZIndex) {
	                                zIndex = parentZIndex + 10;
	                            }
	                        }
	                    }
	                }
	                wrapper.css('zIndex', zIndex);
	                if (fixed && fixed.isFixed) {
	                    wrapper.css({
	                        left: fixed.x,
	                        top: fixed.y
	                    });
	                } else {
	                    wrapper.css(that._align(origins, positions));
	                }
	                var pos = getOffset(wrapper, POSITION, anchor[0] === wrapper.offsetParent()[0]), offset = getOffset(wrapper), anchorParent = anchor.offsetParent().parent('.k-animation-container,.k-popup,.k-group');
	                if (anchorParent.length) {
	                    pos = getOffset(wrapper, POSITION, true);
	                    offset = getOffset(wrapper);
	                }
	                offset.top -= viewportOffset.top;
	                offset.left -= viewportOffset.left;
	                if (!that.wrapper.data(LOCATION)) {
	                    wrapper.data(LOCATION, extend({}, pos));
	                }
	                var offsets = extend({}, offset), location = extend({}, pos), adjustSize = options.adjustSize;
	                if (collisions[0] === 'fit') {
	                    location.top += that._fit(offsets.top, wrapper.outerHeight() + adjustSize.height, viewportHeight / zoomLevel);
	                }
	                if (collisions[1] === 'fit') {
	                    location.left += that._fit(offsets.left, wrapper.outerWidth() + adjustSize.width, viewportWidth / zoomLevel);
	                }
	                var flipPos = extend({}, location);
	                var elementHeight = element.outerHeight();
	                var wrapperHeight = wrapper.outerHeight();
	                if (!wrapper.height() && elementHeight) {
	                    wrapperHeight = wrapperHeight + elementHeight;
	                }
	                if (collisions[0] === 'flip') {
	                    location.top += that._flip(offsets.top, elementHeight, anchor.outerHeight(), viewportHeight / zoomLevel, origins[0], positions[0], wrapperHeight);
	                }
	                if (collisions[1] === 'flip') {
	                    location.left += that._flip(offsets.left, element.outerWidth(), anchor.outerWidth(), viewportWidth / zoomLevel, origins[1], positions[1], wrapper.outerWidth());
	                }
	                element.css(POSITION, ABSOLUTE);
	                wrapper.css(location);
	                return location.left != flipPos.left || location.top != flipPos.top;
	            },
	            _align: function (origin, position) {
	                var that = this, element = that.wrapper, anchor = $(that.options.anchor), verticalOrigin = origin[0], horizontalOrigin = origin[1], verticalPosition = position[0], horizontalPosition = position[1], anchorOffset = getOffset(anchor), appendTo = $(that.options.appendTo), appendToOffset, width = element.outerWidth(), height = element.outerHeight(), anchorWidth = anchor.outerWidth(), anchorHeight = anchor.outerHeight(), top = anchorOffset.top, left = anchorOffset.left, round = Math.round;
	                if (appendTo[0] != document.body) {
	                    appendToOffset = getOffset(appendTo);
	                    top -= appendToOffset.top;
	                    left -= appendToOffset.left;
	                }
	                if (verticalOrigin === BOTTOM) {
	                    top += anchorHeight;
	                }
	                if (verticalOrigin === CENTER) {
	                    top += round(anchorHeight / 2);
	                }
	                if (verticalPosition === BOTTOM) {
	                    top -= height;
	                }
	                if (verticalPosition === CENTER) {
	                    top -= round(height / 2);
	                }
	                if (horizontalOrigin === RIGHT) {
	                    left += anchorWidth;
	                }
	                if (horizontalOrigin === CENTER) {
	                    left += round(anchorWidth / 2);
	                }
	                if (horizontalPosition === RIGHT) {
	                    left -= width;
	                }
	                if (horizontalPosition === CENTER) {
	                    left -= round(width / 2);
	                }
	                return {
	                    top: top,
	                    left: left
	                };
	            }
	        });
	        ui.plugin(Popup);
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(204),
	        __webpack_require__(212)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'list',
	        name: 'List',
	        category: 'framework',
	        depends: [
	            'data',
	            'popup'
	        ],
	        hidden: true
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, ui = kendo.ui, Widget = ui.Widget, keys = kendo.keys, support = kendo.support, htmlEncode = kendo.htmlEncode, activeElement = kendo._activeElement, ObservableArray = kendo.data.ObservableArray, ID = 'id', CHANGE = 'change', FOCUSED = 'k-state-focused', HOVER = 'k-state-hover', LOADING = 'k-i-loading', HIDDENCLASS = 'k-loading-hidden', OPEN = 'open', CLOSE = 'close', CASCADE = 'cascade', SELECT = 'select', SELECTED = 'selected', REQUESTSTART = 'requestStart', REQUESTEND = 'requestEnd', WIDTH = 'width', extend = $.extend, proxy = $.proxy, isArray = $.isArray, browser = support.browser, isIE8 = browser.msie && browser.version < 9, quotRegExp = /"/g, alternativeNames = {
	                'ComboBox': 'DropDownList',
	                'DropDownList': 'ComboBox'
	            };
	        var List = kendo.ui.DataBoundWidget.extend({
	            init: function (element, options) {
	                var that = this, ns = that.ns, id;
	                Widget.fn.init.call(that, element, options);
	                element = that.element;
	                options = that.options;
	                that._isSelect = element.is(SELECT);
	                if (that._isSelect && that.element[0].length) {
	                    if (!options.dataSource) {
	                        options.dataTextField = options.dataTextField || 'text';
	                        options.dataValueField = options.dataValueField || 'value';
	                    }
	                }
	                that.ul = $('<ul unselectable="on" class="k-list k-reset"/>').attr({
	                    tabIndex: -1,
	                    'aria-hidden': true
	                });
	                that.list = $('<div class=\'k-list-container\'/>').append(that.ul).on('mousedown' + ns, proxy(that._listMousedown, that));
	                id = element.attr(ID);
	                if (id) {
	                    that.list.attr(ID, id + '-list');
	                    that.ul.attr(ID, id + '_listbox');
	                }
	                that._header();
	                that._noData();
	                that._footer();
	                that._accessors();
	                that._initValue();
	            },
	            options: {
	                valuePrimitive: false,
	                footerTemplate: '',
	                headerTemplate: '',
	                noDataTemplate: 'No data found.'
	            },
	            setOptions: function (options) {
	                Widget.fn.setOptions.call(this, options);
	                if (options && options.enable !== undefined) {
	                    options.enabled = options.enable;
	                }
	                this._header();
	                this._noData();
	                this._footer();
	                this._renderFooter();
	                this._renderNoData();
	            },
	            focus: function () {
	                this._focused.focus();
	            },
	            readonly: function (readonly) {
	                this._editable({
	                    readonly: readonly === undefined ? true : readonly,
	                    disable: false
	                });
	            },
	            enable: function (enable) {
	                this._editable({
	                    readonly: false,
	                    disable: !(enable = enable === undefined ? true : enable)
	                });
	            },
	            _listOptions: function (options) {
	                var that = this;
	                var currentOptions = that.options;
	                var virtual = currentOptions.virtual;
	                var listBoundHandler = proxy(that._listBound, that);
	                virtual = typeof virtual === 'object' ? virtual : {};
	                options = $.extend({
	                    autoBind: false,
	                    selectable: true,
	                    dataSource: that.dataSource,
	                    click: proxy(that._click, that),
	                    change: proxy(that._listChange, that),
	                    activate: proxy(that._activateItem, that),
	                    deactivate: proxy(that._deactivateItem, that),
	                    dataBinding: function () {
	                        that.trigger('dataBinding');
	                    },
	                    dataBound: listBoundHandler,
	                    height: currentOptions.height,
	                    dataValueField: currentOptions.dataValueField,
	                    dataTextField: currentOptions.dataTextField,
	                    groupTemplate: currentOptions.groupTemplate,
	                    fixedGroupTemplate: currentOptions.fixedGroupTemplate,
	                    template: currentOptions.template
	                }, options, virtual);
	                if (!options.template) {
	                    options.template = '#:' + kendo.expr(options.dataTextField, 'data') + '#';
	                }
	                if (currentOptions.$angular) {
	                    options.$angular = currentOptions.$angular;
	                }
	                return options;
	            },
	            _initList: function () {
	                var that = this;
	                var listOptions = that._listOptions({ selectedItemChange: proxy(that._listChange, that) });
	                if (!that.options.virtual) {
	                    that.listView = new kendo.ui.StaticList(that.ul, listOptions);
	                } else {
	                    that.listView = new kendo.ui.VirtualList(that.ul, listOptions);
	                }
	                that.listView.bind('listBound', proxy(that._listBound, that));
	                that._setListValue();
	            },
	            _setListValue: function (value) {
	                value = value || this.options.value;
	                if (value !== undefined) {
	                    this.listView.value(value).done(proxy(this._updateSelectionState, this));
	                }
	            },
	            _updateSelectionState: $.noop,
	            _listMousedown: function (e) {
	                if (!this.filterInput || this.filterInput[0] !== e.target) {
	                    e.preventDefault();
	                }
	            },
	            _isFilterEnabled: function () {
	                var filter = this.options.filter;
	                return filter && filter !== 'none';
	            },
	            _hideClear: function () {
	                var that = this;
	                if (that._clear) {
	                    this._clear.addClass(HIDDENCLASS);
	                }
	            },
	            _showClear: function () {
	                var that = this;
	                if (that._clear) {
	                    this._clear.removeClass(HIDDENCLASS);
	                }
	            },
	            _clearValue: function () {
	                this.listView.value([]);
	                this._clearText();
	                this._accessor('');
	                if (this._isFilterEnabled()) {
	                    this._filter({
	                        word: '',
	                        open: false
	                    });
	                }
	                this._change();
	            },
	            _clearText: function () {
	                this.text('');
	            },
	            _clearFilter: function () {
	                if (!this.options.virtual) {
	                    this.listView.bound(false);
	                }
	                this._filterSource();
	            },
	            _filterSource: function (filter, force) {
	                var that = this;
	                var options = that.options;
	                var dataSource = that.dataSource;
	                var expression = extend({}, dataSource.filter() || {});
	                var removed = removeFiltersForField(expression, options.dataTextField);
	                if ((filter || removed) && that.trigger('filtering', { filter: filter })) {
	                    return;
	                }
	                expression = {
	                    filters: expression.filters || [],
	                    logic: 'and'
	                };
	                if (filter) {
	                    expression.filters.push(filter);
	                }
	                if (that._cascading) {
	                    this.listView.setDSFilter(expression);
	                }
	                if (!force) {
	                    dataSource.filter(expression);
	                } else {
	                    dataSource.read(dataSource._mergeState({ filter: expression }));
	                }
	            },
	            _angularElement: function (element, action) {
	                if (!element) {
	                    return;
	                }
	                this.angular(action, function () {
	                    return { elements: element };
	                });
	            },
	            _noData: function () {
	                var noData = $(this.noData);
	                var template = this.options.noDataTemplate;
	                this.angular('cleanup', function () {
	                    return { elements: noData };
	                });
	                kendo.destroy(noData);
	                noData.remove();
	                if (!template) {
	                    this.noData = null;
	                    return;
	                }
	                this.noData = $('<div class="k-nodata" style="display:none"><div></div></div>').appendTo(this.list);
	                this.noDataTemplate = typeof template !== 'function' ? kendo.template(template) : template;
	            },
	            _renderNoData: function () {
	                var noData = this.noData;
	                if (!noData) {
	                    return;
	                }
	                this._angularElement(noData, 'cleanup');
	                noData.children(':first').html(this.noDataTemplate({ instance: this }));
	                this._angularElement(noData, 'compile');
	            },
	            _toggleNoData: function (show) {
	                $(this.noData).toggle(show);
	            },
	            _footer: function () {
	                var footer = $(this.footer);
	                var template = this.options.footerTemplate;
	                this._angularElement(footer, 'cleanup');
	                kendo.destroy(footer);
	                footer.remove();
	                if (!template) {
	                    this.footer = null;
	                    return;
	                }
	                this.footer = $('<div class="k-footer"></div>').appendTo(this.list);
	                this.footerTemplate = typeof template !== 'function' ? kendo.template(template) : template;
	            },
	            _renderFooter: function () {
	                var footer = this.footer;
	                if (!footer) {
	                    return;
	                }
	                this._angularElement(footer, 'cleanup');
	                footer.html(this.footerTemplate({ instance: this }));
	                this._angularElement(footer, 'compile');
	            },
	            _header: function () {
	                var header = $(this.header);
	                var template = this.options.headerTemplate;
	                this._angularElement(header, 'cleanup');
	                kendo.destroy(header);
	                header.remove();
	                if (!template) {
	                    this.header = null;
	                    return;
	                }
	                var headerTemplate = typeof template !== 'function' ? kendo.template(template) : template;
	                header = $(headerTemplate({}));
	                this.header = header[0] ? header : null;
	                this.list.prepend(header);
	                this._angularElement(this.header, 'compile');
	            },
	            _allowOpening: function () {
	                return this.options.noDataTemplate || this.dataSource.flatView().length;
	            },
	            _initValue: function () {
	                var that = this, value = that.options.value;
	                if (value !== null) {
	                    that.element.val(value);
	                } else {
	                    value = that._accessor();
	                    that.options.value = value;
	                }
	                that._old = value;
	            },
	            _ignoreCase: function () {
	                var that = this, model = that.dataSource.reader.model, field;
	                if (model && model.fields) {
	                    field = model.fields[that.options.dataTextField];
	                    if (field && field.type && field.type !== 'string') {
	                        that.options.ignoreCase = false;
	                    }
	                }
	            },
	            _focus: function (candidate) {
	                return this.listView.focus(candidate);
	            },
	            _filter: function (options) {
	                var that = this;
	                var widgetOptions = that.options;
	                var ignoreCase = widgetOptions.ignoreCase;
	                var field = widgetOptions.dataTextField;
	                var expression = {
	                    value: ignoreCase ? options.word.toLowerCase() : options.word,
	                    field: field,
	                    operator: widgetOptions.filter,
	                    ignoreCase: ignoreCase
	                };
	                that._open = options.open;
	                that._filterSource(expression);
	            },
	            search: function (word) {
	                var options = this.options;
	                word = typeof word === 'string' ? word : this._inputValue();
	                clearTimeout(this._typingTimeout);
	                if (!options.enforceMinLength && !word.length || word.length >= options.minLength) {
	                    this._state = 'filter';
	                    if (!this._isFilterEnabled()) {
	                        this._searchByWord(word);
	                    } else {
	                        this._filter({
	                            word: word,
	                            open: true
	                        });
	                    }
	                }
	            },
	            current: function (candidate) {
	                return this._focus(candidate);
	            },
	            items: function () {
	                return this.ul[0].children;
	            },
	            destroy: function () {
	                var that = this;
	                var ns = that.ns;
	                Widget.fn.destroy.call(that);
	                that._unbindDataSource();
	                that.listView.destroy();
	                that.list.off(ns);
	                that.popup.destroy();
	                if (that._form) {
	                    that._form.off('reset', that._resetHandler);
	                }
	            },
	            dataItem: function (index) {
	                var that = this;
	                if (index === undefined) {
	                    return that.listView.selectedDataItems()[0];
	                }
	                if (typeof index !== 'number') {
	                    if (that.options.virtual) {
	                        return that.dataSource.getByUid($(index).data('uid'));
	                    }
	                    index = $(that.items()).index(index);
	                }
	                return that.dataSource.flatView()[index];
	            },
	            _activateItem: function () {
	                var current = this.listView.focus();
	                if (current) {
	                    this._focused.add(this.filterInput).attr('aria-activedescendant', current.attr('id'));
	                }
	            },
	            _deactivateItem: function () {
	                this._focused.add(this.filterInput).removeAttr('aria-activedescendant');
	            },
	            _accessors: function () {
	                var that = this;
	                var element = that.element;
	                var options = that.options;
	                var getter = kendo.getter;
	                var textField = element.attr(kendo.attr('text-field'));
	                var valueField = element.attr(kendo.attr('value-field'));
	                if (!options.dataTextField && textField) {
	                    options.dataTextField = textField;
	                }
	                if (!options.dataValueField && valueField) {
	                    options.dataValueField = valueField;
	                }
	                that._text = getter(options.dataTextField);
	                that._value = getter(options.dataValueField);
	            },
	            _aria: function (id) {
	                var that = this, options = that.options, element = that._focused.add(that.filterInput);
	                if (options.suggest !== undefined) {
	                    element.attr('aria-autocomplete', options.suggest ? 'both' : 'list');
	                }
	                id = id ? id + ' ' + that.ul[0].id : that.ul[0].id;
	                element.attr('aria-owns', id);
	                that.ul.attr('aria-live', !that._isFilterEnabled() ? 'off' : 'polite');
	            },
	            _blur: function () {
	                var that = this;
	                that._change();
	                that.close();
	            },
	            _change: function () {
	                var that = this;
	                var index = that.selectedIndex;
	                var optionValue = that.options.value;
	                var value = that.value();
	                var trigger;
	                if (that._isSelect && !that.listView.bound() && optionValue) {
	                    value = optionValue;
	                }
	                if (value !== unifyType(that._old, typeof value)) {
	                    trigger = true;
	                } else if (index !== undefined && index !== that._oldIndex) {
	                    trigger = true;
	                }
	                if (trigger) {
	                    that._old = value;
	                    that._oldIndex = index;
	                    if (!that._typing) {
	                        that.element.trigger(CHANGE);
	                    }
	                    that.trigger(CHANGE);
	                }
	                that.typing = false;
	            },
	            _data: function () {
	                return this.dataSource.view();
	            },
	            _enable: function () {
	                var that = this, options = that.options, disabled = that.element.is('[disabled]');
	                if (options.enable !== undefined) {
	                    options.enabled = options.enable;
	                }
	                if (!options.enabled || disabled) {
	                    that.enable(false);
	                } else {
	                    that.readonly(that.element.is('[readonly]'));
	                }
	            },
	            _dataValue: function (dataItem) {
	                var value = this._value(dataItem);
	                if (value === undefined) {
	                    value = this._text(dataItem);
	                }
	                return value;
	            },
	            _offsetHeight: function () {
	                var offsetHeight = 0;
	                var siblings = this.listView.content.prevAll(':visible');
	                siblings.each(function () {
	                    var element = $(this);
	                    if (element.hasClass('k-list-filter')) {
	                        offsetHeight += element.children().outerHeight();
	                    } else {
	                        offsetHeight += element.outerHeight();
	                    }
	                });
	                return offsetHeight;
	            },
	            _height: function (length) {
	                var that = this;
	                var list = that.list;
	                var height = that.options.height;
	                var visible = that.popup.visible();
	                var offsetTop;
	                var popups;
	                var footerHeight;
	                if (length || that.options.noDataTemplate) {
	                    popups = list.add(list.parent('.k-animation-container')).show();
	                    if (!list.is(':visible')) {
	                        popups.hide();
	                        return;
	                    }
	                    height = that.listView.content[0].scrollHeight > height ? height : 'auto';
	                    popups.height(height);
	                    if (height !== 'auto') {
	                        offsetTop = that._offsetHeight();
	                        footerHeight = $(that.footer).outerHeight() || 0;
	                        height = height - offsetTop - footerHeight;
	                    }
	                    that.listView.content.height(height);
	                    if (!visible) {
	                        popups.hide();
	                    }
	                }
	                return height;
	            },
	            _adjustListWidth: function () {
	                var list = this.list, width = list[0].style.width, wrapper = this.wrapper, computedStyle, computedWidth;
	                if (!list.data(WIDTH) && width) {
	                    return;
	                }
	                computedStyle = window.getComputedStyle ? window.getComputedStyle(wrapper[0], null) : 0;
	                computedWidth = parseFloat(computedStyle && computedStyle.width) || wrapper.outerWidth();
	                if (computedStyle && browser.msie) {
	                    computedWidth += parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight) + parseFloat(computedStyle.borderLeftWidth) + parseFloat(computedStyle.borderRightWidth);
	                }
	                if (list.css('box-sizing') !== 'border-box') {
	                    width = computedWidth - (list.outerWidth() - list.width());
	                } else {
	                    width = computedWidth;
	                }
	                list.css({
	                    fontFamily: wrapper.css('font-family'),
	                    width: this.options.autoWidth ? 'auto' : width,
	                    minWidth: width
	                }).data(WIDTH, width);
	                return true;
	            },
	            _openHandler: function (e) {
	                this._adjustListWidth();
	                if (this.trigger(OPEN)) {
	                    e.preventDefault();
	                } else {
	                    this._focused.attr('aria-expanded', true);
	                    this.ul.attr('aria-hidden', false);
	                }
	            },
	            _closeHandler: function (e) {
	                if (this.trigger(CLOSE)) {
	                    e.preventDefault();
	                } else {
	                    this._focused.attr('aria-expanded', false);
	                    this.ul.attr('aria-hidden', true);
	                }
	            },
	            _focusItem: function () {
	                var listView = this.listView;
	                var focusedItem = listView.focus();
	                var index = listView.select();
	                index = index[index.length - 1];
	                if (index === undefined && this.options.highlightFirst && !focusedItem) {
	                    index = 0;
	                }
	                if (index !== undefined) {
	                    listView.focus(index);
	                } else {
	                    listView.scrollToIndex(0);
	                }
	            },
	            _calculateGroupPadding: function (height) {
	                var li = this.ul.children('.k-first:first');
	                var groupHeader = this.listView.content.prev('.k-group-header');
	                var padding = 0;
	                if (groupHeader[0] && groupHeader[0].style.display !== 'none') {
	                    if (height !== 'auto') {
	                        padding = kendo.support.scrollbar();
	                    }
	                    padding += parseFloat(li.css('border-right-width'), 10) + parseFloat(li.children('.k-group').css('padding-right'), 10);
	                    groupHeader.css('padding-right', padding);
	                }
	            },
	            _calculatePopupHeight: function (force) {
	                var height = this._height(this.dataSource.flatView().length || force);
	                this._calculateGroupPadding(height);
	            },
	            _resizePopup: function (force) {
	                if (this.options.virtual) {
	                    return;
	                }
	                if (!this.popup.element.is(':visible')) {
	                    this.popup.one('open', function (force) {
	                        return proxy(function () {
	                            this._calculatePopupHeight(force);
	                        }, this);
	                    }.call(this, force));
	                } else {
	                    this._calculatePopupHeight(force);
	                }
	            },
	            _popup: function () {
	                var that = this;
	                that.popup = new ui.Popup(that.list, extend({}, that.options.popup, {
	                    anchor: that.wrapper,
	                    open: proxy(that._openHandler, that),
	                    close: proxy(that._closeHandler, that),
	                    animation: that.options.animation,
	                    isRtl: support.isRtl(that.wrapper)
	                }));
	            },
	            _makeUnselectable: function () {
	                if (isIE8) {
	                    this.list.find('*').not('.k-textbox').attr('unselectable', 'on');
	                }
	            },
	            _toggleHover: function (e) {
	                $(e.currentTarget).toggleClass(HOVER, e.type === 'mouseenter');
	            },
	            _toggle: function (open, preventFocus) {
	                var that = this;
	                var touchEnabled = support.mobileOS && (support.touch || support.MSPointers || support.pointers);
	                open = open !== undefined ? open : !that.popup.visible();
	                if (!preventFocus && !touchEnabled && that._focused[0] !== activeElement()) {
	                    that._prevent = true;
	                    that._focused.focus();
	                    that._prevent = false;
	                }
	                that[open ? OPEN : CLOSE]();
	            },
	            _triggerCascade: function () {
	                var that = this;
	                if (!that._cascadeTriggered || that._old !== that.value() || that._oldIndex !== that.selectedIndex) {
	                    that._cascadeTriggered = true;
	                    that.trigger(CASCADE, { userTriggered: that._userTriggered });
	                }
	            },
	            _triggerChange: function () {
	                if (this._valueBeforeCascade !== this.value()) {
	                    this.trigger(CHANGE);
	                }
	            },
	            _unbindDataSource: function () {
	                var that = this;
	                that.dataSource.unbind(REQUESTSTART, that._requestStartHandler).unbind(REQUESTEND, that._requestEndHandler).unbind('error', that._errorHandler);
	            },
	            requireValueMapper: function (options, value) {
	                var hasValue = (options.value instanceof Array ? options.value.length : options.value) || (value instanceof Array ? value.length : value);
	                if (hasValue && options.virtual && typeof options.virtual.valueMapper !== 'function') {
	                    throw new Error('ValueMapper is not provided while the value is being set. See http://docs.telerik.com/kendo-ui/controls/editors/combobox/virtualization#the-valuemapper-function');
	                }
	            }
	        });
	        function unifyType(value, type) {
	            if (value !== undefined && value !== '' && value !== null) {
	                if (type === 'boolean') {
	                    value = Boolean(value);
	                } else if (type === 'number') {
	                    value = Number(value);
	                } else if (type === 'string') {
	                    value = value.toString();
	                }
	            }
	            return value;
	        }
	        extend(List, {
	            inArray: function (node, parentNode) {
	                var idx, length, siblings = parentNode.children;
	                if (!node || node.parentNode !== parentNode) {
	                    return -1;
	                }
	                for (idx = 0, length = siblings.length; idx < length; idx++) {
	                    if (node === siblings[idx]) {
	                        return idx;
	                    }
	                }
	                return -1;
	            },
	            unifyType: unifyType
	        });
	        kendo.ui.List = List;
	        ui.Select = List.extend({
	            init: function (element, options) {
	                List.fn.init.call(this, element, options);
	                this._initial = this.element.val();
	            },
	            setDataSource: function (dataSource) {
	                var that = this;
	                var parent;
	                that.options.dataSource = dataSource;
	                that._dataSource();
	                if (that.listView.bound()) {
	                    that._initialIndex = null;
	                }
	                that.listView.setDataSource(that.dataSource);
	                if (that.options.autoBind) {
	                    that.dataSource.fetch();
	                }
	                parent = that._parentWidget();
	                if (parent) {
	                    that._cascadeSelect(parent);
	                }
	            },
	            close: function () {
	                this.popup.close();
	            },
	            select: function (candidate) {
	                var that = this;
	                if (candidate === undefined) {
	                    return that.selectedIndex;
	                } else {
	                    that._select(candidate);
	                    that._old = that._accessor();
	                    that._oldIndex = that.selectedIndex;
	                }
	            },
	            _accessor: function (value, idx) {
	                return this[this._isSelect ? '_accessorSelect' : '_accessorInput'](value, idx);
	            },
	            _accessorInput: function (value) {
	                var element = this.element[0];
	                if (value === undefined) {
	                    return element.value;
	                } else {
	                    if (value === null) {
	                        value = '';
	                    }
	                    element.value = value;
	                }
	            },
	            _accessorSelect: function (value, idx) {
	                var element = this.element[0];
	                var hasValue;
	                if (value === undefined) {
	                    return getSelectedOption(element).value || '';
	                }
	                getSelectedOption(element).selected = false;
	                if (idx === undefined) {
	                    idx = -1;
	                }
	                hasValue = value !== null && value !== '';
	                if (hasValue && idx == -1) {
	                    this._custom(value);
	                } else {
	                    if (value) {
	                        element.value = value;
	                    } else {
	                        element.selectedIndex = idx;
	                    }
	                }
	            },
	            _custom: function (value) {
	                var that = this;
	                var element = that.element;
	                var custom = that._customOption;
	                if (!custom) {
	                    custom = $('<option/>');
	                    that._customOption = custom;
	                    element.append(custom);
	                }
	                custom.text(value);
	                custom[0].selected = true;
	            },
	            _hideBusy: function () {
	                var that = this;
	                clearTimeout(that._busy);
	                that._arrow.removeClass(LOADING);
	                that._focused.attr('aria-busy', false);
	                that._busy = null;
	                that._showClear();
	            },
	            _showBusy: function () {
	                var that = this;
	                that._request = true;
	                if (that._busy) {
	                    return;
	                }
	                that._busy = setTimeout(function () {
	                    if (that._arrow) {
	                        that._focused.attr('aria-busy', true);
	                        that._arrow.addClass(LOADING);
	                        that._hideClear();
	                    }
	                }, 100);
	            },
	            _requestEnd: function () {
	                this._request = false;
	                this._hideBusy();
	            },
	            _dataSource: function () {
	                var that = this, element = that.element, options = that.options, dataSource = options.dataSource || {}, idx;
	                dataSource = $.isArray(dataSource) ? { data: dataSource } : dataSource;
	                if (that._isSelect) {
	                    idx = element[0].selectedIndex;
	                    if (idx > -1) {
	                        options.index = idx;
	                    }
	                    dataSource.select = element;
	                    dataSource.fields = [
	                        { field: options.dataTextField },
	                        { field: options.dataValueField }
	                    ];
	                }
	                if (that.dataSource) {
	                    that._unbindDataSource();
	                } else {
	                    that._requestStartHandler = proxy(that._showBusy, that);
	                    that._requestEndHandler = proxy(that._requestEnd, that);
	                    that._errorHandler = proxy(that._hideBusy, that);
	                }
	                that.dataSource = kendo.data.DataSource.create(dataSource).bind(REQUESTSTART, that._requestStartHandler).bind(REQUESTEND, that._requestEndHandler).bind('error', that._errorHandler);
	            },
	            _firstItem: function () {
	                this.listView.focusFirst();
	            },
	            _lastItem: function () {
	                this.listView.focusLast();
	            },
	            _nextItem: function () {
	                this.listView.focusNext();
	            },
	            _prevItem: function () {
	                this.listView.focusPrev();
	            },
	            _move: function (e) {
	                var that = this;
	                var listView = that.listView;
	                var key = e.keyCode;
	                var down = key === keys.DOWN;
	                var dataItem;
	                var pressed;
	                var current;
	                if (key === keys.UP || down) {
	                    if (e.altKey) {
	                        that.toggle(down);
	                    } else {
	                        if (!listView.bound()) {
	                            if (!that._fetch) {
	                                that.dataSource.one(CHANGE, function () {
	                                    that._fetch = false;
	                                    that._move(e);
	                                });
	                                that._fetch = true;
	                                that._filterSource();
	                            }
	                            e.preventDefault();
	                            return true;
	                        }
	                        current = that._focus();
	                        if (!that._fetch && (!current || current.hasClass('k-state-selected'))) {
	                            if (down) {
	                                that._nextItem();
	                                if (!that._focus()) {
	                                    that._lastItem();
	                                }
	                            } else {
	                                that._prevItem();
	                                if (!that._focus()) {
	                                    that._firstItem();
	                                }
	                            }
	                        }
	                        dataItem = listView.dataItemByIndex(listView.getElementIndex(that._focus()));
	                        if (that.trigger(SELECT, {
	                                dataItem: dataItem,
	                                item: that._focus()
	                            })) {
	                            that._focus(current);
	                            return;
	                        }
	                        that._select(that._focus(), true);
	                        if (!that.popup.visible()) {
	                            that._blur();
	                        }
	                    }
	                    e.preventDefault();
	                    pressed = true;
	                } else if (key === keys.ENTER || key === keys.TAB) {
	                    if (that.popup.visible()) {
	                        e.preventDefault();
	                    }
	                    current = that._focus();
	                    dataItem = that.dataItem();
	                    if (!that.popup.visible() && (!dataItem || that.text() !== that._text(dataItem))) {
	                        current = null;
	                    }
	                    var activeFilter = that.filterInput && that.filterInput[0] === activeElement();
	                    if (current) {
	                        dataItem = listView.dataItemByIndex(listView.getElementIndex(current));
	                        if (that.trigger(SELECT, {
	                                dataItem: dataItem,
	                                item: current
	                            })) {
	                            return;
	                        }
	                        that._select(current);
	                    } else if (that.input) {
	                        that._accessor(that.input.val());
	                        that.listView.value(that.input.val());
	                    }
	                    if (that._focusElement) {
	                        that._focusElement(that.wrapper);
	                    }
	                    if (activeFilter && key === keys.TAB) {
	                        that.wrapper.focusout();
	                    } else {
	                        that._blur();
	                    }
	                    that.close();
	                    pressed = true;
	                } else if (key === keys.ESC) {
	                    if (that.popup.visible()) {
	                        e.preventDefault();
	                    }
	                    that.close();
	                    pressed = true;
	                } else if (that.popup.visible() && (key === keys.PAGEDOWN || key === keys.PAGEUP)) {
	                    e.preventDefault();
	                    var direction = key === keys.PAGEDOWN ? 1 : -1;
	                    listView.scrollWith(direction * listView.screenHeight());
	                    pressed = true;
	                }
	                return pressed;
	            },
	            _fetchData: function () {
	                var that = this;
	                var hasItems = !!that.dataSource.view().length;
	                if (that._request || that.options.cascadeFrom) {
	                    return;
	                }
	                if (!that.listView.bound() && !that._fetch && !hasItems) {
	                    that._fetch = true;
	                    that.dataSource.fetch().done(function () {
	                        that._fetch = false;
	                    });
	                }
	            },
	            _options: function (data, optionLabel, value) {
	                var that = this, element = that.element, htmlElement = element[0], length = data.length, options = '', option, dataItem, dataText, dataValue, idx = 0;
	                if (optionLabel) {
	                    options = optionLabel;
	                }
	                for (; idx < length; idx++) {
	                    option = '<option';
	                    dataItem = data[idx];
	                    dataText = that._text(dataItem);
	                    dataValue = that._value(dataItem);
	                    if (dataValue !== undefined) {
	                        dataValue += '';
	                        if (dataValue.indexOf('"') !== -1) {
	                            dataValue = dataValue.replace(quotRegExp, '&quot;');
	                        }
	                        option += ' value="' + dataValue + '"';
	                    }
	                    option += '>';
	                    if (dataText !== undefined) {
	                        option += htmlEncode(dataText);
	                    }
	                    option += '</option>';
	                    options += option;
	                }
	                element.html(options);
	                if (value !== undefined) {
	                    htmlElement.value = value;
	                    if (htmlElement.value && !value) {
	                        htmlElement.selectedIndex = -1;
	                    }
	                }
	                if (htmlElement.selectedIndex !== -1) {
	                    option = getSelectedOption(htmlElement);
	                    if (option) {
	                        option.setAttribute(SELECTED, SELECTED);
	                    }
	                }
	            },
	            _reset: function () {
	                var that = this, element = that.element, formId = element.attr('form'), form = formId ? $('#' + formId) : element.closest('form');
	                if (form[0]) {
	                    that._resetHandler = function () {
	                        setTimeout(function () {
	                            that.value(that._initial);
	                        });
	                    };
	                    that._form = form.on('reset', that._resetHandler);
	                }
	            },
	            _parentWidget: function () {
	                var name = this.options.name;
	                if (!this.options.cascadeFrom) {
	                    return;
	                }
	                var parentElement = $('#' + this.options.cascadeFrom);
	                var parent = parentElement.data('kendo' + name);
	                if (!parent) {
	                    parent = parentElement.data('kendo' + alternativeNames[name]);
	                }
	                return parent;
	            },
	            _cascade: function () {
	                var that = this;
	                var options = that.options;
	                var cascade = options.cascadeFrom;
	                var parent;
	                if (cascade) {
	                    parent = that._parentWidget();
	                    that._cascadeHandlerProxy = proxy(that._cascadeHandler, that);
	                    if (!parent) {
	                        return;
	                    }
	                    options.autoBind = false;
	                    parent.bind('set', function () {
	                        that.one('set', function (e) {
	                            that._selectedValue = e.value;
	                        });
	                    });
	                    parent.first(CASCADE, that._cascadeHandlerProxy);
	                    if (parent.listView.bound()) {
	                        that._toggleCascadeOnFocus();
	                        that._cascadeSelect(parent);
	                    } else {
	                        parent.one('dataBound', function () {
	                            that._toggleCascadeOnFocus();
	                        });
	                        if (!parent.value()) {
	                            that.enable(false);
	                        }
	                    }
	                }
	            },
	            _toggleCascadeOnFocus: function () {
	                var that = this;
	                var parent = that._parentWidget();
	                parent._focused.add(parent.filterInput).bind('focus', function () {
	                    parent.unbind(CASCADE, that._cascadeHandlerProxy);
	                    parent.first(CHANGE, that._cascadeHandlerProxy);
	                });
	                parent._focused.add(parent.filterInput).bind('focusout', function () {
	                    parent.unbind(CHANGE, that._cascadeHandlerProxy);
	                    parent.first(CASCADE, that._cascadeHandlerProxy);
	                });
	            },
	            _cascadeHandler: function (e) {
	                var parent = this._parentWidget();
	                var valueBeforeCascade = this.value();
	                this._userTriggered = e.userTriggered;
	                if (this.listView.bound()) {
	                    this._clearSelection(parent, true);
	                }
	                this._cascadeSelect(parent, valueBeforeCascade);
	            },
	            _cascadeChange: function (parent) {
	                var that = this;
	                var value = that._accessor() || that._selectedValue;
	                that._selectedValue = null;
	                if (that._userTriggered) {
	                    that._clearSelection(parent, true);
	                } else if (value) {
	                    if (value !== that.listView.value()[0]) {
	                        that.value(value);
	                    }
	                    if (!that.dataSource.view()[0] || that.selectedIndex === -1) {
	                        that._clearSelection(parent, true);
	                    }
	                } else if (that.dataSource.flatView().length) {
	                    that.select(that.options.index);
	                }
	                that.enable();
	                that._triggerCascade();
	                that._triggerChange();
	                that._userTriggered = false;
	            },
	            _cascadeSelect: function (parent, valueBeforeCascade) {
	                var that = this;
	                var dataItem = parent.dataItem();
	                var filterValue = dataItem ? parent._value(dataItem) : null;
	                var valueField = that.options.cascadeFromField || parent.options.dataValueField;
	                var expressions;
	                that._valueBeforeCascade = valueBeforeCascade !== undefined ? valueBeforeCascade : that.value();
	                if (filterValue || filterValue === 0) {
	                    expressions = that.dataSource.filter() || {};
	                    removeFiltersForField(expressions, valueField);
	                    var handler = function () {
	                        that.unbind('dataBound', handler);
	                        that._cascadeChange(parent);
	                    };
	                    that.first('dataBound', handler);
	                    that._cascading = true;
	                    that._filterSource({
	                        field: valueField,
	                        operator: 'eq',
	                        value: filterValue
	                    });
	                    that._cascading = false;
	                } else {
	                    that.enable(false);
	                    that._clearSelection(parent);
	                    that._triggerCascade();
	                    that._triggerChange();
	                    that._userTriggered = false;
	                }
	            }
	        });
	        var STATIC_LIST_NS = '.StaticList';
	        var StaticList = kendo.ui.DataBoundWidget.extend({
	            init: function (element, options) {
	                Widget.fn.init.call(this, element, options);
	                this.element.attr('role', 'listbox').on('click' + STATIC_LIST_NS, 'li', proxy(this._click, this)).on('mouseenter' + STATIC_LIST_NS, 'li', function () {
	                    $(this).addClass(HOVER);
	                }).on('mouseleave' + STATIC_LIST_NS, 'li', function () {
	                    $(this).removeClass(HOVER);
	                });
	                this.content = this.element.wrap('<div class=\'k-list-scroller\' unselectable=\'on\'></div>').parent();
	                this.header = this.content.before('<div class="k-group-header" style="display:none"></div>').prev();
	                this.bound(false);
	                this._optionID = kendo.guid();
	                this._selectedIndices = [];
	                this._view = [];
	                this._dataItems = [];
	                this._values = [];
	                var value = this.options.value;
	                if (value) {
	                    this._values = $.isArray(value) ? value.slice(0) : [value];
	                }
	                this._getter();
	                this._templates();
	                this.setDataSource(this.options.dataSource);
	                this._onScroll = proxy(function () {
	                    var that = this;
	                    clearTimeout(that._scrollId);
	                    that._scrollId = setTimeout(function () {
	                        that._renderHeader();
	                    }, 50);
	                }, this);
	            },
	            options: {
	                name: 'StaticList',
	                dataValueField: null,
	                valuePrimitive: false,
	                selectable: true,
	                template: null,
	                groupTemplate: null,
	                fixedGroupTemplate: null
	            },
	            events: [
	                'click',
	                CHANGE,
	                'activate',
	                'deactivate',
	                'dataBinding',
	                'dataBound',
	                'selectedItemChange'
	            ],
	            setDataSource: function (source) {
	                var that = this;
	                var dataSource = source || {};
	                var value;
	                dataSource = $.isArray(dataSource) ? { data: dataSource } : dataSource;
	                dataSource = kendo.data.DataSource.create(dataSource);
	                if (that.dataSource) {
	                    that.dataSource.unbind(CHANGE, that._refreshHandler);
	                    value = that.value();
	                    that.value([]);
	                    that.bound(false);
	                    that.value(value);
	                } else {
	                    that._refreshHandler = proxy(that.refresh, that);
	                }
	                that.setDSFilter(dataSource.filter());
	                that.dataSource = dataSource.bind(CHANGE, that._refreshHandler);
	                that._fixedHeader();
	            },
	            skip: function () {
	                return this.dataSource.skip();
	            },
	            setOptions: function (options) {
	                Widget.fn.setOptions.call(this, options);
	                this._getter();
	                this._templates();
	                this._render();
	            },
	            destroy: function () {
	                this.element.off(STATIC_LIST_NS);
	                if (this._refreshHandler) {
	                    this.dataSource.unbind(CHANGE, this._refreshHandler);
	                }
	                clearTimeout(this._scrollId);
	                Widget.fn.destroy.call(this);
	            },
	            dataItemByIndex: function (index) {
	                return this.dataSource.flatView()[index];
	            },
	            screenHeight: function () {
	                return this.content[0].clientHeight;
	            },
	            scrollToIndex: function (index) {
	                var item = this.element[0].children[index];
	                if (item) {
	                    this.scroll(item);
	                }
	            },
	            scrollWith: function (value) {
	                this.content.scrollTop(this.content.scrollTop() + value);
	            },
	            scroll: function (item) {
	                if (!item) {
	                    return;
	                }
	                if (item[0]) {
	                    item = item[0];
	                }
	                var content = this.content[0], itemOffsetTop = item.offsetTop, itemOffsetHeight = item.offsetHeight, contentScrollTop = content.scrollTop, contentOffsetHeight = content.clientHeight, bottomDistance = itemOffsetTop + itemOffsetHeight;
	                if (contentScrollTop > itemOffsetTop) {
	                    contentScrollTop = itemOffsetTop;
	                } else if (bottomDistance > contentScrollTop + contentOffsetHeight) {
	                    contentScrollTop = bottomDistance - contentOffsetHeight;
	                }
	                content.scrollTop = contentScrollTop;
	            },
	            selectedDataItems: function (dataItems) {
	                if (dataItems === undefined) {
	                    return this._dataItems.slice();
	                }
	                this._dataItems = dataItems;
	                this._values = this._getValues(dataItems);
	            },
	            _getValues: function (dataItems) {
	                var getter = this._valueGetter;
	                return $.map(dataItems, function (dataItem) {
	                    return getter(dataItem);
	                });
	            },
	            focusNext: function () {
	                var current = this.focus();
	                if (!current) {
	                    current = 0;
	                } else {
	                    current = current.next();
	                }
	                this.focus(current);
	            },
	            focusPrev: function () {
	                var current = this.focus();
	                if (!current) {
	                    current = this.element[0].children.length - 1;
	                } else {
	                    current = current.prev();
	                }
	                this.focus(current);
	            },
	            focusFirst: function () {
	                this.focus(this.element[0].children[0]);
	            },
	            focusLast: function () {
	                this.focus(this.element[0].children[this.element[0].children.length - 1]);
	            },
	            focus: function (candidate) {
	                var that = this;
	                var id = that._optionID;
	                var hasCandidate;
	                if (candidate === undefined) {
	                    return that._current;
	                }
	                candidate = that._get(candidate);
	                candidate = candidate[candidate.length - 1];
	                candidate = $(this.element[0].children[candidate]);
	                if (that._current) {
	                    that._current.removeClass(FOCUSED).removeAttr('aria-selected').removeAttr(ID);
	                    that.trigger('deactivate');
	                }
	                hasCandidate = !!candidate[0];
	                if (hasCandidate) {
	                    candidate.addClass(FOCUSED);
	                    that.scroll(candidate);
	                    candidate.attr('id', id);
	                }
	                that._current = hasCandidate ? candidate : null;
	                that.trigger('activate');
	            },
	            focusIndex: function () {
	                return this.focus() ? this.focus().index() : undefined;
	            },
	            skipUpdate: function (skipUpdate) {
	                this._skipUpdate = skipUpdate;
	            },
	            select: function (indices) {
	                var that = this;
	                var selectable = that.options.selectable;
	                var singleSelection = selectable !== 'multiple' && selectable !== false;
	                var selectedIndices = that._selectedIndices;
	                var added = [];
	                var removed = [];
	                var result;
	                if (indices === undefined) {
	                    return selectedIndices.slice();
	                }
	                indices = that._get(indices);
	                if (indices.length === 1 && indices[0] === -1) {
	                    indices = [];
	                }
	                var filtered = that.isFiltered();
	                if (filtered && !singleSelection && that._deselectFiltered(indices)) {
	                    return;
	                }
	                if (singleSelection && !filtered && $.inArray(indices[indices.length - 1], selectedIndices) !== -1) {
	                    if (that._dataItems.length && that._view.length) {
	                        that._dataItems = [that._view[selectedIndices[0]].item];
	                    }
	                    return;
	                }
	                result = that._deselect(indices);
	                removed = result.removed;
	                indices = result.indices;
	                if (indices.length) {
	                    if (singleSelection) {
	                        indices = [indices[indices.length - 1]];
	                    }
	                    added = that._select(indices);
	                }
	                if (added.length || removed.length) {
	                    that._valueComparer = null;
	                    that.trigger(CHANGE, {
	                        added: added,
	                        removed: removed
	                    });
	                }
	            },
	            removeAt: function (position) {
	                this._selectedIndices.splice(position, 1);
	                this._values.splice(position, 1);
	                this._valueComparer = null;
	                return {
	                    position: position,
	                    dataItem: this._dataItems.splice(position, 1)[0]
	                };
	            },
	            setValue: function (value) {
	                value = $.isArray(value) || value instanceof ObservableArray ? value.slice(0) : [value];
	                this._values = value;
	                this._valueComparer = null;
	            },
	            value: function (value) {
	                var that = this;
	                var deferred = that._valueDeferred;
	                var indices;
	                if (value === undefined) {
	                    return that._values.slice();
	                }
	                that.setValue(value);
	                if (!deferred || deferred.state() === 'resolved') {
	                    that._valueDeferred = deferred = $.Deferred();
	                }
	                if (that.bound()) {
	                    indices = that._valueIndices(that._values);
	                    if (that.options.selectable === 'multiple') {
	                        that.select(-1);
	                    }
	                    that.select(indices);
	                    deferred.resolve();
	                }
	                that._skipUpdate = false;
	                return deferred;
	            },
	            items: function () {
	                return this.element.children('.k-item');
	            },
	            _click: function (e) {
	                if (!e.isDefaultPrevented()) {
	                    if (!this.trigger('click', { item: $(e.currentTarget) })) {
	                        this.select(e.currentTarget);
	                    }
	                }
	            },
	            _valueExpr: function (type, values) {
	                var that = this;
	                var idx = 0;
	                var body;
	                var comparer;
	                var normalized = [];
	                if (!that._valueComparer || that._valueType !== type) {
	                    that._valueType = type;
	                    for (; idx < values.length; idx++) {
	                        normalized.push(unifyType(values[idx], type));
	                    }
	                    body = 'for (var idx = 0; idx < ' + normalized.length + '; idx++) {' + ' if (current === values[idx]) {' + '   return idx;' + ' }' + '} ' + 'return -1;';
	                    comparer = new Function('current', 'values', body);
	                    that._valueComparer = function (current) {
	                        return comparer(current, normalized);
	                    };
	                }
	                return that._valueComparer;
	            },
	            _dataItemPosition: function (dataItem, values) {
	                var value = this._valueGetter(dataItem);
	                var valueExpr = this._valueExpr(typeof value, values);
	                return valueExpr(value);
	            },
	            _getter: function () {
	                this._valueGetter = kendo.getter(this.options.dataValueField);
	            },
	            _deselect: function (indices) {
	                var that = this;
	                var children = that.element[0].children;
	                var selectable = that.options.selectable;
	                var selectedIndices = that._selectedIndices;
	                var dataItems = that._dataItems;
	                var values = that._values;
	                var removed = [];
	                var i = 0;
	                var j;
	                var index, selectedIndex;
	                var removedIndices = 0;
	                indices = indices.slice();
	                if (selectable === true || !indices.length) {
	                    for (; i < selectedIndices.length; i++) {
	                        $(children[selectedIndices[i]]).removeClass('k-state-selected');
	                        removed.push({
	                            position: i,
	                            dataItem: dataItems[i]
	                        });
	                    }
	                    that._values = [];
	                    that._dataItems = [];
	                    that._selectedIndices = [];
	                } else if (selectable === 'multiple') {
	                    for (; i < indices.length; i++) {
	                        index = indices[i];
	                        if (!$(children[index]).hasClass('k-state-selected')) {
	                            continue;
	                        }
	                        for (j = 0; j < selectedIndices.length; j++) {
	                            selectedIndex = selectedIndices[j];
	                            if (selectedIndex === index) {
	                                $(children[selectedIndex]).removeClass('k-state-selected');
	                                removed.push({
	                                    position: j + removedIndices,
	                                    dataItem: dataItems.splice(j, 1)[0]
	                                });
	                                selectedIndices.splice(j, 1);
	                                indices.splice(i, 1);
	                                values.splice(j, 1);
	                                removedIndices += 1;
	                                i -= 1;
	                                j -= 1;
	                                break;
	                            }
	                        }
	                    }
	                }
	                return {
	                    indices: indices,
	                    removed: removed
	                };
	            },
	            _deselectFiltered: function (indices) {
	                var children = this.element[0].children;
	                var dataItem, index, position;
	                var removed = [];
	                var idx = 0;
	                for (; idx < indices.length; idx++) {
	                    index = indices[idx];
	                    dataItem = this._view[index].item;
	                    position = this._dataItemPosition(dataItem, this._values);
	                    if (position > -1) {
	                        removed.push(this.removeAt(position));
	                        $(children[index]).removeClass('k-state-selected');
	                    }
	                }
	                if (removed.length) {
	                    this.trigger(CHANGE, {
	                        added: [],
	                        removed: removed
	                    });
	                    return true;
	                }
	                return false;
	            },
	            _select: function (indices) {
	                var that = this;
	                var children = that.element[0].children;
	                var data = that._view;
	                var dataItem, index;
	                var added = [];
	                var idx = 0;
	                if (indices[indices.length - 1] !== -1) {
	                    that.focus(indices);
	                }
	                for (; idx < indices.length; idx++) {
	                    index = indices[idx];
	                    dataItem = data[index];
	                    if (index === -1 || !dataItem) {
	                        continue;
	                    }
	                    dataItem = dataItem.item;
	                    that._selectedIndices.push(index);
	                    that._dataItems.push(dataItem);
	                    that._values.push(that._valueGetter(dataItem));
	                    $(children[index]).addClass('k-state-selected').attr('aria-selected', true);
	                    added.push({ dataItem: dataItem });
	                }
	                return added;
	            },
	            getElementIndex: function (element) {
	                return $(element).data('offset-index');
	            },
	            _get: function (candidate) {
	                if (typeof candidate === 'number') {
	                    candidate = [candidate];
	                } else if (!isArray(candidate)) {
	                    candidate = this.getElementIndex(candidate);
	                    candidate = [candidate !== undefined ? candidate : -1];
	                }
	                return candidate;
	            },
	            _template: function () {
	                var that = this;
	                var options = that.options;
	                var template = options.template;
	                if (!template) {
	                    template = kendo.template('<li tabindex="-1" role="option" unselectable="on" class="k-item">${' + kendo.expr(options.dataTextField, 'data') + '}</li>', { useWithBlock: false });
	                } else {
	                    template = kendo.template(template);
	                    template = function (data) {
	                        return '<li tabindex="-1" role="option" unselectable="on" class="k-item">' + template(data) + '</li>';
	                    };
	                }
	                return template;
	            },
	            _templates: function () {
	                var template;
	                var options = this.options;
	                var templates = {
	                    template: options.template,
	                    groupTemplate: options.groupTemplate,
	                    fixedGroupTemplate: options.fixedGroupTemplate
	                };
	                for (var key in templates) {
	                    template = templates[key];
	                    if (template && typeof template !== 'function') {
	                        templates[key] = kendo.template(template);
	                    }
	                }
	                this.templates = templates;
	            },
	            _normalizeIndices: function (indices) {
	                var newIndices = [];
	                var idx = 0;
	                for (; idx < indices.length; idx++) {
	                    if (indices[idx] !== undefined) {
	                        newIndices.push(indices[idx]);
	                    }
	                }
	                return newIndices;
	            },
	            _valueIndices: function (values, indices) {
	                var data = this._view;
	                var idx = 0;
	                var index;
	                indices = indices ? indices.slice() : [];
	                if (!values.length) {
	                    return [];
	                }
	                for (; idx < data.length; idx++) {
	                    index = this._dataItemPosition(data[idx].item, values);
	                    if (index !== -1) {
	                        indices[index] = idx;
	                    }
	                }
	                return this._normalizeIndices(indices);
	            },
	            _firstVisibleItem: function () {
	                var element = this.element[0];
	                var content = this.content[0];
	                var scrollTop = content.scrollTop;
	                var itemHeight = $(element.children[0]).height();
	                var itemIndex = Math.floor(scrollTop / itemHeight) || 0;
	                var item = element.children[itemIndex] || element.lastChild;
	                var forward = item.offsetTop < scrollTop;
	                while (item) {
	                    if (forward) {
	                        if (item.offsetTop + itemHeight > scrollTop || !item.nextSibling) {
	                            break;
	                        }
	                        item = item.nextSibling;
	                    } else {
	                        if (item.offsetTop <= scrollTop || !item.previousSibling) {
	                            break;
	                        }
	                        item = item.previousSibling;
	                    }
	                }
	                return this._view[$(item).data('offset-index')];
	            },
	            _fixedHeader: function () {
	                if (this.isGrouped() && this.templates.fixedGroupTemplate) {
	                    this.header.show();
	                    this.content.scroll(this._onScroll);
	                } else {
	                    this.header.hide();
	                    this.content.off('scroll', this._onScroll);
	                }
	            },
	            _renderHeader: function () {
	                var template = this.templates.fixedGroupTemplate;
	                if (!template) {
	                    return;
	                }
	                var visibleItem = this._firstVisibleItem();
	                if (visibleItem) {
	                    this.header.html(template(visibleItem.group));
	                }
	            },
	            _renderItem: function (context) {
	                var item = '<li tabindex="-1" role="option" unselectable="on" class="k-item';
	                var dataItem = context.item;
	                var notFirstItem = context.index !== 0;
	                var selected = context.selected;
	                if (notFirstItem && context.newGroup) {
	                    item += ' k-first';
	                }
	                if (selected) {
	                    item += ' k-state-selected';
	                }
	                item += '"' + (selected ? ' aria-selected="true"' : '') + ' data-offset-index="' + context.index + '">';
	                item += this.templates.template(dataItem);
	                if (notFirstItem && context.newGroup) {
	                    item += '<div class="k-group">' + this.templates.groupTemplate(context.group) + '</div>';
	                }
	                return item + '</li>';
	            },
	            _render: function () {
	                var html = '';
	                var i = 0;
	                var idx = 0;
	                var context;
	                var dataContext = [];
	                var view = this.dataSource.view();
	                var values = this.value();
	                var group, newGroup, j;
	                var isGrouped = this.isGrouped();
	                if (isGrouped) {
	                    for (i = 0; i < view.length; i++) {
	                        group = view[i];
	                        newGroup = true;
	                        for (j = 0; j < group.items.length; j++) {
	                            context = {
	                                selected: this._selected(group.items[j], values),
	                                item: group.items[j],
	                                group: group.value,
	                                newGroup: newGroup,
	                                index: idx
	                            };
	                            dataContext[idx] = context;
	                            idx += 1;
	                            html += this._renderItem(context);
	                            newGroup = false;
	                        }
	                    }
	                } else {
	                    for (i = 0; i < view.length; i++) {
	                        context = {
	                            selected: this._selected(view[i], values),
	                            item: view[i],
	                            index: i
	                        };
	                        dataContext[i] = context;
	                        html += this._renderItem(context);
	                    }
	                }
	                this._view = dataContext;
	                this.element[0].innerHTML = html;
	                if (isGrouped && dataContext.length) {
	                    this._renderHeader();
	                }
	            },
	            _selected: function (dataItem, values) {
	                var select = !this.isFiltered() || this.options.selectable === 'multiple';
	                return select && this._dataItemPosition(dataItem, values) !== -1;
	            },
	            setDSFilter: function (filter) {
	                this._lastDSFilter = extend({}, filter);
	            },
	            isFiltered: function () {
	                if (!this._lastDSFilter) {
	                    this.setDSFilter(this.dataSource.filter());
	                }
	                return !kendo.data.Query.compareFilters(this.dataSource.filter(), this._lastDSFilter);
	            },
	            refresh: function (e) {
	                var that = this;
	                var action = e && e.action;
	                var skipUpdateOnBind = that.options.skipUpdateOnBind;
	                var isItemChange = action === 'itemchange';
	                var result;
	                that.trigger('dataBinding');
	                that._angularItems('cleanup');
	                that._fixedHeader();
	                that._render();
	                that.bound(true);
	                if (isItemChange || action === 'remove') {
	                    result = mapChangedItems(that._dataItems, e.items);
	                    if (result.changed.length) {
	                        if (isItemChange) {
	                            that.trigger('selectedItemChange', { items: result.changed });
	                        } else {
	                            that.value(that._getValues(result.unchanged));
	                        }
	                    }
	                } else if (that.isFiltered() || that._skipUpdate) {
	                    that.focus(0);
	                    if (that._skipUpdate) {
	                        that._skipUpdate = false;
	                        that._selectedIndices = that._valueIndices(that._values, that._selectedIndices);
	                    }
	                } else if (!skipUpdateOnBind && (!action || action === 'add')) {
	                    that.value(that._values);
	                }
	                if (that._valueDeferred) {
	                    that._valueDeferred.resolve();
	                }
	                that._angularItems('compile');
	                that.trigger('dataBound');
	            },
	            bound: function (bound) {
	                if (bound === undefined) {
	                    return this._bound;
	                }
	                this._bound = bound;
	            },
	            isGrouped: function () {
	                return (this.dataSource.group() || []).length;
	            }
	        });
	        ui.plugin(StaticList);
	        function getSelectedOption(select) {
	            var index = select.selectedIndex;
	            return index > -1 ? select.options[index] : {};
	        }
	        function mapChangedItems(selected, itemsToMatch) {
	            var itemsLength = itemsToMatch.length;
	            var selectedLength = selected.length;
	            var dataItem;
	            var found;
	            var i, j;
	            var changed = [];
	            var unchanged = [];
	            if (selectedLength) {
	                for (i = 0; i < selectedLength; i++) {
	                    dataItem = selected[i];
	                    found = false;
	                    for (j = 0; j < itemsLength; j++) {
	                        if (dataItem === itemsToMatch[j]) {
	                            found = true;
	                            changed.push({
	                                index: i,
	                                item: dataItem
	                            });
	                            break;
	                        }
	                    }
	                    if (!found) {
	                        unchanged.push(dataItem);
	                    }
	                }
	            }
	            return {
	                changed: changed,
	                unchanged: unchanged
	            };
	        }
	        function removeFiltersForField(expression, field) {
	            var filters;
	            var found = false;
	            if (expression.filters) {
	                filters = $.grep(expression.filters, function (filter) {
	                    found = removeFiltersForField(filter, field);
	                    if (filter.filters) {
	                        return filter.filters.length;
	                    } else {
	                        return filter.field != field;
	                    }
	                });
	                if (!found && expression.filters.length !== filters.length) {
	                    found = true;
	                }
	                expression.filters = filters;
	            }
	            return found;
	        }
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(213),
	        __webpack_require__(211)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'dropdownlist',
	        name: 'DropDownList',
	        category: 'web',
	        description: 'The DropDownList widget displays a list of values and allows the selection of a single value from the list.',
	        depends: ['list'],
	        features: [
	            {
	                id: 'mobile-scroller',
	                name: 'Mobile scroller',
	                description: 'Support for kinetic scrolling in mobile device',
	                depends: ['mobile.scroller']
	            },
	            {
	                id: 'virtualization',
	                name: 'VirtualList',
	                description: 'Support for virtualization',
	                depends: ['virtuallist']
	            }
	        ]
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, ui = kendo.ui, List = ui.List, Select = ui.Select, support = kendo.support, activeElement = kendo._activeElement, ObservableObject = kendo.data.ObservableObject, keys = kendo.keys, ns = '.kendoDropDownList', DISABLED = 'disabled', READONLY = 'readonly', CHANGE = 'change', FOCUSED = 'k-state-focused', DEFAULT = 'k-state-default', STATEDISABLED = 'k-state-disabled', ARIA_DISABLED = 'aria-disabled', HOVEREVENTS = 'mouseenter' + ns + ' mouseleave' + ns, TABINDEX = 'tabindex', STATE_FILTER = 'filter', STATE_ACCEPT = 'accept', MSG_INVALID_OPTION_LABEL = 'The `optionLabel` option is not valid due to missing fields. Define a custom optionLabel as shown here http://docs.telerik.com/kendo-ui/api/javascript/ui/dropdownlist#configuration-optionLabel', proxy = $.proxy;
	        var DropDownList = Select.extend({
	            init: function (element, options) {
	                var that = this;
	                var index = options && options.index;
	                var optionLabel, text, disabled;
	                that.ns = ns;
	                options = $.isArray(options) ? { dataSource: options } : options;
	                Select.fn.init.call(that, element, options);
	                options = that.options;
	                element = that.element.on('focus' + ns, proxy(that._focusHandler, that));
	                that._focusInputHandler = $.proxy(that._focusInput, that);
	                that.optionLabel = $();
	                that._optionLabel();
	                that._inputTemplate();
	                that._reset();
	                that._prev = '';
	                that._word = '';
	                that._wrapper();
	                that._tabindex();
	                that.wrapper.data(TABINDEX, that.wrapper.attr(TABINDEX));
	                that._span();
	                that._popup();
	                that._mobile();
	                that._dataSource();
	                that._ignoreCase();
	                that._filterHeader();
	                that._aria();
	                that._enable();
	                that._oldIndex = that.selectedIndex = -1;
	                if (index !== undefined) {
	                    options.index = index;
	                }
	                that._initialIndex = options.index;
	                that.requireValueMapper(that.options);
	                that._initList();
	                that._cascade();
	                if (options.autoBind) {
	                    that.dataSource.fetch();
	                } else if (that.selectedIndex === -1) {
	                    text = options.text || '';
	                    if (!text) {
	                        optionLabel = options.optionLabel;
	                        if (optionLabel && options.index === 0) {
	                            text = optionLabel;
	                        } else if (that._isSelect) {
	                            text = element.children(':selected').text();
	                        }
	                    }
	                    that._textAccessor(text);
	                }
	                disabled = $(that.element).parents('fieldset').is(':disabled');
	                if (disabled) {
	                    that.enable(false);
	                }
	                that.listView.bind('click', function (e) {
	                    e.preventDefault();
	                });
	                kendo.notify(that);
	            },
	            options: {
	                name: 'DropDownList',
	                enabled: true,
	                autoBind: true,
	                index: 0,
	                text: null,
	                value: null,
	                delay: 500,
	                height: 200,
	                dataTextField: '',
	                dataValueField: '',
	                optionLabel: '',
	                cascadeFrom: '',
	                cascadeFromField: '',
	                ignoreCase: true,
	                animation: {},
	                filter: 'none',
	                minLength: 1,
	                enforceMinLength: false,
	                virtual: false,
	                template: null,
	                valueTemplate: null,
	                optionLabelTemplate: null,
	                groupTemplate: '#:data#',
	                fixedGroupTemplate: '#:data#'
	            },
	            events: [
	                'open',
	                'close',
	                CHANGE,
	                'select',
	                'filtering',
	                'dataBinding',
	                'dataBound',
	                'cascade',
	                'set'
	            ],
	            setOptions: function (options) {
	                Select.fn.setOptions.call(this, options);
	                this.listView.setOptions(this._listOptions(options));
	                this._optionLabel();
	                this._inputTemplate();
	                this._accessors();
	                this._filterHeader();
	                this._enable();
	                this._aria();
	                if (!this.value() && this.hasOptionLabel()) {
	                    this.select(0);
	                }
	            },
	            destroy: function () {
	                var that = this;
	                Select.fn.destroy.call(that);
	                that.wrapper.off(ns);
	                that.element.off(ns);
	                that._inputWrapper.off(ns);
	                that._arrow.off();
	                that._arrow = null;
	                that.optionLabel.off();
	            },
	            open: function () {
	                var that = this;
	                if (that.popup.visible()) {
	                    return;
	                }
	                if (!that.listView.bound() || that._state === STATE_ACCEPT) {
	                    that._open = true;
	                    that._state = 'rebind';
	                    if (that.filterInput) {
	                        that.filterInput.val('');
	                        that._prev = '';
	                    }
	                    if (that.filterInput && that.options.minLength !== 1) {
	                        that.refresh();
	                        that.popup.one('activate', that._focusInputHandler);
	                        that.popup.open();
	                        if (that.filterInput) {
	                            that._resizeFilterInput();
	                        }
	                    } else {
	                        that._filterSource();
	                    }
	                } else if (that._allowOpening()) {
	                    that.popup.one('activate', that._focusInputHandler);
	                    that.popup.open();
	                    if (that.filterInput) {
	                        that._resizeFilterInput();
	                    }
	                    that._focusItem();
	                }
	            },
	            _focusInput: function () {
	                this._focusElement(this.filterInput);
	            },
	            _resizeFilterInput: function () {
	                this.filterInput.css('display', 'none');
	                this.filterInput.css('width', this.popup.element.css('width'));
	                this.filterInput.css('display', 'inline-block');
	            },
	            _allowOpening: function () {
	                return this.hasOptionLabel() || this.filterInput || Select.fn._allowOpening.call(this);
	            },
	            toggle: function (toggle) {
	                this._toggle(toggle, true);
	            },
	            current: function (candidate) {
	                var current;
	                if (candidate === undefined) {
	                    current = this.listView.focus();
	                    if (!current && this.selectedIndex === 0 && this.hasOptionLabel()) {
	                        return this.optionLabel;
	                    }
	                    return current;
	                }
	                this._focus(candidate);
	            },
	            dataItem: function (index) {
	                var that = this;
	                var dataItem = null;
	                if (index === null) {
	                    return index;
	                }
	                if (index === undefined) {
	                    dataItem = that.listView.selectedDataItems()[0];
	                } else {
	                    if (typeof index !== 'number') {
	                        if (that.options.virtual) {
	                            return that.dataSource.getByUid($(index).data('uid'));
	                        }
	                        if (index.hasClass('k-list-optionlabel')) {
	                            index = -1;
	                        } else {
	                            index = $(that.items()).index(index);
	                        }
	                    } else if (that.hasOptionLabel()) {
	                        index -= 1;
	                    }
	                    dataItem = that.dataSource.flatView()[index];
	                }
	                if (!dataItem) {
	                    dataItem = that._optionLabelDataItem();
	                }
	                return dataItem;
	            },
	            refresh: function () {
	                this.listView.refresh();
	            },
	            text: function (text) {
	                var that = this;
	                var dataItem, loweredText;
	                var ignoreCase = that.options.ignoreCase;
	                text = text === null ? '' : text;
	                if (text !== undefined) {
	                    if (typeof text === 'string') {
	                        loweredText = ignoreCase ? text.toLowerCase() : text;
	                        that._select(function (data) {
	                            data = that._text(data);
	                            if (ignoreCase) {
	                                data = (data + '').toLowerCase();
	                            }
	                            return data === loweredText;
	                        });
	                        dataItem = that.dataItem();
	                        if (dataItem) {
	                            text = dataItem;
	                        }
	                    }
	                    that._textAccessor(text);
	                } else {
	                    return that._textAccessor();
	                }
	            },
	            _clearFilter: function () {
	                $(this.filterInput).val('');
	                Select.fn._clearFilter.call(this);
	            },
	            value: function (value) {
	                var that = this;
	                var listView = that.listView;
	                var dataSource = that.dataSource;
	                if (value === undefined) {
	                    value = that._accessor() || that.listView.value()[0];
	                    return value === undefined || value === null ? '' : value;
	                }
	                that.requireValueMapper(that.options, value);
	                if (value || !that.hasOptionLabel()) {
	                    that._initialIndex = null;
	                }
	                this.trigger('set', { value: value });
	                if (that._request && that.options.cascadeFrom && that.listView.bound()) {
	                    if (that._valueSetter) {
	                        dataSource.unbind(CHANGE, that._valueSetter);
	                    }
	                    that._valueSetter = proxy(function () {
	                        that.value(value);
	                    }, that);
	                    dataSource.one(CHANGE, that._valueSetter);
	                    return;
	                }
	                if (that._isFilterEnabled() && listView.bound() && listView.isFiltered()) {
	                    that._clearFilter();
	                } else {
	                    that._fetchData();
	                }
	                listView.value(value).done(function () {
	                    if (that.selectedIndex === -1 && that.text()) {
	                        that.text('');
	                        that._accessor('', -1);
	                    }
	                    that._old = that._accessor();
	                    that._oldIndex = that.selectedIndex;
	                });
	            },
	            hasOptionLabel: function () {
	                return this.optionLabel && !!this.optionLabel[0];
	            },
	            _optionLabel: function () {
	                var that = this;
	                var options = that.options;
	                var optionLabel = options.optionLabel;
	                var template = options.optionLabelTemplate;
	                if (!optionLabel) {
	                    that.optionLabel.off().remove();
	                    that.optionLabel = $();
	                    return;
	                }
	                if (!template) {
	                    template = '#:';
	                    if (typeof optionLabel === 'string') {
	                        template += 'data';
	                    } else {
	                        template += kendo.expr(options.dataTextField, 'data');
	                    }
	                    template += '#';
	                }
	                if (typeof template !== 'function') {
	                    template = kendo.template(template);
	                }
	                that.optionLabelTemplate = template;
	                if (!that.hasOptionLabel()) {
	                    that.optionLabel = $('<div class="k-list-optionlabel"></div>').prependTo(that.list);
	                }
	                that.optionLabel.html(template(optionLabel)).off().click(proxy(that._click, that)).on(HOVEREVENTS, that._toggleHover);
	                that.angular('compile', function () {
	                    return {
	                        elements: that.optionLabel,
	                        data: [{ dataItem: that._optionLabelDataItem() }]
	                    };
	                });
	            },
	            _optionLabelText: function () {
	                var optionLabel = this.options.optionLabel;
	                return typeof optionLabel === 'string' ? optionLabel : this._text(optionLabel);
	            },
	            _optionLabelDataItem: function () {
	                var that = this;
	                var optionLabel = that.options.optionLabel;
	                if (that.hasOptionLabel()) {
	                    return $.isPlainObject(optionLabel) ? new ObservableObject(optionLabel) : that._assignInstance(that._optionLabelText(), '');
	                }
	                return null;
	            },
	            _buildOptions: function (data) {
	                var that = this;
	                if (!that._isSelect) {
	                    return;
	                }
	                var value = that.listView.value()[0];
	                var optionLabel = that._optionLabelDataItem();
	                var optionLabelValue = optionLabel && that._value(optionLabel);
	                if (value === undefined || value === null) {
	                    value = '';
	                }
	                if (optionLabel) {
	                    if (optionLabelValue === undefined || optionLabelValue === null) {
	                        optionLabelValue = '';
	                    }
	                    optionLabel = '<option value="' + optionLabelValue + '">' + that._text(optionLabel) + '</option>';
	                }
	                that._options(data, optionLabel, value);
	                if (value !== List.unifyType(that._accessor(), typeof value)) {
	                    that._customOption = null;
	                    that._custom(value);
	                }
	            },
	            _listBound: function () {
	                var that = this;
	                var initialIndex = that._initialIndex;
	                var filtered = that._state === STATE_FILTER;
	                var data = that.dataSource.flatView();
	                var dataItem;
	                that._presetValue = false;
	                that._renderFooter();
	                that._renderNoData();
	                that._toggleNoData(!data.length);
	                that._resizePopup(true);
	                that.popup.position();
	                that._buildOptions(data);
	                that._makeUnselectable();
	                if (!filtered) {
	                    if (that._open) {
	                        that.toggle(that._allowOpening());
	                    }
	                    that._open = false;
	                    if (!that._fetch) {
	                        if (data.length) {
	                            if (!that.listView.value().length && initialIndex > -1 && initialIndex !== null) {
	                                that.select(initialIndex);
	                            }
	                            that._initialIndex = null;
	                            dataItem = that.listView.selectedDataItems()[0];
	                            if (dataItem && that.text() !== that._text(dataItem)) {
	                                that._selectValue(dataItem);
	                            }
	                        } else if (that._textAccessor() !== that._optionLabelText()) {
	                            that.listView.value('');
	                            that._selectValue(null);
	                            that._oldIndex = that.selectedIndex;
	                        }
	                    }
	                }
	                that._hideBusy();
	                that.trigger('dataBound');
	            },
	            _listChange: function () {
	                this._selectValue(this.listView.selectedDataItems()[0]);
	                if (this._presetValue || this._old && this._oldIndex === -1) {
	                    this._oldIndex = this.selectedIndex;
	                }
	            },
	            _filterPaste: function () {
	                this._search();
	            },
	            _focusHandler: function () {
	                this.wrapper.focus();
	            },
	            _focusinHandler: function () {
	                this._inputWrapper.addClass(FOCUSED);
	                this._prevent = false;
	            },
	            _focusoutHandler: function () {
	                var that = this;
	                var filtered = that._state === STATE_FILTER;
	                var isIFrame = window.self !== window.top;
	                var focusedItem = that._focus();
	                var dataItem = that._getElementDataItem(focusedItem);
	                if (!that._prevent) {
	                    clearTimeout(that._typingTimeout);
	                    if (!filtered && focusedItem && !that.trigger('select', {
	                            dataItem: dataItem,
	                            item: focusedItem
	                        })) {
	                        that._select(focusedItem, !that.dataSource.view().length);
	                    }
	                    if (support.mobileOS.ios && isIFrame) {
	                        that._change();
	                    } else {
	                        that._blur();
	                    }
	                    that._inputWrapper.removeClass(FOCUSED);
	                    that._prevent = true;
	                    that._open = false;
	                    that.element.blur();
	                }
	            },
	            _wrapperMousedown: function () {
	                this._prevent = !!this.filterInput;
	            },
	            _wrapperClick: function (e) {
	                e.preventDefault();
	                this.popup.unbind('activate', this._focusInputHandler);
	                this._focused = this.wrapper;
	                this._toggle();
	            },
	            _editable: function (options) {
	                var that = this;
	                var element = that.element;
	                var disable = options.disable;
	                var readonly = options.readonly;
	                var wrapper = that.wrapper.add(that.filterInput).off(ns);
	                var dropDownWrapper = that._inputWrapper.off(HOVEREVENTS);
	                if (!readonly && !disable) {
	                    element.removeAttr(DISABLED).removeAttr(READONLY);
	                    dropDownWrapper.addClass(DEFAULT).removeClass(STATEDISABLED).on(HOVEREVENTS, that._toggleHover);
	                    wrapper.attr(TABINDEX, wrapper.data(TABINDEX)).attr(ARIA_DISABLED, false).on('keydown' + ns, proxy(that._keydown, that)).on('focusin' + ns, proxy(that._focusinHandler, that)).on('focusout' + ns, proxy(that._focusoutHandler, that)).on('mousedown' + ns, proxy(that._wrapperMousedown, that)).on('paste' + ns, proxy(that._filterPaste, that));
	                    that.wrapper.on('click' + ns, proxy(that._wrapperClick, that));
	                    if (!that.filterInput) {
	                        wrapper.on('keypress' + ns, proxy(that._keypress, that));
	                    }
	                } else if (disable) {
	                    wrapper.removeAttr(TABINDEX);
	                    dropDownWrapper.addClass(STATEDISABLED).removeClass(DEFAULT);
	                } else {
	                    dropDownWrapper.addClass(DEFAULT).removeClass(STATEDISABLED);
	                    wrapper.on('focusin' + ns, proxy(that._focusinHandler, that)).on('focusout' + ns, proxy(that._focusoutHandler, that));
	                }
	                element.attr(DISABLED, disable).attr(READONLY, readonly);
	                wrapper.attr(ARIA_DISABLED, disable);
	            },
	            _keydown: function (e) {
	                var that = this;
	                var key = e.keyCode;
	                var altKey = e.altKey;
	                var isInputActive;
	                var handled;
	                var isPopupVisible = that.popup.visible();
	                if (that.filterInput) {
	                    isInputActive = that.filterInput[0] === activeElement();
	                }
	                if (key === keys.LEFT) {
	                    key = keys.UP;
	                    handled = true;
	                } else if (key === keys.RIGHT) {
	                    key = keys.DOWN;
	                    handled = true;
	                }
	                if (handled && isInputActive) {
	                    return;
	                }
	                e.keyCode = key;
	                if (altKey && key === keys.UP || key === keys.ESC) {
	                    that._focusElement(that.wrapper);
	                }
	                if (that._state === STATE_FILTER && key === keys.ESC) {
	                    that._clearFilter();
	                }
	                if (key === keys.ENTER && that._typingTimeout && that.filterInput && isPopupVisible) {
	                    e.preventDefault();
	                    return;
	                }
	                handled = that._move(e);
	                if (handled) {
	                    return;
	                }
	                if (!isPopupVisible || !that.filterInput) {
	                    var current = that._focus();
	                    if (key === keys.HOME) {
	                        handled = true;
	                        that._firstItem();
	                    } else if (key === keys.END) {
	                        handled = true;
	                        that._lastItem();
	                    }
	                    if (handled) {
	                        if (that.trigger('select', {
	                                dataItem: that._getElementDataItem(that._focus()),
	                                item: that._focus()
	                            })) {
	                            that._focus(current);
	                            return;
	                        }
	                        that._select(that._focus(), true);
	                        if (!isPopupVisible) {
	                            that._blur();
	                        }
	                    }
	                }
	                if (!altKey && !handled && that.filterInput) {
	                    that._search();
	                }
	            },
	            _matchText: function (text, word) {
	                var ignoreCase = this.options.ignoreCase;
	                if (text === undefined || text === null) {
	                    return false;
	                }
	                text = text + '';
	                if (ignoreCase) {
	                    text = text.toLowerCase();
	                }
	                return text.indexOf(word) === 0;
	            },
	            _shuffleData: function (data, splitIndex) {
	                var optionDataItem = this._optionLabelDataItem();
	                if (optionDataItem) {
	                    data = [optionDataItem].concat(data);
	                }
	                return data.slice(splitIndex).concat(data.slice(0, splitIndex));
	            },
	            _selectNext: function () {
	                var that = this;
	                var data = that.dataSource.flatView();
	                var dataLength = data.length + (that.hasOptionLabel() ? 1 : 0);
	                var isInLoop = sameCharsOnly(that._word, that._last);
	                var startIndex = that.selectedIndex;
	                var oldFocusedItem;
	                var text;
	                if (startIndex === -1) {
	                    startIndex = 0;
	                } else {
	                    startIndex += isInLoop ? 1 : 0;
	                    startIndex = normalizeIndex(startIndex, dataLength);
	                }
	                data = data.toJSON ? data.toJSON() : data.slice();
	                data = that._shuffleData(data, startIndex);
	                for (var idx = 0; idx < dataLength; idx++) {
	                    text = that._text(data[idx]);
	                    if (isInLoop && that._matchText(text, that._last)) {
	                        break;
	                    } else if (that._matchText(text, that._word)) {
	                        break;
	                    }
	                }
	                if (idx !== dataLength) {
	                    oldFocusedItem = that._focus();
	                    that._select(normalizeIndex(startIndex + idx, dataLength));
	                    if (that.trigger('select', {
	                            dataItem: that._getElementDataItem(that._focus()),
	                            item: that._focus()
	                        })) {
	                        that._select(oldFocusedItem);
	                    }
	                    if (!that.popup.visible()) {
	                        that._change();
	                    }
	                }
	            },
	            _keypress: function (e) {
	                var that = this;
	                if (e.which === 0 || e.keyCode === kendo.keys.ENTER) {
	                    return;
	                }
	                var character = String.fromCharCode(e.charCode || e.keyCode);
	                if (that.options.ignoreCase) {
	                    character = character.toLowerCase();
	                }
	                if (character === ' ') {
	                    e.preventDefault();
	                }
	                that._word += character;
	                that._last = character;
	                that._search();
	            },
	            _popupOpen: function () {
	                var popup = this.popup;
	                popup.wrapper = kendo.wrap(popup.element);
	                if (popup.element.closest('.km-root')[0]) {
	                    popup.wrapper.addClass('km-popup km-widget');
	                    this.wrapper.addClass('km-widget');
	                }
	            },
	            _popup: function () {
	                Select.fn._popup.call(this);
	                this.popup.one('open', proxy(this._popupOpen, this));
	            },
	            _getElementDataItem: function (element) {
	                if (!element || !element[0]) {
	                    return null;
	                }
	                if (element[0] === this.optionLabel[0]) {
	                    return this._optionLabelDataItem();
	                }
	                return this.listView.dataItemByIndex(this.listView.getElementIndex(element));
	            },
	            _click: function (e) {
	                var item = e.item || $(e.currentTarget);
	                e.preventDefault();
	                if (this.trigger('select', {
	                        dataItem: this._getElementDataItem(item),
	                        item: item
	                    })) {
	                    this.close();
	                    return;
	                }
	                this._userTriggered = true;
	                this._select(item);
	                this._focusElement(this.wrapper);
	                this._blur();
	            },
	            _focusElement: function (element) {
	                var active = activeElement();
	                var wrapper = this.wrapper;
	                var filterInput = this.filterInput;
	                var compareElement = element === filterInput ? wrapper : filterInput;
	                var touchEnabled = support.mobileOS && (support.touch || support.MSPointers || support.pointers);
	                if (filterInput && filterInput[0] === element[0] && touchEnabled) {
	                    return;
	                }
	                if (filterInput && compareElement[0] === active) {
	                    this._prevent = true;
	                    this._focused = element.focus();
	                }
	            },
	            _searchByWord: function (word) {
	                if (word) {
	                    var that = this;
	                    var ignoreCase = that.options.ignoreCase;
	                    if (ignoreCase) {
	                        word = word.toLowerCase();
	                    }
	                    that._select(function (dataItem) {
	                        return that._matchText(that._text(dataItem), word);
	                    });
	                }
	            },
	            _inputValue: function () {
	                return this.text();
	            },
	            _search: function () {
	                var that = this;
	                var dataSource = that.dataSource;
	                clearTimeout(that._typingTimeout);
	                if (that._isFilterEnabled()) {
	                    that._typingTimeout = setTimeout(function () {
	                        var value = that.filterInput.val();
	                        if (that._prev !== value) {
	                            that._prev = value;
	                            that.search(value);
	                            that._resizeFilterInput();
	                        }
	                        that._typingTimeout = null;
	                    }, that.options.delay);
	                } else {
	                    that._typingTimeout = setTimeout(function () {
	                        that._word = '';
	                    }, that.options.delay);
	                    if (!that.listView.bound()) {
	                        dataSource.fetch().done(function () {
	                            that._selectNext();
	                        });
	                        return;
	                    }
	                    that._selectNext();
	                }
	            },
	            _get: function (candidate) {
	                var data, found, idx;
	                var isFunction = typeof candidate === 'function';
	                var jQueryCandidate = !isFunction ? $(candidate) : $();
	                if (this.hasOptionLabel()) {
	                    if (typeof candidate === 'number') {
	                        if (candidate > -1) {
	                            candidate -= 1;
	                        }
	                    } else if (jQueryCandidate.hasClass('k-list-optionlabel')) {
	                        candidate = -1;
	                    }
	                }
	                if (isFunction) {
	                    data = this.dataSource.flatView();
	                    for (idx = 0; idx < data.length; idx++) {
	                        if (candidate(data[idx])) {
	                            candidate = idx;
	                            found = true;
	                            break;
	                        }
	                    }
	                    if (!found) {
	                        candidate = -1;
	                    }
	                }
	                return candidate;
	            },
	            _firstItem: function () {
	                if (this.hasOptionLabel()) {
	                    this._focus(this.optionLabel);
	                } else {
	                    this.listView.focusFirst();
	                }
	            },
	            _lastItem: function () {
	                this._resetOptionLabel();
	                this.listView.focusLast();
	            },
	            _nextItem: function () {
	                if (this.optionLabel.hasClass('k-state-focused')) {
	                    this._resetOptionLabel();
	                    this.listView.focusFirst();
	                } else {
	                    this.listView.focusNext();
	                }
	            },
	            _prevItem: function () {
	                if (this.optionLabel.hasClass('k-state-focused')) {
	                    return;
	                }
	                this.listView.focusPrev();
	                if (!this.listView.focus()) {
	                    this._focus(this.optionLabel);
	                }
	            },
	            _focusItem: function () {
	                var listView = this.listView;
	                var focusedItem = listView.focus();
	                var index = listView.select();
	                index = index[index.length - 1];
	                if (index === undefined && this.options.highlightFirst && !focusedItem) {
	                    index = 0;
	                }
	                if (index !== undefined) {
	                    listView.focus(index);
	                } else {
	                    if (this.options.optionLabel) {
	                        this._focus(this.optionLabel);
	                        this._select(this.optionLabel);
	                    } else {
	                        listView.scrollToIndex(0);
	                    }
	                }
	            },
	            _resetOptionLabel: function (additionalClass) {
	                this.optionLabel.removeClass('k-state-focused' + (additionalClass || '')).removeAttr('id');
	            },
	            _focus: function (candidate) {
	                var listView = this.listView;
	                var optionLabel = this.optionLabel;
	                if (candidate === undefined) {
	                    candidate = listView.focus();
	                    if (!candidate && optionLabel.hasClass('k-state-focused')) {
	                        candidate = optionLabel;
	                    }
	                    return candidate;
	                }
	                this._resetOptionLabel();
	                candidate = this._get(candidate);
	                listView.focus(candidate);
	                if (candidate === -1) {
	                    optionLabel.addClass('k-state-focused').attr('id', listView._optionID);
	                    this._focused.add(this.filterInput).removeAttr('aria-activedescendant').attr('aria-activedescendant', listView._optionID);
	                }
	            },
	            _select: function (candidate, keepState) {
	                var that = this;
	                candidate = that._get(candidate);
	                that.listView.select(candidate);
	                if (!keepState && that._state === STATE_FILTER) {
	                    that._state = STATE_ACCEPT;
	                }
	                if (candidate === -1) {
	                    that._selectValue(null);
	                }
	            },
	            _selectValue: function (dataItem) {
	                var that = this;
	                var optionLabel = that.options.optionLabel;
	                var idx = that.listView.select();
	                var value = '';
	                var text = '';
	                idx = idx[idx.length - 1];
	                if (idx === undefined) {
	                    idx = -1;
	                }
	                this._resetOptionLabel(' k-state-selected');
	                if (dataItem) {
	                    text = dataItem;
	                    value = that._dataValue(dataItem);
	                    if (optionLabel) {
	                        idx += 1;
	                    }
	                } else if (optionLabel) {
	                    that._focus(that.optionLabel.addClass('k-state-selected'));
	                    text = that._optionLabelText();
	                    if (typeof optionLabel === 'string') {
	                        value = '';
	                    } else {
	                        value = that._value(optionLabel);
	                    }
	                    idx = 0;
	                }
	                that.selectedIndex = idx;
	                if (value === null) {
	                    value = '';
	                }
	                that._textAccessor(text);
	                that._accessor(value, idx);
	                that._triggerCascade();
	            },
	            _mobile: function () {
	                var that = this, popup = that.popup, mobileOS = support.mobileOS, root = popup.element.parents('.km-root').eq(0);
	                if (root.length && mobileOS) {
	                    popup.options.animation.open.effects = mobileOS.android || mobileOS.meego ? 'fadeIn' : mobileOS.ios || mobileOS.wp ? 'slideIn:up' : popup.options.animation.open.effects;
	                }
	            },
	            _filterHeader: function () {
	                var icon;
	                if (this.filterInput) {
	                    this.filterInput.off(ns).parent().remove();
	                    this.filterInput = null;
	                }
	                if (this._isFilterEnabled()) {
	                    icon = '<span class="k-icon k-i-search"></span>';
	                    this.filterInput = $('<input class="k-textbox"/>').attr({
	                        placeholder: this.element.attr('placeholder'),
	                        title: this.element.attr('title'),
	                        role: 'listbox',
	                        'aria-haspopup': true,
	                        'aria-expanded': false
	                    });
	                    this.list.prepend($('<span class="k-list-filter" />').append(this.filterInput.add(icon)));
	                }
	            },
	            _span: function () {
	                var that = this, wrapper = that.wrapper, SELECTOR = 'span.k-input', span;
	                span = wrapper.find(SELECTOR);
	                if (!span[0]) {
	                    wrapper.append('<span unselectable="on" class="k-dropdown-wrap k-state-default"><span unselectable="on" class="k-input">&nbsp;</span><span unselectable="on" class="k-select" aria-label="select"><span class="k-icon k-i-arrow-s"></span></span></span>').append(that.element);
	                    span = wrapper.find(SELECTOR);
	                }
	                that.span = span;
	                that._inputWrapper = $(wrapper[0].firstChild);
	                that._arrow = wrapper.find('.k-icon');
	            },
	            _wrapper: function () {
	                var that = this, element = that.element, DOMelement = element[0], wrapper;
	                wrapper = element.parent();
	                if (!wrapper.is('span.k-widget')) {
	                    wrapper = element.wrap('<span />').parent();
	                    wrapper[0].style.cssText = DOMelement.style.cssText;
	                    wrapper[0].title = DOMelement.title;
	                }
	                that._focused = that.wrapper = wrapper.addClass('k-widget k-dropdown k-header').addClass(DOMelement.className).css('display', '').attr({
	                    accesskey: element.attr('accesskey'),
	                    unselectable: 'on',
	                    role: 'listbox',
	                    'aria-haspopup': true,
	                    'aria-expanded': false
	                });
	                element.hide().removeAttr('accesskey');
	            },
	            _clearSelection: function (parent) {
	                this.select(parent.value() ? 0 : -1);
	            },
	            _inputTemplate: function () {
	                var that = this, template = that.options.valueTemplate;
	                if (!template) {
	                    template = $.proxy(kendo.template('#:this._text(data)#', { useWithBlock: false }), that);
	                } else {
	                    template = kendo.template(template);
	                }
	                that.valueTemplate = template;
	                if (that.hasOptionLabel() && !that.options.optionLabelTemplate) {
	                    try {
	                        that.valueTemplate(that._optionLabelDataItem());
	                    } catch (e) {
	                        throw new Error(MSG_INVALID_OPTION_LABEL);
	                    }
	                }
	            },
	            _textAccessor: function (text) {
	                var dataItem = null;
	                var template = this.valueTemplate;
	                var optionLabelText = this._optionLabelText();
	                var span = this.span;
	                if (text === undefined) {
	                    return span.text();
	                }
	                if ($.isPlainObject(text) || text instanceof ObservableObject) {
	                    dataItem = text;
	                } else if (optionLabelText && optionLabelText === text) {
	                    dataItem = this.options.optionLabel;
	                }
	                if (!dataItem) {
	                    dataItem = this._assignInstance(text, this._accessor());
	                }
	                if (this.hasOptionLabel()) {
	                    if (dataItem === optionLabelText || this._text(dataItem) === optionLabelText) {
	                        template = this.optionLabelTemplate;
	                        if (typeof this.options.optionLabel === 'string' && !this.options.optionLabelTemplate) {
	                            dataItem = optionLabelText;
	                        }
	                    }
	                }
	                var getElements = function () {
	                    return {
	                        elements: span.get(),
	                        data: [{ dataItem: dataItem }]
	                    };
	                };
	                this.angular('cleanup', getElements);
	                try {
	                    span.html(template(dataItem));
	                } catch (e) {
	                    span.html('');
	                }
	                this.angular('compile', getElements);
	            },
	            _preselect: function (value, text) {
	                if (!value && !text) {
	                    text = this._optionLabelText();
	                }
	                this._accessor(value);
	                this._textAccessor(text);
	                this._old = this._accessor();
	                this._oldIndex = this.selectedIndex;
	                this.listView.setValue(value);
	                this._initialIndex = null;
	                this._presetValue = true;
	            },
	            _assignInstance: function (text, value) {
	                var dataTextField = this.options.dataTextField;
	                var dataItem = {};
	                if (dataTextField) {
	                    assign(dataItem, dataTextField.split('.'), text);
	                    assign(dataItem, this.options.dataValueField.split('.'), value);
	                    dataItem = new ObservableObject(dataItem);
	                } else {
	                    dataItem = text;
	                }
	                return dataItem;
	            }
	        });
	        function assign(instance, fields, value) {
	            var idx = 0, lastIndex = fields.length - 1, field;
	            for (; idx < lastIndex; ++idx) {
	                field = fields[idx];
	                if (!(field in instance)) {
	                    instance[field] = {};
	                }
	                instance = instance[field];
	            }
	            instance[fields[lastIndex]] = value;
	        }
	        function normalizeIndex(index, length) {
	            if (index >= length) {
	                index -= length;
	            }
	            return index;
	        }
	        function sameCharsOnly(word, character) {
	            for (var idx = 0; idx < word.length; idx++) {
	                if (word.charAt(idx) !== character) {
	                    return false;
	                }
	            }
	            return true;
	        }
	        ui.plugin(DropDownList);
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(202),
	        __webpack_require__(207),
	        __webpack_require__(208)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'view',
	        name: 'View',
	        category: 'framework',
	        description: 'The View class instantiates and handles the events of a certain screen from the application.',
	        depends: [
	            'core',
	            'binder',
	            'fx'
	        ],
	        hidden: false
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, Observable = kendo.Observable, SCRIPT = 'SCRIPT', INIT = 'init', SHOW = 'show', HIDE = 'hide', TRANSITION_START = 'transitionStart', TRANSITION_END = 'transitionEnd', ATTACH = 'attach', DETACH = 'detach', sizzleErrorRegExp = /unrecognized expression/;
	        var View = Observable.extend({
	            init: function (content, options) {
	                var that = this;
	                options = options || {};
	                Observable.fn.init.call(that);
	                that.content = content;
	                that.id = kendo.guid();
	                that.tagName = options.tagName || 'div';
	                that.model = options.model;
	                that._wrap = options.wrap !== false;
	                this._evalTemplate = options.evalTemplate || false;
	                that._fragments = {};
	                that.bind([
	                    INIT,
	                    SHOW,
	                    HIDE,
	                    TRANSITION_START,
	                    TRANSITION_END
	                ], options);
	            },
	            render: function (container) {
	                var that = this, notInitialized = !that.element;
	                if (notInitialized) {
	                    that.element = that._createElement();
	                }
	                if (container) {
	                    $(container).append(that.element);
	                }
	                if (notInitialized) {
	                    kendo.bind(that.element, that.model);
	                    that.trigger(INIT);
	                }
	                if (container) {
	                    that._eachFragment(ATTACH);
	                    that.trigger(SHOW);
	                }
	                return that.element;
	            },
	            clone: function () {
	                return new ViewClone(this);
	            },
	            triggerBeforeShow: function () {
	                return true;
	            },
	            triggerBeforeHide: function () {
	                return true;
	            },
	            showStart: function () {
	                this.element.css('display', '');
	            },
	            showEnd: function () {
	            },
	            hideEnd: function () {
	                this.hide();
	            },
	            beforeTransition: function (type) {
	                this.trigger(TRANSITION_START, { type: type });
	            },
	            afterTransition: function (type) {
	                this.trigger(TRANSITION_END, { type: type });
	            },
	            hide: function () {
	                this._eachFragment(DETACH);
	                this.element.detach();
	                this.trigger(HIDE);
	            },
	            destroy: function () {
	                var element = this.element;
	                if (element) {
	                    kendo.unbind(element);
	                    kendo.destroy(element);
	                    element.remove();
	                }
	            },
	            fragments: function (fragments) {
	                $.extend(this._fragments, fragments);
	            },
	            _eachFragment: function (methodName) {
	                for (var placeholder in this._fragments) {
	                    this._fragments[placeholder][methodName](this, placeholder);
	                }
	            },
	            _createElement: function () {
	                var that = this, wrapper = '<' + that.tagName + ' />', element, content;
	                try {
	                    content = $(document.getElementById(that.content) || that.content);
	                    if (content[0].tagName === SCRIPT) {
	                        content = content.html();
	                    }
	                } catch (e) {
	                    if (sizzleErrorRegExp.test(e.message)) {
	                        content = that.content;
	                    }
	                }
	                if (typeof content === 'string') {
	                    content = content.replace(/^\s+|\s+$/g, '');
	                    if (that._evalTemplate) {
	                        content = kendo.template(content)(that.model || {});
	                    }
	                    element = $(wrapper).append(content);
	                    if (!that._wrap) {
	                        element = element.contents();
	                    }
	                } else {
	                    element = content;
	                    if (that._evalTemplate) {
	                        var result = $(kendo.template($('<div />').append(element.clone(true)).html())(that.model || {}));
	                        if ($.contains(document, element[0])) {
	                            element.replaceWith(result);
	                        }
	                        element = result;
	                    }
	                    if (that._wrap) {
	                        element = element.wrapAll(wrapper).parent();
	                    }
	                }
	                return element;
	            }
	        });
	        var ViewClone = kendo.Class.extend({
	            init: function (view) {
	                $.extend(this, {
	                    element: view.element.clone(true),
	                    transition: view.transition,
	                    id: view.id
	                });
	                view.element.parent().append(this.element);
	            },
	            hideEnd: function () {
	                this.element.remove();
	            },
	            beforeTransition: $.noop,
	            afterTransition: $.noop
	        });
	        var Layout = View.extend({
	            init: function (content, options) {
	                View.fn.init.call(this, content, options);
	                this.containers = {};
	            },
	            container: function (selector) {
	                var container = this.containers[selector];
	                if (!container) {
	                    container = this._createContainer(selector);
	                    this.containers[selector] = container;
	                }
	                return container;
	            },
	            showIn: function (selector, view, transition) {
	                this.container(selector).show(view, transition);
	            },
	            _createContainer: function (selector) {
	                var root = this.render(), element = root.find(selector), container;
	                if (!element.length && root.is(selector)) {
	                    if (root.is(selector)) {
	                        element = root;
	                    } else {
	                        throw new Error('can\'t find a container with the specified ' + selector + ' selector');
	                    }
	                }
	                container = new ViewContainer(element);
	                container.bind('accepted', function (e) {
	                    e.view.render(element);
	                });
	                return container;
	            }
	        });
	        var Fragment = View.extend({
	            attach: function (view, placeholder) {
	                view.element.find(placeholder).replaceWith(this.render());
	            },
	            detach: function () {
	            }
	        });
	        var transitionRegExp = /^(\w+)(:(\w+))?( (\w+))?$/;
	        function parseTransition(transition) {
	            if (!transition) {
	                return {};
	            }
	            var matches = transition.match(transitionRegExp) || [];
	            return {
	                type: matches[1],
	                direction: matches[3],
	                reverse: matches[5] === 'reverse'
	            };
	        }
	        var ViewContainer = Observable.extend({
	            init: function (container) {
	                Observable.fn.init.call(this);
	                this.container = container;
	                this.history = [];
	                this.view = null;
	                this.running = false;
	            },
	            after: function () {
	                this.running = false;
	                this.trigger('complete', { view: this.view });
	                this.trigger('after');
	            },
	            end: function () {
	                this.view.showEnd();
	                this.previous.hideEnd();
	                this.after();
	            },
	            show: function (view, transition, locationID) {
	                if (!view.triggerBeforeShow() || this.view && !this.view.triggerBeforeHide()) {
	                    this.trigger('after');
	                    return false;
	                }
	                locationID = locationID || view.id;
	                var that = this, current = view === that.view ? view.clone() : that.view, history = that.history, previousEntry = history[history.length - 2] || {}, back = previousEntry.id === locationID, theTransition = transition || (back ? history[history.length - 1].transition : view.transition), transitionData = parseTransition(theTransition);
	                if (that.running) {
	                    that.effect.stop();
	                }
	                if (theTransition === 'none') {
	                    theTransition = null;
	                }
	                that.trigger('accepted', { view: view });
	                that.view = view;
	                that.previous = current;
	                that.running = true;
	                if (!back) {
	                    history.push({
	                        id: locationID,
	                        transition: theTransition
	                    });
	                } else {
	                    history.pop();
	                }
	                if (!current) {
	                    view.showStart();
	                    view.showEnd();
	                    that.after();
	                    return true;
	                }
	                if (!theTransition || !kendo.effects.enabled) {
	                    view.showStart();
	                    that.end();
	                } else {
	                    view.element.addClass('k-fx-hidden');
	                    view.showStart();
	                    if (back && !transition) {
	                        transitionData.reverse = !transitionData.reverse;
	                    }
	                    that.effect = kendo.fx(view.element).replace(current.element, transitionData.type).beforeTransition(function () {
	                        view.beforeTransition('show');
	                        current.beforeTransition('hide');
	                    }).afterTransition(function () {
	                        view.afterTransition('show');
	                        current.afterTransition('hide');
	                    }).direction(transitionData.direction).setReverse(transitionData.reverse);
	                    that.effect.run().then(function () {
	                        that.end();
	                    });
	                }
	                return true;
	            }
	        });
	        kendo.ViewContainer = ViewContainer;
	        kendo.Fragment = Fragment;
	        kendo.Layout = Layout;
	        kendo.View = View;
	        kendo.ViewClone = ViewClone;
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(202),
	        __webpack_require__(208),
	        __webpack_require__(211),
	        __webpack_require__(215)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'mobile.view',
	        name: 'View',
	        category: 'mobile',
	        description: 'Mobile View',
	        depends: [
	            'core',
	            'fx',
	            'mobile.scroller',
	            'view'
	        ],
	        hidden: true
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, mobile = kendo.mobile, ui = mobile.ui, attr = kendo.attr, Widget = ui.Widget, ViewClone = kendo.ViewClone, INIT = 'init', UI_OVERLAY = '<div style="height: 100%; width: 100%; position: absolute; top: 0; left: 0; z-index: 20000; display: none" />', BEFORE_SHOW = 'beforeShow', SHOW = 'show', AFTER_SHOW = 'afterShow', BEFORE_HIDE = 'beforeHide', TRANSITION_END = 'transitionEnd', TRANSITION_START = 'transitionStart', HIDE = 'hide', DESTROY = 'destroy', attrValue = kendo.attrValue, roleSelector = kendo.roleSelector, directiveSelector = kendo.directiveSelector, compileMobileDirective = kendo.compileMobileDirective;
	        function initPopOvers(element) {
	            var popovers = element.find(roleSelector('popover')), idx, length, roles = ui.roles;
	            for (idx = 0, length = popovers.length; idx < length; idx++) {
	                kendo.initWidget(popovers[idx], {}, roles);
	            }
	        }
	        function preventScrollIfNotInput(e) {
	            if (!kendo.triggeredByInput(e)) {
	                e.preventDefault();
	            }
	        }
	        var View = Widget.extend({
	            init: function (element, options) {
	                Widget.fn.init.call(this, element, options);
	                this.params = {};
	                $.extend(this, options);
	                this.transition = this.transition || this.defaultTransition;
	                this._id();
	                if (!this.options.$angular) {
	                    this._layout();
	                    this._overlay();
	                    this._scroller();
	                    this._model();
	                } else {
	                    this._overlay();
	                }
	            },
	            events: [
	                INIT,
	                BEFORE_SHOW,
	                SHOW,
	                AFTER_SHOW,
	                BEFORE_HIDE,
	                HIDE,
	                DESTROY,
	                TRANSITION_START,
	                TRANSITION_END
	            ],
	            options: {
	                name: 'View',
	                title: '',
	                layout: null,
	                getLayout: $.noop,
	                reload: false,
	                transition: '',
	                defaultTransition: '',
	                useNativeScrolling: false,
	                stretch: false,
	                zoom: false,
	                model: null,
	                modelScope: window,
	                scroller: {},
	                initWidgets: true
	            },
	            enable: function (enable) {
	                if (typeof enable == 'undefined') {
	                    enable = true;
	                }
	                if (enable) {
	                    this.overlay.hide();
	                } else {
	                    this.overlay.show();
	                }
	            },
	            destroy: function () {
	                if (this.layout) {
	                    this.layout.detach(this);
	                }
	                this.trigger(DESTROY);
	                Widget.fn.destroy.call(this);
	                if (this.scroller) {
	                    this.scroller.destroy();
	                }
	                if (this.options.$angular) {
	                    this.element.scope().$destroy();
	                }
	                kendo.destroy(this.element);
	            },
	            purge: function () {
	                this.destroy();
	                this.element.remove();
	            },
	            triggerBeforeShow: function () {
	                if (this.trigger(BEFORE_SHOW, { view: this })) {
	                    return false;
	                }
	                return true;
	            },
	            triggerBeforeHide: function () {
	                if (this.trigger(BEFORE_HIDE, { view: this })) {
	                    return false;
	                }
	                return true;
	            },
	            showStart: function () {
	                var element = this.element;
	                element.css('display', '');
	                if (!this.inited) {
	                    this.inited = true;
	                    this.trigger(INIT, { view: this });
	                } else {
	                    this._invokeNgController();
	                }
	                if (this.layout) {
	                    this.layout.attach(this);
	                }
	                this._padIfNativeScrolling();
	                this.trigger(SHOW, { view: this });
	                kendo.resize(element);
	            },
	            showEnd: function () {
	                this.trigger(AFTER_SHOW, { view: this });
	                this._padIfNativeScrolling();
	            },
	            hideEnd: function () {
	                var that = this;
	                that.element.hide();
	                that.trigger(HIDE, { view: that });
	                if (that.layout) {
	                    that.layout.trigger(HIDE, {
	                        view: that,
	                        layout: that.layout
	                    });
	                }
	            },
	            beforeTransition: function (type) {
	                this.trigger(TRANSITION_START, { type: type });
	            },
	            afterTransition: function (type) {
	                this.trigger(TRANSITION_END, { type: type });
	            },
	            _padIfNativeScrolling: function () {
	                if (mobile.appLevelNativeScrolling()) {
	                    var isAndroid = kendo.support.mobileOS && kendo.support.mobileOS.android, skin = mobile.application.skin() || '', isAndroidForced = mobile.application.os.android || skin.indexOf('android') > -1, hasPlatformIndependentSkin = skin === 'flat' || skin.indexOf('material') > -1, topContainer = (isAndroid || isAndroidForced) && !hasPlatformIndependentSkin ? 'footer' : 'header', bottomContainer = (isAndroid || isAndroidForced) && !hasPlatformIndependentSkin ? 'header' : 'footer';
	                    this.content.css({
	                        paddingTop: this[topContainer].height(),
	                        paddingBottom: this[bottomContainer].height()
	                    });
	                }
	            },
	            contentElement: function () {
	                var that = this;
	                return that.options.stretch ? that.content : that.scrollerContent;
	            },
	            clone: function () {
	                return new ViewClone(this);
	            },
	            _scroller: function () {
	                var that = this;
	                if (mobile.appLevelNativeScrolling()) {
	                    return;
	                }
	                if (that.options.stretch) {
	                    that.content.addClass('km-stretched-view');
	                } else {
	                    that.content.kendoMobileScroller($.extend(that.options.scroller, {
	                        zoom: that.options.zoom,
	                        useNative: that.options.useNativeScrolling
	                    }));
	                    that.scroller = that.content.data('kendoMobileScroller');
	                    that.scrollerContent = that.scroller.scrollElement;
	                }
	                if (kendo.support.kineticScrollNeeded) {
	                    $(that.element).on('touchmove', '.km-header', preventScrollIfNotInput);
	                    if (!that.options.useNativeScrolling && !that.options.stretch) {
	                        $(that.element).on('touchmove', '.km-content', preventScrollIfNotInput);
	                    }
	                }
	            },
	            _model: function () {
	                var that = this, element = that.element, model = that.options.model;
	                if (typeof model === 'string') {
	                    model = kendo.getter(model)(that.options.modelScope);
	                }
	                that.model = model;
	                initPopOvers(element);
	                that.element.css('display', '');
	                if (that.options.initWidgets) {
	                    if (model) {
	                        kendo.bind(element, model, ui, kendo.ui, kendo.dataviz.ui);
	                    } else {
	                        mobile.init(element.children());
	                    }
	                }
	                that.element.css('display', 'none');
	            },
	            _id: function () {
	                var element = this.element, idAttrValue = element.attr('id') || '';
	                this.id = attrValue(element, 'url') || '#' + idAttrValue;
	                if (this.id == '#') {
	                    this.id = kendo.guid();
	                    element.attr('id', this.id);
	                }
	            },
	            _layout: function () {
	                var contentSelector = roleSelector('content'), element = this.element;
	                element.addClass('km-view');
	                this.header = element.children(roleSelector('header')).addClass('km-header');
	                this.footer = element.children(roleSelector('footer')).addClass('km-footer');
	                if (!element.children(contentSelector)[0]) {
	                    element.wrapInner('<div ' + attr('role') + '="content"></div>');
	                }
	                this.content = element.children(roleSelector('content')).addClass('km-content');
	                this.element.prepend(this.header).append(this.footer);
	                this.layout = this.options.getLayout(this.layout);
	                if (this.layout) {
	                    this.layout.setup(this);
	                }
	            },
	            _overlay: function () {
	                this.overlay = $(UI_OVERLAY).appendTo(this.element);
	            },
	            _invokeNgController: function () {
	                var controller, scope;
	                if (this.options.$angular) {
	                    controller = this.element.controller();
	                    scope = this.options.$angular[0];
	                    if (controller) {
	                        var callback = $.proxy(this, '_callController', controller, scope);
	                        if (/^\$(digest|apply)$/.test(scope.$$phase)) {
	                            callback();
	                        } else {
	                            scope.$apply(callback);
	                        }
	                    }
	                }
	            },
	            _callController: function (controller, scope) {
	                this.element.injector().invoke(controller.constructor, controller, { $scope: scope });
	            }
	        });
	        function initWidgets(collection) {
	            collection.each(function () {
	                kendo.initWidget($(this), {}, ui.roles);
	            });
	        }
	        var Layout = Widget.extend({
	            init: function (element, options) {
	                Widget.fn.init.call(this, element, options);
	                element = this.element;
	                this.header = element.children(this._locate('header')).addClass('km-header');
	                this.footer = element.children(this._locate('footer')).addClass('km-footer');
	                this.elements = this.header.add(this.footer);
	                initPopOvers(element);
	                if (!this.options.$angular) {
	                    kendo.mobile.init(this.element.children());
	                }
	                this.element.detach();
	                this.trigger(INIT, { layout: this });
	            },
	            _locate: function (selectors) {
	                return this.options.$angular ? directiveSelector(selectors) : roleSelector(selectors);
	            },
	            options: {
	                name: 'Layout',
	                id: null,
	                platform: null
	            },
	            events: [
	                INIT,
	                SHOW,
	                HIDE
	            ],
	            setup: function (view) {
	                if (!view.header[0]) {
	                    view.header = this.header;
	                }
	                if (!view.footer[0]) {
	                    view.footer = this.footer;
	                }
	            },
	            detach: function (view) {
	                var that = this;
	                if (view.header === that.header && that.header[0]) {
	                    view.element.prepend(that.header.detach()[0].cloneNode(true));
	                }
	                if (view.footer === that.footer && that.footer.length) {
	                    view.element.append(that.footer.detach()[0].cloneNode(true));
	                }
	            },
	            attach: function (view) {
	                var that = this, previousView = that.currentView;
	                if (previousView) {
	                    that.detach(previousView);
	                }
	                if (view.header === that.header) {
	                    that.header.detach();
	                    view.element.children(roleSelector('header')).remove();
	                    view.element.prepend(that.header);
	                }
	                if (view.footer === that.footer) {
	                    that.footer.detach();
	                    view.element.children(roleSelector('footer')).remove();
	                    view.element.append(that.footer);
	                }
	                that.trigger(SHOW, {
	                    layout: that,
	                    view: view
	                });
	                that.currentView = view;
	            }
	        });
	        var Observable = kendo.Observable, bodyRegExp = /<body[^>]*>(([\u000a\u000d\u2028\u2029]|.)*)<\/body>/i, LOAD_START = 'loadStart', LOAD_COMPLETE = 'loadComplete', SHOW_START = 'showStart', SAME_VIEW_REQUESTED = 'sameViewRequested', VIEW_SHOW = 'viewShow', VIEW_TYPE_DETERMINED = 'viewTypeDetermined', AFTER = 'after';
	        var ViewEngine = Observable.extend({
	            init: function (options) {
	                var that = this, views, errorMessage, container, collection;
	                Observable.fn.init.call(that);
	                $.extend(that, options);
	                that.sandbox = $('<div />');
	                container = that.container;
	                views = that._hideViews(container);
	                that.rootView = views.first();
	                if (!that.rootView[0] && options.rootNeeded) {
	                    if (container[0] == kendo.mobile.application.element[0]) {
	                        errorMessage = 'Your kendo mobile application element does not contain any direct child elements with data-role="view" attribute set. Make sure that you instantiate the mobile application using the correct container.';
	                    } else {
	                        errorMessage = 'Your pane element does not contain any direct child elements with data-role="view" attribute set.';
	                    }
	                    throw new Error(errorMessage);
	                }
	                that.layouts = {};
	                that.viewContainer = new kendo.ViewContainer(that.container);
	                that.viewContainer.bind('accepted', function (e) {
	                    e.view.params = that.params;
	                });
	                that.viewContainer.bind('complete', function (e) {
	                    that.trigger(VIEW_SHOW, { view: e.view });
	                });
	                that.viewContainer.bind(AFTER, function () {
	                    that.trigger(AFTER);
	                });
	                this.getLayoutProxy = $.proxy(this, '_getLayout');
	                that._setupLayouts(container);
	                collection = container.children(that._locate('modalview drawer'));
	                if (that.$angular) {
	                    that.$angular[0].viewOptions = {
	                        defaultTransition: that.transition,
	                        loader: that.loader,
	                        container: that.container,
	                        getLayout: that.getLayoutProxy
	                    };
	                    collection.each(function (idx, element) {
	                        compileMobileDirective($(element), options.$angular[0]);
	                    });
	                } else {
	                    initWidgets(collection);
	                }
	                this.bind(this.events, options);
	            },
	            events: [
	                SHOW_START,
	                AFTER,
	                VIEW_SHOW,
	                LOAD_START,
	                LOAD_COMPLETE,
	                SAME_VIEW_REQUESTED,
	                VIEW_TYPE_DETERMINED
	            ],
	            destroy: function () {
	                kendo.destroy(this.container);
	                for (var id in this.layouts) {
	                    this.layouts[id].destroy();
	                }
	            },
	            view: function () {
	                return this.viewContainer.view;
	            },
	            showView: function (url, transition, params) {
	                url = url.replace(new RegExp('^' + this.remoteViewURLPrefix), '');
	                if (url === '' && this.remoteViewURLPrefix) {
	                    url = '/';
	                }
	                if (url.replace(/^#/, '') === this.url) {
	                    this.trigger(SAME_VIEW_REQUESTED);
	                    return false;
	                }
	                this.trigger(SHOW_START);
	                var that = this, showClosure = function (view) {
	                        return that.viewContainer.show(view, transition, url);
	                    }, element = that._findViewElement(url), view = kendo.widgetInstance(element);
	                that.url = url.replace(/^#/, '');
	                that.params = params;
	                if (view && view.reload) {
	                    view.purge();
	                    element = [];
	                }
	                this.trigger(VIEW_TYPE_DETERMINED, {
	                    remote: element.length === 0,
	                    url: url
	                });
	                if (element[0]) {
	                    if (!view) {
	                        view = that._createView(element);
	                    }
	                    return showClosure(view);
	                } else {
	                    if (this.serverNavigation) {
	                        location.href = url;
	                    } else {
	                        that._loadView(url, showClosure);
	                    }
	                    return true;
	                }
	            },
	            append: function (html, url) {
	                var sandbox = this.sandbox, urlPath = (url || '').split('?')[0], container = this.container, views, modalViews, view;
	                if (bodyRegExp.test(html)) {
	                    html = RegExp.$1;
	                }
	                sandbox[0].innerHTML = html;
	                container.append(sandbox.children('script, style'));
	                views = this._hideViews(sandbox);
	                view = views.first();
	                if (!view.length) {
	                    views = view = sandbox.wrapInner('<div data-role=view />').children();
	                }
	                if (urlPath) {
	                    view.hide().attr(attr('url'), urlPath);
	                }
	                this._setupLayouts(sandbox);
	                modalViews = sandbox.children(this._locate('modalview drawer'));
	                container.append(sandbox.children(this._locate('layout modalview drawer')).add(views));
	                initWidgets(modalViews);
	                return this._createView(view);
	            },
	            _locate: function (selectors) {
	                return this.$angular ? directiveSelector(selectors) : roleSelector(selectors);
	            },
	            _findViewElement: function (url) {
	                var element, urlPath = url.split('?')[0];
	                if (!urlPath) {
	                    return this.rootView;
	                }
	                element = this.container.children('[' + attr('url') + '=\'' + urlPath + '\']');
	                if (!element[0] && urlPath.indexOf('/') === -1) {
	                    element = this.container.children(urlPath.charAt(0) === '#' ? urlPath : '#' + urlPath);
	                }
	                return element;
	            },
	            _createView: function (element) {
	                if (this.$angular) {
	                    return compileMobileDirective(element, this.$angular[0]);
	                } else {
	                    return kendo.initWidget(element, {
	                        defaultTransition: this.transition,
	                        loader: this.loader,
	                        container: this.container,
	                        getLayout: this.getLayoutProxy,
	                        modelScope: this.modelScope,
	                        reload: attrValue(element, 'reload')
	                    }, ui.roles);
	                }
	            },
	            _getLayout: function (name) {
	                if (name === '') {
	                    return null;
	                }
	                return name ? this.layouts[name] : this.layouts[this.layout];
	            },
	            _loadView: function (url, callback) {
	                if (this._xhr) {
	                    this._xhr.abort();
	                }
	                this.trigger(LOAD_START);
	                this._xhr = $.get(kendo.absoluteURL(url, this.remoteViewURLPrefix), 'html').always($.proxy(this, '_xhrComplete', callback, url));
	            },
	            _xhrComplete: function (callback, url, response) {
	                var success = true;
	                if (typeof response === 'object') {
	                    if (response.status === 0) {
	                        if (response.responseText && response.responseText.length > 0) {
	                            success = true;
	                            response = response.responseText;
	                        } else {
	                            return;
	                        }
	                    }
	                }
	                this.trigger(LOAD_COMPLETE);
	                if (success) {
	                    callback(this.append(response, url));
	                }
	            },
	            _hideViews: function (container) {
	                return container.children(this._locate('view splitview')).hide();
	            },
	            _setupLayouts: function (element) {
	                var that = this, layout;
	                element.children(that._locate('layout')).each(function () {
	                    if (that.$angular) {
	                        layout = compileMobileDirective($(this), that.$angular[0]);
	                    } else {
	                        layout = kendo.initWidget($(this), {}, ui.roles);
	                    }
	                    var platform = layout.options.platform;
	                    if (!platform || platform === mobile.application.os.name) {
	                        that.layouts[layout.options.id] = layout;
	                    } else {
	                        layout.destroy();
	                    }
	                });
	            }
	        });
	        kendo.mobile.ViewEngine = ViewEngine;
	        ui.plugin(View);
	        ui.plugin(Layout);
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(202)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'mobile.loader',
	        name: 'Loader',
	        category: 'mobile',
	        description: 'Mobile Loader',
	        depends: ['core'],
	        hidden: true
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, ui = kendo.mobile.ui, Widget = ui.Widget, CAPTURE_EVENTS = $.map(kendo.eventMap, function (value) {
	                return value;
	            }).join(' ').split(' ');
	        var Loader = Widget.extend({
	            init: function (container, options) {
	                var that = this, element = $('<div class="km-loader"><span class="km-loading km-spin"></span><span class="km-loading-left"></span><span class="km-loading-right"></span></div>');
	                Widget.fn.init.call(that, element, options);
	                that.container = container;
	                that.captureEvents = false;
	                that._attachCapture();
	                element.append(that.options.loading).hide().appendTo(container);
	            },
	            options: {
	                name: 'Loader',
	                loading: '<h1>Loading...</h1>',
	                timeout: 100
	            },
	            show: function () {
	                var that = this;
	                clearTimeout(that._loading);
	                if (that.options.loading === false) {
	                    return;
	                }
	                that.captureEvents = true;
	                that._loading = setTimeout(function () {
	                    that.element.show();
	                }, that.options.timeout);
	            },
	            hide: function () {
	                this.captureEvents = false;
	                clearTimeout(this._loading);
	                this.element.hide();
	            },
	            changeMessage: function (message) {
	                this.options.loading = message;
	                this.element.find('>h1').html(message);
	            },
	            transition: function () {
	                this.captureEvents = true;
	                this.container.css('pointer-events', 'none');
	            },
	            transitionDone: function () {
	                this.captureEvents = false;
	                this.container.css('pointer-events', '');
	            },
	            _attachCapture: function () {
	                var that = this;
	                that.captureEvents = false;
	                function capture(e) {
	                    if (that.captureEvents) {
	                        e.preventDefault();
	                    }
	                }
	                for (var i = 0; i < CAPTURE_EVENTS.length; i++) {
	                    that.container[0].addEventListener(CAPTURE_EVENTS[i], capture, true);
	                }
	            }
	        });
	        ui.plugin(Loader);
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(212),
	        __webpack_require__(219)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'mobile.popover',
	        name: 'PopOver',
	        category: 'mobile',
	        description: 'The mobile PopOver widget represents a transient view which is displayed when the user taps on a navigational widget or area on the screen. ',
	        depends: [
	            'popup',
	            'mobile.pane'
	        ]
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, mobile = kendo.mobile, ui = mobile.ui, HIDE = 'hide', OPEN = 'open', CLOSE = 'close', WRAPPER = '<div class="km-popup-wrapper" />', ARROW = '<div class="km-popup-arrow" />', OVERLAY = '<div class="km-popup-overlay" />', DIRECTION_CLASSES = 'km-up km-down km-left km-right', Widget = ui.Widget, DIRECTIONS = {
	                'down': {
	                    origin: 'bottom center',
	                    position: 'top center'
	                },
	                'up': {
	                    origin: 'top center',
	                    position: 'bottom center'
	                },
	                'left': {
	                    origin: 'center left',
	                    position: 'center right',
	                    collision: 'fit flip'
	                },
	                'right': {
	                    origin: 'center right',
	                    position: 'center left',
	                    collision: 'fit flip'
	                }
	            }, ANIMATION = {
	                animation: {
	                    open: {
	                        effects: 'fade:in',
	                        duration: 0
	                    },
	                    close: {
	                        effects: 'fade:out',
	                        duration: 400
	                    }
	                }
	            }, DIMENSIONS = {
	                'horizontal': {
	                    offset: 'top',
	                    size: 'height'
	                },
	                'vertical': {
	                    offset: 'left',
	                    size: 'width'
	                }
	            }, REVERSE = {
	                'up': 'down',
	                'down': 'up',
	                'left': 'right',
	                'right': 'left'
	            };
	        var Popup = Widget.extend({
	            init: function (element, options) {
	                var that = this, containerPopup = element.closest('.km-modalview-wrapper'), viewport = element.closest('.km-root').children('.km-pane').first(), container = containerPopup[0] ? containerPopup : viewport, popupOptions, axis;
	                if (options.viewport) {
	                    viewport = options.viewport;
	                } else if (!viewport[0]) {
	                    viewport = window;
	                }
	                if (options.container) {
	                    container = options.container;
	                } else if (!container[0]) {
	                    container = document.body;
	                }
	                popupOptions = {
	                    viewport: viewport,
	                    copyAnchorStyles: false,
	                    autosize: true,
	                    open: function () {
	                        that.overlay.show();
	                    },
	                    activate: $.proxy(that._activate, that),
	                    deactivate: function () {
	                        that.overlay.hide();
	                        if (!that._apiCall) {
	                            that.trigger(HIDE);
	                        }
	                        that._apiCall = false;
	                    }
	                };
	                Widget.fn.init.call(that, element, options);
	                element = that.element;
	                options = that.options;
	                element.wrap(WRAPPER).addClass('km-popup').show();
	                axis = that.options.direction.match(/left|right/) ? 'horizontal' : 'vertical';
	                that.dimensions = DIMENSIONS[axis];
	                that.wrapper = element.parent().css({
	                    width: options.width,
	                    height: options.height
	                }).addClass('km-popup-wrapper km-' + options.direction).hide();
	                that.arrow = $(ARROW).prependTo(that.wrapper).hide();
	                that.overlay = $(OVERLAY).appendTo(container).hide();
	                popupOptions.appendTo = that.overlay;
	                if (options.className) {
	                    that.overlay.addClass(options.className);
	                }
	                that.popup = new kendo.ui.Popup(that.wrapper, $.extend(true, popupOptions, ANIMATION, DIRECTIONS[options.direction]));
	            },
	            options: {
	                name: 'Popup',
	                width: 240,
	                height: '',
	                direction: 'down',
	                container: null,
	                viewport: null
	            },
	            events: [HIDE],
	            show: function (target) {
	                this.popup.options.anchor = $(target);
	                this.popup.open();
	            },
	            hide: function () {
	                this._apiCall = true;
	                this.popup.close();
	            },
	            destroy: function () {
	                Widget.fn.destroy.call(this);
	                this.popup.destroy();
	                this.overlay.remove();
	            },
	            target: function () {
	                return this.popup.options.anchor;
	            },
	            _activate: function () {
	                var that = this, direction = that.options.direction, dimensions = that.dimensions, offset = dimensions.offset, popup = that.popup, anchor = popup.options.anchor, anchorOffset = $(anchor).offset(), elementOffset = $(popup.element).offset(), cssClass = popup.flipped ? REVERSE[direction] : direction, min = that.arrow[dimensions.size]() * 2, max = that.element[dimensions.size]() - that.arrow[dimensions.size](), size = $(anchor)[dimensions.size](), offsetAmount = anchorOffset[offset] - elementOffset[offset] + size / 2;
	                if (offsetAmount < min) {
	                    offsetAmount = min;
	                }
	                if (offsetAmount > max) {
	                    offsetAmount = max;
	                }
	                that.wrapper.removeClass(DIRECTION_CLASSES).addClass('km-' + cssClass);
	                that.arrow.css(offset, offsetAmount).show();
	            }
	        });
	        var PopOver = Widget.extend({
	            init: function (element, options) {
	                var that = this, popupOptions;
	                that.initialOpen = false;
	                Widget.fn.init.call(that, element, options);
	                popupOptions = $.extend({
	                    className: 'km-popover-root',
	                    hide: function () {
	                        that.trigger(CLOSE);
	                    }
	                }, this.options.popup);
	                that.popup = new Popup(that.element, popupOptions);
	                that.popup.overlay.on('move', function (e) {
	                    if (e.target == that.popup.overlay[0]) {
	                        e.preventDefault();
	                    }
	                });
	                that.pane = new ui.Pane(that.element, $.extend(this.options.pane, { $angular: this.options.$angular }));
	                kendo.notify(that, ui);
	            },
	            options: {
	                name: 'PopOver',
	                popup: {},
	                pane: {}
	            },
	            events: [
	                OPEN,
	                CLOSE
	            ],
	            open: function (target) {
	                this.popup.show(target);
	                if (!this.initialOpen) {
	                    if (!this.pane.navigateToInitial()) {
	                        this.pane.navigate('');
	                    }
	                    this.popup.popup._position();
	                    this.initialOpen = true;
	                } else {
	                    this.pane.view()._invokeNgController();
	                }
	            },
	            openFor: function (target) {
	                this.open(target);
	                this.trigger(OPEN, { target: this.popup.target() });
	            },
	            close: function () {
	                this.popup.hide();
	            },
	            destroy: function () {
	                Widget.fn.destroy.call(this);
	                this.pane.destroy();
	                this.popup.destroy();
	                kendo.destroy(this.element);
	            }
	        });
	        ui.plugin(Popup);
	        ui.plugin(PopOver);
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(216),
	        __webpack_require__(217)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'mobile.pane',
	        name: 'Pane',
	        category: 'mobile',
	        description: 'Mobile Pane',
	        depends: [
	            'mobile.view',
	            'mobile.loader'
	        ],
	        hidden: true
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, mobile = kendo.mobile, roleSelector = kendo.roleSelector, ui = mobile.ui, Widget = ui.Widget, ViewEngine = mobile.ViewEngine, View = ui.View, Loader = mobile.ui.Loader, EXTERNAL = 'external', HREF = 'href', DUMMY_HREF = '#!', NAVIGATE = 'navigate', VIEW_SHOW = 'viewShow', SAME_VIEW_REQUESTED = 'sameViewRequested', OS = kendo.support.mobileOS, SKIP_TRANSITION_ON_BACK_BUTTON = OS.ios && !OS.appMode && OS.flatVersion >= 700, WIDGET_RELS = /popover|actionsheet|modalview|drawer/, BACK = '#:back', attrValue = kendo.attrValue;
	        var Pane = Widget.extend({
	            init: function (element, options) {
	                var that = this;
	                Widget.fn.init.call(that, element, options);
	                options = that.options;
	                element = that.element;
	                element.addClass('km-pane');
	                if (that.options.collapsible) {
	                    element.addClass('km-collapsible-pane');
	                }
	                this.history = [];
	                this.historyCallback = function (url, params, backButtonPressed) {
	                    var transition = that.transition;
	                    that.transition = null;
	                    if (SKIP_TRANSITION_ON_BACK_BUTTON && backButtonPressed) {
	                        transition = 'none';
	                    }
	                    return that.viewEngine.showView(url, transition, params);
	                };
	                this._historyNavigate = function (url) {
	                    if (url === BACK) {
	                        if (that.history.length === 1) {
	                            return;
	                        }
	                        that.history.pop();
	                        url = that.history[that.history.length - 1];
	                    } else {
	                        that.history.push(url);
	                    }
	                    that.historyCallback(url, kendo.parseQueryStringParams(url));
	                };
	                this._historyReplace = function (url) {
	                    var params = kendo.parseQueryStringParams(url);
	                    that.history[that.history.length - 1] = url;
	                    that.historyCallback(url, params);
	                };
	                that.loader = new Loader(element, { loading: that.options.loading });
	                that.viewEngine = new ViewEngine({
	                    container: element,
	                    transition: options.transition,
	                    modelScope: options.modelScope,
	                    rootNeeded: !options.initial,
	                    serverNavigation: options.serverNavigation,
	                    remoteViewURLPrefix: options.root || '',
	                    layout: options.layout,
	                    $angular: options.$angular,
	                    loader: that.loader,
	                    showStart: function () {
	                        that.loader.transition();
	                        that.closeActiveDialogs();
	                    },
	                    after: function () {
	                        that.loader.transitionDone();
	                    },
	                    viewShow: function (e) {
	                        that.trigger(VIEW_SHOW, e);
	                    },
	                    loadStart: function () {
	                        that.loader.show();
	                    },
	                    loadComplete: function () {
	                        that.loader.hide();
	                    },
	                    sameViewRequested: function () {
	                        that.trigger(SAME_VIEW_REQUESTED);
	                    },
	                    viewTypeDetermined: function (e) {
	                        if (!e.remote || !that.options.serverNavigation) {
	                            that.trigger(NAVIGATE, { url: e.url });
	                        }
	                    }
	                });
	                this._setPortraitWidth();
	                kendo.onResize(function () {
	                    that._setPortraitWidth();
	                });
	                that._setupAppLinks();
	            },
	            closeActiveDialogs: function () {
	                var dialogs = this.element.find(roleSelector('actionsheet popover modalview')).filter(':visible');
	                dialogs.each(function () {
	                    kendo.widgetInstance($(this), ui).close();
	                });
	            },
	            navigateToInitial: function () {
	                var initial = this.options.initial;
	                if (initial) {
	                    this.navigate(initial);
	                }
	                return initial;
	            },
	            options: {
	                name: 'Pane',
	                portraitWidth: '',
	                transition: '',
	                layout: '',
	                collapsible: false,
	                initial: null,
	                modelScope: window,
	                loading: '<h1>Loading...</h1>'
	            },
	            events: [
	                NAVIGATE,
	                VIEW_SHOW,
	                SAME_VIEW_REQUESTED
	            ],
	            append: function (html) {
	                return this.viewEngine.append(html);
	            },
	            destroy: function () {
	                Widget.fn.destroy.call(this);
	                this.viewEngine.destroy();
	                this.userEvents.destroy();
	            },
	            navigate: function (url, transition) {
	                if (url instanceof View) {
	                    url = url.id;
	                }
	                this.transition = transition;
	                this._historyNavigate(url);
	            },
	            replace: function (url, transition) {
	                if (url instanceof View) {
	                    url = url.id;
	                }
	                this.transition = transition;
	                this._historyReplace(url);
	            },
	            bindToRouter: function (router) {
	                var that = this, history = this.history, viewEngine = this.viewEngine;
	                router.bind('init', function (e) {
	                    var url = e.url, attrUrl = router.pushState ? url : '/';
	                    viewEngine.rootView.attr(kendo.attr('url'), attrUrl);
	                    var length = history.length;
	                    if (url === '/' && length) {
	                        router.navigate(history[length - 1], true);
	                        e.preventDefault();
	                    }
	                });
	                router.bind('routeMissing', function (e) {
	                    if (!that.historyCallback(e.url, e.params, e.backButtonPressed)) {
	                        e.preventDefault();
	                    }
	                });
	                router.bind('same', function () {
	                    that.trigger(SAME_VIEW_REQUESTED);
	                });
	                that._historyNavigate = function (url) {
	                    router.navigate(url);
	                };
	                that._historyReplace = function (url) {
	                    router.replace(url);
	                };
	            },
	            hideLoading: function () {
	                this.loader.hide();
	            },
	            showLoading: function () {
	                this.loader.show();
	            },
	            changeLoadingMessage: function (message) {
	                this.loader.changeMessage(message);
	            },
	            view: function () {
	                return this.viewEngine.view();
	            },
	            _setPortraitWidth: function () {
	                var width, portraitWidth = this.options.portraitWidth;
	                if (portraitWidth) {
	                    width = kendo.mobile.application.element.is('.km-vertical') ? portraitWidth : 'auto';
	                    this.element.css('width', width);
	                }
	            },
	            _setupAppLinks: function () {
	                var that = this, linkRoles = 'tab', pressedButtonSelector = '[data-' + kendo.ns + 'navigate-on-press]', buttonSelectors = $.map([
	                        'button',
	                        'backbutton',
	                        'detailbutton',
	                        'listview-link'
	                    ], function (role) {
	                        return roleSelector(role) + ':not(' + pressedButtonSelector + ')';
	                    }).join(',');
	                this.element.handler(this).on('down', roleSelector(linkRoles) + ',' + pressedButtonSelector, '_mouseup').on('click', roleSelector(linkRoles) + ',' + buttonSelectors + ',' + pressedButtonSelector, '_appLinkClick');
	                this.userEvents = new kendo.UserEvents(this.element, {
	                    fastTap: true,
	                    filter: buttonSelectors,
	                    tap: function (e) {
	                        e.event.currentTarget = e.touch.currentTarget;
	                        that._mouseup(e.event);
	                    }
	                });
	                this.element.css('-ms-touch-action', '');
	            },
	            _appLinkClick: function (e) {
	                var href = $(e.currentTarget).attr('href');
	                var remote = href && href[0] !== '#' && this.options.serverNavigation;
	                if (!remote && attrValue($(e.currentTarget), 'rel') != EXTERNAL) {
	                    e.preventDefault();
	                }
	            },
	            _mouseup: function (e) {
	                if (e.which > 1 || e.isDefaultPrevented()) {
	                    return;
	                }
	                var pane = this, link = $(e.currentTarget), transition = attrValue(link, 'transition'), rel = attrValue(link, 'rel') || '', target = attrValue(link, 'target'), href = link.attr(HREF), delayedTouchEnd = SKIP_TRANSITION_ON_BACK_BUTTON && link[0].offsetHeight === 0, remote = href && href[0] !== '#' && this.options.serverNavigation;
	                if (delayedTouchEnd || remote || rel === EXTERNAL || typeof href === 'undefined' || href === DUMMY_HREF) {
	                    return;
	                }
	                link.attr(HREF, DUMMY_HREF);
	                setTimeout(function () {
	                    link.attr(HREF, href);
	                });
	                if (rel.match(WIDGET_RELS)) {
	                    kendo.widgetInstance($(href), ui).openFor(link);
	                    if (rel === 'actionsheet' || rel === 'drawer') {
	                        e.stopPropagation();
	                    }
	                } else {
	                    if (target === '_top') {
	                        pane = mobile.application.pane;
	                    } else if (target) {
	                        pane = $('#' + target).data('kendoMobilePane');
	                    }
	                    pane.navigate(href, transition);
	                }
	                e.preventDefault();
	            }
	        });
	        Pane.wrap = function (element) {
	            if (!element.is(roleSelector('view'))) {
	                element = element.wrap('<div data-' + kendo.ns + 'role="view" data-stretch="true"></div>').parent();
	            }
	            var paneContainer = element.wrap('<div class="km-pane-wrapper"><div></div></div>').parent(), pane = new Pane(paneContainer);
	            pane.navigate('');
	            return pane;
	        };
	        ui.plugin(Pane);
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(212)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'mobile.shim',
	        name: 'Shim',
	        category: 'mobile',
	        description: 'Mobile Shim',
	        depends: ['popup'],
	        hidden: true
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, ui = kendo.mobile.ui, Popup = kendo.ui.Popup, SHIM = '<div class="km-shim"/>', HIDE = 'hide', Widget = ui.Widget;
	        var Shim = Widget.extend({
	            init: function (element, options) {
	                var that = this, app = kendo.mobile.application, os = kendo.support.mobileOS, osname = app ? app.os.name : os ? os.name : 'ios', ioswp = osname === 'ios' || osname === 'wp' || (app ? app.os.skin : false), bb = osname === 'blackberry', align = options.align || (ioswp ? 'bottom center' : bb ? 'center right' : 'center center'), position = options.position || (ioswp ? 'bottom center' : bb ? 'center right' : 'center center'), effect = options.effect || (ioswp ? 'slideIn:up' : bb ? 'slideIn:left' : 'fade:in'), shim = $(SHIM).handler(that).hide();
	                Widget.fn.init.call(that, element, options);
	                that.shim = shim;
	                element = that.element;
	                options = that.options;
	                if (options.className) {
	                    that.shim.addClass(options.className);
	                }
	                if (!options.modal) {
	                    that.shim.on('down', '_hide');
	                }
	                (app ? app.element : $(document.body)).append(shim);
	                that.popup = new Popup(that.element, {
	                    anchor: shim,
	                    modal: true,
	                    appendTo: shim,
	                    origin: align,
	                    position: position,
	                    animation: {
	                        open: {
	                            effects: effect,
	                            duration: options.duration
	                        },
	                        close: { duration: options.duration }
	                    },
	                    close: function (e) {
	                        var prevented = false;
	                        if (!that._apiCall) {
	                            prevented = that.trigger(HIDE);
	                        }
	                        if (prevented) {
	                            e.preventDefault();
	                        }
	                        that._apiCall = false;
	                    },
	                    deactivate: function () {
	                        shim.hide();
	                    },
	                    open: function () {
	                        shim.show();
	                    }
	                });
	                kendo.notify(that);
	            },
	            events: [HIDE],
	            options: {
	                name: 'Shim',
	                modal: false,
	                align: undefined,
	                position: undefined,
	                effect: undefined,
	                duration: 200
	            },
	            show: function () {
	                this.popup.open();
	            },
	            hide: function () {
	                this._apiCall = true;
	                this.popup.close();
	            },
	            destroy: function () {
	                Widget.fn.destroy.call(this);
	                this.shim.kendoDestroy();
	                this.popup.destroy();
	                this.shim.remove();
	            },
	            _hide: function (e) {
	                if (!e || !$.contains(this.shim.children().children('.k-popup')[0], e.target)) {
	                    this.popup.close();
	                }
	            }
	        });
	        ui.plugin(Shim);
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(218),
	        __webpack_require__(220)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'mobile.actionsheet',
	        name: 'ActionSheet',
	        category: 'mobile',
	        description: 'The mobile ActionSheet widget displays a set of choices related to a task the user initiates.',
	        depends: [
	            'mobile.popover',
	            'mobile.shim'
	        ]
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, support = kendo.support, ui = kendo.mobile.ui, Shim = ui.Shim, Popup = ui.Popup, Widget = ui.Widget, OPEN = 'open', CLOSE = 'close', COMMAND = 'command', BUTTONS = 'li>a', CONTEXT_DATA = 'actionsheetContext', WRAP = '<div class="km-actionsheet-wrapper" />', cancelTemplate = kendo.template('<li class="km-actionsheet-cancel"><a href="\\#">#:cancel#</a></li>');
	        var ActionSheet = Widget.extend({
	            init: function (element, options) {
	                var that = this, ShimClass, tablet, type, os = support.mobileOS;
	                Widget.fn.init.call(that, element, options);
	                options = that.options;
	                type = options.type;
	                element = that.element;
	                if (type === 'auto') {
	                    tablet = os && os.tablet;
	                } else {
	                    tablet = type === 'tablet';
	                }
	                ShimClass = tablet ? Popup : Shim;
	                if (options.cancelTemplate) {
	                    cancelTemplate = kendo.template(options.cancelTemplate);
	                }
	                element.addClass('km-actionsheet').append(cancelTemplate({ cancel: that.options.cancel })).wrap(WRAP).on('up', BUTTONS, '_click').on('click', BUTTONS, kendo.preventDefault);
	                that.view().bind('destroy', function () {
	                    that.destroy();
	                });
	                that.wrapper = element.parent().addClass(type ? ' km-actionsheet-' + type : '');
	                that.shim = new ShimClass(that.wrapper, $.extend({
	                    modal: os.ios && os.majorVersion < 7,
	                    className: 'km-actionsheet-root'
	                }, that.options.popup));
	                that._closeProxy = $.proxy(that, '_close');
	                that._shimHideProxy = $.proxy(that, '_shimHide');
	                that.shim.bind('hide', that._shimHideProxy);
	                if (tablet) {
	                    kendo.onResize(that._closeProxy);
	                }
	                kendo.notify(that, ui);
	            },
	            events: [
	                OPEN,
	                CLOSE,
	                COMMAND
	            ],
	            options: {
	                name: 'ActionSheet',
	                cancel: 'Cancel',
	                type: 'auto',
	                popup: { height: 'auto' }
	            },
	            open: function (target, context) {
	                var that = this;
	                that.target = $(target);
	                that.context = context;
	                that.shim.show(target);
	            },
	            close: function () {
	                this.context = this.target = null;
	                this.shim.hide();
	            },
	            openFor: function (target) {
	                var that = this, context = target.data(CONTEXT_DATA);
	                that.open(target, context);
	                that.trigger(OPEN, {
	                    target: target,
	                    context: context
	                });
	            },
	            destroy: function () {
	                Widget.fn.destroy.call(this);
	                kendo.unbindResize(this._closeProxy);
	                this.shim.destroy();
	            },
	            _click: function (e) {
	                if (e.isDefaultPrevented()) {
	                    return;
	                }
	                var currentTarget = $(e.currentTarget);
	                var action = currentTarget.data('action');
	                if (action) {
	                    var actionData = {
	                            target: this.target,
	                            context: this.context
	                        }, $angular = this.options.$angular;
	                    if ($angular) {
	                        this.element.injector().get('$parse')(action)($angular[0])(actionData);
	                    } else {
	                        kendo.getter(action)(window)(actionData);
	                    }
	                }
	                this.trigger(COMMAND, {
	                    target: this.target,
	                    context: this.context,
	                    currentTarget: currentTarget
	                });
	                e.preventDefault();
	                this._close();
	            },
	            _shimHide: function (e) {
	                if (!this.trigger(CLOSE)) {
	                    this.context = this.target = null;
	                } else {
	                    e.preventDefault();
	                }
	            },
	            _close: function (e) {
	                if (!this.trigger(CLOSE)) {
	                    this.close();
	                } else {
	                    e.preventDefault();
	                }
	            }
	        });
	        ui.plugin(ActionSheet);
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(202)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'router',
	        name: 'Router',
	        category: 'framework',
	        description: 'The Router class is responsible for tracking the application state and navigating between the application states.',
	        depends: ['core'],
	        hidden: false
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, CHANGE = 'change', BACK = 'back', SAME = 'same', support = kendo.support, location = window.location, history = window.history, CHECK_URL_INTERVAL = 50, BROKEN_BACK_NAV = kendo.support.browser.msie, hashStrip = /^#*/, document = window.document;
	        function absoluteURL(path, pathPrefix) {
	            if (!pathPrefix) {
	                return path;
	            }
	            if (path + '/' === pathPrefix) {
	                path = pathPrefix;
	            }
	            var regEx = new RegExp('^' + pathPrefix, 'i');
	            if (!regEx.test(path)) {
	                path = pathPrefix + '/' + path;
	            }
	            return location.protocol + '//' + (location.host + '/' + path).replace(/\/\/+/g, '/');
	        }
	        function hashDelimiter(bang) {
	            return bang ? '#!' : '#';
	        }
	        function locationHash(hashDelimiter) {
	            var href = location.href;
	            if (hashDelimiter === '#!' && href.indexOf('#') > -1 && href.indexOf('#!') < 0) {
	                return null;
	            }
	            return href.split(hashDelimiter)[1] || '';
	        }
	        function stripRoot(root, url) {
	            if (url.indexOf(root) === 0) {
	                return url.substr(root.length).replace(/\/\//g, '/');
	            } else {
	                return url;
	            }
	        }
	        var HistoryAdapter = kendo.Class.extend({
	            back: function () {
	                if (BROKEN_BACK_NAV) {
	                    setTimeout(function () {
	                        history.back();
	                    });
	                } else {
	                    history.back();
	                }
	            },
	            forward: function () {
	                if (BROKEN_BACK_NAV) {
	                    setTimeout(function () {
	                        history.forward();
	                    });
	                } else {
	                    history.forward();
	                }
	            },
	            length: function () {
	                return history.length;
	            },
	            replaceLocation: function (url) {
	                location.replace(url);
	            }
	        });
	        var PushStateAdapter = HistoryAdapter.extend({
	            init: function (root) {
	                this.root = root;
	            },
	            navigate: function (to) {
	                history.pushState({}, document.title, absoluteURL(to, this.root));
	            },
	            replace: function (to) {
	                history.replaceState({}, document.title, absoluteURL(to, this.root));
	            },
	            normalize: function (url) {
	                return stripRoot(this.root, url);
	            },
	            current: function () {
	                var current = location.pathname;
	                if (location.search) {
	                    current += location.search;
	                }
	                return stripRoot(this.root, current);
	            },
	            change: function (callback) {
	                $(window).bind('popstate.kendo', callback);
	            },
	            stop: function () {
	                $(window).unbind('popstate.kendo');
	            },
	            normalizeCurrent: function (options) {
	                var fixedUrl, root = options.root, pathname = location.pathname, hash = locationHash(hashDelimiter(options.hashBang));
	                if (root === pathname + '/') {
	                    fixedUrl = root;
	                }
	                if (root === pathname && hash) {
	                    fixedUrl = absoluteURL(hash.replace(hashStrip, ''), root);
	                }
	                if (fixedUrl) {
	                    history.pushState({}, document.title, fixedUrl);
	                }
	            }
	        });
	        function fixHash(url) {
	            return url.replace(/^(#)?/, '#');
	        }
	        function fixBang(url) {
	            return url.replace(/^(#(!)?)?/, '#!');
	        }
	        var HashAdapter = HistoryAdapter.extend({
	            init: function (bang) {
	                this._id = kendo.guid();
	                this.prefix = hashDelimiter(bang);
	                this.fix = bang ? fixBang : fixHash;
	            },
	            navigate: function (to) {
	                location.hash = this.fix(to);
	            },
	            replace: function (to) {
	                this.replaceLocation(this.fix(to));
	            },
	            normalize: function (url) {
	                if (url.indexOf(this.prefix) < 0) {
	                    return url;
	                } else {
	                    return url.split(this.prefix)[1];
	                }
	            },
	            change: function (callback) {
	                if (support.hashChange) {
	                    $(window).on('hashchange.' + this._id, callback);
	                } else {
	                    this._interval = setInterval(callback, CHECK_URL_INTERVAL);
	                }
	            },
	            stop: function () {
	                $(window).off('hashchange.' + this._id);
	                clearInterval(this._interval);
	            },
	            current: function () {
	                return locationHash(this.prefix);
	            },
	            normalizeCurrent: function (options) {
	                var pathname = location.pathname, root = options.root;
	                if (options.pushState && root !== pathname) {
	                    this.replaceLocation(root + this.prefix + stripRoot(root, pathname));
	                    return true;
	                }
	                return false;
	            }
	        });
	        var History = kendo.Observable.extend({
	            start: function (options) {
	                options = options || {};
	                this.bind([
	                    CHANGE,
	                    BACK,
	                    SAME
	                ], options);
	                if (this._started) {
	                    return;
	                }
	                this._started = true;
	                options.root = options.root || '/';
	                var adapter = this.createAdapter(options), current;
	                if (adapter.normalizeCurrent(options)) {
	                    return;
	                }
	                current = adapter.current();
	                $.extend(this, {
	                    adapter: adapter,
	                    root: options.root,
	                    historyLength: adapter.length(),
	                    current: current,
	                    locations: [current]
	                });
	                adapter.change($.proxy(this, '_checkUrl'));
	            },
	            createAdapter: function (options) {
	                return support.pushState && options.pushState ? new PushStateAdapter(options.root) : new HashAdapter(options.hashBang);
	            },
	            stop: function () {
	                if (!this._started) {
	                    return;
	                }
	                this.adapter.stop();
	                this.unbind(CHANGE);
	                this._started = false;
	            },
	            change: function (callback) {
	                this.bind(CHANGE, callback);
	            },
	            replace: function (to, silent) {
	                this._navigate(to, silent, function (adapter) {
	                    adapter.replace(to);
	                    this.locations[this.locations.length - 1] = this.current;
	                });
	            },
	            navigate: function (to, silent) {
	                if (to === '#:back') {
	                    this.backCalled = true;
	                    this.adapter.back();
	                    return;
	                }
	                this._navigate(to, silent, function (adapter) {
	                    adapter.navigate(to);
	                    this.locations.push(this.current);
	                });
	            },
	            _navigate: function (to, silent, callback) {
	                var adapter = this.adapter;
	                to = adapter.normalize(to);
	                if (this.current === to || this.current === decodeURIComponent(to)) {
	                    this.trigger(SAME);
	                    return;
	                }
	                if (!silent) {
	                    if (this.trigger(CHANGE, {
	                            url: to,
	                            decode: false
	                        })) {
	                        return;
	                    }
	                }
	                this.current = to;
	                callback.call(this, adapter);
	                this.historyLength = adapter.length();
	            },
	            _checkUrl: function () {
	                var adapter = this.adapter, current = adapter.current(), newLength = adapter.length(), navigatingInExisting = this.historyLength === newLength, back = current === this.locations[this.locations.length - 2] && navigatingInExisting, backCalled = this.backCalled, prev = this.current;
	                if (current === null || this.current === current || this.current === decodeURIComponent(current)) {
	                    return true;
	                }
	                this.historyLength = newLength;
	                this.backCalled = false;
	                this.current = current;
	                if (back && this.trigger('back', {
	                        url: prev,
	                        to: current
	                    })) {
	                    adapter.forward();
	                    this.current = prev;
	                    return;
	                }
	                if (this.trigger(CHANGE, {
	                        url: current,
	                        backButtonPressed: !backCalled
	                    })) {
	                    if (back) {
	                        adapter.forward();
	                    } else {
	                        adapter.back();
	                        this.historyLength--;
	                    }
	                    this.current = prev;
	                    return;
	                }
	                if (back) {
	                    this.locations.pop();
	                } else {
	                    this.locations.push(current);
	                }
	            }
	        });
	        kendo.History = History;
	        kendo.History.HistoryAdapter = HistoryAdapter;
	        kendo.History.HashAdapter = HashAdapter;
	        kendo.History.PushStateAdapter = PushStateAdapter;
	        kendo.absoluteURL = absoluteURL;
	        kendo.history = new History();
	    }(window.kendo.jQuery));
	    (function () {
	        var kendo = window.kendo, history = kendo.history, Observable = kendo.Observable, INIT = 'init', ROUTE_MISSING = 'routeMissing', CHANGE = 'change', BACK = 'back', SAME = 'same', optionalParam = /\((.*?)\)/g, namedParam = /(\(\?)?:\w+/g, splatParam = /\*\w+/g, escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
	        function namedParamReplace(match, optional) {
	            return optional ? match : '([^/]+)';
	        }
	        function routeToRegExp(route, ignoreCase) {
	            return new RegExp('^' + route.replace(escapeRegExp, '\\$&').replace(optionalParam, '(?:$1)?').replace(namedParam, namedParamReplace).replace(splatParam, '(.*?)') + '$', ignoreCase ? 'i' : '');
	        }
	        function stripUrl(url) {
	            return url.replace(/(\?.*)|(#.*)/g, '');
	        }
	        var Route = kendo.Class.extend({
	            init: function (route, callback, ignoreCase) {
	                if (!(route instanceof RegExp)) {
	                    route = routeToRegExp(route, ignoreCase);
	                }
	                this.route = route;
	                this._callback = callback;
	            },
	            callback: function (url, back, decode) {
	                var params, idx = 0, length, queryStringParams = kendo.parseQueryStringParams(url);
	                queryStringParams._back = back;
	                url = stripUrl(url);
	                params = this.route.exec(url).slice(1);
	                length = params.length;
	                if (decode) {
	                    for (; idx < length; idx++) {
	                        if (typeof params[idx] !== 'undefined') {
	                            params[idx] = decodeURIComponent(params[idx]);
	                        }
	                    }
	                }
	                params.push(queryStringParams);
	                this._callback.apply(null, params);
	            },
	            worksWith: function (url, back, decode) {
	                if (this.route.test(stripUrl(url))) {
	                    this.callback(url, back, decode);
	                    return true;
	                } else {
	                    return false;
	                }
	            }
	        });
	        var Router = Observable.extend({
	            init: function (options) {
	                if (!options) {
	                    options = {};
	                }
	                Observable.fn.init.call(this);
	                this.routes = [];
	                this.pushState = options.pushState;
	                this.hashBang = options.hashBang;
	                this.root = options.root;
	                this.ignoreCase = options.ignoreCase !== false;
	                this.bind([
	                    INIT,
	                    ROUTE_MISSING,
	                    CHANGE,
	                    SAME
	                ], options);
	            },
	            destroy: function () {
	                history.unbind(CHANGE, this._urlChangedProxy);
	                history.unbind(SAME, this._sameProxy);
	                history.unbind(BACK, this._backProxy);
	                this.unbind();
	            },
	            start: function () {
	                var that = this, sameProxy = function () {
	                        that._same();
	                    }, backProxy = function (e) {
	                        that._back(e);
	                    }, urlChangedProxy = function (e) {
	                        that._urlChanged(e);
	                    };
	                history.start({
	                    same: sameProxy,
	                    change: urlChangedProxy,
	                    back: backProxy,
	                    pushState: that.pushState,
	                    hashBang: that.hashBang,
	                    root: that.root
	                });
	                var initEventObject = {
	                    url: history.current || '/',
	                    preventDefault: $.noop
	                };
	                if (!that.trigger(INIT, initEventObject)) {
	                    that._urlChanged(initEventObject);
	                }
	                this._urlChangedProxy = urlChangedProxy;
	                this._backProxy = backProxy;
	            },
	            route: function (route, callback) {
	                this.routes.push(new Route(route, callback, this.ignoreCase));
	            },
	            navigate: function (url, silent) {
	                kendo.history.navigate(url, silent);
	            },
	            replace: function (url, silent) {
	                kendo.history.replace(url, silent);
	            },
	            _back: function (e) {
	                if (this.trigger(BACK, {
	                        url: e.url,
	                        to: e.to
	                    })) {
	                    e.preventDefault();
	                }
	            },
	            _same: function () {
	                this.trigger(SAME);
	            },
	            _urlChanged: function (e) {
	                var url = e.url;
	                var decode = typeof e.decode === 'undefined';
	                var back = e.backButtonPressed;
	                if (!url) {
	                    url = '/';
	                }
	                if (this.trigger(CHANGE, {
	                        url: e.url,
	                        params: kendo.parseQueryStringParams(e.url),
	                        backButtonPressed: back
	                    })) {
	                    e.preventDefault();
	                    return;
	                }
	                var idx = 0, routes = this.routes, route, length = routes.length;
	                for (; idx < length; idx++) {
	                    route = routes[idx];
	                    if (route.worksWith(url, back, decode)) {
	                        return;
	                    }
	                }
	                if (this.trigger(ROUTE_MISSING, {
	                        url: url,
	                        params: kendo.parseQueryStringParams(url),
	                        backButtonPressed: back
	                    })) {
	                    e.preventDefault();
	                }
	            }
	        });
	        kendo.Router = Router;
	    }());
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(219),
	        __webpack_require__(222)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'mobile.application',
	        name: 'Application',
	        category: 'mobile',
	        description: 'The Mobile application provides a framework to build native looking web applications on mobile devices.',
	        depends: [
	            'mobile.pane',
	            'router'
	        ]
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, mobile = kendo.mobile, support = kendo.support, Widget = mobile.ui.Widget, Pane = mobile.ui.Pane, DEFAULT_OS = 'ios7', OS = support.mobileOS, BERRYPHONEGAP = OS.device == 'blackberry' && OS.flatVersion >= 600 && OS.flatVersion < 1000 && OS.appMode, FONT_SIZE_COEF = 0.93, VERTICAL = 'km-vertical', CHROME = OS.browser === 'chrome', BROKEN_WEBVIEW_RESIZE = OS.ios && OS.flatVersion >= 700 && OS.flatVersion < 800 && (OS.appMode || CHROME), INITIALLY_HORIZONTAL = Math.abs(window.orientation) / 90 == 1, HORIZONTAL = 'km-horizontal', MOBILE_PLATFORMS = {
	                ios7: {
	                    ios: true,
	                    browser: 'default',
	                    device: 'iphone',
	                    flatVersion: '700',
	                    majorVersion: '7',
	                    minorVersion: '0.0',
	                    name: 'ios',
	                    tablet: false
	                },
	                ios: {
	                    ios: true,
	                    browser: 'default',
	                    device: 'iphone',
	                    flatVersion: '612',
	                    majorVersion: '6',
	                    minorVersion: '1.2',
	                    name: 'ios',
	                    tablet: false
	                },
	                android: {
	                    android: true,
	                    browser: 'default',
	                    device: 'android',
	                    flatVersion: '442',
	                    majorVersion: '4',
	                    minorVersion: '4.2',
	                    name: 'android',
	                    tablet: false
	                },
	                blackberry: {
	                    blackberry: true,
	                    browser: 'default',
	                    device: 'blackberry',
	                    flatVersion: '710',
	                    majorVersion: '7',
	                    minorVersion: '1.0',
	                    name: 'blackberry',
	                    tablet: false
	                },
	                meego: {
	                    meego: true,
	                    browser: 'default',
	                    device: 'meego',
	                    flatVersion: '850',
	                    majorVersion: '8',
	                    minorVersion: '5.0',
	                    name: 'meego',
	                    tablet: false
	                },
	                wp: {
	                    wp: true,
	                    browser: 'default',
	                    device: 'wp',
	                    flatVersion: '800',
	                    majorVersion: '8',
	                    minorVersion: '0.0',
	                    name: 'wp',
	                    tablet: false
	                }
	            }, viewportTemplate = kendo.template('<meta content="initial-scale=#: data.scale #, maximum-scale=#: data.scale #, user-scalable=no#=data.height#" name="viewport" />', { usedWithBlock: false }), systemMeta = kendo.template('<meta name="apple-mobile-web-app-capable" content="#= data.webAppCapable === false ? \'no\' : \'yes\' #" /> ' + '<meta name="apple-mobile-web-app-status-bar-style" content="#=data.statusBarStyle#" /> ' + '<meta name="msapplication-tap-highlight" content="no" /> ', { usedWithBlock: false }), clipTemplate = kendo.template('<style>.km-view { clip: rect(0 #= data.width #px #= data.height #px 0); }</style>', { usedWithBlock: false }), ENABLE_CLIP = OS.android && OS.browser != 'chrome' || OS.blackberry, iconMeta = kendo.template('<link rel="apple-touch-icon' + (OS.android ? '-precomposed' : '') + '" # if(data.size) { # sizes="#=data.size#" #}# href="#=data.icon#" />', { usedWithBlock: false }), HIDEBAR = (OS.device == 'iphone' || OS.device == 'ipod') && OS.majorVersion < 7, SUPPORT_SWIPE_TO_GO_BACK = (OS.device == 'iphone' || OS.device == 'ipod') && OS.majorVersion >= 7, HISTORY_TRANSITION = SUPPORT_SWIPE_TO_GO_BACK ? 'none' : null, BARCOMPENSATION = OS.browser == 'mobilesafari' ? 60 : 0, STATUS_BAR_HEIGHT = 20, WINDOW = $(window), SCREEN = window.screen, HEAD = $('head'), INIT = 'init', proxy = $.proxy;
	        function osCssClass(os, options) {
	            var classes = [];
	            if (OS) {
	                classes.push('km-on-' + OS.name);
	            }
	            if (os.skin) {
	                classes.push('km-' + os.skin);
	            } else {
	                if (os.name == 'ios' && os.majorVersion > 6) {
	                    classes.push('km-ios7');
	                } else {
	                    classes.push('km-' + os.name);
	                }
	            }
	            if (os.name == 'ios' && os.majorVersion < 7 || os.name != 'ios') {
	                classes.push('km-' + os.name + os.majorVersion);
	            }
	            classes.push('km-' + os.majorVersion);
	            classes.push('km-m' + (os.minorVersion ? os.minorVersion[0] : 0));
	            if (os.variant && (os.skin && os.skin === os.name || !os.skin || os.setDefaultPlatform === false)) {
	                classes.push('km-' + (os.skin ? os.skin : os.name) + '-' + os.variant);
	            }
	            if (os.cordova) {
	                classes.push('km-cordova');
	            }
	            if (os.appMode) {
	                classes.push('km-app');
	            } else {
	                classes.push('km-web');
	            }
	            if (options && options.statusBarStyle) {
	                classes.push('km-' + options.statusBarStyle + '-status-bar');
	            }
	            return classes.join(' ');
	        }
	        function wp8Background(os) {
	            return 'km-wp-' + (os.noVariantSet ? parseInt($('<div style=\'background: Background\' />').css('background-color').split(',')[1], 10) === 0 ? 'dark' : 'light' : os.variant + ' km-wp-' + os.variant + '-force');
	        }
	        function isOrientationHorizontal(element) {
	            return OS.wp ? element.css('animation-name') == '-kendo-landscape' : Math.abs(window.orientation) / 90 == 1;
	        }
	        function getOrientationClass(element) {
	            return isOrientationHorizontal(element) ? HORIZONTAL : VERTICAL;
	        }
	        function setMinimumHeight(pane) {
	            pane.parent().addBack().css('min-height', window.innerHeight);
	        }
	        function applyViewportHeight() {
	            $('meta[name=viewport]').remove();
	            HEAD.append(viewportTemplate({ height: ', width=device-width' + (isOrientationHorizontal() ? ', height=' + window.innerHeight + 'px' : support.mobileOS.flatVersion >= 600 && support.mobileOS.flatVersion < 700 ? ', height=' + window.innerWidth + 'px' : ', height=device-height') }));
	        }
	        var Application = Widget.extend({
	            init: function (element, options) {
	                mobile.application = this;
	                $($.proxy(this, 'bootstrap', element, options));
	            },
	            bootstrap: function (element, options) {
	                element = $(element);
	                if (!element[0]) {
	                    element = $(document.body);
	                }
	                Widget.fn.init.call(this, element, options);
	                this.element.removeAttr('data-' + kendo.ns + 'role');
	                this._setupPlatform();
	                this._attachMeta();
	                this._setupElementClass();
	                this._attachHideBarHandlers();
	                var paneOptions = $.extend({}, this.options);
	                delete paneOptions.name;
	                var that = this, startHistory = function () {
	                        that.pane = new Pane(that.element, paneOptions);
	                        that.pane.navigateToInitial();
	                        if (that.options.updateDocumentTitle) {
	                            that._setupDocumentTitle();
	                        }
	                        that._startHistory();
	                        that.trigger(INIT);
	                    };
	                if (this.options.$angular) {
	                    setTimeout(startHistory);
	                } else {
	                    startHistory();
	                }
	            },
	            options: {
	                name: 'Application',
	                hideAddressBar: true,
	                browserHistory: true,
	                historyTransition: HISTORY_TRANSITION,
	                modelScope: window,
	                statusBarStyle: 'black',
	                transition: '',
	                retina: false,
	                platform: null,
	                skin: null,
	                updateDocumentTitle: true,
	                useNativeScrolling: false
	            },
	            events: [INIT],
	            navigate: function (url, transition) {
	                this.pane.navigate(url, transition);
	            },
	            replace: function (url, transition) {
	                this.pane.replace(url, transition);
	            },
	            scroller: function () {
	                return this.view().scroller;
	            },
	            hideLoading: function () {
	                if (this.pane) {
	                    this.pane.hideLoading();
	                } else {
	                    throw new Error('The mobile application instance is not fully instantiated. Please consider activating loading in the application init event handler.');
	                }
	            },
	            showLoading: function () {
	                if (this.pane) {
	                    this.pane.showLoading();
	                } else {
	                    throw new Error('The mobile application instance is not fully instantiated. Please consider activating loading in the application init event handler.');
	                }
	            },
	            changeLoadingMessage: function (message) {
	                if (this.pane) {
	                    this.pane.changeLoadingMessage(message);
	                } else {
	                    throw new Error('The mobile application instance is not fully instantiated. Please consider changing the message in the application init event handler.');
	                }
	            },
	            view: function () {
	                return this.pane.view();
	            },
	            skin: function (skin) {
	                var that = this;
	                if (!arguments.length) {
	                    return that.options.skin;
	                }
	                that.options.skin = skin || '';
	                that.element[0].className = 'km-pane';
	                that._setupPlatform();
	                that._setupElementClass();
	                return that.options.skin;
	            },
	            destroy: function () {
	                Widget.fn.destroy.call(this);
	                this.pane.destroy();
	                if (this.options.browserHistory) {
	                    this.router.destroy();
	                }
	            },
	            _setupPlatform: function () {
	                var that = this, platform = that.options.platform, skin = that.options.skin, split = [], os = OS || MOBILE_PLATFORMS[DEFAULT_OS];
	                if (platform) {
	                    os.setDefaultPlatform = true;
	                    if (typeof platform === 'string') {
	                        split = platform.split('-');
	                        os = $.extend({ variant: split[1] }, os, MOBILE_PLATFORMS[split[0]]);
	                    } else {
	                        os = platform;
	                    }
	                }
	                if (skin) {
	                    split = skin.split('-');
	                    if (!OS) {
	                        os.setDefaultPlatform = false;
	                    }
	                    os = $.extend({}, os, {
	                        skin: split[0],
	                        variant: split[1]
	                    });
	                }
	                if (!os.variant) {
	                    os.noVariantSet = true;
	                    os.variant = 'dark';
	                }
	                that.os = os;
	                that.osCssClass = osCssClass(that.os, that.options);
	                if (os.name == 'wp') {
	                    if (!that.refreshBackgroundColorProxy) {
	                        that.refreshBackgroundColorProxy = $.proxy(function () {
	                            if (that.os.variant && (that.os.skin && that.os.skin === that.os.name) || !that.os.skin) {
	                                that.element.removeClass('km-wp-dark km-wp-light km-wp-dark-force km-wp-light-force').addClass(wp8Background(that.os));
	                            }
	                        }, that);
	                    }
	                    $(document).off('visibilitychange', that.refreshBackgroundColorProxy);
	                    $(document).off('resume', that.refreshBackgroundColorProxy);
	                    if (!os.skin) {
	                        that.element.parent().css('overflow', 'hidden');
	                        $(document).on('visibilitychange', that.refreshBackgroundColorProxy);
	                        $(document).on('resume', that.refreshBackgroundColorProxy);
	                        that.refreshBackgroundColorProxy();
	                    }
	                }
	            },
	            _startHistory: function () {
	                if (this.options.browserHistory) {
	                    this.router = new kendo.Router({
	                        pushState: this.options.pushState,
	                        root: this.options.root,
	                        hashBang: this.options.hashBang
	                    });
	                    this.pane.bindToRouter(this.router);
	                    this.router.start();
	                } else {
	                    if (!this.options.initial) {
	                        this.pane.navigate('');
	                    }
	                }
	            },
	            _resizeToScreenHeight: function () {
	                var includeStatusBar = $('meta[name=apple-mobile-web-app-status-bar-style]').attr('content').match(/black-translucent|hidden/), element = this.element, height;
	                if (CHROME) {
	                    height = window.innerHeight;
	                } else {
	                    if (isOrientationHorizontal(element)) {
	                        if (includeStatusBar) {
	                            if (INITIALLY_HORIZONTAL) {
	                                height = SCREEN.availWidth + STATUS_BAR_HEIGHT;
	                            } else {
	                                height = SCREEN.availWidth;
	                            }
	                        } else {
	                            if (INITIALLY_HORIZONTAL) {
	                                height = SCREEN.availWidth;
	                            } else {
	                                height = SCREEN.availWidth - STATUS_BAR_HEIGHT;
	                            }
	                        }
	                    } else {
	                        if (includeStatusBar) {
	                            if (INITIALLY_HORIZONTAL) {
	                                height = SCREEN.availHeight;
	                            } else {
	                                height = SCREEN.availHeight + STATUS_BAR_HEIGHT;
	                            }
	                        } else {
	                            if (INITIALLY_HORIZONTAL) {
	                                height = SCREEN.availHeight - STATUS_BAR_HEIGHT;
	                            } else {
	                                height = SCREEN.availHeight;
	                            }
	                        }
	                    }
	                }
	                element.height(height);
	            },
	            _setupElementClass: function () {
	                var that = this, size, element = that.element;
	                element.parent().addClass('km-root km-' + (that.os.tablet ? 'tablet' : 'phone'));
	                element.addClass(that.osCssClass + ' ' + getOrientationClass(element));
	                if (this.options.useNativeScrolling) {
	                    element.parent().addClass('km-native-scrolling');
	                }
	                if (CHROME) {
	                    element.addClass('km-ios-chrome');
	                }
	                if (support.wpDevicePixelRatio) {
	                    element.parent().css('font-size', support.wpDevicePixelRatio + 'em');
	                }
	                if (this.options.retina) {
	                    element.parent().addClass('km-retina');
	                    element.parent().css('font-size', support.devicePixelRatio * FONT_SIZE_COEF + 'em');
	                }
	                if (BERRYPHONEGAP) {
	                    applyViewportHeight();
	                }
	                if (that.options.useNativeScrolling) {
	                    element.parent().addClass('km-native-scrolling');
	                } else if (ENABLE_CLIP) {
	                    size = (screen.availWidth > screen.availHeight ? screen.availWidth : screen.availHeight) + 200;
	                    $(clipTemplate({
	                        width: size,
	                        height: size
	                    })).appendTo(HEAD);
	                }
	                if (BROKEN_WEBVIEW_RESIZE) {
	                    that._resizeToScreenHeight();
	                }
	                kendo.onResize(function () {
	                    element.removeClass('km-horizontal km-vertical').addClass(getOrientationClass(element));
	                    if (that.options.useNativeScrolling) {
	                        setMinimumHeight(element);
	                    }
	                    if (BROKEN_WEBVIEW_RESIZE) {
	                        that._resizeToScreenHeight();
	                    }
	                    if (BERRYPHONEGAP) {
	                        applyViewportHeight();
	                    }
	                    kendo.resize(element);
	                });
	            },
	            _clearExistingMeta: function () {
	                HEAD.find('meta').filter('[name|=\'apple-mobile-web-app\'],[name|=\'msapplication-tap\'],[name=\'viewport\']').remove();
	            },
	            _attachMeta: function () {
	                var options = this.options, icon = options.icon, size;
	                this._clearExistingMeta();
	                if (!BERRYPHONEGAP) {
	                    HEAD.prepend(viewportTemplate({
	                        height: '',
	                        scale: this.options.retina ? 1 / support.devicePixelRatio : '1.0'
	                    }));
	                }
	                HEAD.prepend(systemMeta(options));
	                if (icon) {
	                    if (typeof icon === 'string') {
	                        icon = { '': icon };
	                    }
	                    for (size in icon) {
	                        HEAD.prepend(iconMeta({
	                            icon: icon[size],
	                            size: size
	                        }));
	                    }
	                }
	                if (options.useNativeScrolling) {
	                    setMinimumHeight(this.element);
	                }
	            },
	            _attachHideBarHandlers: function () {
	                var that = this, hideBar = proxy(that, '_hideBar');
	                if (support.mobileOS.appMode || !that.options.hideAddressBar || !HIDEBAR || that.options.useNativeScrolling) {
	                    return;
	                }
	                that._initialHeight = {};
	                WINDOW.on('load', hideBar);
	                kendo.onResize(function () {
	                    setTimeout(window.scrollTo, 0, 0, 1);
	                });
	            },
	            _setupDocumentTitle: function () {
	                var that = this, defaultTitle = document.title;
	                that.pane.bind('viewShow', function (e) {
	                    var title = e.view.title;
	                    document.title = title !== undefined ? title : defaultTitle;
	                });
	            },
	            _hideBar: function () {
	                var that = this, element = that.element;
	                element.height(kendo.support.transforms.css + 'calc(100% + ' + BARCOMPENSATION + 'px)');
	                $(window).trigger(kendo.support.resize);
	            }
	        });
	        kendo.mobile.Application = Application;
	        kendo.ui.plugin(Application, kendo.mobile, 'Mobile');
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(209)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'mobile.button',
	        name: 'Button',
	        category: 'mobile',
	        description: 'The Button widget navigates between mobile Application views when pressed.',
	        depends: ['userevents']
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, mobile = kendo.mobile, ui = mobile.ui, Widget = ui.Widget, support = kendo.support, os = support.mobileOS, ANDROID3UP = os.android && os.flatVersion >= 300, CLICK = 'click', DISABLED = 'disabled', DISABLEDSTATE = 'km-state-disabled';
	        function highlightButton(widget, event, highlight) {
	            $(event.target).closest('.km-button,.km-detail').toggleClass('km-state-active', highlight);
	            if (ANDROID3UP && widget.deactivateTimeoutID) {
	                clearTimeout(widget.deactivateTimeoutID);
	                widget.deactivateTimeoutID = 0;
	            }
	        }
	        function createBadge(value) {
	            return $('<span class="km-badge">' + value + '</span>');
	        }
	        var Button = Widget.extend({
	            init: function (element, options) {
	                var that = this;
	                Widget.fn.init.call(that, element, options);
	                var useTap = that.options.clickOn === 'up';
	                that._wrap();
	                that._style();
	                if (!useTap) {
	                    that.element.attr('data-navigate-on-press', true);
	                }
	                that.options.enable = that.options.enable && !that.element.attr(DISABLED);
	                that.enable(that.options.enable);
	                that._userEvents = new kendo.UserEvents(that.element, {
	                    allowSelection: !useTap,
	                    fastTap: true,
	                    press: function (e) {
	                        that._activate(e);
	                    },
	                    release: function (e) {
	                        highlightButton(that, e, false);
	                        if (!useTap) {
	                            e.event.stopPropagation();
	                        }
	                    }
	                });
	                that._userEvents.bind(useTap ? 'tap' : 'press', function (e) {
	                    that._release(e);
	                });
	                if (ANDROID3UP) {
	                    that.element.on('move', function (e) {
	                        that._timeoutDeactivate(e);
	                    });
	                }
	            },
	            destroy: function () {
	                Widget.fn.destroy.call(this);
	                this._userEvents.destroy();
	            },
	            events: [CLICK],
	            options: {
	                name: 'Button',
	                icon: '',
	                style: '',
	                badge: '',
	                clickOn: 'up',
	                enable: true
	            },
	            badge: function (value) {
	                var badge = this.badgeElement = this.badgeElement || createBadge(value).appendTo(this.element);
	                if (value || value === 0) {
	                    badge.html(value);
	                    return this;
	                }
	                if (value === false) {
	                    badge.empty().remove();
	                    this.badgeElement = false;
	                    return this;
	                }
	                return badge.html();
	            },
	            enable: function (enable) {
	                var element = this.element;
	                if (typeof enable == 'undefined') {
	                    enable = true;
	                }
	                this.options.enable = enable;
	                if (enable) {
	                    element.removeAttr(DISABLED);
	                } else {
	                    element.attr(DISABLED, DISABLED);
	                }
	                element.toggleClass(DISABLEDSTATE, !enable);
	            },
	            _timeoutDeactivate: function (e) {
	                if (!this.deactivateTimeoutID) {
	                    this.deactivateTimeoutID = setTimeout(highlightButton, 500, this, e, false);
	                }
	            },
	            _activate: function (e) {
	                var activeElement = document.activeElement, nodeName = activeElement ? activeElement.nodeName : '';
	                if (this.options.enable) {
	                    highlightButton(this, e, true);
	                    if (nodeName == 'INPUT' || nodeName == 'TEXTAREA') {
	                        activeElement.blur();
	                    }
	                }
	            },
	            _release: function (e) {
	                var that = this;
	                if (e.which > 1) {
	                    return;
	                }
	                if (!that.options.enable) {
	                    e.preventDefault();
	                    return;
	                }
	                if (that.trigger(CLICK, {
	                        target: $(e.target),
	                        button: that.element
	                    })) {
	                    e.preventDefault();
	                }
	            },
	            _style: function () {
	                var style = this.options.style, element = this.element, styles;
	                if (style) {
	                    styles = style.split(' ');
	                    $.each(styles, function () {
	                        element.addClass('km-' + this);
	                    });
	                }
	            },
	            _wrap: function () {
	                var that = this, icon = that.options.icon, badge = that.options.badge, iconSpan = '<span class="km-icon km-' + icon, element = that.element.addClass('km-button'), span = element.children('span:not(.km-icon)').addClass('km-text'), image = element.find('img').addClass('km-image');
	                if (!span[0] && element.html()) {
	                    span = element.wrapInner('<span class="km-text" />').children('span.km-text');
	                }
	                if (!image[0] && icon) {
	                    if (!span[0]) {
	                        iconSpan += ' km-notext';
	                    }
	                    that.iconElement = element.prepend($(iconSpan + '" />'));
	                }
	                if (badge || badge === 0) {
	                    that.badgeElement = createBadge(badge).appendTo(element);
	                }
	            }
	        });
	        var BackButton = Button.extend({
	            options: {
	                name: 'BackButton',
	                style: 'back'
	            },
	            init: function (element, options) {
	                var that = this;
	                Button.fn.init.call(that, element, options);
	                if (typeof that.element.attr('href') === 'undefined') {
	                    that.element.attr('href', '#:back');
	                }
	            }
	        });
	        var DetailButton = Button.extend({
	            options: {
	                name: 'DetailButton',
	                style: ''
	            },
	            init: function (element, options) {
	                Button.fn.init.call(this, element, options);
	            },
	            _style: function () {
	                var style = this.options.style + ' detail', element = this.element;
	                if (style) {
	                    var styles = style.split(' ');
	                    $.each(styles, function () {
	                        element.addClass('km-' + this);
	                    });
	                }
	            },
	            _wrap: function () {
	                var that = this, icon = that.options.icon, iconSpan = '<span class="km-icon km-' + icon, element = that.element, span = element.children('span'), image = element.find('img').addClass('km-image');
	                if (!image[0] && icon) {
	                    if (!span[0]) {
	                        iconSpan += ' km-notext';
	                    }
	                    element.prepend($(iconSpan + '" />'));
	                }
	            }
	        });
	        ui.plugin(Button);
	        ui.plugin(BackButton);
	        ui.plugin(DetailButton);
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(202)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'mobile.buttongroup',
	        name: 'ButtonGroup',
	        category: 'mobile',
	        description: 'The Kendo mobile ButtonGroup widget is a linear set of grouped buttons.',
	        depends: ['core']
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, ui = kendo.mobile.ui, Widget = ui.Widget, ACTIVE = 'km-state-active', DISABLE = 'km-state-disabled', SELECT = 'select', SELECTOR = 'li:not(.' + ACTIVE + ')';
	        function createBadge(value) {
	            return $('<span class="km-badge">' + value + '</span>');
	        }
	        var ButtonGroup = Widget.extend({
	            init: function (element, options) {
	                var that = this;
	                Widget.fn.init.call(that, element, options);
	                that.element.addClass('km-buttongroup').find('li').each(that._button);
	                that.element.on(that.options.selectOn, SELECTOR, '_select');
	                that._enable = true;
	                that.select(that.options.index);
	                if (!that.options.enable) {
	                    that._enable = false;
	                    that.wrapper.addClass(DISABLE);
	                }
	            },
	            events: [SELECT],
	            options: {
	                name: 'ButtonGroup',
	                selectOn: 'down',
	                index: -1,
	                enable: true
	            },
	            current: function () {
	                return this.element.find('.' + ACTIVE);
	            },
	            select: function (li) {
	                var that = this, index = -1;
	                if (li === undefined || li === -1 || !that._enable || $(li).is('.' + DISABLE)) {
	                    return;
	                }
	                that.current().removeClass(ACTIVE);
	                if (typeof li === 'number') {
	                    index = li;
	                    li = $(that.element[0].children[li]);
	                } else if (li.nodeType) {
	                    li = $(li);
	                    index = li.index();
	                }
	                li.addClass(ACTIVE);
	                that.selectedIndex = index;
	            },
	            badge: function (item, value) {
	                var buttongroup = this.element, badge;
	                if (!isNaN(item)) {
	                    item = buttongroup.children().get(item);
	                }
	                item = buttongroup.find(item);
	                badge = $(item.children('.km-badge')[0] || createBadge(value).appendTo(item));
	                if (value || value === 0) {
	                    badge.html(value);
	                    return this;
	                }
	                if (value === false) {
	                    badge.empty().remove();
	                    return this;
	                }
	                return badge.html();
	            },
	            enable: function (enable) {
	                var wrapper = this.wrapper;
	                if (typeof enable == 'undefined') {
	                    enable = true;
	                }
	                if (enable) {
	                    wrapper.removeClass(DISABLE);
	                } else {
	                    wrapper.addClass(DISABLE);
	                }
	                this._enable = this.options.enable = enable;
	            },
	            _button: function () {
	                var button = $(this).addClass('km-button'), icon = kendo.attrValue(button, 'icon'), badge = kendo.attrValue(button, 'badge'), span = button.children('span'), image = button.find('img').addClass('km-image');
	                if (!span[0]) {
	                    span = button.wrapInner('<span/>').children('span');
	                }
	                span.addClass('km-text');
	                if (!image[0] && icon) {
	                    button.prepend($('<span class="km-icon km-' + icon + '"/>'));
	                }
	                if (badge || badge === 0) {
	                    createBadge(badge).appendTo(button);
	                }
	            },
	            _select: function (e) {
	                if (e.which > 1 || e.isDefaultPrevented() || !this._enable) {
	                    return;
	                }
	                this.select(e.currentTarget);
	                this.trigger(SELECT, { index: this.selectedIndex });
	            }
	        });
	        ui.plugin(ButtonGroup);
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(216),
	        __webpack_require__(209)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'mobile.drawer',
	        name: 'Drawer',
	        category: 'mobile',
	        description: 'The Kendo Mobile Drawer widget provides slide to reveal global application toolbox',
	        depends: [
	            'mobile.view',
	            'userevents'
	        ]
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, mobile = kendo.mobile, os = kendo.support.mobileOS, Transition = kendo.effects.Transition, roleSelector = kendo.roleSelector, AXIS = 'x', ui = mobile.ui, SWIPE_TO_OPEN = !(os.ios && os.majorVersion == 7 && !os.appMode), BEFORE_SHOW = 'beforeShow', INIT = 'init', SHOW = 'show', HIDE = 'hide', AFTER_HIDE = 'afterHide', NULL_VIEW = { enable: $.noop };
	        var Drawer = ui.View.extend({
	            init: function (element, options) {
	                $(element).parent().prepend(element);
	                mobile.ui.Widget.fn.init.call(this, element, options);
	                if (!this.options.$angular) {
	                    this._layout();
	                    this._scroller();
	                }
	                this._model();
	                var pane = this.element.closest(roleSelector('pane')).data('kendoMobilePane'), userEvents;
	                if (pane) {
	                    this.pane = pane;
	                    this.pane.bind('viewShow', function (e) {
	                        drawer._viewShow(e);
	                    });
	                    this.pane.bind('sameViewRequested', function () {
	                        drawer.hide();
	                    });
	                    userEvents = this.userEvents = new kendo.UserEvents(pane.element, {
	                        fastTap: true,
	                        filter: roleSelector('view splitview'),
	                        allowSelection: true
	                    });
	                } else {
	                    this.currentView = NULL_VIEW;
	                    var container = $(this.options.container);
	                    if (!container) {
	                        throw new Error('The drawer needs a container configuration option set.');
	                    }
	                    userEvents = this.userEvents = new kendo.UserEvents(container, {
	                        fastTap: true,
	                        allowSelection: true
	                    });
	                    this._attachTransition(container);
	                }
	                var drawer = this;
	                var hide = function (e) {
	                    if (drawer.visible) {
	                        drawer.hide();
	                        e.preventDefault();
	                    }
	                };
	                if (this.options.swipeToOpen && SWIPE_TO_OPEN) {
	                    userEvents.bind('press', function () {
	                        drawer.transition.cancel();
	                    });
	                    userEvents.bind('start', function (e) {
	                        drawer._start(e);
	                    });
	                    userEvents.bind('move', function (e) {
	                        drawer._update(e);
	                    });
	                    userEvents.bind('end', function (e) {
	                        drawer._end(e);
	                    });
	                    userEvents.bind('tap', hide);
	                } else {
	                    userEvents.bind('press', hide);
	                }
	                this.leftPositioned = this.options.position === 'left';
	                this.visible = false;
	                this.element.hide().addClass('km-drawer').addClass(this.leftPositioned ? 'km-left-drawer' : 'km-right-drawer');
	                this.trigger(INIT);
	            },
	            options: {
	                name: 'Drawer',
	                position: 'left',
	                views: [],
	                swipeToOpenViews: [],
	                swipeToOpen: true,
	                title: '',
	                container: null
	            },
	            events: [
	                BEFORE_SHOW,
	                HIDE,
	                AFTER_HIDE,
	                INIT,
	                SHOW
	            ],
	            show: function () {
	                if (this._activate()) {
	                    this._show();
	                }
	            },
	            hide: function () {
	                if (!this.currentView) {
	                    return;
	                }
	                this.currentView.enable();
	                Drawer.current = null;
	                this._moveViewTo(0);
	                this.trigger(HIDE, { view: this });
	            },
	            openFor: function () {
	                if (this.visible) {
	                    this.hide();
	                } else {
	                    this.show();
	                }
	            },
	            destroy: function () {
	                ui.View.fn.destroy.call(this);
	                this.userEvents.destroy();
	            },
	            _activate: function () {
	                if (this.visible) {
	                    return true;
	                }
	                var visibleOnCurrentView = this._currentViewIncludedIn(this.options.views);
	                if (!visibleOnCurrentView || this.trigger(BEFORE_SHOW, { view: this })) {
	                    return false;
	                }
	                this._setAsCurrent();
	                this.element.show();
	                this.trigger(SHOW, { view: this });
	                this._invokeNgController();
	                return true;
	            },
	            _currentViewIncludedIn: function (views) {
	                if (!this.pane || !views.length) {
	                    return true;
	                }
	                var view = this.pane.view();
	                return $.inArray(view.id.replace('#', ''), views) > -1 || $.inArray(view.element.attr('id'), views) > -1;
	            },
	            _show: function () {
	                this.currentView.enable(false);
	                this.visible = true;
	                var offset = this.element.width();
	                if (!this.leftPositioned) {
	                    offset = -offset;
	                }
	                this._moveViewTo(offset);
	            },
	            _setAsCurrent: function () {
	                if (Drawer.last !== this) {
	                    if (Drawer.last) {
	                        Drawer.last.element.hide();
	                    }
	                    this.element.show();
	                }
	                Drawer.last = this;
	                Drawer.current = this;
	            },
	            _moveViewTo: function (offset) {
	                this.userEvents.cancel();
	                this.transition.moveTo({
	                    location: offset,
	                    duration: 400,
	                    ease: Transition.easeOutExpo
	                });
	            },
	            _viewShow: function (e) {
	                if (this.currentView) {
	                    this.currentView.enable();
	                }
	                if (this.currentView === e.view) {
	                    this.hide();
	                    return;
	                }
	                this.currentView = e.view;
	                this._attachTransition(e.view.element);
	            },
	            _attachTransition: function (element) {
	                var that = this, movable = this.movable, currentOffset = movable && movable.x;
	                if (this.transition) {
	                    this.transition.cancel();
	                    this.movable.moveAxis('x', 0);
	                }
	                movable = this.movable = new kendo.ui.Movable(element);
	                this.transition = new Transition({
	                    axis: AXIS,
	                    movable: this.movable,
	                    onEnd: function () {
	                        if (movable[AXIS] === 0) {
	                            element[0].style.cssText = '';
	                            that.element.hide();
	                            that.trigger(AFTER_HIDE);
	                            that.visible = false;
	                        }
	                    }
	                });
	                if (currentOffset) {
	                    element.addClass('k-fx-hidden');
	                    kendo.animationFrame(function () {
	                        element.removeClass('k-fx-hidden');
	                        that.movable.moveAxis(AXIS, currentOffset);
	                        that.hide();
	                    });
	                }
	            },
	            _start: function (e) {
	                var userEvents = e.sender;
	                if (Math.abs(e.x.velocity) < Math.abs(e.y.velocity) || kendo.triggeredByInput(e.event) || !this._currentViewIncludedIn(this.options.swipeToOpenViews)) {
	                    userEvents.cancel();
	                    return;
	                }
	                var leftPositioned = this.leftPositioned, visible = this.visible, canMoveLeft = leftPositioned && visible || !leftPositioned && !Drawer.current, canMoveRight = !leftPositioned && visible || leftPositioned && !Drawer.current, leftSwipe = e.x.velocity < 0;
	                if (canMoveLeft && leftSwipe || canMoveRight && !leftSwipe) {
	                    if (this._activate()) {
	                        userEvents.capture();
	                        return;
	                    }
	                }
	                userEvents.cancel();
	            },
	            _update: function (e) {
	                var movable = this.movable, newPosition = movable.x + e.x.delta, limitedPosition;
	                if (this.leftPositioned) {
	                    limitedPosition = Math.min(Math.max(0, newPosition), this.element.width());
	                } else {
	                    limitedPosition = Math.max(Math.min(0, newPosition), -this.element.width());
	                }
	                this.movable.moveAxis(AXIS, limitedPosition);
	                e.event.preventDefault();
	                e.event.stopPropagation();
	            },
	            _end: function (e) {
	                var velocity = e.x.velocity, pastHalf = Math.abs(this.movable.x) > this.element.width() / 2, velocityThreshold = 0.8, shouldShow;
	                if (this.leftPositioned) {
	                    shouldShow = velocity > -velocityThreshold && (velocity > velocityThreshold || pastHalf);
	                } else {
	                    shouldShow = velocity < velocityThreshold && (velocity < -velocityThreshold || pastHalf);
	                }
	                if (shouldShow) {
	                    this._show();
	                } else {
	                    this.hide();
	                }
	            }
	        });
	        ui.plugin(Drawer);
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(204),
	        __webpack_require__(209),
	        __webpack_require__(224)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'mobile.listview',
	        name: 'ListView',
	        category: 'mobile',
	        description: 'The Kendo Mobile ListView widget is used to display flat or grouped list of items.',
	        depends: [
	            'data',
	            'userevents',
	            'mobile.button'
	        ]
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, Node = window.Node, mobile = kendo.mobile, ui = mobile.ui, DataSource = kendo.data.DataSource, Widget = ui.DataBoundWidget, ITEM_SELECTOR = '.km-list > li, > li:not(.km-group-container)', HIGHLIGHT_SELECTOR = '.km-listview-link, .km-listview-label', ICON_SELECTOR = '[' + kendo.attr('icon') + ']', proxy = $.proxy, attrValue = kendo.attrValue, GROUP_CLASS = 'km-group-title', ACTIVE_CLASS = 'km-state-active', GROUP_WRAPPER = '<div class="' + GROUP_CLASS + '"><div class="km-text"></div></div>', GROUP_TEMPLATE = kendo.template('<li><div class="' + GROUP_CLASS + '"><div class="km-text">#= this.headerTemplate(data) #</div></div><ul>#= kendo.render(this.template, data.items)#</ul></li>'), WRAPPER = '<div class="km-listview-wrapper" />', SEARCH_TEMPLATE = kendo.template('<form class="km-filter-form"><div class="km-filter-wrap"><input type="search" placeholder="#=placeholder#"/><a href="\\#" class="km-filter-reset" title="Clear"><span class="km-icon km-clear"></span><span class="km-text">Clear</span></a></div></form>'), NS = '.kendoMobileListView', STYLED = 'styled', DATABOUND = 'dataBound', DATABINDING = 'dataBinding', ITEM_CHANGE = 'itemChange', CLICK = 'click', CHANGE = 'change', PROGRESS = 'progress', FUNCTION = 'function', whitespaceRegExp = /^\s+$/, buttonRegExp = /button/;
	        function whitespace() {
	            return this.nodeType === Node.TEXT_NODE && this.nodeValue.match(whitespaceRegExp);
	        }
	        function addIcon(item, icon) {
	            if (icon && !item[0].querySelector('.km-icon')) {
	                item.prepend('<span class="km-icon km-' + icon + '"/>');
	            }
	        }
	        function enhanceItem(item) {
	            addIcon(item, attrValue(item, 'icon'));
	            addIcon(item, attrValue(item.children(ICON_SELECTOR), 'icon'));
	        }
	        function enhanceLinkItem(item) {
	            var parent = item.parent(), itemAndDetailButtons = item.add(parent.children(kendo.roleSelector('detailbutton'))), otherNodes = parent.contents().not(itemAndDetailButtons).not(whitespace);
	            if (otherNodes.length) {
	                return;
	            }
	            item.addClass('km-listview-link').attr(kendo.attr('role'), 'listview-link');
	            addIcon(item, attrValue(parent, 'icon'));
	            addIcon(item, attrValue(item, 'icon'));
	        }
	        function enhanceCheckBoxItem(label) {
	            if (!label[0].querySelector('input[type=checkbox],input[type=radio]')) {
	                return;
	            }
	            var item = label.parent();
	            if (item.contents().not(label).not(function () {
	                    return this.nodeType == 3;
	                })[0]) {
	                return;
	            }
	            label.addClass('km-listview-label');
	            label.children('[type=checkbox],[type=radio]').addClass('km-widget km-icon km-check');
	        }
	        function putAt(element, top) {
	            $(element).css('transform', 'translate3d(0px, ' + top + 'px, 0px)');
	        }
	        var HeaderFixer = kendo.Class.extend({
	            init: function (listView) {
	                var scroller = listView.scroller();
	                if (!scroller) {
	                    return;
	                }
	                this.options = listView.options;
	                this.element = listView.element;
	                this.scroller = listView.scroller();
	                this._shouldFixHeaders();
	                var headerFixer = this;
	                var cacheHeaders = function () {
	                    headerFixer._cacheHeaders();
	                };
	                listView.bind('resize', cacheHeaders);
	                listView.bind(STYLED, cacheHeaders);
	                listView.bind(DATABOUND, cacheHeaders);
	                this._scrollHandler = function (e) {
	                    headerFixer._fixHeader(e);
	                };
	                scroller.bind('scroll', this._scrollHandler);
	            },
	            destroy: function () {
	                var that = this;
	                if (that.scroller) {
	                    that.scroller.unbind('scroll', that._scrollHandler);
	                }
	            },
	            _fixHeader: function (e) {
	                if (!this.fixedHeaders) {
	                    return;
	                }
	                var i = 0, scroller = this.scroller, headers = this.headers, scrollTop = e.scrollTop, headerPair, offset, header;
	                do {
	                    headerPair = headers[i++];
	                    if (!headerPair) {
	                        header = $('<div />');
	                        break;
	                    }
	                    offset = headerPair.offset;
	                    header = headerPair.header;
	                } while (offset + 1 > scrollTop);
	                if (this.currentHeader != i) {
	                    scroller.fixedContainer.html(header.clone());
	                    this.currentHeader = i;
	                }
	            },
	            _shouldFixHeaders: function () {
	                this.fixedHeaders = this.options.type === 'group' && this.options.fixedHeaders;
	            },
	            _cacheHeaders: function () {
	                this._shouldFixHeaders();
	                if (!this.fixedHeaders) {
	                    return;
	                }
	                var headers = [], offset = this.scroller.scrollTop;
	                this.element.find('.' + GROUP_CLASS).each(function (_, header) {
	                    header = $(header);
	                    headers.unshift({
	                        offset: header.position().top + offset,
	                        header: header
	                    });
	                });
	                this.headers = headers;
	                this._fixHeader({ scrollTop: offset });
	            }
	        });
	        var DEFAULT_PULL_PARAMETERS = function () {
	            return { page: 1 };
	        };
	        var RefreshHandler = kendo.Class.extend({
	            init: function (listView) {
	                var handler = this, options = listView.options, scroller = listView.scroller(), pullParameters = options.pullParameters || DEFAULT_PULL_PARAMETERS;
	                this.listView = listView;
	                this.scroller = scroller;
	                listView.bind('_dataSource', function (e) {
	                    handler.setDataSource(e.dataSource);
	                });
	                scroller.setOptions({
	                    pullToRefresh: true,
	                    pull: function () {
	                        if (!handler._pulled) {
	                            handler._pulled = true;
	                            handler.dataSource.read(pullParameters.call(listView, handler._first));
	                        }
	                    },
	                    messages: {
	                        pullTemplate: options.messages.pullTemplate,
	                        releaseTemplate: options.messages.releaseTemplate,
	                        refreshTemplate: options.messages.refreshTemplate
	                    }
	                });
	            },
	            setDataSource: function (dataSource) {
	                var handler = this;
	                this._first = dataSource.view()[0];
	                this.dataSource = dataSource;
	                dataSource.bind('change', function () {
	                    handler._change();
	                });
	                dataSource.bind('error', function () {
	                    handler._change();
	                });
	            },
	            _change: function () {
	                var scroller = this.scroller, dataSource = this.dataSource;
	                if (this._pulled) {
	                    scroller.pullHandled();
	                }
	                if (this._pulled || !this._first) {
	                    var view = dataSource.view();
	                    if (view[0]) {
	                        this._first = view[0];
	                    }
	                }
	                this._pulled = false;
	            }
	        });
	        var VirtualList = kendo.Observable.extend({
	            init: function (options) {
	                var list = this;
	                kendo.Observable.fn.init.call(list);
	                list.buffer = options.buffer;
	                list.height = options.height;
	                list.item = options.item;
	                list.items = [];
	                list.footer = options.footer;
	                list.buffer.bind('reset', function () {
	                    list.refresh();
	                });
	            },
	            refresh: function () {
	                var buffer = this.buffer, items = this.items, endReached = false;
	                while (items.length) {
	                    items.pop().destroy();
	                }
	                this.offset = buffer.offset;
	                var itemConstructor = this.item, prevItem, item;
	                for (var idx = 0; idx < buffer.viewSize; idx++) {
	                    if (idx === buffer.total()) {
	                        endReached = true;
	                        break;
	                    }
	                    item = itemConstructor(this.content(this.offset + items.length));
	                    item.below(prevItem);
	                    prevItem = item;
	                    items.push(item);
	                }
	                this.itemCount = items.length;
	                this.trigger('reset');
	                this._resize();
	                if (endReached) {
	                    this.trigger('endReached');
	                }
	            },
	            totalHeight: function () {
	                if (!this.items[0]) {
	                    return 0;
	                }
	                var list = this, items = list.items, top = items[0].top, bottom = items[items.length - 1].bottom, averageItemHeight = (bottom - top) / list.itemCount, remainingItemsCount = list.buffer.length - list.offset - list.itemCount;
	                return (this.footer ? this.footer.height : 0) + bottom + remainingItemsCount * averageItemHeight;
	            },
	            batchUpdate: function (top) {
	                var height = this.height(), items = this.items, item, initialOffset = this.offset;
	                if (!items[0]) {
	                    return;
	                }
	                if (this.lastDirection) {
	                    while (items[items.length - 1].bottom > top + height * 2) {
	                        if (this.offset === 0) {
	                            break;
	                        }
	                        this.offset--;
	                        item = items.pop();
	                        item.update(this.content(this.offset));
	                        item.above(items[0]);
	                        items.unshift(item);
	                    }
	                } else {
	                    while (items[0].top < top - height) {
	                        var nextIndex = this.offset + this.itemCount;
	                        if (nextIndex === this.buffer.total()) {
	                            this.trigger('endReached');
	                            break;
	                        }
	                        if (nextIndex === this.buffer.length) {
	                            break;
	                        }
	                        item = items.shift();
	                        item.update(this.content(this.offset + this.itemCount));
	                        item.below(items[items.length - 1]);
	                        items.push(item);
	                        this.offset++;
	                    }
	                }
	                if (initialOffset !== this.offset) {
	                    this._resize();
	                }
	            },
	            update: function (top) {
	                var list = this, items = this.items, item, firstItem, lastItem, height = this.height(), itemCount = this.itemCount, padding = height / 2, up = (this.lastTop || 0) > top, topBorder = top - padding, bottomBorder = top + height + padding;
	                if (!items[0]) {
	                    return;
	                }
	                this.lastTop = top;
	                this.lastDirection = up;
	                if (up) {
	                    if (items[0].top > topBorder && items[items.length - 1].bottom > bottomBorder + padding && this.offset > 0) {
	                        this.offset--;
	                        item = items.pop();
	                        firstItem = items[0];
	                        item.update(this.content(this.offset));
	                        items.unshift(item);
	                        item.above(firstItem);
	                        list._resize();
	                    }
	                } else {
	                    if (items[items.length - 1].bottom < bottomBorder && items[0].top < topBorder - padding) {
	                        var nextIndex = this.offset + itemCount;
	                        if (nextIndex === this.buffer.total()) {
	                            this.trigger('endReached');
	                        } else if (nextIndex !== this.buffer.length) {
	                            item = items.shift();
	                            lastItem = items[items.length - 1];
	                            items.push(item);
	                            item.update(this.content(this.offset + this.itemCount));
	                            list.offset++;
	                            item.below(lastItem);
	                            list._resize();
	                        }
	                    }
	                }
	            },
	            content: function (index) {
	                return this.buffer.at(index);
	            },
	            destroy: function () {
	                this.unbind();
	            },
	            _resize: function () {
	                var items = this.items, top = 0, bottom = 0, firstItem = items[0], lastItem = items[items.length - 1];
	                if (firstItem) {
	                    top = firstItem.top;
	                    bottom = lastItem.bottom;
	                }
	                this.trigger('resize', {
	                    top: top,
	                    bottom: bottom
	                });
	                if (this.footer) {
	                    this.footer.below(lastItem);
	                }
	            }
	        });
	        kendo.mobile.ui.VirtualList = VirtualList;
	        var VirtualListViewItem = kendo.Class.extend({
	            init: function (listView, dataItem) {
	                var element = listView.append([dataItem], true)[0], height = element.offsetHeight;
	                $.extend(this, {
	                    top: 0,
	                    element: element,
	                    listView: listView,
	                    height: height,
	                    bottom: height
	                });
	            },
	            update: function (dataItem) {
	                this.element = this.listView.setDataItem(this.element, dataItem);
	            },
	            above: function (item) {
	                if (item) {
	                    this.height = this.element.offsetHeight;
	                    this.top = item.top - this.height;
	                    this.bottom = item.top;
	                    putAt(this.element, this.top);
	                }
	            },
	            below: function (item) {
	                if (item) {
	                    this.height = this.element.offsetHeight;
	                    this.top = item.bottom;
	                    this.bottom = this.top + this.height;
	                    putAt(this.element, this.top);
	                }
	            },
	            destroy: function () {
	                kendo.destroy(this.element);
	                $(this.element).remove();
	            }
	        });
	        var LOAD_ICON = '<div><span class="km-icon"></span><span class="km-loading-left"></span><span class="km-loading-right"></span></div>';
	        var VirtualListViewLoadingIndicator = kendo.Class.extend({
	            init: function (listView) {
	                this.element = $('<li class="km-load-more km-scroller-refresh" style="display: none"></li>').appendTo(listView.element);
	                this._loadIcon = $(LOAD_ICON).appendTo(this.element);
	            },
	            enable: function () {
	                this.element.show();
	                this.height = this.element.outerHeight(true);
	            },
	            disable: function () {
	                this.element.hide();
	                this.height = 0;
	            },
	            below: function (item) {
	                if (item) {
	                    this.top = item.bottom;
	                    this.bottom = this.height + this.top;
	                    putAt(this.element, this.top);
	                }
	            }
	        });
	        var VirtualListViewPressToLoadMore = VirtualListViewLoadingIndicator.extend({
	            init: function (listView, buffer) {
	                this._loadIcon = $(LOAD_ICON).hide();
	                this._loadButton = $('<a class="km-load">' + listView.options.messages.loadMoreText + '</a>').hide();
	                this.element = $('<li class="km-load-more" style="display: none"></li>').append(this._loadIcon).append(this._loadButton).appendTo(listView.element);
	                var loadMore = this;
	                this._loadButton.kendoMobileButton().data('kendoMobileButton').bind('click', function () {
	                    loadMore._hideShowButton();
	                    buffer.next();
	                });
	                buffer.bind('resize', function () {
	                    loadMore._showLoadButton();
	                });
	                this.height = this.element.outerHeight(true);
	                this.disable();
	            },
	            _hideShowButton: function () {
	                this._loadButton.hide();
	                this.element.addClass('km-scroller-refresh');
	                this._loadIcon.css('display', 'block');
	            },
	            _showLoadButton: function () {
	                this._loadButton.show();
	                this.element.removeClass('km-scroller-refresh');
	                this._loadIcon.hide();
	            }
	        });
	        var VirtualListViewItemBinder = kendo.Class.extend({
	            init: function (listView) {
	                var binder = this;
	                this.chromeHeight = listView.wrapper.children().not(listView.element).outerHeight() || 0;
	                this.listView = listView;
	                this.scroller = listView.scroller();
	                this.options = listView.options;
	                listView.bind('_dataSource', function (e) {
	                    binder.setDataSource(e.dataSource, e.empty);
	                });
	                listView.bind('resize', function () {
	                    if (!binder.list.items.length) {
	                        return;
	                    }
	                    binder.scroller.reset();
	                    binder.buffer.range(0);
	                    binder.list.refresh();
	                });
	                this.scroller.makeVirtual();
	                this.scroller.bind('scroll', function (e) {
	                    binder.list.update(e.scrollTop);
	                });
	                this.scroller.bind('scrollEnd', function (e) {
	                    binder.list.batchUpdate(e.scrollTop);
	                });
	            },
	            destroy: function () {
	                this.list.unbind();
	                this.buffer.unbind();
	            },
	            setDataSource: function (dataSource, empty) {
	                var binder = this, options = this.options, listView = this.listView, scroller = listView.scroller(), pressToLoadMore = options.loadMore, pageSize, buffer, footer;
	                this.dataSource = dataSource;
	                pageSize = dataSource.pageSize() || options.virtualViewSize;
	                if (!pageSize && !empty) {
	                    throw new Error('the DataSource does not have page size configured. Page Size setting is mandatory for the mobile listview virtual scrolling to work as expected.');
	                }
	                if (this.buffer) {
	                    this.buffer.destroy();
	                }
	                buffer = new kendo.data.Buffer(dataSource, Math.floor(pageSize / 2), pressToLoadMore);
	                if (pressToLoadMore) {
	                    footer = new VirtualListViewPressToLoadMore(listView, buffer);
	                } else {
	                    footer = new VirtualListViewLoadingIndicator(listView);
	                }
	                if (this.list) {
	                    this.list.destroy();
	                }
	                var list = new VirtualList({
	                    buffer: buffer,
	                    footer: footer,
	                    item: function (dataItem) {
	                        return new VirtualListViewItem(listView, dataItem);
	                    },
	                    height: function () {
	                        return scroller.height();
	                    }
	                });
	                list.bind('resize', function () {
	                    binder.updateScrollerSize();
	                    listView.updateSize();
	                });
	                list.bind('reset', function () {
	                    binder.footer.enable();
	                });
	                list.bind('endReached', function () {
	                    footer.disable();
	                    binder.updateScrollerSize();
	                });
	                buffer.bind('expand', function () {
	                    list.lastDirection = false;
	                    list.batchUpdate(scroller.scrollTop);
	                });
	                $.extend(this, {
	                    buffer: buffer,
	                    scroller: scroller,
	                    list: list,
	                    footer: footer
	                });
	            },
	            updateScrollerSize: function () {
	                this.scroller.virtualSize(0, this.list.totalHeight() + this.chromeHeight);
	            },
	            refresh: function () {
	                this.list.refresh();
	            },
	            reset: function () {
	                this.buffer.range(0);
	                this.list.refresh();
	            }
	        });
	        var ListViewItemBinder = kendo.Class.extend({
	            init: function (listView) {
	                var binder = this;
	                this.listView = listView;
	                this.options = listView.options;
	                var itemBinder = this;
	                this._refreshHandler = function (e) {
	                    itemBinder.refresh(e);
	                };
	                this._progressHandler = function () {
	                    listView.showLoading();
	                };
	                listView.bind('_dataSource', function (e) {
	                    binder.setDataSource(e.dataSource);
	                });
	            },
	            destroy: function () {
	                this._unbindDataSource();
	            },
	            reset: function () {
	            },
	            refresh: function (e) {
	                var action = e && e.action, dataItems = e && e.items, listView = this.listView, dataSource = this.dataSource, prependOnRefresh = this.options.appendOnRefresh, view = dataSource.view(), groups = dataSource.group(), groupedMode = groups && groups[0], item;
	                if (action === 'itemchange') {
	                    if (!listView._hasBindingTarget()) {
	                        item = listView.findByDataItem(dataItems)[0];
	                        if (item) {
	                            listView.setDataItem(item, dataItems[0]);
	                        }
	                    }
	                    return;
	                }
	                var removedItems, addedItems, addedDataItems;
	                var adding = action === 'add' && !groupedMode || prependOnRefresh && !listView._filter;
	                var removing = action === 'remove' && !groupedMode;
	                if (adding) {
	                    removedItems = [];
	                } else if (removing) {
	                    removedItems = listView.findByDataItem(dataItems);
	                }
	                if (listView.trigger(DATABINDING, {
	                        action: action || 'rebind',
	                        items: dataItems,
	                        removedItems: removedItems,
	                        index: e && e.index
	                    })) {
	                    if (this._shouldShowLoading()) {
	                        listView.hideLoading();
	                    }
	                    return;
	                }
	                if (action === 'add' && !groupedMode) {
	                    var index = view.indexOf(dataItems[0]);
	                    if (index > -1) {
	                        addedItems = listView.insertAt(dataItems, index);
	                        addedDataItems = dataItems;
	                    }
	                } else if (action === 'remove' && !groupedMode) {
	                    addedItems = [];
	                    listView.remove(dataItems);
	                } else if (groupedMode) {
	                    listView.replaceGrouped(view);
	                } else if (prependOnRefresh && !listView._filter) {
	                    addedItems = listView.prepend(view);
	                    addedDataItems = view;
	                } else {
	                    listView.replace(view);
	                }
	                if (this._shouldShowLoading()) {
	                    listView.hideLoading();
	                }
	                listView.trigger(DATABOUND, {
	                    ns: ui,
	                    addedItems: addedItems,
	                    addedDataItems: addedDataItems
	                });
	            },
	            setDataSource: function (dataSource) {
	                if (this.dataSource) {
	                    this._unbindDataSource();
	                }
	                this.dataSource = dataSource;
	                dataSource.bind(CHANGE, this._refreshHandler);
	                if (this._shouldShowLoading()) {
	                    this.dataSource.bind(PROGRESS, this._progressHandler);
	                }
	            },
	            _unbindDataSource: function () {
	                this.dataSource.unbind(CHANGE, this._refreshHandler).unbind(PROGRESS, this._progressHandler);
	            },
	            _shouldShowLoading: function () {
	                var options = this.options;
	                return !options.pullToRefresh && !options.loadMore && !options.endlessScroll;
	            }
	        });
	        var ListViewFilter = kendo.Class.extend({
	            init: function (listView) {
	                var filter = this, filterable = listView.options.filterable, events = 'change paste', that = this;
	                this.listView = listView;
	                this.options = filterable;
	                listView.element.before(SEARCH_TEMPLATE({ placeholder: filterable.placeholder || 'Search...' }));
	                if (filterable.autoFilter !== false) {
	                    events += ' keyup';
	                }
	                this.element = listView.wrapper.find('.km-search-form');
	                this.searchInput = listView.wrapper.find('input[type=search]').closest('form').on('submit' + NS, function (e) {
	                    e.preventDefault();
	                }).end().on('focus' + NS, function () {
	                    filter._oldFilter = filter.searchInput.val();
	                }).on(events.split(' ').join(NS + ' ') + NS, proxy(this._filterChange, this));
	                this.clearButton = listView.wrapper.find('.km-filter-reset').on(CLICK, proxy(this, '_clearFilter')).hide();
	                this._dataSourceChange = $.proxy(this._refreshInput, this);
	                listView.bind('_dataSource', function (e) {
	                    e.dataSource.bind('change', that._dataSourceChange);
	                });
	            },
	            _refreshInput: function () {
	                var appliedFilters = this.listView.dataSource.filter();
	                var searchInput = this.listView._filter.searchInput;
	                if (!appliedFilters || appliedFilters.filters[0].field !== this.listView.options.filterable.field) {
	                    searchInput.val('');
	                } else {
	                    searchInput.val(appliedFilters.filters[0].value);
	                }
	            },
	            _search: function (expr) {
	                this._filter = true;
	                this.clearButton[expr ? 'show' : 'hide']();
	                this.listView.dataSource.filter(expr);
	            },
	            _filterChange: function (e) {
	                var filter = this;
	                if (e.type == 'paste' && this.options.autoFilter !== false) {
	                    setTimeout(function () {
	                        filter._applyFilter();
	                    }, 1);
	                } else {
	                    this._applyFilter();
	                }
	            },
	            _applyFilter: function () {
	                var options = this.options, value = this.searchInput.val(), expr = value.length ? {
	                        field: options.field,
	                        operator: options.operator || 'startswith',
	                        ignoreCase: options.ignoreCase,
	                        value: value
	                    } : null;
	                if (value === this._oldFilter) {
	                    return;
	                }
	                this._oldFilter = value;
	                this._search(expr);
	            },
	            _clearFilter: function (e) {
	                this.searchInput.val('');
	                this._search(null);
	                e.preventDefault();
	            }
	        });
	        var ListView = Widget.extend({
	            init: function (element, options) {
	                var listView = this;
	                Widget.fn.init.call(this, element, options);
	                element = this.element;
	                options = this.options;
	                if (options.scrollTreshold) {
	                    options.scrollThreshold = options.scrollTreshold;
	                }
	                element.on('down', HIGHLIGHT_SELECTOR, '_highlight').on('move up cancel', HIGHLIGHT_SELECTOR, '_dim');
	                this._userEvents = new kendo.UserEvents(element, {
	                    fastTap: true,
	                    filter: ITEM_SELECTOR,
	                    allowSelection: true,
	                    tap: function (e) {
	                        listView._click(e);
	                    }
	                });
	                element.css('-ms-touch-action', 'auto');
	                element.wrap(WRAPPER);
	                this.wrapper = this.element.parent();
	                this._headerFixer = new HeaderFixer(this);
	                this._itemsCache = {};
	                this._templates();
	                this.virtual = options.endlessScroll || options.loadMore;
	                this._style();
	                if (this.options.$angular && (this.virtual || this.options.pullToRefresh)) {
	                    setTimeout($.proxy(this, '_start'));
	                } else {
	                    this._start();
	                }
	            },
	            _start: function () {
	                var options = this.options;
	                if (this.options.filterable) {
	                    this._filter = new ListViewFilter(this);
	                }
	                if (this.virtual) {
	                    this._itemBinder = new VirtualListViewItemBinder(this);
	                } else {
	                    this._itemBinder = new ListViewItemBinder(this);
	                }
	                if (this.options.pullToRefresh) {
	                    this._pullToRefreshHandler = new RefreshHandler(this);
	                }
	                this.setDataSource(options.dataSource);
	                this._enhanceItems(this.items());
	                kendo.notify(this, ui);
	            },
	            events: [
	                CLICK,
	                DATABINDING,
	                DATABOUND,
	                ITEM_CHANGE
	            ],
	            options: {
	                name: 'ListView',
	                style: '',
	                type: 'flat',
	                autoBind: true,
	                fixedHeaders: false,
	                template: '#:data#',
	                headerTemplate: '<span class="km-text">#:value#</span>',
	                appendOnRefresh: false,
	                loadMore: false,
	                endlessScroll: false,
	                scrollThreshold: 30,
	                pullToRefresh: false,
	                messages: {
	                    loadMoreText: 'Press to load more',
	                    pullTemplate: 'Pull to refresh',
	                    releaseTemplate: 'Release to refresh',
	                    refreshTemplate: 'Refreshing'
	                },
	                pullOffset: 140,
	                filterable: false,
	                virtualViewSize: null
	            },
	            refresh: function () {
	                this._itemBinder.refresh();
	            },
	            reset: function () {
	                this._itemBinder.reset();
	            },
	            setDataSource: function (dataSource) {
	                var emptyDataSource = !dataSource;
	                this.dataSource = DataSource.create(dataSource);
	                this.trigger('_dataSource', {
	                    dataSource: this.dataSource,
	                    empty: emptyDataSource
	                });
	                if (this.options.autoBind && !emptyDataSource) {
	                    this.items().remove();
	                    this.dataSource.fetch();
	                }
	            },
	            destroy: function () {
	                Widget.fn.destroy.call(this);
	                kendo.destroy(this.element);
	                this._userEvents.destroy();
	                if (this._itemBinder) {
	                    this._itemBinder.destroy();
	                }
	                if (this._headerFixer) {
	                    this._headerFixer.destroy();
	                }
	                this.element.unwrap();
	                delete this.element;
	                delete this.wrapper;
	                delete this._userEvents;
	            },
	            items: function () {
	                if (this.options.type === 'group') {
	                    return this.element.find('.km-list').children();
	                } else {
	                    return this.element.children().not('.km-load-more');
	                }
	            },
	            scroller: function () {
	                if (!this._scrollerInstance) {
	                    this._scrollerInstance = this.element.closest('.km-scroll-wrapper').data('kendoMobileScroller');
	                }
	                return this._scrollerInstance;
	            },
	            showLoading: function () {
	                var view = this.view();
	                if (view && view.loader) {
	                    view.loader.show();
	                }
	            },
	            hideLoading: function () {
	                var view = this.view();
	                if (view && view.loader) {
	                    view.loader.hide();
	                }
	            },
	            insertAt: function (dataItems, index, triggerChange) {
	                var listView = this;
	                return listView._renderItems(dataItems, function (items) {
	                    if (index === 0) {
	                        listView.element.prepend(items);
	                    } else if (index === -1) {
	                        listView.element.append(items);
	                    } else {
	                        listView.items().eq(index - 1).after(items);
	                    }
	                    if (triggerChange) {
	                        for (var i = 0; i < items.length; i++) {
	                            listView.trigger(ITEM_CHANGE, {
	                                item: items.eq(i),
	                                data: dataItems[i],
	                                ns: ui
	                            });
	                        }
	                    }
	                });
	            },
	            append: function (dataItems, triggerChange) {
	                return this.insertAt(dataItems, -1, triggerChange);
	            },
	            prepend: function (dataItems, triggerChange) {
	                return this.insertAt(dataItems, 0, triggerChange);
	            },
	            replace: function (dataItems) {
	                this.options.type = 'flat';
	                this._angularItems('cleanup');
	                kendo.destroy(this.element.children());
	                this.element.empty();
	                this._userEvents.cancel();
	                this._style();
	                return this.insertAt(dataItems, 0);
	            },
	            replaceGrouped: function (groups) {
	                this.options.type = 'group';
	                this._angularItems('cleanup');
	                this.element.empty();
	                var items = $(kendo.render(this.groupTemplate, groups));
	                this._enhanceItems(items.children('ul').children('li'));
	                this.element.append(items);
	                mobile.init(items);
	                this._style();
	                this._angularItems('compile');
	            },
	            remove: function (dataItems) {
	                var items = this.findByDataItem(dataItems);
	                this.angular('cleanup', function () {
	                    return { elements: items };
	                });
	                kendo.destroy(items);
	                items.remove();
	            },
	            findByDataItem: function (dataItems) {
	                var selectors = [];
	                for (var idx = 0, length = dataItems.length; idx < length; idx++) {
	                    selectors[idx] = '[data-' + kendo.ns + 'uid=' + dataItems[idx].uid + ']';
	                }
	                return this.element.find(selectors.join(','));
	            },
	            setDataItem: function (item, dataItem) {
	                var listView = this, replaceItem = function (items) {
	                        var newItem = $(items[0]);
	                        kendo.destroy(item);
	                        listView.angular('cleanup', function () {
	                            return { elements: [$(item)] };
	                        });
	                        $(item).replaceWith(newItem);
	                        listView.trigger(ITEM_CHANGE, {
	                            item: newItem,
	                            data: dataItem,
	                            ns: ui
	                        });
	                    };
	                return this._renderItems([dataItem], replaceItem)[0];
	            },
	            updateSize: function () {
	                this._size = this.getSize();
	            },
	            _renderItems: function (dataItems, callback) {
	                var items = $(kendo.render(this.template, dataItems));
	                callback(items);
	                this.angular('compile', function () {
	                    return {
	                        elements: items,
	                        data: dataItems.map(function (data) {
	                            return { dataItem: data };
	                        })
	                    };
	                });
	                mobile.init(items);
	                this._enhanceItems(items);
	                return items;
	            },
	            _dim: function (e) {
	                this._toggle(e, false);
	            },
	            _highlight: function (e) {
	                this._toggle(e, true);
	            },
	            _toggle: function (e, highlight) {
	                if (e.which > 1) {
	                    return;
	                }
	                var clicked = $(e.currentTarget), item = clicked.parent(), role = attrValue(clicked, 'role') || '', plainItem = !role.match(buttonRegExp), prevented = e.isDefaultPrevented();
	                if (plainItem) {
	                    item.toggleClass(ACTIVE_CLASS, highlight && !prevented);
	                }
	            },
	            _templates: function () {
	                var template = this.options.template, headerTemplate = this.options.headerTemplate, dataIDAttribute = ' data-uid="#=arguments[0].uid || ""#"', templateProxy = {}, groupTemplateProxy = {};
	                if (typeof template === FUNCTION) {
	                    templateProxy.template = template;
	                    template = '#=this.template(data)#';
	                }
	                this.template = proxy(kendo.template('<li' + dataIDAttribute + '>' + template + '</li>'), templateProxy);
	                groupTemplateProxy.template = this.template;
	                if (typeof headerTemplate === FUNCTION) {
	                    groupTemplateProxy._headerTemplate = headerTemplate;
	                    headerTemplate = '#=this._headerTemplate(data)#';
	                }
	                groupTemplateProxy.headerTemplate = kendo.template(headerTemplate);
	                this.groupTemplate = proxy(GROUP_TEMPLATE, groupTemplateProxy);
	            },
	            _click: function (e) {
	                if (e.event.which > 1 || e.event.isDefaultPrevented()) {
	                    return;
	                }
	                var dataItem, item = e.target, target = $(e.event.target), buttonElement = target.closest(kendo.roleSelector('button', 'detailbutton', 'backbutton')), button = kendo.widgetInstance(buttonElement, ui), id = item.attr(kendo.attr('uid'));
	                if (id) {
	                    dataItem = this.dataSource.getByUid(id);
	                }
	                if (this.trigger(CLICK, {
	                        target: target,
	                        item: item,
	                        dataItem: dataItem,
	                        button: button
	                    })) {
	                    e.preventDefault();
	                }
	            },
	            _styleGroups: function () {
	                var rootItems = this.element.children();
	                rootItems.children('ul').addClass('km-list');
	                rootItems.each(function () {
	                    var li = $(this), groupHeader = li.contents().first();
	                    li.addClass('km-group-container');
	                    if (!groupHeader.is('ul') && !groupHeader.is('div.' + GROUP_CLASS)) {
	                        groupHeader.wrap(GROUP_WRAPPER);
	                    }
	                });
	            },
	            _style: function () {
	                var options = this.options, grouped = options.type === 'group', element = this.element, inset = options.style === 'inset';
	                element.addClass('km-listview').toggleClass('km-list', !grouped).toggleClass('km-virtual-list', this.virtual).toggleClass('km-listinset', !grouped && inset).toggleClass('km-listgroup', grouped && !inset).toggleClass('km-listgroupinset', grouped && inset);
	                if (!element.parents('.km-listview')[0]) {
	                    element.closest('.km-content').toggleClass('km-insetcontent', inset);
	                }
	                if (grouped) {
	                    this._styleGroups();
	                }
	                this.trigger(STYLED);
	            },
	            _enhanceItems: function (items) {
	                items.each(function () {
	                    var item = $(this), child, enhanced = false;
	                    item.children().each(function () {
	                        child = $(this);
	                        if (child.is('a')) {
	                            enhanceLinkItem(child);
	                            enhanced = true;
	                        } else if (child.is('label')) {
	                            enhanceCheckBoxItem(child);
	                            enhanced = true;
	                        }
	                    });
	                    if (!enhanced) {
	                        enhanceItem(item);
	                    }
	                });
	            }
	        });
	        ui.plugin(ListView);
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(202)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'mobile.navbar',
	        name: 'NavBar',
	        category: 'mobile',
	        description: 'The Kendo mobile NavBar widget is used inside a mobile View or Layout Header element to display an application navigation bar.',
	        depends: ['core']
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, mobile = kendo.mobile, ui = mobile.ui, Widget = ui.Widget;
	        function createContainer(align, element) {
	            var items = element.find('[' + kendo.attr('align') + '=' + align + ']');
	            if (items[0]) {
	                return $('<div class="km-' + align + 'item" />').append(items).prependTo(element);
	            }
	        }
	        function toggleTitle(centerElement) {
	            var siblings = centerElement.siblings(), noTitle = !!centerElement.children('ul')[0], showTitle = !!siblings[0] && $.trim(centerElement.text()) === '', android = !!(kendo.mobile.application && kendo.mobile.application.element.is('.km-android'));
	            centerElement.prevAll().toggleClass('km-absolute', noTitle);
	            centerElement.toggleClass('km-show-title', showTitle);
	            centerElement.toggleClass('km-fill-title', showTitle && !$.trim(centerElement.html()));
	            centerElement.toggleClass('km-no-title', noTitle);
	            centerElement.toggleClass('km-hide-title', android && !siblings.children().is(':visible'));
	        }
	        var NavBar = Widget.extend({
	            init: function (element, options) {
	                var that = this;
	                Widget.fn.init.call(that, element, options);
	                element = that.element;
	                that.container().bind('show', $.proxy(this, 'refresh'));
	                element.addClass('km-navbar').wrapInner($('<div class="km-view-title km-show-title" />'));
	                that.leftElement = createContainer('left', element);
	                that.rightElement = createContainer('right', element);
	                that.centerElement = element.find('.km-view-title');
	            },
	            options: { name: 'NavBar' },
	            title: function (value) {
	                this.element.find(kendo.roleSelector('view-title')).text(value);
	                toggleTitle(this.centerElement);
	            },
	            refresh: function (e) {
	                var view = e.view;
	                this.title(view.options.title);
	            },
	            destroy: function () {
	                Widget.fn.destroy.call(this);
	                kendo.destroy(this.element);
	            }
	        });
	        ui.plugin(NavBar);
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(208),
	        __webpack_require__(209)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'mobile.switch',
	        name: 'Switch',
	        category: 'mobile',
	        description: 'The mobile Switch widget is used to display two exclusive choices.',
	        depends: [
	            'fx',
	            'userevents'
	        ]
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, ui = kendo.mobile.ui, Widget = ui.Widget, support = kendo.support, CHANGE = 'change', SWITCHON = 'km-switch-on', SWITCHOFF = 'km-switch-off', MARGINLEFT = 'margin-left', ACTIVE_STATE = 'km-state-active', DISABLED_STATE = 'km-state-disabled', DISABLED = 'disabled', TRANSFORMSTYLE = support.transitions.css + 'transform', proxy = $.proxy;
	        function limitValue(value, minLimit, maxLimit) {
	            return Math.max(minLimit, Math.min(maxLimit, value));
	        }
	        var SWITCH_MARKUP = '<span class="km-switch km-widget">        <span class="km-switch-wrapper"><span class="km-switch-background"></span></span>         <span class="km-switch-container"><span class="km-switch-handle" >             <span class="km-switch-label-on">{0}</span>             <span class="km-switch-label-off">{1}</span>         </span>     </span>';
	        var Switch = Widget.extend({
	            init: function (element, options) {
	                var that = this, checked;
	                Widget.fn.init.call(that, element, options);
	                options = that.options;
	                that.wrapper = $(kendo.format(SWITCH_MARKUP, options.onLabel, options.offLabel));
	                that.handle = that.wrapper.find('.km-switch-handle');
	                that.background = that.wrapper.find('.km-switch-background');
	                that.wrapper.insertBefore(that.element).prepend(that.element);
	                that._drag();
	                that.origin = parseInt(that.background.css(MARGINLEFT), 10);
	                that.constrain = 0;
	                that.snapPoint = 0;
	                element = that.element[0];
	                element.type = 'checkbox';
	                that._animateBackground = true;
	                checked = that.options.checked;
	                if (checked === null) {
	                    checked = element.checked;
	                }
	                that.check(checked);
	                that.options.enable = that.options.enable && !that.element.attr(DISABLED);
	                that.enable(that.options.enable);
	                that.refresh();
	                kendo.notify(that, kendo.mobile.ui);
	            },
	            refresh: function () {
	                var that = this, handleWidth = that.handle.outerWidth(true);
	                that.width = that.wrapper.width();
	                that.constrain = that.width - handleWidth;
	                that.snapPoint = that.constrain / 2;
	                if (typeof that.origin != 'number') {
	                    that.origin = parseInt(that.background.css(MARGINLEFT), 10);
	                }
	                that.background.data('origin', that.origin);
	                that.check(that.element[0].checked);
	            },
	            events: [CHANGE],
	            options: {
	                name: 'Switch',
	                onLabel: 'on',
	                offLabel: 'off',
	                checked: null,
	                enable: true
	            },
	            check: function (check) {
	                var that = this, element = that.element[0];
	                if (check === undefined) {
	                    return element.checked;
	                }
	                that._position(check ? that.constrain : 0);
	                element.checked = check;
	                that.wrapper.toggleClass(SWITCHON, check).toggleClass(SWITCHOFF, !check);
	            },
	            value: function () {
	                return this.check.apply(this, arguments);
	            },
	            destroy: function () {
	                Widget.fn.destroy.call(this);
	                this.userEvents.destroy();
	            },
	            toggle: function () {
	                var that = this;
	                that.check(!that.element[0].checked);
	            },
	            enable: function (enable) {
	                var element = this.element, wrapper = this.wrapper;
	                if (typeof enable == 'undefined') {
	                    enable = true;
	                }
	                this.options.enable = enable;
	                if (enable) {
	                    element.removeAttr(DISABLED);
	                } else {
	                    element.attr(DISABLED, DISABLED);
	                }
	                wrapper.toggleClass(DISABLED_STATE, !enable);
	            },
	            _resize: function () {
	                this.refresh();
	            },
	            _move: function (e) {
	                var that = this;
	                e.preventDefault();
	                that._position(limitValue(that.position + e.x.delta, 0, that.width - that.handle.outerWidth(true)));
	            },
	            _position: function (position) {
	                var that = this;
	                that.position = position;
	                that.handle.css(TRANSFORMSTYLE, 'translatex(' + position + 'px)');
	                if (that._animateBackground) {
	                    that.background.css(MARGINLEFT, that.origin + position);
	                }
	            },
	            _start: function () {
	                if (!this.options.enable) {
	                    this.userEvents.cancel();
	                } else {
	                    this.userEvents.capture();
	                    this.handle.addClass(ACTIVE_STATE);
	                }
	            },
	            _stop: function () {
	                var that = this;
	                that.handle.removeClass(ACTIVE_STATE);
	                that._toggle(that.position > that.snapPoint);
	            },
	            _toggle: function (checked) {
	                var that = this, handle = that.handle, element = that.element[0], value = element.checked, duration = kendo.mobile.application && kendo.mobile.application.os.wp ? 100 : 200, distance;
	                that.wrapper.toggleClass(SWITCHON, checked).toggleClass(SWITCHOFF, !checked);
	                that.position = distance = checked * that.constrain;
	                if (that._animateBackground) {
	                    that.background.kendoStop(true, true).kendoAnimate({
	                        effects: 'slideMargin',
	                        offset: distance,
	                        reset: true,
	                        reverse: !checked,
	                        axis: 'left',
	                        duration: duration
	                    });
	                }
	                handle.kendoStop(true, true).kendoAnimate({
	                    effects: 'slideTo',
	                    duration: duration,
	                    offset: distance + 'px,0',
	                    reset: true,
	                    complete: function () {
	                        if (value !== checked) {
	                            element.checked = checked;
	                            that.trigger(CHANGE, { checked: checked });
	                        }
	                    }
	                });
	            },
	            _drag: function () {
	                var that = this;
	                that.userEvents = new kendo.UserEvents(that.wrapper, {
	                    fastTap: true,
	                    tap: function () {
	                        if (that.options.enable) {
	                            that._toggle(!that.element[0].checked);
	                        }
	                    },
	                    start: proxy(that._start, that),
	                    move: proxy(that._move, that),
	                    end: proxy(that._stop, that)
	                });
	            }
	        });
	        ui.plugin(Switch);
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(202),
	        __webpack_require__(209)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'touch',
	        name: 'Touch',
	        category: 'mobile',
	        description: 'The kendo Touch widget provides a cross-platform compatible API for handling user-initiated touch events, multi-touch gestures and event sequences (drag, swipe, etc.). ',
	        depends: [
	            'core',
	            'userevents'
	        ]
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, Widget = kendo.ui.Widget, proxy = $.proxy, abs = Math.abs, MAX_DOUBLE_TAP_DISTANCE = 20;
	        var Touch = Widget.extend({
	            init: function (element, options) {
	                var that = this;
	                Widget.fn.init.call(that, element, options);
	                options = that.options;
	                element = that.element;
	                that.wrapper = element;
	                function eventProxy(name) {
	                    return function (e) {
	                        that._triggerTouch(name, e);
	                    };
	                }
	                function gestureEventProxy(name) {
	                    return function (e) {
	                        that.trigger(name, {
	                            touches: e.touches,
	                            distance: e.distance,
	                            center: e.center,
	                            event: e.event
	                        });
	                    };
	                }
	                that.events = new kendo.UserEvents(element, {
	                    filter: options.filter,
	                    surface: options.surface,
	                    minHold: options.minHold,
	                    multiTouch: options.multiTouch,
	                    allowSelection: true,
	                    fastTap: options.fastTap,
	                    press: eventProxy('touchstart'),
	                    hold: eventProxy('hold'),
	                    tap: proxy(that, '_tap'),
	                    gesturestart: gestureEventProxy('gesturestart'),
	                    gesturechange: gestureEventProxy('gesturechange'),
	                    gestureend: gestureEventProxy('gestureend')
	                });
	                if (options.enableSwipe) {
	                    that.events.bind('start', proxy(that, '_swipestart'));
	                    that.events.bind('move', proxy(that, '_swipemove'));
	                } else {
	                    that.events.bind('start', proxy(that, '_dragstart'));
	                    that.events.bind('move', eventProxy('drag'));
	                    that.events.bind('end', eventProxy('dragend'));
	                }
	                kendo.notify(that);
	            },
	            events: [
	                'touchstart',
	                'dragstart',
	                'drag',
	                'dragend',
	                'tap',
	                'doubletap',
	                'hold',
	                'swipe',
	                'gesturestart',
	                'gesturechange',
	                'gestureend'
	            ],
	            options: {
	                name: 'Touch',
	                surface: null,
	                global: false,
	                fastTap: false,
	                filter: null,
	                multiTouch: false,
	                enableSwipe: false,
	                minXDelta: 30,
	                maxYDelta: 20,
	                maxDuration: 1000,
	                minHold: 800,
	                doubleTapTimeout: 800
	            },
	            cancel: function () {
	                this.events.cancel();
	            },
	            destroy: function () {
	                this.events.destroy();
	            },
	            _triggerTouch: function (type, e) {
	                if (this.trigger(type, {
	                        touch: e.touch,
	                        event: e.event
	                    })) {
	                    e.preventDefault();
	                }
	            },
	            _tap: function (e) {
	                var that = this, lastTap = that.lastTap, touch = e.touch;
	                if (lastTap && touch.endTime - lastTap.endTime < that.options.doubleTapTimeout && kendo.touchDelta(touch, lastTap).distance < MAX_DOUBLE_TAP_DISTANCE) {
	                    that._triggerTouch('doubletap', e);
	                    that.lastTap = null;
	                } else {
	                    that._triggerTouch('tap', e);
	                    that.lastTap = touch;
	                }
	            },
	            _dragstart: function (e) {
	                this._triggerTouch('dragstart', e);
	            },
	            _swipestart: function (e) {
	                if (abs(e.x.velocity) * 2 >= abs(e.y.velocity)) {
	                    e.sender.capture();
	                }
	            },
	            _swipemove: function (e) {
	                var that = this, options = that.options, touch = e.touch, duration = e.event.timeStamp - touch.startTime, direction = touch.x.initialDelta > 0 ? 'right' : 'left';
	                if (abs(touch.x.initialDelta) >= options.minXDelta && abs(touch.y.initialDelta) < options.maxYDelta && duration < options.maxDuration) {
	                    that.trigger('swipe', {
	                        direction: direction,
	                        touch: e.touch
	                    });
	                    touch.cancel();
	                }
	            }
	        });
	        kendo.ui.plugin(Touch);
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    (function (undefined) {
	
	        var STRING = 'string';
	        var OBJECT = 'object';
	        var FUNCTION = 'function';
	        var UNDEFINED = 'undefined';
	
	        // Populate the class2type map
	        var class2type = {};
	        'Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' ').forEach(function (name) {
	            class2type[ '[object ' + name + ']' ] = name.toLowerCase();
	        });
	        var toString = class2type.toString;
	        var hasOwn = class2type.hasOwnProperty;
	
	        // jQuery core functions to remove any dependencies
	        // @see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/core.js
	        var $ = {
	            isArray: Array.isArray,
	            isFunction: function (obj) {
	                return $.type(obj) === FUNCTION;
	            },
	            isEmptyObject: function (obj) {
	                var name;
	                for (name in obj) {
	                    return false;
	                }
	                return true;
	            },
	            isNumeric: function (obj) {
	                // parseFloat NaNs numeric-cast false positives (null|true|false|"")
	                // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
	                // subtraction forces infinities to NaN
	                // adding 1 corrects loss of precision from parseFloat (#15100)
	                return !$.isArray(obj) && (obj - parseFloat(obj) + 1) >= 0;
	            },
	            isPlainObject: function (obj) {
	                // Not plain objects:
	                // - Any object or value whose internal [[Class]] property is not "[object Object]"
	                // - DOM nodes
	                // - window
	                if ($.type(obj) !== OBJECT || obj.nodeType || $.isWindow(obj)) {
	                    return false;
	                }
	                if (obj.constructor && !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
	                    return false;
	                }
	                // If the function hasn't returned already, we're confident that
	                // |obj| is a plain object, created by {} or constructed with new Object
	                return true;
	            },
	            isWindow: function (obj) {
	                return obj !== null && obj === obj.window;
	            },
	            type: function (obj) {
	                if (obj === null) {
	                    return obj + '';
	                }
	                // Support: Android<4.0 (functionish RegExp)
	                return typeof obj === OBJECT || typeof obj === FUNCTION ? class2type[toString.call(obj)] || OBJECT : typeof obj;
	            }
	        };
	
	        /**
	         * Asserts
	         * Note: Use asserts where unmet conditions are independent from user entries, and
	         * developers should be warned that there is probably something unexpected in their code
	         */
	        var assert = window.assert = function (test, message) {
	            if (!test) { throw new Error(message); }
	        };
	
	        // By extending assert, we ensure we can call both assert() and assert.ok() for the same result (like in nodeJS)
	
	        /**
	         * Assert enumeration
	         * @param array
	         * @param value
	         * @param message
	         */
	        assert.enum = function (array, value, message) {
	            if (array.indexOf(value) === -1) {
	                throw new RangeError(message);
	            }
	        };
	
	        /**
	         * Assert equal
	         * @param expected
	         * @param actual
	         * @param message
	         */
	        assert.equal = function (expected, actual, message) {
	            if (expected !== actual) {
	                throw new RangeError(message);
	            }
	        };
	
	        /**
	         * Assert the length property (for Arrays and jQuery)
	         * @param el
	         * @param message
	         */
	        assert.hasLength = function (el, message) {
	            if (!el || !el.length) {
	                throw new TypeError(message);
	            }
	        };
	
	        /**
	         * Assert instance of
	         * @param Class
	         * @param value
	         * @param message
	         */
	        assert.instanceof = function (Class, value, message) {
	            if (!(value instanceof Class)) {
	                throw new TypeError(message);
	            }
	        };
	
	        /**
	         * Assert optional object (can be undefined but mot an empty object, i.e. {})
	         * @param value
	         * @param message
	         */
	        assert.isOptionalObject = function (value, message) {
	            if ($.type(value) !== UNDEFINED && (!$.isPlainObject(value) || $.isEmptyObject(value))) {
	                throw new TypeError(message);
	            }
	        };
	
	        /**
	         * Assert a plain object (not empty)
	         * @param value
	         * @param message
	         */
	        assert.isPlainObject = function (value, message) {
	            if (!$.isPlainObject(value) || $.isEmptyObject(value)) {
	                throw new TypeError(message);
	            }
	        };
	
	        /**
	         * Assert undefined
	         * @param value
	         * @param message
	         */
	        assert.isUndefined = function (value, message) {
	            if ($.type(value) !== UNDEFINED) {
	                throw new TypeError(message);
	            }
	        };
	
	        /**
	         * Assert regular expression match
	         * @param rx
	         * @param value
	         * @param message
	         */
	        assert.match = function (rx, value, message) {
	            if ($.type(value) !== STRING || !rx.test(value)) {
	                throw new RangeError(message);
	            }
	        };
	
	        /**
	         * Assert true condition
	         * @param test
	         * @param message
	         * @returns {*}
	         */
	        assert.ok = function (test, message) {
	            return assert(test, message);
	        };
	
	        /**
	         * Assert type
	         * @param type
	         * @param value
	         * @param message
	         */
	        assert.type = function (type, value, message) {
	            if ($.type(value) !== type) {
	                throw new TypeError(message);
	            }
	        };
	
	        assert.messages = {
	            enum: {
	                default: '`{0}` is expected to be any of `{1}`'
	            },
	            equal: {
	                default: '`{0}` is expected to equal `{1}`'
	            },
	            hasLength: {
	                default: '`{0}` has neither length nor any item'
	            },
	            instanceof: {
	                default: '`{0}` is expected to be an instance of `{1}`'
	            },
	            isOptionalObject: {
	                default: '`{0}` is expected to be undefined or a plain object'
	            },
	            isPlainObject: {
	                default: '`{0}` is expected to be a plain object'
	            },
	            isUndefined: {
	                default: '`{0}` is expected to be undefined'
	            },
	            match: {
	                default: '`{0}` is expected to match `{1}`'
	            },
	            ok: {
	                default: 'A statement is expected to be true'
	            },
	            type: {
	                default: '`{0}` is expected to have type `{1}`'
	            }
	        };
	
	    }());
	
	    return window.assert;
	
	}, __webpack_require__(200));


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    (function (undefined) {
	
	        var app = window.app = window.app || {};
	        var STRING = 'string';
	        var FUNCTION = 'function';
	        var UNDEFINED = 'undefined';
	        var LEVELS = {
	            DEBUG: { NAME: 'DEBUG', VALUE: 1 },
	            INFO: { NAME: 'INFO', VALUE: 2 },
	            WARN: { NAME: 'WARN', VALUE: 4 },
	            ERROR: { NAME: 'ERROR', VALUE: 5 },
	            CRIT: { NAME: 'CRIT', VALUE: 6 }
	        };
	        var DEFAULT = LEVELS.INFO;
	        var LINEFEED = '\n';
	        var LINESEP = ', ';
	        var SPACES = /\s+/g;
	        var SPACE = ' ';
	        var EQ = ': ';
	        var FIRST = ' ';
	        var SEP = '; '; // '  |  ';
	
	        /**
	         * Logger class
	         * @class Logger
	         */
	        var Logger = window.Logger = function (module/*, appLogger*/) {
	            this._module = module;
	        };
	
	        /**
	         * Log message
	         * @param level
	         * @param message
	         * @param data
	         * @returns {boolean}
	         */
	        Logger.prototype.log = function (level, message, data) {
	
	            // Preprocess message + data to return an object
	            function preProcess(message, data) {
	                if (typeof message !== STRING && typeof data !== UNDEFINED) {
	                    throw new TypeError('Unexpected data when message is not a string');
	                }
	                var entry;
	                if (typeof message === STRING) {
	                    entry = { message: message, data: data };
	                } else if (message instanceof window.Error) {
	                    entry = {
	                        message: message.message,
	                        error: message
	                    };
	                } else if (typeof window.ErrorEvent === FUNCTION && message instanceof window.ErrorEvent) {
	                    // window.ErrorEvent does not exist in PhantomJS
	                    entry = {
	                        message: message.message,
	                        data: { filename: message.filename, lineno: message.lineno, colno: message.colno },
	                        error: message.error
	                    };
	                } else if (Object.prototype.toString.call(message) === '[object Object]') {
	                    entry = JSON.parse(JSON.stringify(message));
	                    if (message.error instanceof Error) {
	                        // We need to do that because JSON.stringify(new Error('Oops)) === {}
	                        entry.error = message.error;
	                    }
	                } else {
	                    entry = { data: message };
	                }
	                return entry;
	            }
	
	            // Enhance a log entry
	            function enhance(entry, module, level) {
	                if (Object.prototype.toString.call(entry) !== '[object Object]') {
	                    throw new TypeError('entry is expected to be an object');
	                }
	
	                // Improve error logging
	                if (entry.error instanceof Error) {
	                    if (typeof entry.message === UNDEFINED) {
	                        entry.message = entry.error.message;
	                    }
	                    if (entry.error.originalError instanceof window.Error) {
	                        entry.originalMessage = entry.error.originalError.message;
	                        if (typeof entry.error.originalError.stack === STRING) { // To care for an exception in PhantomJS
	                            entry.stack = entry.error.originalError.stack.split(LINEFEED).join(LINESEP).replace(SPACES, SPACE);
	                        }
	                    } else {
	                        if (typeof entry.error.stack === STRING) { // To care for an exception in PhantomJS
	                            entry.stack = entry.error.stack.split(LINEFEED).join(LINESEP).replace(SPACES, SPACE);
	                        }
	                    }
	                }
	
	                // Add module
	                entry.module = typeof module === STRING ? module : UNDEFINED;
	
	                // Add level
	                level = String(level).toUpperCase();
	                entry.level = Object.keys(LEVELS).indexOf(level) > -1 ? level : DEFAULT.NAME;
	
	                // If there is a hidden input field named `trace` on the page, read it and add it
	                var input = document.getElementById('trace');
	                if (input instanceof HTMLInputElement && input.type === 'hidden') {
	                    entry.trace = input.value;
	                }
	
	                // Log the page url
	                var pos = (window.location.protocol + '//' + window.location.host).length;
	                entry.url = window.location.href.substr(pos);
	
	                // Log the query string
	                if (window.location.search || window.location.hash) {
	                    if (window.jQuery && typeof window.jQuery.deparam === 'function') {
	                        entry.query = {
	                            search: window.jQuery.deparam(window.location.search.substr(1)),
	                            hash: window.jQuery.deparam(window.location.hash)
	                        };
	                    } else {
	                        entry.query = {
	                            search: window.location.search.substr(1),
	                            hash: window.location.hash
	                        };
	                    }
	                } else {
	                    entry.query = {};
	                }
	            }
	
	            /* This function has too many statements. */
	            /* jshint -W071 */
	
	            /* This function's cyclomatic complexity is too high. */
	            /* jshint -W074 */
	
	            // Print a formatted log entry to the console
	            function log2Console(entry) {
	                /* jshint maxcomplexity: 24 */
	                /* jshint maxstatements: 34 */
	                var console = window.console;
	                if (console && typeof console.log === FUNCTION) {
	                    var message = '[' + entry.level + (entry.level.length === 4 ? ' ' : '') + ']';
	                    var first = true;
	                    if (entry.message) {
	                        message += (first ? FIRST : SEP) + 'message' + EQ + entry.message;
	                        first = false;
	                    }
	                    if (entry.originalMessage) {
	                        message += (first ? FIRST : SEP) + 'originalMessage' + EQ + entry.originalMessage;
	                        first = false;
	                    }
	                    if (entry.module) {
	                        message += (first ? FIRST : SEP) + 'module' + EQ + entry.module;
	                        first = false;
	                    }
	                    if (entry.method) {
	                        message += (first ? FIRST : SEP) + 'method' + EQ + entry.method;
	                        first = false;
	                    }
	                    if (entry.stack) {
	                        message += (first ? FIRST : SEP) + 'stack' + EQ + entry.stack;
	                        first = false;
	                    }
	                    if (entry.data) {
	                        try {
	                            message += (first ? FIRST : SEP) + 'data' + EQ + JSON.stringify(entry.data);
	                        } catch (exception) {
	                            if (typeof entry.data.toString === FUNCTION) {
	                                message += (first ? FIRST : SEP) + 'data' + EQ + entry.data.toString();
	                            }
	                        }
	                    }
	                    if (entry.trace) {
	                        message += (first ? FIRST : SEP) + 'trace' + EQ + entry.trace;
	                        first = false;
	                    }
	                    console.log(message);
	                    if (entry.error instanceof Error) {
	                        if (typeof window.console.error === FUNCTION) {
	                            window.console.error(entry.error);
	                        }
	                    }
	                    if (entry.originalError instanceof Error) {
	                        if (typeof window.console.error === FUNCTION) {
	                            window.console.error(entry.originalError);
	                        }
	                    }
	                }
	            }
	
	            /* jshint +W074 */
	            /* jshint +W071 */
	
	
	            level = String(level).toUpperCase();
	            if (Object.keys(LEVELS).indexOf(level) === -1) {
	                throw new TypeError('level is either `debug`, `info`, `warn`, `error` or `crit`');
	            }
	            if (app.level > LEVELS[level].VALUE) {
	                return false;
	            }
	            var entry = preProcess(message, data);
	            enhance(entry, this._module, level);
	            if (app.DEBUG) {
	                log2Console(entry, level);
	            }
	            var logger = app.logger;
	            if (logger && typeof logger['_' + level.toLowerCase()] === FUNCTION) {
	                logger['_' + level.toLowerCase()](entry);
	            }
	            return true;
	        };
	
	        /**
	         * Debug message
	         * @param message
	         * @param data
	         */
	        Logger.prototype.debug = function (message, data) {
	            return this.log(LEVELS.DEBUG.NAME, message, data);
	        };
	
	        /**
	         * Info message
	         * @param message
	         * @param data
	         */
	        Logger.prototype.info = function (message, data) {
	            return this.log(LEVELS.INFO.NAME, message, data);
	        };
	
	        /**
	         * Warning message
	         * @param message
	         * @param data
	         */
	        Logger.prototype.warn = function (message, data) {
	            return this.log(LEVELS.WARN.NAME, message, data);
	        };
	
	        /**
	         * Error message
	         * @param message
	         * @param data
	         */
	        Logger.prototype.error = function (message, data) {
	            return this.log(LEVELS.ERROR.NAME, message, data);
	        };
	
	        /**
	         * Critical message
	         * @param message
	         * @param data
	         */
	        Logger.prototype.crit = Logger.prototype.critical = function (message, data) {
	            return this.log(LEVELS.CRIT.NAME, message, data);
	        };
	
	        /**
	         * OnError global event handler
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror
	         * @param message
	         * @param source
	         * @param lineno
	         * @param colno
	         * @param error
	         */
	        window.onerror = function (message, source, lineno, colno, error) {
	            var logger = new Logger('window.logger');
	            logger.crit({
	                data: { source: source, lineno: lineno, colno: colno },
	                error: error,
	                message: message
	            });
	        };
	
	    }());
	
	    return window.Logger;
	
	}, __webpack_require__(200));


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(207)
	        // './kidoju.tools'
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    /* This function has too many statements. */
	    /* jshint -W071 */
	
	    (function ($, undefined) {
	
	        var kendo = window.kendo;
	        var kidoju = window.kidoju = window.kidoju || {};
	        var models = kidoju.data = kidoju.data || {};
	        var assert = window.assert;
	        var logger = new window.Logger('kidoju.data');
	        var OBJECT = 'object';
	        var STRING = 'string';
	        // var BOOLEAN = 'boolean';
	        var NUMBER = 'number';
	        var UNDEFINED = 'undefined';
	        var CHANGE = 'change';
	        var ERROR = 'error';
	        var WARNING = 'warning';
	        var ZERO_NUMBER = 0;
	        var NEGATIVE_NUMBER = -1;
	        var RX_VALID_NAME = /^val_[a-z0-9]{6}$/;
	        var location = window.location;
	        var workerLibPath = location.protocol + '//' + location.host + '/Kidoju.Widgets/src/js/kidoju.data.workerlib.js';
	        // var workerLibPath = location.protocol + '//' + location.host + '/src/js/kidoju.data.workerlib.js'; // for WEINRE
	        var workerTimeout = 250;
	
	        /*********************************************************************************
	         * Base Model
	         *********************************************************************************/
	
	        /**
	         * kidoju.data.Model enhances kendo.data.Model
	         * for aggregation of submodels as as a mongoose document property can designate a subdocument
	         * for DataSource of submodels as a mongoose document property can designate an array of subdocuments
	         */
	        var Model = models.Model = kendo.data.Model.define({
	
	            /**
	             * Function called in init(data) and accept(data)
	             * to parse data and convert fields to model field types
	             * @param data
	             * @private
	             */
	            _parseData: function (data) {
	                /* This function's cyclomatic complexity is too high */
	                /* jshint -W074 */
	                var that = this;
	                var parsed = {};
	                // We need a clone to avoid modifications to original data
	                for (var field in that.fields) {
	                    if (that.fields.hasOwnProperty(field)) {
	                        if (data && $.isFunction(data.hasOwnProperty) && data.hasOwnProperty(field) && $.type(data[field]) !== UNDEFINED) {
	                            parsed[field] = that._parse(field, data[field]);
	                        } else if (that.defaults && that.defaults.hasOwnProperty(field)) {
	                            if (that[field] instanceof kendo.data.DataSource) {
	                                // Important! Do not erase existing dataSources
	                                // unless data.hasOwnProperty(field) here above
	                                parsed[field] = that[field];
	                            } else {
	                                // Important! We need to parse default values
	                                // especially to initialize Stream.pages.defaultValue
	                                // and Page.components.defaultValue
	                                parsed[field] = that._parse(field, that.defaults[field]);
	                            }
	                        } else if (that.fields[field].type === 'string') {
	                            parsed[field] = '';
	                        } else if (that.fields[field].type === 'number') {
	                            parsed[field] = 0;
	                        } else if (that.fields[field].type === 'boolean') {
	                            parsed[field] = false;
	                        } else if (that.fields[field].type === 'date') {
	                            parsed[field] = new Date();
	                        } else {
	                            // Any field which is part of the model schema/definition
	                            // and which has no type and no defaultValue infers a null default value
	                            parsed[field] = null;
	                        }
	                    }
	                }
	                return parsed;
	                /* jshint -W074 */
	            },
	
	            /**
	             * Modify original init method
	             * to add casting of properties into their underlying type
	             * For example, if a model field of type date receives a string value, it will be cast into a date
	             * and if a model field designates a submodel, it will be cast into that submodel
	             * @see http://www.telerik.com/forums/parsing-on-initialization-of-kendo-data-model
	             * @param data
	             */
	            init: function (data) {
	                // Call the base init method after parsing data
	                kendo.data.Model.fn.init.call(this, this._parseData(data));
	            },
	
	            /**
	             * Modify original accept method
	             * Add casting of properties into their underlying type (see init above)
	             * @see http://www.telerik.com/forums/parsing-on-initialization-of-kendo-data-model
	             * Trigger a change event on the parent observable (hierarchies of models and submodels)
	             * @see http://www.telerik.com/forums/triggering-a-change-event-on-the-parent-observable-when-calling-kendo-data-model-accept-method
	             * @param data
	             * @returns {boolean}
	             */
	            accept: function (data) {
	                // Call the base accept method
	                kendo.data.Model.fn.accept.call(this, this._parseData(data));
	
	                // Trigger a change event on the parent observable (possibly a viewModel)
	                // Without it, any UI wodget data bound to the parent is not updated
	                // TODO Review this event thing.......
	                if ($.isFunction(this.parent)) {
	                    var parent = this.parent();
	                    if (parent instanceof kendo.data.ObservableObject) {
	                        for (var key in parent) {
	                            if (parent.hasOwnProperty(key) && parent[key] instanceof this.constructor && parent[key].uid === this.uid) {
	                                // As we have found our nested object in the parent
	                                // trigger a change event otherwise UI won't be updated via MVVM
	                                parent.trigger(CHANGE, { field: key });
	                                // Once we have found the key holding our model in its parent and triggered the change event,
	                                // break out of for loop
	                                break;
	                            }
	                        }
	                        // } else if (parent instanceof kendo.data.ObservableArray) {
	                        // TODO: What in this case ????
	                    }
	                }
	            },
	
	            /**
	             * Override shouldSerialize to
	             * 1) only serialize fields defined in the Model (any other value should be discarded)
	             * 2) discard model fields with property serializable === false
	             * @param field
	             */
	            shouldSerialize: function (field) {
	
	                assert.type(STRING, field, kendo.format(assert.messages.type.default, 'field', STRING));
	
	                return this.fields.hasOwnProperty(field) && this.fields[field].serializable !== false &&
	                    kendo.data.Model.fn.shouldSerialize.call(this, field);
	            },
	
	
	            /**
	             * Modify original toJSON method to:
	             * (1) only serialize actual editable fields with their id
	             * (2) optionally serialize the entire tree
	             *
	             * Note that we have also considered taking a list of fields as parameters
	             * to only send the data we know has been modified
	             * toPartialJSON was not copied when moving app.models.BaseModel to kidoju.data.Model
	             * @param includeDataSources defines whether to include datasources in the result or not
	             * This would actually depend upon the fact whether the hierarchy is saved with the root object
	             * or the data sources have their own transport to save their nodes.
	             * @returns {{}}
	             */
	            toJSON: function (includeDataSources) {
	
	                var json = {};
	                var value;
	                var field;
	
	                for (field in this) {
	                    if (this.shouldSerialize(field)) {
	
	                        value = this[field];
	
	                        // Also call toJSON on any kidoju.data.DataSource which aggregates a collection of models (not in original toJSON method)
	                        // if (value instanceof kendo.data.ObservableObject || value instanceof kendo.data.ObservableArray) {
	                        if (value instanceof kendo.data.ObservableObject || value instanceof kendo.data.ObservableArray || (includeDataSources && value instanceof DataSource)) {
	                            value = value.toJSON(includeDataSources);
	                        }
	
	                        // Also discard undefined values and empty objects (not in original toJSON method)
	                        // Note: we are not discarding empty arrays though:
	                        // We are considering that an empty object is a collection of undefined attributes
	                        // It is not the same with an empty array
	                        if ($.type(value) !== UNDEFINED && // Not an undefined value
	                            !($.isPlainObject(value) && $.isEmptyObject(value)) && // Not an empty object {}
	                            !($.type(value) === OBJECT && value.constructor !== Object)) { // Not an instance of a Class, Model or DataSource
	                            json[field] = value;
	                        }
	
	                        // `undefined` is ambiguous because it is also the value of a missing property.
	                        // if we really want to assign data = undefined or data = {}, we should make data nullable and assign data = null
	                        // See https://github.com/christkv/mongodb-core/issues/31
	                        // Note also that this is consistent with JSON.stringify which ignores undefined values
	                    }
	                }
	
	                return json;
	            },
	
	            /* This function's cyclomatic complexity is too high */
	            /* jshint -W074 */
	
	            /**
	             * Execute validation of the model data considering the rules defined on fields
	             * @returns {boolean}
	             */
	            validate: function () {
	                /* jshint maxcomplexity: 8 */
	                var that = this;
	                var validated = true;
	                for (var field in that.fields) {
	                    if (that.fields.hasOwnProperty(field)) {
	                        var validation = that.fields[field].validation;
	                        if (!$.isPlainObject(validation)) {
	                            continue;
	                        }
	                        if (validation.required === true && !that[field]) { // nullable fields?
	                            validated = false;
	                            break;
	                        }
	                        if ($.type(validation.pattern) === STRING && !(new RegExp(validation.pattern)).test(that[field])) {
	                            validated = false;
	                            break;
	                        }
	                        if ($.type(validation.min) === NUMBER && !isNaN(parseFloat(that[field])) && parseFloat(that[field]) < validation.min) {
	                            validated = false;
	                            break;
	                        }
	                        if ($.type(validation.max) === NUMBER && !isNaN(parseFloat(that[field])) && parseFloat(that[field]) > validation.max) {
	                            validated = false;
	                            break;
	                        }
	                    }
	                }
	                return validated; // Should we return an array of errors instead
	            }
	
	            /* jshint +W074 */
	
	            // Consider a function that populates validation rules on forms
	            // See http://docs.telerik.com/kendo-ui/framework/validator/overview
	
	        });
	
	        /*********************************************************************************
	         * Base DataReader
	         *********************************************************************************/
	
	        /**
	         * ModelCollectionDataReader
	         * We cannot subclass kendo.data.DataReader because the data function is created in the constructor
	         * using a wrapDataAccess private function
	         * @class ModelCollectionDataReader
	         */
	        var ModelCollectionDataReader = kidoju.data.ModelCollectionDataReader = kendo.Class.extend({
	            init: function (reader) {
	                this.reader = reader;
	                if (reader.model) {
	                    this.model = reader.model;
	                }
	            },
	            errors: function (data) {
	                return this.reader.errors(data);
	            },
	            parse: function (data) {
	                if ($.isArray(data) && $.isFunction(this.model)) {
	                    var defaults = (new this.model()).defaults;
	                    for (var i = 0; i < data.length; i++) {
	                        // We assume data[i] is an object
	                        for (var field in defaults) {
	                            if (!data[i].hasOwnProperty(field) && defaults.hasOwnProperty(field) && !$.isArray(defaults[field])) {
	                                // Set default values unless they are arrays
	                                // Otherwise we might erase dependant collections (i.e pages or components)
	                                data[i][field] = defaults[field];
	                            }
	                        }
	                    }
	                }
	                return this.reader.parse(data);
	            },
	            data: function (data) {
	                // We get funny values from the original kendo.data.DataReader
	                // due to the getters in the convertRecords(...) function in kendo.data.js
	                // especially with page components
	                // This can be checked by commenting the if block in the parse function
	                // Note: we did the fix in the parse function so as to apply to this.data and this.groups.
	                return this.reader.data(data);
	            },
	            total: function (data) {
	                return this.reader.total(data);
	            },
	            groups: function (data) {
	                return this.reader.groups(data);
	            },
	            aggregates: function (data) {
	                return this.reader.aggregates(data);
	            },
	            serialize: function (data) {
	                return this.reader.serialize(data);
	            }
	        });
	
	        /*********************************************************************************
	         * Base DataSource
	         *********************************************************************************/
	
	        /**
	         * @see kendo.data.HierarchicalDataSource
	         * @param name
	         * @returns {Function}
	         */
	        function dataMethod(name) {
	            return function () {
	                var data = this._data;
	                var result = kendo.data.DataSource.fn[name].apply(this, [].slice.call(arguments));
	
	                if (this._data !== data) {
	                    this._attachBubbleHandlers();
	                }
	
	                return result;
	            };
	        }
	
	        /**
	         * kidoju.data.DataSource enhances kendo.data.DataSource
	         * especially to serialize the stream tree as a whole
	         */
	        var DataSource = models.DataSource = kendo.data.DataSource.extend({
	
	            /**
	             * @ constructor
	             * @param options
	             */
	            // init: dataMethod('init'),
	
	            /**
	             * @method success
	             */
	            // success: dataMethod('success'),
	
	            /**
	             * @method data
	             */
	            // data: dataMethod('data'),
	
	            /**
	             * @method _attachBubbleHandlers
	             * @private
	             */
	            /*
	            _attachBubbleHandlers: function () {
	                var that = this;
	                that._data.bind(ERROR, function (e) {
	                    that.trigger(ERROR, e);
	                });
	            },
	            */
	
	            /**
	             * @method toJSON
	             */
	            toJSON: function () {
	                var json = [];
	                // total() give the total number of items, all of which are not necessarily available considering paging
	                // for (var i = 0; i < this.total(); i++) {
	                for (var i = 0; i < this.data().length; i++) {
	                    // If we pass includeDataSource === true to kidoju.data.Model.toJSON
	                    // this method is executed and we should call toJSON(true) on each DataSource item
	                    // So has to serialize the whole tree
	                    json.push(this.at(i).toJSON(true));
	                }
	                return json;
	            }
	
	        });
	
	        /*********************************************************************************
	         * PageComponent Model and DataSource
	         *********************************************************************************/
	
	        /**
	         * PageComponent model
	         * @class PageComponent
	         * @type {void|*}
	         */
	        var PageComponent = models.PageComponent = Model.define({
	            id: 'id',
	            fields: {
	                id: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                },
	                tool: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                },
	                top: {
	                    type: NUMBER,
	                    defaultValue: ZERO_NUMBER
	                },
	                left: {
	                    type: NUMBER,
	                    defaultValue: ZERO_NUMBER
	                },
	                height: {
	                    type: NUMBER,
	                    defaultValue: NEGATIVE_NUMBER
	                },
	                width: {
	                    type: NUMBER,
	                    defaultValue: NEGATIVE_NUMBER
	                },
	                rotate: {
	                    type: NUMBER,
	                    defaultValue: ZERO_NUMBER,
	                    parse: function (value) {
	                        return $.type(value) === NUMBER ? (value + 360) % 360 : ZERO_NUMBER;
	                    }
	                },
	                tag: {
	                    type: STRING,
	                    defaultValue: null
	                },
	                attributes: {
	                    defaultValue: null
	                },
	                properties: {
	                    defaultValue: null
	                }
	            },
	
	            /* jshint -W074 */
	            /* This function's cyclomatic complexity is too high. */
	
	            /**
	             * Constructor
	             * @param component
	             */
	            init: function (component) {
	
	                var that = this;
	
	                // Note: Kendo UI requires that new PageComponent() works, i.e. component = undefined
	                if ($.type(component) === OBJECT /*&& !$.isEmptyObject(component)*/) {
	                    assert.instanceof(kendo.Observable, kidoju.tools, kendo.format(assert.messages.instanceof.default, 'kidoju.tools', 'kendo.Observable'));
	                    if ($.type(component.tool) !== STRING || component.tool.length === 0 || !(kidoju.tools[component.tool] instanceof kidoju.Tool)) {
	                        throw new Error(kendo.format('`{0}` is not a valid Kidoju tool', component.tool));
	                    }
	                }
	
	                Model.fn.init.call(that, component);
	
	                if (kidoju.tools && $.type(that.tool) === STRING && that.tool.length) {
	
	                    var tool = kidoju.tools[that.tool];
	                    if (tool instanceof kidoju.Tool) {
	
	                        // Let the tool build a Model for attributes to allow validation in the property grid
	                        var Attributes = tool._getAttributeModel();
	                        // Extend component attributes with possible new attributes as tools improve
	                        var attributes = $.extend({}, Attributes.prototype.defaults, that.attributes);
	                        // Cast with Model
	                        // that.set('attributes', new Attributes(attributes)); // <--- this sets the dirty flag and raises the change event
	                        that.attributes = new Attributes(attributes);
	                        that.attributes.bind(CHANGE, function (e) {
	                            e.field = 'attributes.' + e.field;
	                            that.trigger(CHANGE, e);
	                        });
	
	                        // Let the tool build a Model for properties to allow validation in the property grid
	                        var Properties = tool._getPropertyModel();
	                        // Extend component properties with possible new properties as tools improve
	                        var properties = $.extend({}, Properties.prototype.defaults, that.properties);
	                        // Cast with Model
	                        // that.set('properties', new Properties(properties)); // <--- this sets the dirty flag and raises the change event
	                        that.properties = new Properties(properties);
	                        that.properties.bind(CHANGE, function (e) {
	                            e.field = 'properties.' + e.field;
	                            that.trigger(CHANGE, e);
	                        });
	
	                        // Add the code library if any, otherwise we will be missing code for any items designated by a name
	                        if (tool.properties && tool.properties.validation instanceof kidoju.adapters.ValidationAdapter) {
	                            that._library = tool.properties.validation.library;
	                        }
	
	                    }
	                }
	            },
	            /* jshint +W074 */
	
	            /**
	             * Get the parent page
	             * @returns {*}
	             */
	            page: function () {
	                if ($.isFunction(this.parent)) {
	                    var componentCollectionArray = this.parent();
	                    if ($.isFunction(componentCollectionArray.parent)) {
	                        return componentCollectionArray.parent();
	                    }
	                }
	            },
	
	            /**
	             * Clone a page component
	             */
	            clone: function () {
	                var component = this;
	                assert.type(STRING, component.tool, kendo.format(assert.messages.type.default, 'component.tool', STRING));
	                var fields = component.fields;
	                var clone = {};
	                // Copy page component fields (tool, top, left, height, width, rotate, ...), but not attributes and properties
	                for (var field in fields) {
	                    if (fields.hasOwnProperty(field) && $.type(fields[field].type) === STRING && field !== component.idField) {
	                        clone[field] = component.get(field);
	                    }
	                }
	                // Copy display attributes
	                fields = component.attributes.fields;
	                clone.attributes = {};
	                for (/*var */field in fields) {
	                    if (fields.hasOwnProperty(field) && $.type(fields[field].type) === STRING) {
	                        clone.attributes[field] = component.get('attributes.' + field);
	                    }
	                }
	                // IMPORTANT: we do not copy test logic (properties)
	                clone = new PageComponent(clone);
	                // Return clone
	                return clone;
	            },
	
	            /**
	             * PageComponent validation
	             * @param pageIdx (in PageCollection)
	             */
	            validate: function (pageIdx) {
	                assert.instanceof (PageComponent, this, kendo.format(assert.messages.instanceof.default, 'this', 'kidoju.data.PageComponent'));
	                assert.type(NUMBER, pageIdx, kendo.format(assert.messages.type.default, 'pageIdx', NUMBER));
	                assert.instanceof(kendo.Observable, kidoju.tools, kendo.format(assert.messages.instanceof.default, 'kidoju.tools', 'kendo.Observable'));
	                var component = this;
	                var ret = [];
	                var tool = component.get('tool');
	                assert.type(STRING, tool, kendo.format(assert.messages.type.default, 'tool', STRING));
	                if (kidoju.tools[tool] instanceof kidoju.Tool) {
	                    ret = kidoju.tools[tool].validate(component, pageIdx);
	                }
	                return ret;
	            }
	
	        });
	
	        /**
	         * @class PageComponentCollectionDataSource
	         * @type {*|void|Object}
	         */
	        var PageComponentCollectionDataSource =  models.PageComponentCollectionDataSource = DataSource.extend({
	
	            /**
	             * Constructor
	             * @constructor
	             * @param options
	             */
	            init: function (options) {
	
	                // Enforce the use of PageComponent items in the collection data source
	                // options contains a property options.schema.model which needs to be replaced
	                // DataSource.fn.init.call(this, $.extend(true, {}, { schema: { modelBase: PageComponent, model: PageComponent } }, options));
	                DataSource.fn.init.call(this, $.extend(true, {}, options, { schema: { modelBase: PageComponent, model: PageComponent } }));
	
	                // Let's use a slightly modified reader to leave data conversions to kidoju.data.Model._parseData
	                this.reader = new ModelCollectionDataReader(this.reader);
	            },
	
	            /**
	             * Remove
	             * @param model
	             * @returns {*}
	             */
	            remove: function (model) {
	                return DataSource.fn.remove.call(this, model);
	            },
	
	            /**
	             * Insert
	             * @param index
	             * @param model
	             * @returns {*}
	             */
	            insert: function (index, model) {
	                if (!model) {
	                    return;
	                }
	                if (!(model instanceof PageComponent)) {
	                    var component = model;
	
	                    model = this._createNewModel();
	                    model.accept(component);
	                }
	                return DataSource.fn.insert.call(this, index, model);
	            }
	
	        });
	
	        /**
	         * @method create
	         * @param options
	         */
	        PageComponentCollectionDataSource.create = function (options) {
	            options = options && options.push ? { data: options } : options;
	
	            var dataSource = options || {};
	            var data = dataSource.data;
	
	            dataSource.data = data;
	
	            if (!(dataSource instanceof PageComponentCollectionDataSource) && dataSource instanceof kendo.data.DataSource) {
	                throw new Error('Incorrect DataSource type. Only PageComponentCollectionDataSource instances are supported');
	            }
	
	            return dataSource instanceof PageComponentCollectionDataSource ? dataSource : new PageComponentCollectionDataSource(dataSource);
	        };
	
	        /*********************************************************************************
	         * Page Model and DataSource
	         *********************************************************************************/
	
	        /**
	         * Page
	         * @see kendo.data.HierarchicalDataSource and kendo.data.Node for implementation details
	         * @class Page
	         * @type {void|*}
	         */
	        var Page = models.Page = Model.define({
	            id: 'id',
	            fields: {
	                id: {
	                    type: STRING,
	                    nullable: true,
	                    editable:false
	                },
	                components: {
	                    // We cannot assign a data source as default value of a model
	                    // because otherwise it might be reused amongst instances.
	                    // The only way to ensure that a new instance gets a new default value is to initialize with []
	                    // and have kidoju.data.Model._parseData initialize the instance data source from [].
	                    // defaultValue: new kidoju.data.PageComponentCollectionDataSource({ data: [] }),
	                    defaultValue: [],
	                    parse: function (value) {
	                        if (value instanceof PageComponentCollectionDataSource) {
	                            return value;
	                        } else if (value && value.push) {
	                            return new PageComponentCollectionDataSource({ data: value });
	                        } else {
	                            return new PageComponentCollectionDataSource(value);
	                        }
	                    }
	                },
	                explanations: { // displayed in review mode
	                    type: STRING
	                },
	                instructions: { // displayed in explanation mode
	                    type: STRING
	                },
	                style: {
	                    type: STRING
	                }
	            },
	
	            /**
	             * @constructor
	             * @param value
	             */
	            init: function (value) {
	                var that = this;
	
	                // Call the base init method
	                Model.fn.init.call(that, value);
	
	                if (that.model && that.model.components) {
	                    // Reset PageCollectionDataSource with model.pages dataSource options
	                    // especially for the case where we have defined CRUD transports
	                    that.components = new PageComponentCollectionDataSource(that.model.components);
	                }
	
	                var components = that.components;
	
	                /*
	                var transport = components.transport,
	                    parameterMap = transport.parameterMap;
	                transport.parameterMap = function (data, type) {
	                    data[that.idField || 'id'] = that.id;
	                    if (parameterMap) {
	                        data = parameterMap(data, type);
	                    }
	                    return data;
	                };
	                */
	
	                if (components instanceof PageComponentCollectionDataSource) {
	
	                    // Add parent function
	                    components.parent = function () {
	                        return that;
	                    };
	
	                    // Bind the change and error events
	                    // to propagate them from the components collection to the page node
	                    /*
	                    components
	                        .bind(CHANGE, function (e) {
	                            e.page = e.page || that;
	                            that.trigger(CHANGE, e);
	                        })
	                        .bind(ERROR, function (e) {
	                            var pageCollection = that.parent();
	                            if (pageCollection) {
	                                e.page = e.page || that;
	                                pageCollection.trigger(ERROR, e);
	                            }
	                        });
	                        */
	                }
	
	                that._loaded = !!(value && (value.components || value._loaded));
	            },
	
	            /**
	             * @method append
	             * @param component
	             */
	            append: function (component) {
	                this.loaded(true);
	                this.components.add(component);
	            },
	
	            /**
	             * @method load
	             * @returns {*}
	             */
	            load: function () {
	                var options = {};
	                var method = '_query';
	                var components = this.components;
	                // Passing the id of the page to the components _query method
	                // is suggested by lendo.data.Node
	                options[this.idField || 'id'] = this.id;
	                if (!this._loaded) {
	                    components._data = undefined;
	                    method = 'read';
	                }
	                components.one(CHANGE, $.proxy(function () { this.loaded(true); }, this));
	                return components[method](options);
	            },
	
	            /**
	             * Get the parent stream if any
	             * @returns {*}
	             */
	            stream: function () {
	                if ($.isFunction(this.parent)) {
	                    var pageCollectionArray = this.parent();
	                    if ($.isFunction(pageCollectionArray.parent)) {
	                        return pageCollectionArray.parent();
	                    }
	                }
	            },
	
	            /**
	             * Gets or sets the loaded status of page components
	             * @param value
	             * @returns {boolean|*|Page._loaded}
	             */
	            loaded: function (value) {
	                if (value !== undefined) {
	                    this._loaded = value;
	                } else {
	                    return this._loaded;
	                }
	            },
	
	            /**
	             * Clone a page
	             */
	            clone: function () {
	                var page = this;
	                var fields = page.fields;
	                var clone = {};
	                // Copy page fields (explanations, instructions, style)
	                for (var field in fields) {
	                    if (fields.hasOwnProperty(field) && $.type(fields[field].type) === STRING && field !== page.idField) {
	                        clone[field] = page.get(field);
	                    }
	                }
	                clone = new Page(clone);
	                // Copy components
	                var components = page.components;
	                for (var i = 0, total = components.total(); i < total; i++) {
	                    clone.components.add(components.at(i).clone());
	                }
	                // Return clone
	                return clone;
	            },
	
	            /**
	             * i18n Messages
	             */
	            messages: {
	                emptyPage: 'Page {0} cannot be empty.',
	                minConnectors: 'At least {0} Connectors are required to make a question on page {1}.',
	                missingDraggable: 'Draggable Labels or Images are required for a Drop Zone on page {0}.',
	                missingDropZone: 'A Drop Zone is required for draggable Labels or Images on page {0}.',
	                missingLabel: 'A Label is recommended on page {0}.',
	                missingMultimedia: 'A multimedia element (Image, Audio, Video) is recommended on page {0}.',
	                missingQuestion: 'A question is recommended on page {0}.',
	                missingInstructions: 'Instructions are recommended on page {0}.',
	                missingExplanations: 'Explanations are recommended on page {0}.'
	            },
	
	            /* This function's cyclomatic complexity is too high. */
	            /* jshint -W074 */
	
	            /**
	             * Page validation
	             * @param pageIdx
	             * @returns {Array}
	             */
	            validate: function (pageIdx) {
	                /* jshint maxcomplexity: 22 */
	                assert.instanceof (Page, this, kendo.format(assert.messages.instanceof.default, 'this', 'kidoju.data.Page'));
	                assert.type(NUMBER, pageIdx, kendo.format(assert.messages.type.default, 'pageIdx', NUMBER));
	                var ret = [];
	                var hasDraggable = false;
	                var hasDropZone = false;
	                var hasLabel = false;
	                var hasMultimedia = false;
	                var hasQuestion = false;
	                var connectorCount = 0;
	                var componentTotal = this.components.total();
	                if (componentTotal === 0) {
	                    ret.push({ type: ERROR, index: pageIdx, message: kendo.format(this.messages.emptyPage, pageIdx + 1) });
	                }
	                for (var i = 0; i < componentTotal; i++) {
	                    var component = this.components.at(i);
	                    if (component.tool === 'label') {
	                        hasLabel = true;
	                        if (component.properties.draggable) {
	                            hasDraggable = true;
	                        }
	                    } else if (component.tool === 'image' || component.tool === 'audio' || component.tool === 'video') {
	                        hasMultimedia = true;
	                        if (component.properties.draggable) {
	                            hasDraggable = true;
	                        }
	                    } else if ($.type(component.properties) ===  OBJECT && $.type(component.properties.validation) === STRING) {
	                        hasQuestion = true;
	                        if (component.tool === 'connector') {
	                            connectorCount++;
	                        } else if (component.tool === 'dropzone') {
	                            hasDropZone = true;
	                        }
	                    }
	                    ret = ret.concat(component.validate(pageIdx));
	                }
	                // Check a label
	                if (componentTotal > 0 && !hasLabel) {
	                    ret.push({ type: WARNING, index: pageIdx, message: kendo.format(this.messages.missingLabel, pageIdx + 1) });
	                }
	                // Check a multimedia element
	                if (componentTotal > 0 && !hasMultimedia) {
	                    ret.push({ type: WARNING, index: pageIdx, message: kendo.format(this.messages.missingMultimedia, pageIdx + 1) });
	                }
	                // Check a question
	                if (componentTotal > 0 && !hasQuestion) {
	                    ret.push({ type: WARNING, index: pageIdx, message: kendo.format(this.messages.missingQuestion, pageIdx + 1) });
	                }
	                // Check connectors
	                var MIN_CONNECTORS = 4;
	                if (connectorCount > 0 && connectorCount < MIN_CONNECTORS) {
	                    ret.push({ type: WARNING, index: pageIdx, message: kendo.format(this.messages.minConnectors, MIN_CONNECTORS, pageIdx + 1) });
	                }
	                // Check drop zone and draggable
	                if (hasDropZone && !hasDraggable) {
	                    ret.push({ type: ERROR, index: pageIdx, message: kendo.format(this.messages.missingDraggable, pageIdx + 1) });
	                } else if (!hasDropZone && hasDraggable) {
	                    ret.push({ type: ERROR, index: pageIdx, message: kendo.format(this.messages.missingDropZone, pageIdx + 1) });
	                }
	                // Check instructions
	                var instructions = (this.get('instructions') || '').trim();
	                if (!instructions) {
	                    ret.push({ type: WARNING, index: pageIdx, message: kendo.format(this.messages.missingInstructions, pageIdx + 1) });
	                }
	                // Check explanations
	                var explanations = (this.get('explanations') || '').trim();
	                if (!explanations) {
	                    ret.push({ type: WARNING, index: pageIdx, message: kendo.format(this.messages.missingExplanations, pageIdx + 1) });
	                }
	                return ret;
	            }
	
	            /* jshint +W074 */
	
	        });
	
	        /**
	         * WorkerPool
	         * @class WorkerPool
	         * @param concurrency
	         * @param timeOut
	         */
	        var WorkerPool = models.WorkerPool = function (concurrency, timeOut) {
	            // concurrency = concurrency || navigator.hardwareConcurrency || 4;
	            // Array of concurrent working threads
	            var workers = new Array(concurrency);
	            // Queue of tasks
	            var tasks = [];
	            // Array of deferreds
	            var deferreds = [];
	            // State of worker pool
	            var running = false;
	
	            /**
	             * Helper function to chain tasks on a thread
	             * Note: thread is a number between 0 and concurrency - 1 which designates an entry in the workers array
	             * @param thread
	             */
	            function runNextTask(thread) {
	                // console.log('run next task');
	                if (tasks.length > 0) {
	                    var task = tasks.shift();
	                    workers[thread] = new Worker(task.script);
	                    workers[thread].onmessage = function (e) {
	                        workers[thread].terminate();
	                        deferreds[task.id].resolve({ name: task.name, value: e.data });
	                        runNextTask(thread);
	                    };
	                    workers[thread].onerror = function (e) {
	                        workers[thread].terminate();
	                        // e is an ErrorEvent and e.error is null
	                        var error = new Error(e.message || 'Unknown error');
	                        error.taskname = task.name;
	                        error.filename = e.filename;
	                        error.colno = e.colno;
	                        error.lineno = e.lineno;
	                        deferreds[task.id].reject(error);
	                        logger.crit(error);
	                        // No need to run next task because $.when fails on the first failing deferred
	                        // runNextTask(thread);
	                    };
	                    // We need JSON.stringify because of a DataCloneError with character grid values
	                    workers[thread].postMessage(JSON.stringify(task.message));
	                    if ($.type(timeOut) === 'number') {
	                        setTimeout(function () {
	                            if (deferreds[task.id].state() === 'pending') {
	                                workers[thread].terminate();
	                                var error = new Error('The execution of a web worker has timed out');
	                                error.taskname = task.name;
	                                error.filename = task.script;
	                                error.timeout = true;
	                                deferreds[task.id].reject(error);
	                                logger.crit(error);
	                                // No need to run next task because $.when fails on the first failing deferred
	                                // runNextTask(thread);
	                            }
	                        }, timeOut);
	                    }
	                }
	            }
	
	            /***
	             * Add a task to the queue
	             * @param name
	             * @param script
	             * @param message
	             */
	            this.add = function (name, script, message) {
	                if (running) {
	                    throw new Error('Cannot add to running pool');
	                }
	                tasks.push({ name: name, script: script, message: message, id: tasks.length });
	                deferreds.push($.Deferred());
	            };
	
	            /**
	             * Run the work pool
	             * Note: Add all tasks first
	             * @returns {*}
	             */
	            this.run = function () {
	                if (running) {
	                    throw new Error('A worker pool cannot be executed twice');
	                }
	                running = true;
	                // Start each pool
	                for (var poolId = 0; poolId < workers.length; poolId++) {
	                    runNextTask(poolId);
	                }
	                // Return an array of deferreds
	                return $.when.apply($, deferreds);
	            };
	        };
	
	        /**
	         * ValidatedTest model
	         */
	        /*
	        var ValidatedTest = models.ValidatedTest = Model.define({
	            fields: {
	                max: {
	                    type: 'number',
	                    nullable: false
	                },
	                score: {
	                    type: 'number',
	                    nullable: false
	                }
	            }
	        });
	        */
	
	
	        /**
	         * @class PageCollectionDataSource
	         * @type {*|void|Object}
	         */
	        var PageCollectionDataSource =  models.PageCollectionDataSource = DataSource.extend({
	
	            /**
	             * @constructor
	             * @param options
	             */
	            init: function (options) {
	
	                // PageWithOptions propagates configuration options to PageComponentCollectionDataSource
	                var PageWithOptions = options && options.schema && ($.type(options.schema.model) === OBJECT) ?
	                    Page.define({ model: options.schema.model }) : Page;
	
	                // Enforce the use of PageWithOptions items in the page collection data source
	                // options contains a property options.schema.model which needs to be replaced with PageWithOptions
	                // kidoju.data.DataSource.fn.init.call(this, $.extend(true, {}, { schema: { modelBase: PageWithOptions, model: PageWithOptions } }, options));
	                DataSource.fn.init.call(this, $.extend(true, {}, options, { schema: { modelBase: PageWithOptions, model: PageWithOptions } }));
	
	                // Let's use a slightly modified reader to leave data conversions to kidoju.data.Model._parseData
	                this.reader = new ModelCollectionDataReader(this.reader);
	            },
	
	            /**
	             * @method remove
	             * @param model
	             * @returns {*}
	             */
	            remove: function (model) {
	                return DataSource.fn.remove.call(this, model);
	            },
	
	            /**
	             * @method insert
	             * @param index
	             * @param model
	             * @returns {*}
	             */
	            insert: function (index, model) {
	                if (!model) {
	                    return;
	                }
	                if (!(model instanceof Page)) {
	                    var page = model;
	                    model = this._createNewModel();
	                    model.accept(page);
	                }
	                return DataSource.fn.insert.call(this, index, model);
	            },
	
	            /**
	             * Get empty user test data from properties
	             * IMPORTANT: Make sure all pages are loaded first
	             * @method getTestFromProperties
	             * @returns {*}
	             */
	            getTestFromProperties: function () {
	                assert.instanceof(kendo.Observable, kidoju.tools, kendo.format(assert.messages.instanceof.default, 'kidoju.tools', 'kendo.Observable'));
	                var that = this;
	                var tools = kidoju.tools;
	                var test = {
	                    // Store for connections
	                    connections: [],
	                    // Store for positioning draggable items
	                    draggables: []
	                };
	                $.each(that.data(), function (pageIdx, page) {
	                    $.each(page.components.data(), function (componentIdx, component) {
	                        var properties = component.properties;
	                        if (properties instanceof kendo.data.Model &&
	                            $.type(properties.fields) === OBJECT && !$.isEmptyObject(properties.fields) &&
	                            $.type(properties.name) === STRING && $.type(properties.validation) === STRING) {
	                            var tool = kidoju.tools[component.tool];
	                            assert.instanceof(kidoju.Tool, tool, kendo.format(assert.messages.instanceof.default, 'tool', 'kidoju.Tool'));
	                            test[properties.name] = { value: tool.getTestDefaultValue(component) };
	                        }
	                    });
	                });
	                return test;
	            },
	
	            /**
	             * Validate user test data
	             * IMPORTANT: Make sure all pages are loaded first
	             * @method validateTestFromProperties
	             * @returns {*}
	             */
	            validateTestFromProperties: function (test) {
	
	                // Note: the model being created on the fly (no kendo.data.Model)), we only have an ObservableObject to test
	                assert.instanceof(kendo.data.ObservableObject, test, kendo.format(assert.messages.instanceof.default, 'test', 'kendo.data.ObservableObject'));
	
	                var pageCollectionDataSource = this; // don't use that which is used below
	                var deferred = $.Deferred();
	                var workerPool = new WorkerPool(window.navigator.hardwareConcurrency || 4, workerTimeout);
	                // TODO: use an app.model and define a submodel with each field - see ValidatedTest above
	                var result = {
	                        connections: test.connections,
	                        draggables: test.draggables,
	                        score: function () {
	                            var score = 0;
	                            assert.instanceof(kendo.data.ObservableObject, this, kendo.format(assert.messages.instanceof.default, 'this', 'kendo.data.ObservableObject'));
	                            for (var name in this) {
	                                if (this.hasOwnProperty(name) && RX_VALID_NAME.test(name)) {
	                                    score += this.get(name + '.score');
	                                }
	                            }
	                            return score;
	                        },
	                        max: function () {
	                            var max = 0;
	                            assert.instanceof(kendo.data.ObservableObject, this, kendo.format(assert.messages.instanceof.default, 'this', 'kendo.data.ObservableObject'));
	                            for (var name in this) {
	                                if (this.hasOwnProperty(name) && RX_VALID_NAME.test(name)) {
	                                    max += this.get(name + '.success');
	                                }
	                            }
	                            return max;
	                        },
	                        percent: function () {
	                            assert.instanceof(kendo.data.ObservableObject, this, kendo.format(assert.messages.instanceof.default, 'this', 'kendo.data.ObservableObject'));
	                            var max = this.max();
	                            var score = this.score();
	                            return score === 0 || max === 0 ?  0 : 100 * score / max;
	                        },
	                        getScoreArray: function () {
	                            function matchPageConnectors (pageIdx) {
	                                // Connectors are a match if they have the same solution
	                                var ret = {};
	                                var connectors = pageCollectionDataSource.at(pageIdx).components.data().filter(function (component) {
	                                    return component.tool === 'connector';
	                                });
	                                for (var i = 0, length = connectors.length; i < length; i++) {
	                                    var connector = connectors[i];
	                                    var name = connector.properties.name;
	                                    assert.match(RX_VALID_NAME, name, kendo.format(assert.messages.match.default, 'name', RX_VALID_NAME));
	                                    var solution = connector.properties.solution;
	                                    var found = false;
	                                    for (var prop in ret) {
	                                        if (ret.hasOwnProperty(prop)) {
	                                            if (prop === name) {
	                                                // already processed
	                                                found = true;
	                                                break;
	                                            } else if (ret[prop] === solution) {
	                                                // found matching connector, point to name
	                                                ret[prop] = name;
	                                                found = true;
	                                                break;
	                                            }
	                                        }
	                                    }
	                                    if (!found) {
	                                        // Add first connector, waiting to find a matching one
	                                        ret[name] = solution;
	                                    }
	                                }
	                                return ret;
	                            }
	                            function matchConnectors () {
	                                // We need a separate function because matching connectors neded to have the same solution on the same page (not a different page)
	                                var ret = {};
	                                for (var pageIdx = 0, pageTotal = pageCollectionDataSource.total(); pageIdx < pageTotal; pageIdx++) {
	                                    ret = $.extend(ret, matchPageConnectors(pageIdx));
	                                }
	                                return ret;
	                            }
	                            assert.instanceof(kendo.data.ObservableObject, this, kendo.format(assert.messages.instanceof.default, 'this', 'kendo.data.ObservableObject'));
	                            var that = this; // this is variable `result`
	                            var matchingConnectors = matchConnectors();
	                            var redundantConnectors = {};
	                            var scoreArray = [];
	                            for (var name in that) {
	                                // Only display valid names in the form val_xxxxxx that are not redundant connectors
	                                if (that.hasOwnProperty(name) && RX_VALID_NAME.test(name) && !redundantConnectors.hasOwnProperty(name)) {
	                                    var testItem = that.get(name);
	                                    var scoreItem = testItem.toJSON();
	                                    // Improved display of values in score grids
	                                    scoreItem.value = testItem.value$();
	                                    scoreItem.solution = testItem.solution$();
	                                    // Aggregate score of redundant items (connectors)
	                                    var redundantName = matchingConnectors[name];
	                                    if (that.hasOwnProperty(redundantName) && RX_VALID_NAME.test(redundantName)) {
	                                        // If there is a redundancy, adjust scores
	                                        var redundantItem = that.get(redundantName);
	                                        scoreItem.failure += redundantItem.failure;
	                                        scoreItem.omit += redundantItem.omit;
	                                        scoreItem.score += redundantItem.score;
	                                        scoreItem.success += redundantItem.success;
	                                        redundantConnectors[redundantName] = true;
	                                    }
	                                    scoreArray.push(scoreItem);
	                                }
	                            }
	                            return scoreArray;
	                        },
	                        toJSON: function () {
	                            var json = {};
	                            assert.instanceof(kendo.data.ObservableObject, this, kendo.format(assert.messages.instanceof.default, 'this', 'kendo.data.ObservableObject'));
	                            for (var name in this) {
	                                if (this.hasOwnProperty(name)) {
	                                    if (RX_VALID_NAME.test(name)) {
	                                        json[name] = {
	                                            result: this.get(name + '.result'),
	                                            score: this.get(name + '.score'),
	                                            value: this.get(name + '.value')
	                                        };
	                                    } else if (name === 'connections' || name === 'draggables') {
	                                        json[name] = this.get(name).slice();
	                                    }
	                                }
	                            }
	                            return json;
	                        }
	                    };
	
	                // Flatten test for validation formulas
	                var all = test.toJSON();
	                delete all.connections;
	                delete all.draggables;
	                for (var prop in all) {
	                    if (all.hasOwnProperty(prop) && $.type(all[prop]) === OBJECT) {
	                        if (all[prop].value === null) {
	                            // tools built upon kendo ui widgets cannot have undefined values because value(undefined) === value() so they use null
	                            all[prop] = undefined; // TODO use undefined or null? we should probably use null for unanswered tests
	                        } else {
	                            all[prop] = all[prop].value;
	                        }
	                    }
	                }
	
	                // TODO we might even consider storing workerLib in session storage considering https://addyosmani.com/basket.js/
	                var app = window.app;
	                $.ajax({ url: (app && app.uris && app.uris.webapp && app.uris.webapp.workerlib) || workerLibPath, cache: true, dataType: 'text' })
	                    .done(function (workerLib) {
	
	                        // Add tasks to the worker pool
	                        // Iterate through pages
	                        $.each(pageCollectionDataSource.data(), function (pageIdx, page) {
	                            // Iterate through page components
	                            $.each(page.components.data(), function (componentIdx, component) {
	
	                                // List component properties
	                                var properties = component.properties;
	                                assert.instanceof(kendo.data.Model, properties, kendo.format(assert.messages.instanceof.default, 'properties', 'kendo.data.Model'));
	                                assert.type(OBJECT, properties.fields, kendo.format(assert.messages.type.default, 'properties.fields', OBJECT));
	
	                                // If our component has a name property to record the result of a test interaction
	                                // Note: some components like textboxes have properties, others likes labels and images don't
	                                // assert.type(STRING, properties.name, kendo.format(assert.messages.type.default, 'properties.name', STRING));
	                                if ($.type(properties.name) === STRING) {
	                                    var found;
	                                    var libraryMatches = properties.validation.match(/^\/\/ ([^\n]+)$/);
	                                    // var customMatches = value.match(/^function[\s]+validate[\s]*\([\s]*value[\s]*,[\s]*solution[\s]*(,[\s]*all[\s]*)?\)[\s]*\{[\s\S]*\}$/);
	                                    if ($.isArray(libraryMatches) && libraryMatches.length === 2) {
	                                        // Find in the code library
	                                        found = properties._library.filter(function (item) {
	                                            return item.name === libraryMatches[1];
	                                        });
	                                        assert.ok($.isArray(found) && found.length, 'properties.validation cannot be found in code library');
	                                    }
	                                    var code = $.isArray(found) ? found[0].formula : properties.validation;
	
	                                    // Note: when e.data.value is undefined, we need to specifically call postMessage(undefined) instead of postMessage() otherwise we get the following error:
	                                    // Uncaught TypeError: Failed to execute 'postMessage' on 'DedicatedWorkerGlobalScope': 1 argument required, but only 0 present.
	                                    var blob = new Blob([
	                                        // 'self.importScripts("' + workerLibPath + '");\n' +
	                                        workerLib + ';\n' +
	                                        'self.onmessage = function (e) {\n' + code + '\nvar data=JSON.parse(e.data);\nif (typeof data.value === "undefined") { self.postMessage(undefined); } else { self.postMessage(validate(data.value, data.solution, data.all)); } self.close(); };'
	                                    ]);
	                                    var blobURL = window.URL.createObjectURL(blob);
	
	                                    // Queue task into worker pool with name, script, and value to be posted to script
	                                    workerPool.add(
	                                        properties.name,
	                                        blobURL,
	                                        {
	                                            value: all[properties.name],
	                                            solution: properties.solution,
	                                            all: all // all properties
	                                        }
	                                    );
	
	                                    // Update result
	                                    result[properties.name] = {
	                                        page: pageIdx,
	                                        name: properties.name,
	                                        description: properties.description,
	                                        value: test[properties.name].value,
	                                        solution: properties.solution,
	                                        result: undefined,
	                                        omit: properties.omit,
	                                        failure: properties.failure,
	                                        success: properties.success,
	                                        // Functions used by getScoreArray for improved display in score grid
	                                        value$: function () {
	                                            assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'PageComponent'));
	                                            assert.instanceof(kendo.Observable, kidoju.tools, kendo.format(assert.messages.instanceof.default, 'kidoju.tools', 'kendo.Observable'));
	                                            var tool = kidoju.tools[component.tool];
	                                            assert.instanceof(kidoju.Tool, tool, kendo.format(assert.messages.instanceof.default, 'tool', 'kidoju.Tool'));
	                                            return tool.value$(test[properties.name].value);
	                                        },
	                                        solution$: function () {
	                                            assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'PageComponent'));
	                                            assert.instanceof(kendo.Observable, kidoju.tools, kendo.format(assert.messages.instanceof.default, 'kidoju.tools', 'kendo.Observable'));
	                                            var tool = kidoju.tools[component.tool];
	                                            assert.instanceof(kidoju.Tool, tool, kendo.format(assert.messages.instanceof.default, 'tool', 'kidoju.Tool'));
	                                            return tool.solution$(properties.solution);
	                                        }
	                                    };
	
	                                    logger.debug({ message: properties.name + ' added to the worker pool', data: blobURL });
	                                }
	                            });
	                        });
	
	                        // Run the worker pool
	                        workerPool.run()
	                            .done(function () {
	                                // iterate through recorded answer validations (arguments)
	                                // for each named value
	                                $.each(arguments, function (index, argument) {
	                                    // store the result which is success, failure or omitted (undefined)
	                                    result[argument.name].result = argument.value;
	                                    // store the score depending on the result
	                                    switch (argument.value) {
	                                        case true: // success
	                                            if (result[argument.name] && $.type(result[argument.name].success) === NUMBER) {
	                                                result[argument.name].score = result[argument.name].success;
	                                            }
	                                            break;
	                                        case false: // failure
	                                            if (result[argument.name] && $.type(result[argument.name].failure) === NUMBER) {
	                                                result[argument.name].score = result[argument.name].failure;
	                                            }
	                                            break;
	                                        default: // undefined (omitted)
	                                            if (result[argument.name] && $.type(result[argument.name].omit) === NUMBER) {
	                                                result[argument.name].score = result[argument.name].omit;
	                                            }
	                                            break;
	                                    }
	                                    // calculate the total test score
	                                    // result.score += result[argument.name].score;
	                                    // calculate the max possible score in order to calculate a percentage
	                                    // if (result[argument.name] && result[argument.name].success) {
	                                    //    result.max += result[argument.name].success;
	                                    // }
	                                });
	                                deferred.resolve(result);
	                            })
	                            .fail(deferred.reject);
	
	                    })
	                    .fail(deferred.reject);
	
	                // return the test result
	                return deferred.promise();
	            }
	        });
	
	        /**
	         * @method create
	         * @param options
	         */
	        PageCollectionDataSource.create = function (options) {
	            options = options && options.push ? { data: options } : options;
	
	            var dataSource = options || {};
	            var data = dataSource.data;
	
	            dataSource.data = data;
	
	            if (!(dataSource instanceof PageCollectionDataSource) && dataSource instanceof kendo.data.DataSource) {
	                throw new Error('Incorrect DataSource type. Only PageCollectionDataSource instances are supported');
	            }
	
	            return dataSource instanceof PageCollectionDataSource ? dataSource : new PageCollectionDataSource(dataSource);
	        };
	
	        /*********************************************************************************
	         * Stream
	         *********************************************************************************/
	
	        /**
	         * A stream is essentially a collection of pages
	         * @class Stream
	         */
	        var Stream = models.Stream = Model.define({
	            fields: {
	                /**
	                 * pages
	                 */
	                pages: {
	                    // We cannot assign a data source as default value of a model
	                    // because otherwise it might be reused amongst instances.
	                    // The only way to ensure that a new instance gets a new default value is to initialize with []
	                    // and have kidoju.data.Model._parseData initialize the instance data source from [].
	                    // defaultValue: new kidoju.data.PageCollectionDataSource({ data: [] }),
	                    defaultValue: [],
	                    parse: function (value) {
	                        if (value instanceof PageCollectionDataSource) {
	                            return value;
	                        } else if (value && value.push) {
	                            return new PageCollectionDataSource({ data: value });
	                        } else {
	                            return new PageCollectionDataSource(value);
	                        }
	                    }
	                }
	            },
	
	            /**
	             * Constructor
	             * @constructor
	             * @param value
	             */
	            init: function (value) {
	                var that = this;
	
	                // Call the base init method
	                Model.fn.init.call(that, value);
	
	                if (that.model && that.model.pages) {
	                    // Reset PageCollectionDataSource with model.pages dataSource options
	                    that.pages = new PageCollectionDataSource(that.model.pages);
	                }
	
	                var pages = that.pages;
	
	                /*
	                var transport = pages.transport,
	                    parameterMap = transport.parameterMap;
	                transport.parameterMap = function (data, type) {
	                    data[that.idField || 'id'] = that.id;
	                    if (parameterMap) {
	                        data = parameterMap(data, type);
	                    }
	                    return data;
	                };
	                */
	
	                if (pages instanceof PageCollectionDataSource) {
	
	                    // Add parent() function
	                    that.pages.parent = function () {
	                        return that;
	                    };
	
	                    // Note: this is where kendo.data.Node bind the change and error events
	                    // to propagate them from the pages collection to the stream node or a parent collection
	
	                }
	
	                that._loaded = !!(value && (value.pages || value._loaded));
	            },
	
	            /**
	             * Append a page
	             * @param model
	             */
	            append: function (page) {
	                this.loaded(true);
	                this.pages.add(page);
	            },
	
	            /**
	             * Load pages
	             * @returns {*}
	             */
	            load: function () {
	                var options = {};
	                var method = '_query';
	                var pages = this.pages;
	                // Passing the id of the page to the components _query method
	                // is suggested by kendo.data.Node
	                options[this.idField || 'id'] = this.id;
	                if (!this._loaded) {
	                    pages._data = undefined;
	                    method = 'read';
	                }
	                pages.one(CHANGE, $.proxy(function () { this.loaded(true); }, this));
	                return pages[method](options);
	            },
	
	            /**
	             * Gets or sets loaded value
	             * @param value
	             * @returns {boolean|*}
	             */
	            loaded: function (value) {
	                if (value !== undefined) {
	                    this._loaded = value;
	                } else {
	                    return this._loaded;
	                }
	            },
	
	            /**
	             * i18n Messages
	             */
	            messages: {
	                duplicateNames: 'Delete components using the same name `{0}` on pages {1}',
	                minPages: 'At least {0} pages are required to be allowed to publish.',
	                minQuestions: 'At least {0} questions are required to be allowed to publish.',
	                typeVariety: 'The use of at least {0} types of questions (Multiple Choice, TextBox, Connector or else) is recommended.',
	                qtyVariety: 'More variety is recommended because {0:p0} of questions are of type {1}.'
	            },
	
	            /* Blocks are nested too deeply. */
	            /* jshint -W073 */
	
	            /* This function's cyclomatic complexity is too high. */
	            /* jshint -W074 */
	
	            /**
	             * Stream validation
	             */
	            validate: function () {
	                /* jshint maxcomplexity: 20 */
	                assert.instanceof (Stream, this, kendo.format(assert.messages.instanceof.default, 'this', 'kidoju.data.Stream'));
	                var ret = [];
	                var names = {};
	                var values = { _total: 0, _weight: 0 };
	                // Minimum number of pages
	                // var MIN_PAGES = 5;
	                // var pageTotal = this.pages.total();
	                // if (pageTotal < MIN_PAGES) {
	                //    ret.push({ type: ERROR, index: -1, message: kendo.format(this.messages.minPages, MIN_PAGES) });
	                // }
	                // for (var i = 0; i < pageTotal; i++) {
	                for (var i = 0, pageTotal = this.pages.total(); i < pageTotal; i++) {
	                    var page = this.pages.at(i);
	                    var hasConnectors = false;
	                    // Count names and questions
	                    for (var j = 0, componentTotal = page.components.total(); j < componentTotal; j++) {
	                        var component = page.components.at(j);
	                        var properties = component.properties;
	                        if (properties) {
	                            if ($.type(properties.name) === STRING) {
	                                // Collect all pages where a name can be found in view to check that each name is only used once
	                                names[properties.name] = (names[properties.name] || []).push(i);
	                            }
	                            if ($.type(properties.validation) === STRING) {
	                                assert.type(STRING, component.tool, kendo.format(assert.messages.type.default, 'component.tool', STRING));
	                                var tool = component.tool;
	                                if (tool !== 'connector' || !hasConnectors) {
	                                    hasConnectors = (tool === 'connector');
	                                    // Connectors go in pairs but it would not make sense to only have 2 connectors or less on a page, you need at least 4 to make a question
	                                    // Accordingly, we count connectors only once per page
	                                    values._total += 1;
	                                    values[tool] = (values[tool] || 0) + 1;
	                                }
	                                values._weight += kidoju.tools[tool].weight;
	                            }
	                        }
	                    }
	                    // Validate each page
	                    ret = ret.concat(page.validate(i));
	                }
	                // Duplicate names
	                for (var name in names) {
	                    if (names.hasOwnProperty(name)) {
	                        var pages = names[name];
	                        if ($.isArray(pages) && pages.length > 1) {
	                            var index = pages[0];
	                            // page numbers start at 1 when page indexes start at 0
	                            pages = pages.map(function (idx) { return idx + 1; });
	                            ret.push({ type: ERROR, index: index, message: kendo.format(this.messages.duplicateNames, name, pages) });
	                        }
	                    }
	                }
	                // Minimum number of questions (minimum weight)
	                var MIN_WEIGHT = 8;
	                if (values._weight < MIN_WEIGHT) {
	                    ret.push({ type: ERROR, index: -1, message: kendo.format(this.messages.minQuestions, MIN_WEIGHT) });
	                }
	                // Validate toolset (which includes _total) to make sure questions are varied
	                // var TYPE_VARIETY = 3;
	                // if (Object.keys(questions).length <= TYPE_VARIETY) {
	                //     ret.push({ type: WARNING, index: -1, message: kendo.format(this.messages.typeVariety, TYPE_VARIETY) });
	                // }
	                var QTY_VARIETY = 0.5;
	                for (var prop in values) {
	                    if (values.hasOwnProperty(prop) && prop !== '_total' && prop !== '_weight') {
	                        var proportion =  values[prop] / values._total;
	                        if (proportion >= QTY_VARIETY) {
	                            assert.instanceof(kendo.Observable, kidoju.tools, kendo.format(assert.messages.instanceof.default, 'kidoju.tools', 'kendo.Observable'));
	                            ret.push({ type: WARNING, index: -1, message: kendo.format(this.messages.qtyVariety, proportion, kidoju.tools[prop].description) });
	                        }
	                    }
	                }
	                return ret;
	            }
	
	            /* jshint +W074 */
	            /* jshint +W073 */
	
	        });
	
	
	    }(window.jQuery));
	
	    /* jshint +W071 */
	
	    return window.kidoju;
	
	}, __webpack_require__(200));


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        // './vendor/kendo/kendo.binder',
	        // './vendor/kendo/kendo.dialog',
	        // './vendor/kendo/kendo.spreadsheet',
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(233)
	        // Note: The player does not need the assetmanager, the codeeditor and the styleeditor
	        // './kidoju.widgets.assetmanager',
	        // './kidoju.widgets.chargrid',
	        // './kidoju.widgets.codeeditor',
	        // './kidoju.widgets.codeinput',
	        // './kidoju.widgets.connector',
	        // './kidoju.widgets.dropzone',
	        // './kidoju.widgets.mathexpression',
	        // './kidoju.widgets.mediaplayer',
	        // './kidoju.widgets.propertygrid',
	        // './kidoju.widgets.quiz',
	        // './kidoju.widgets.stage', !IMPORTANT: Stage needs to be loaded after tools
	        // './kidoju.widgets.styleeditor'
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    /* This function has too many statements. */
	    /* jshint -W071 */
	
	    (function ($, undefined) {
	
	        var kendo = window.kendo;
	        var kidoju = window.kidoju = window.kidoju || {};
	        var Model = kidoju.data.Model;
	        var ObservableArray = kendo.data.ObservableArray;
	        var PageComponent = kidoju.data.PageComponent;
	        var Page = kidoju.data.Page;
	        var assert = window.assert;
	        var logger = new window.Logger('kidoju.tools');
	        var OBJECT = 'object';
	        var ARRAY = 'array';
	        var STRING = 'string';
	        var NUMBER = 'number';
	        var BOOLEAN = 'boolean';
	        var DATE = 'date';
	        var ERROR = 'error';
	        var WARNING = 'warning';
	        var CURSOR_DEFAULT = 'default';
	        var CURSOR_CROSSHAIR = 'crosshair';
	        var REGISTER = 'register';
	        var ACTIVE = 'active';
	        var POINTER = 'pointer';
	        var ELEMENT_CLASS = '.kj-element';
	        var DIALOG_DIV = '<div {0}"></div>';
	        var DIALOG_SELECTOR = '.kj-dialog';
	        var NO_PADDING_CLASS = 'no-padding';
	        var CLICK = 'click';
	        var RX_HTTP_S = /^https?:\/\//;
	        var RX_FONT_SIZE = /font(-size)?:[^;]*[0-9]+px/;
	        var RX_AUDIO = /^(cdn|data):\/\/[\s\S]+.mp3$/i;
	        var RX_COLOR = /^#[0-9a-f]{6}$/i;
	        var RX_DATA = /\S+/i;
	        var RX_DESCRIPTION = /\S+/i; // question
	        var RX_DROPVALUE = /\S+/i;
	        var RX_FORMULA = /\S+/i;
	        var RX_IMAGE = /^(cdn|data):\/\/[\s\S]+.(gif|jpe?g|png|svg)$/i;
	        var RX_STYLE = /^(([\w-]+)\s*:([^;<>]+);\s*)+$/i;
	        var RX_SOLUTION = /\S+/i;
	        var RX_TEXT = /\S+/i;
	        var RX_VALIDATION = /\S+/i;
	        var RX_VIDEO = /^(cdn|data):\/\/[\s\S]+.mp4$/i;
	        var FORMULA = 'function validate(value, solution, all) {\n\t{0}\n}';
	        var JS_COMMENT = '// ';
	        var CUSTOM = {
	            name: 'custom',
	            formula: kendo.format(FORMULA, '// Your code should return true when value is validated against solution.')
	        };
	        var util = {};
	
	        /*********************************************************************************
	         * Helpers
	         *********************************************************************************/
	
	        /**
	         * Incors images for corrections
	         */
	        // Incors O-Collection check.svg
	        // var SVG_SUCCESS = '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" width="1024px" height="1024px" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="nonzero" clip-rule="evenodd" viewBox="0 0 10240 10240" xmlns:xlink="http://www.w3.org/1999/xlink"><path id="curve0" fill="#76A797" d="M3840 5760l3934 -3934c124,-124 328,-124 452,0l1148 1148c124,124 124,328 0,452l-5308 5308c-124,124 -328,124 -452,0l-2748 -2748c-124,-124 -124,-328 0,-452l1148 -1148c124,-124 328,-124 452,0l1374 1374z"/></svg>';
	        var SVG_SUCCESS = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWw6c3BhY2U9InByZXNlcnZlIiB3aWR0aD0iMTAyNHB4IiBoZWlnaHQ9IjEwMjRweCIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHRleHQtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIGltYWdlLXJlbmRlcmluZz0ib3B0aW1pemVRdWFsaXR5IiBmaWxsLXJ1bGU9Im5vbnplcm8iIGNsaXAtcnVsZT0iZXZlbm9kZCIgdmlld0JveD0iMCAwIDEwMjQwIDEwMjQwIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHBhdGggaWQ9ImN1cnZlMCIgZmlsbD0iIzc2QTc5NyIgZD0iTTM4NDAgNTc2MGwzOTM0IC0zOTM0YzEyNCwtMTI0IDMyOCwtMTI0IDQ1MiwwbDExNDggMTE0OGMxMjQsMTI0IDEyNCwzMjggMCw0NTJsLTUzMDggNTMwOGMtMTI0LDEyNCAtMzI4LDEyNCAtNDUyLDBsLTI3NDggLTI3NDhjLTEyNCwtMTI0IC0xMjQsLTMyOCAwLC00NTJsMTE0OCAtMTE0OGMxMjQsLTEyNCAzMjgsLTEyNCA0NTIsMGwxMzc0IDEzNzR6Ii8+PC9zdmc+';
	        // Incors O-Collection delete.svg
	        // var SVG_FAILURE = '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" width="1024px" height="1024px" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="nonzero" clip-rule="evenodd" viewBox="0 0 10240 10240" xmlns:xlink="http://www.w3.org/1999/xlink"><path id="curve0" fill="#E68497" d="M1273 7156l2037 -2036 -2037 -2036c-124,-125 -124,-328 0,-453l1358 -1358c125,-124 328,-124 453,0l2036 2037 2036 -2037c125,-124 328,-124 453,0l1358 1358c124,125 124,328 0,453l-2037 2036 2037 2036c124,125 124,328 0,453l-1358 1358c-125,124 -328,124 -453,0l-2036 -2037 -2036 2037c-125,124 -328,124 -453,0l-1358 -1358c-124,-125 -124,-328 0,-453z"/></svg>';
	        var SVG_FAILURE = 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWw6c3BhY2U9InByZXNlcnZlIiB3aWR0aD0iMTAyNHB4IiBoZWlnaHQ9IjEwMjRweCIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHRleHQtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIGltYWdlLXJlbmRlcmluZz0ib3B0aW1pemVRdWFsaXR5IiBmaWxsLXJ1bGU9Im5vbnplcm8iIGNsaXAtcnVsZT0iZXZlbm9kZCIgdmlld0JveD0iMCAwIDEwMjQwIDEwMjQwIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHBhdGggaWQ9ImN1cnZlMCIgZmlsbD0iI0U2ODQ5NyIgZD0iTTEyNzMgNzE1NmwyMDM3IC0yMDM2IC0yMDM3IC0yMDM2Yy0xMjQsLTEyNSAtMTI0LC0zMjggMCwtNDUzbDEzNTggLTEzNThjMTI1LC0xMjQgMzI4LC0xMjQgNDUzLDBsMjAzNiAyMDM3IDIwMzYgLTIwMzdjMTI1LC0xMjQgMzI4LC0xMjQgNDUzLDBsMTM1OCAxMzU4YzEyNCwxMjUgMTI0LDMyOCAwLDQ1M2wtMjAzNyAyMDM2IDIwMzcgMjAzNmMxMjQsMTI1IDEyNCwzMjggMCw0NTNsLTEzNTggMTM1OGMtMTI1LDEyNCAtMzI4LDEyNCAtNDUzLDBsLTIwMzYgLTIwMzcgLTIwMzYgMjAzN2MtMTI1LDEyNCAtMzI4LDEyNCAtNDUzLDBsLTEzNTggLTEzNThjLTEyNCwtMTI1IC0xMjQsLTMyOCAwLC00NTN6Ii8+PC9zdmc+';
	
	        /**
	         * All i18n messages
	         */
	        var i18n = {
	
	            tool: {
	                top: { title: 'Top' },
	                left: { title: 'Left' },
	                height: { title: 'Height' },
	                width: { title: 'Width' },
	                rotate: { title: 'Rotate' }
	            },
	
	            dialogs: {
	                ok: { text: '<img alt="icon" src="https://cdn.kidoju.com/images/o_collection/svg/office/ok.svg" class="k-image">OK' },
	                cancel: { text: '<img alt="icon" src="https://cdn.kidoju.com/images/o_collection/svg/office/close.svg" class="k-image">Cancel' }
	            },
	
	            messages: {
	                invalidAltText: 'A(n) {0} on page {1} requires some alternate text in display attributes.',
	                invalidAudioFile: 'A(n) {0} on page {1} requires an mp3 file in display attributes.',
	                invalidColor: 'A(n) {0} on page {1} has an invalid color in display attributes.',
	                invalidData: 'A(n) {0} on page {1} requires values in display attributes.',
	                invalidDescription: 'A(n) {0} named `{1}` on page {2} requires a question in test logic.',
	                invalidDropValue: 'A(n) {0} on page {1} requires a drop value in test logic.',
	                invalidFailure: 'A(n) {0} named `{1}` on page {2} has a failure score higher than the omit score or zero in test logic.',
	                invalidFormula: 'A(n) {0} on page {1} requires a formula in display attributes.',
	                invalidImageFile: 'A(n) {0} on page {1} requires an image file in display attributes.',
	                invalidSolution: 'A(n) {0} named `{1}` on page {2} requires a solution in test logic.',
	                invalidStyle: 'A(n) {0} on page {1} has an invalid style in display attributes.',
	                invalidSuccess: 'A(n) {0} named `{1}` on page {2} has a success score lower than the omit score or zero in test logic.',
	                invalidText: 'A(n) {0} on page {1} requires some text in display attributes.',
	                invalidValidation: 'A(n) {0} named `{1}` on page {2} requires a validation formula in test logic.',
	                invalidVideoFile: 'A(n) {0} on page {1} requires an mp4 file in display attributes.'
	            },
	
	            pointer: {
	                description: 'Pointer'
	            },
	
	            audio: {
	                description: 'Audio Player',
	                attributes: {
	                    autoplay: { title: 'Autoplay' },
	                    mp3: { title: 'MP3 File' },
	                    ogg: { title: 'OGG File' }
	                }
	            },
	
	            chart: {
	                description: 'Chart',
	                attributes: {
	                    type: { title: 'Type' },
	                    title: { title: 'Title' },
	                    categories: { title: 'Categories' },
	                    values: { title: 'Values' },
	                    legend: { title: 'Legend' },
	                    data: { title: 'Data' },
	                    style: { title: 'Style' }
	                }
	            },
	
	            chargrid: {
	                description: 'Character Grid',
	                attributes: {
	                    blank: { title: 'Blank' },
	                    columns: { title: 'Columns' },
	                    layout: { title: 'Layout' },
	                    rows: { title: 'Rows' },
	                    whitelist: { title: 'Whitelist' },
	                    gridFill: { title: 'Grid Fill' },
	                    gridStroke: { title: 'Grid Stroke' },
	                    // blankFill = gridStroke
	                    selectedFill: { title: 'Selection Fill' },
	                    lockedFill: { title: 'Locked Fill' },
	                    // lockedColor = valueColor = fontColor
	                    fontColor: { title: 'Font Color' }
	                },
	                properties: {
	                    name: { title: 'Name' },
	                    description: { title: 'Question' },
	                    solution: { title: 'Solution' },
	                    validation: { title: 'Validation' },
	                    success: { title: 'Success' },
	                    failure: { title: 'Failure' },
	                    omit: { title: 'Omit' }
	                }
	            },
	
	            chargridadapter: {
	                messages: {
	                    layout: '<h3>Design the grid layout</h3><p>Any character you enter in the grid is locked and cannot be changed in play mode.</p><p>Use `{0}` to blank out cells.</p>',
	                    solution: '<h3>Enter the solution</h3><p>Use any whitelisted character, i.e. `{0}`.</p>'
	                }
	            },
	
	            checkbox: {
	                description: 'CheckBox',
	                attributes: {
	                    data: { title: 'Values', defaultValue: 'Option 1\nOption 2' },
	                    groupStyle: { title: 'Group Style' },
	                    itemStyle: { title: 'Item Style' },
	                    selectedStyle: { title: 'Select. Style' }
	                },
	                properties: {
	                    name: { title: 'Name' },
	                    description: { title: 'Question' },
	                    solution: { title: 'Solution' },
	                    validation: { title: 'Validation' },
	                    success: { title: 'Success' },
	                    failure: { title: 'Failure' },
	                    omit: { title: 'Omit' }
	                }
	            },
	
	            connector: {
	                description: 'Connector',
	                attributes: {
	                    color: { title: 'Color' }
	                },
	                properties: {
	                    name: { title: 'Name' },
	                    description: { title: 'Question' },
	                    solution: { title: 'Solution' },
	                    validation: { title: 'Validation' },
	                    success: { title: 'Success' },
	                    failure: { title: 'Failure' },
	                    omit: { title: 'Omit' }
	                }
	            },
	
	            dropzone: {
	                description: 'Drop Zone',
	                attributes: {
	                    style: { title: 'Style' },
	                    text: { title: 'Text', defaultValue: 'Please drop here.' }
	                },
	                properties: {
	                    name: { title: 'Name' },
	                    description: { title: 'Question' },
	                    solution: { title: 'Solution' },
	                    validation: { title: 'Validation' },
	                    success: { title: 'Success' },
	                    failure: { title: 'Failure' },
	                    omit: { title: 'Omit' }
	                }
	            },
	
	            image: {
	                description: 'Image',
	                attributes: {
	                    alt: { title: 'Text', defaultValue: 'Image' },
	                    src: { title: 'Source', defaultValue: 'cdn://images/o_collection/svg/office/painting_landscape.svg' },
	                    style: { title: 'Style' }
	                },
	                properties: {
	                    draggable: { title: 'Draggable' },
	                    dropValue: { title: 'Value' }
	                }
	            },
	
	            label: {
	                description: 'Label',
	                attributes: {
	                    style: { title: 'Style' },
	                    text: { title: 'Text', defaultValue: 'Label' }
	                },
	                properties: {
	                    draggable: { title: 'Draggable' },
	                    dropValue: { title: 'Value' }
	                }
	            },
	
	            mathexpression: {
	                description: 'Mathematic Expression',
	                attributes: {
	                    formula: { title: 'Formula', defaultValue: '#sum_(i=1)^n i^3=((n(n+1))/2)^2#' },
	                    style: { title: 'Style' }
	                }
	            },
	
	            quiz: {
	                description: 'Quiz',
	                attributes: {
	                    data: { title: 'Values', defaultValue: 'True\nFalse' },
	                    groupStyle: { title: 'Group Style' },
	                    itemStyle: { title: 'Item Style' },
	                    mode: { title: 'Mode' },
	                    selectedStyle: { title: 'Select. Style' }
	                },
	                properties: {
	                    name: { title: 'Name' },
	                    description: { title: 'Question' },
	                    solution: { title: 'Solution' },
	                    validation: { title: 'Validation' },
	                    success: { title: 'Success' },
	                    failure: { title: 'Failure' },
	                    omit: { title: 'Omit' }
	                }
	            },
	
	            table: {
	                description: 'Static Table',
	                attributes: {
	                    columns: { title: 'Columns' },
	                    rows: { title: 'Rows' },
	                    data: { title: 'Data' }
	                }
	            },
	
	            textarea: {
	                description: 'TextArea',
	                attributes: {
	                    style: { title: 'Style' }
	                },
	                properties: {
	                    name: { title: 'Name' },
	                    description: { title: 'Question' },
	                    solution: { title: 'Solution' },
	                    validation: { title: 'Validation' },
	                    success: { title: 'Success' },
	                    failure: { title: 'Failure' },
	                    omit: { title: 'Omit' }
	                }
	            },
	
	            textbox: {
	                description: 'TextBox',
	                attributes: {
	                    mask: { title: 'Mask' },
	                    style: { title: 'Style' }
	                },
	                properties: {
	                    name: { title: 'Name' },
	                    description: { title: 'Question' },
	                    solution: { title: 'Solution' },
	                    validation: { title: 'Validation' },
	                    success: { title: 'Success' },
	                    failure: { title: 'Failure' },
	                    omit: { title: 'Omit' }
	                }
	            },
	
	            video: {
	                description: 'Video Player',
	                attributes: {
	                    autoplay: { title: 'Autoplay' },
	                    toolbarHeight: { title: 'Toolbar Height' },
	                    mp4: { title: 'MP4 File' },
	                    ogv: { title: 'OGV File' },
	                    wbem: { title: 'WBEM File' }
	                }
	            }
	
	        };
	
	        /**
	         * Build a random hex string of length characters
	         * @param length
	         * @returns {string}
	         */
	        function randomString(length) {
	            var s = new Array(length + 1).join('x');
	            return s.replace(/x/g, function (c) {
	                /* jshint -W016 */
	                return (Math.random() * 16|0).toString(16);
	                /* jshint +W016 */
	            });
	        }
	
	        /*********************************************************************************
	         * Assets
	         *********************************************************************************/
	
	        var ToolAssets = kidoju.ToolAssets = kendo.Class.extend({
	            init: function (options) {
	                options = options || {};
	                var collections = options.collections || [];
	                var extensions = options.extensions || [];
	                var schemes = options.schemes || {};
	                var transport = options.transport || {};
	                assert.type(ARRAY, collections, kendo.format(assert.messages.type.default, 'options.collections', ARRAY));
	                assert.type(ARRAY, extensions, kendo.format(assert.messages.type.default, 'options.extensions', ARRAY));
	                assert.type(OBJECT, schemes, kendo.format(assert.messages.type.default, 'options.schemes', OBJECT));
	                assert.type(OBJECT, transport, kendo.format(assert.messages.type.default, 'options.transport', OBJECT));
	                this.collections = collections;
	                this.extensions = extensions;
	                this.schemes = schemes;
	                this.transport = transport;
	            }
	        });
	
	        var assets = kidoju.assets = {
	            // Assets for the audio tool
	            audio : new ToolAssets(),
	            // Assets for the image tool
	            image: new ToolAssets(),
	            // Assets for the video tool
	            video: new ToolAssets()
	        };
	
	        /*********************************************************************************
	         * Generic tools
	         *********************************************************************************/
	
	        /**
	         * Registry of tools
	         * @type {{register: Function}}
	         */
	        var tools = kidoju.tools = kendo.observable({
	            active: null,
	            register: function (Class) {
	                assert.type(OBJECT, Class.prototype, kendo.format(assert.messages.type.default, 'Class.prototype', OBJECT));
	                var obj = new Class();
	                assert.instanceof(Tool, obj, kendo.format(assert.messages.instanceof.default, 'obj', 'kidoju.Tool'));
	                assert.type(STRING, obj.id, kendo.format(assert.messages.type.default, 'obj.id', STRING));
	                obj.id = obj.id.trim();
	                assert.ok(obj.id.length > 0, 'A tool cannot have an empty id');
	                assert.ok(obj.id !== ACTIVE && obj.id !== REGISTER, 'A tool cannot have `active` or `register` for id');
	                assert.isUndefined(this[obj.id], 'Existing tools cannot be replaced');
	                this[obj.id] = obj;
	                if (obj.id === POINTER) {
	                    this.active = POINTER;
	                }
	            }
	        });
	
	        /**
	         * @class kidoju.Tool
	         * @type {void|*}
	         */
	        var Tool = kidoju.Tool = kendo.Class.extend({
	            id: null,
	            icon: null,
	            description: null,
	            cursor: null,
	            weight: 0,
	            height: 250,
	            width: 250,
	            attributes: {},
	            properties: {},
	            svg: {
	                success: SVG_SUCCESS,
	                failure: SVG_FAILURE
	            },
	            i18n: {
	                // They are here to be translated in kidoju.messages.[locale].js
	                tool: {
	                    top: { title: i18n.tool.top.title },
	                    left: { title: i18n.tool.left.title },
	                    height: { title: i18n.tool.height.title },
	                    width: { title: i18n.tool.width.title },
	                    rotate: { title: i18n.tool.rotate.title }
	                },
	                dialogs: {
	                    ok: { text: i18n.dialogs.ok.text },
	                    cancel: { text: i18n.dialogs.cancel.text }
	                },
	                messages: {
	                    invalidAltText: i18n.messages.invalidAltText,
	                    invalidAudioFile: i18n.messages.invalidAudioFile,
	                    invalidColor: i18n.messages.invalidColor,
	                    invalidData: i18n.messages.invalidData,
	                    invalidDescription: i18n.messages.invalidDescription,
	                    invalidDropValue: i18n.messages.invalidDropValue,
	                    invalidFailure: i18n.messages.invalidFailure,
	                    invalidFormula: i18n.messages.invalidFormula,
	                    invalidImageFile: i18n.messages.invalidImageFile,
	                    invalidSolution: i18n.messages.invalidSolution,
	                    invalidStyle: i18n.messages.invalidStyle,
	                    invalidSuccess: i18n.messages.invalidSuccess,
	                    invalidText: i18n.messages.invalidText,
	                    invalidValidation: i18n.messages.invalidValidation,
	                    invalidVideoFile: i18n.messages.invalidVideoFile
	                }
	            },
	
	            /**
	             * Constructor
	             * @class kidoju.Tool
	             * @constructor
	             * @param options
	             */
	            init: function (options) {
	
	                // Extend tool with init options
	                $.extend(this, options);
	
	                // Pass solution adapter library to validation adapter, especially for the code editor
	                if (this.properties && this.properties.solution instanceof BaseAdapter && this.properties.validation instanceof adapters.ValidationAdapter) {
	                    this.properties.validation.library = this.properties.solution.library;
	                    this.properties.validation.defaultValue = JS_COMMENT + this.properties.solution.libraryDefault;
	                }
	
	            },
	
	            /**
	             * Get a kidoju.data.Model for attributes
	             * @class kidoju.Tool
	             * @method _getAttributeModel
	             * @returns {kidoju.data.Model}
	             * @private
	             */
	            _getAttributeModel: function () {
	                var model = { fields: {} };
	                for (var attr in this.attributes) {
	                    if (this.attributes.hasOwnProperty(attr)) {
	                        if (this.attributes[attr] instanceof BaseAdapter) {
	                            model.fields[attr] = this.attributes[attr].getField();
	                        }
	                    }
	                }
	                return Model.define(model);
	            },
	
	            /**
	             * Gets property grid row specifications for attributes
	             * @class kidoju.Tool
	             * @method _getAttributeRows
	             * @returns {Array}
	             * @private
	             */
	            _getAttributeRows: function () {
	                var rows = [];
	
	                // Add top, left, height, width, rotation
	                rows.push(new adapters.NumberAdapter({ title: this.i18n.tool.top.title }, { 'data-decimals': 0, 'data-format': 'n0' }).getRow('top'));
	                rows.push(new adapters.NumberAdapter({ title: this.i18n.tool.left.title }, { 'data-decimals': 0, 'data-format': 'n0' }).getRow('left'));
	                rows.push(new adapters.NumberAdapter({ title: this.i18n.tool.height.title }, { 'data-decimals': 0, 'data-format': 'n0' }).getRow('height'));
	                rows.push(new adapters.NumberAdapter({ title: this.i18n.tool.width.title }, { 'data-decimals': 0, 'data-format': 'n0' }).getRow('width'));
	                rows.push(new adapters.NumberAdapter({ title: this.i18n.tool.rotate.title }, { 'data-decimals': 0, 'data-format': 'n0' }).getRow('rotate'));
	
	                // Add other attributes
	                for (var attr in this.attributes) {
	                    if (this.attributes.hasOwnProperty(attr)) {
	                        if (this.attributes[attr] instanceof BaseAdapter) {
	                            rows.push(this.attributes[attr].getRow('attributes.' + attr));
	                        }
	                    }
	                }
	                return rows;
	            },
	
	            /**
	             * Get a kidoju.data.Model for properties
	             * @class kidoju.Tool
	             * @method _getPropertyModel
	             * @returns {kidoju.data.Model}
	             * @private
	             */
	            _getPropertyModel: function () {
	                var properties = this.properties;
	                var model = { fields: {} };
	                for (var prop in properties) {
	                    if (properties.hasOwnProperty(prop)) {
	                        if (properties[prop] instanceof BaseAdapter) {
	                            model.fields[prop] = properties[prop].getField();
	                            if (prop === 'name') {
	                                // This cannot be set as a default value on the  adapter because each instance should have a different name
	                                model.fields.name.defaultValue = 'val_' + randomString(6);
	                            } else if (prop === 'validation') {
	                                // We need the code library otherwise we won't have code to execute when validation === '// equal' or any other library value
	                                model._library = properties.validation.library;
	                            }
	                        }
	                    }
	                }
	                return Model.define(model);
	            },
	
	            /**
	             * Gets property grid row specifications for properties
	             * @class kidoju.Tool
	             * @method _getPropertyRows
	             * @returns {Array}
	             * @private
	             */
	            _getPropertyRows: function () {
	                var rows = [];
	
	                for (var prop in this.properties) {
	                    if (this.properties.hasOwnProperty(prop)) {
	                        if (this.properties[prop] instanceof BaseAdapter) {
	                            rows.push(this.properties[prop].getRow('properties.' + prop));
	                        }
	                    }
	                }
	                return rows;
	            },
	
	            /**
	             * Get Html or jQuery content
	             * @class kidoju.Tool
	             * @method getHtmlContent
	             * @param component
	             * @param mode
	             * @returns {*}
	             */
	            getHtmlContent: function (component, mode) {
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                assert.enum(Object.keys(kendo.ui.Stage.fn.modes), mode, kendo.format(assert.messages.enum.default, 'mode', Object.keys(kendo.ui.Stage.fn.modes)));
	                var template = kendo.template(this.templates[mode] || this.templates.default);
	                return template($.extend(component, { ns: kendo.ns }));
	            },
	
	            /**
	             * Return the default value when playing the component as part of a test
	             * @param component
	             */
	            getTestDefaultValue: function (component) {
	                // TODO: consider removing as it seems useless
	                return;
	            },
	
	            /**
	             * Add the display of a success or failure icon to the corresponding stage element
	             * @returns {string}
	             */
	            showResult: function () {
	                // Contrary to https://css-tricks.com/probably-dont-base64-svg/, we need base64 encoded strings otherwise kendo templates fail
	                return '<div class=".kj-element-result">' +
	                    '<div data-#= ns #bind="visible: #: properties.name #.result" style="position: absolute; height: 92px; width:92px; bottom: -20px; right: -20px; background-image: url(data:image/svg+xml;base64,' + Tool.fn.svg.success + '); background-size: 92px 92px; background-repeat: no-repeat; width: 92px; height: 92px;"></div>' +
	                    '<div data-#= ns #bind="invisible: #: properties.name #.result" style="position: absolute; height: 92px; width:92px; bottom: -20px; right: -20px; background-image: url(data:image/svg+xml;base64,' + Tool.fn.svg.failure + '); background-size: 92px 92px; background-repeat: no-repeat; width: 92px; height: 92px;"></div>' +
	                    '</div>';
	            },
	
	            /**
	             * Improved display of value in score grid
	             * Note: search for getScoreArray in kidoju.data
	             * @param value
	             */
	            value$: function (value) {
	                return kendo.htmlEncode(value || '');
	            },
	
	            /**
	             * Improved display of solution in score grid
	             * Note: search for getScoreArray in kidoju.data
	             * @param solution
	             */
	            solution$: function (solution) {
	                return kendo.htmlEncode(solution || '');
	            },
	
	            // onEnable: function (e, component, enabled) {},
	            // onMove: function (e, component) {},
	            // onResize: function (e, component) {},
	            // onRotate: function (e, component) {},
	
	            /* This function's cyclomatic complexity is too high. */
	            /* jshint -W074 */
	
	            /**
	             * Component validation
	             * @param component
	             * @param pageIdx
	             */
	            validate: function (component, pageIdx) {
	                /* jshint maxcomplexity: 8 */
	                assert.instanceof (PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                assert.type(NUMBER, pageIdx, kendo.format(assert.messages.type.default, 'pageIdx', NUMBER));
	                var ret = [];
	                if (component.properties) {
	                    var properties = component.properties;
	                    var description = this.description; // tool description
	                    var messages = this.i18n.messages;
	                    var name = properties.name;
	                    // TODO: test name? note that all components do not necessarily have a name
	                    if (properties.draggable === true && !RX_DROPVALUE.test(properties.dropValue)) {
	                        ret.push({ type: ERROR, index: pageIdx, message: kendo.format(messages.invalidDropValue, description, /*name,*/ pageIdx + 1) });
	                    }
	                    if ($.type(properties.description) === STRING && !RX_DESCRIPTION.test(properties.description)) {
	                        ret.push({ type: ERROR, index: pageIdx, message: kendo.format(messages.invalidDescription, description, name, pageIdx + 1) });
	                    }
	                    if ($.type(properties.solution) === STRING && !RX_SOLUTION.test(properties.solution)) {
	                        // TODO: what if solution is not a string but a number or something else ?
	                        ret.push({ type: ERROR, index: pageIdx, message: kendo.format(messages.invalidSolution, description, name, pageIdx + 1) });
	                    }
	                    if ($.type(properties.validation) === STRING && !RX_VALIDATION.test(properties.validation)) {
	                        // TODO: There is room for better validation of the validation formula
	                        ret.push({ type: ERROR, index: pageIdx, message: kendo.format(messages.invalidValidation, description, name, pageIdx + 1) });
	                    }
	                    if ($.type(properties.failure) === NUMBER && $.type(properties.omit) === NUMBER && properties.failure > Math.min(properties.omit, 0)) {
	                        ret.push({ type: WARNING, index: pageIdx, message: kendo.format(messages.invalidFailure, description, name, pageIdx + 1) });
	                    }
	                    if ($.type(properties.success) === NUMBER && $.type(properties.omit) === NUMBER && properties.success < Math.max(properties.omit, 0)) {
	                        ret.push({ type: WARNING, index: pageIdx, message: kendo.format(messages.invalidSuccess, description, name, pageIdx + 1) });
	                    }
	                }
	                return ret;
	            }
	
	            /* jshint +W074 */
	
	        });
	
	        /*******************************************************************************************
	         * Adapter classes
	         * Used to display values in a property grid
	         *******************************************************************************************/
	        var adapters = kidoju.adapters = {};
	
	        /**
	         * Base (abstract) adapter
	         */
	        var BaseAdapter = adapters.BaseAdapter = kendo.Class.extend({
	
	            /**
	             * Data type: string, number, boolean or date
	             */
	            type: undefined,
	
	            /**
	             * Constructor
	             * @param options
	             */
	            init: function (options) {
	                options = options || {};
	                // this.value = options.value;
	
	                // See http://docs.telerik.com/kendo-ui/api/javascript/data/model#methods-Model.define
	                this.defaultValue = options.defaultValue;
	                this.editable = options.editable;
	                this.nullable = options.nullable;
	                this.parse = options.parse;
	                this.from = options.from;
	                this.validation = options.validation;
	
	                // See http://docs.telerik.com/kendo-ui/api/javascript/ui/grid#configuration-columns
	                this.field = options.field;
	                this.title = options.title;
	                this.format = options.format;
	                this.template = options.template;
	                this.editor = options.editor;
	                // TODO: HTML encode????
	                this.attributes = options.attributes;
	            },
	
	            /**
	             * Get a dialog window
	             */
	            getDialog: function (options) {
	                var that = this;
	                var dialogWidget = $(DIALOG_SELECTOR).data('kendoDialog');
	                assert.ok(kendo.ui.Dialog, '`kendo.dialog.js` is expected to be loaded');
	                // Find or create dialog frame
	                if (!(dialogWidget instanceof kendo.ui.Dialog)) {
	                    // Create dialog
	                    dialogWidget = $(kendo.format(DIALOG_DIV, DIALOG_SELECTOR.substr(1)))
	                        .appendTo(document.body)
	                        .kendoDialog({
	                            actions: [
	                                { text: Tool.fn.i18n.dialogs.ok.text, primary: true, action: $.proxy(that.onOkAction, that, options) },
	                                { text: Tool.fn.i18n.dialogs.cancel.text }
	                            ],
	                            buttonLayout: 'normal',
	                            modal: true,
	                            visible: false,
	                            width: 860,
	                            close: function (e) {
	                                // This is a reusable dialog, so we need to make sure it is ready for the next content
	                                dialogWidget.element.removeClass(NO_PADDING_CLASS);
	                                // The content method destroys widgets and unbinds data
	                                dialogWidget.content('');
	                                dialogWidget.viewModel = undefined;
	                            }
	                        })
	                        .data('kendoDialog');
	                    // Hides the display of "Fermer" after the "X" icon in the window title bar
	                    dialogWidget.wrapper.find('.k-window-titlebar > .k-dialog-close > .k-font-icon.k-i-x').text('');
	                }
	                return dialogWidget;
	            },
	
	            /* This function's cyclomatic complexity is too high. */
	            /* jshint -W074 */
	
	            /**
	             * Get a kendo.data.Model field
	             * See http://docs.telerik.com/kendo-ui/api/javascript/data/model#methods-Model.define
	             * @returns {{}}
	             */
	            getField: function () {
	                var field = {};
	                if ([STRING, NUMBER, BOOLEAN, DATE].indexOf(this.type) > -1) {
	                    field.type = this.type;
	                }
	                if ($.type(this.defaultValue) === this.type ||
	                    this.type === undefined) { // TODO: test that defaultValue is null or an object
	                    field.defaultValue = this.defaultValue;
	                }
	                if ($.type(this.editable) === BOOLEAN) {
	                    field.editable = this.defaultValue;
	                }
	                if ($.type(this.nullable) === BOOLEAN) {
	                    field.nullable = this.nullable;
	                }
	                if ($.isFunction(this.parse)) {
	                    field.parse = this.parse;
	                }
	                if ($.type(this.from) === STRING) {
	                    field.from = this.from;
	                }
	                if ($.type(this.validation) === OBJECT) {
	                    field.validation = this.validation;
	                }
	                return field;
	            },
	
	            /* jshint +W074 */
	
	            /* This function's cyclomatic complexity is too high. */
	            /* jshint -W074 */
	
	            /**
	             * Get a property grid row
	             * See http://docs.telerik.com/kendo-ui/api/javascript/ui/grid#configuration-columns
	             * @param field - This is the MVVM path to the field the data is bound to
	             * @returns {{}}
	             */
	            getRow: function (field) {
	                if ($.type(field) !== STRING || field.length === 0) {
	                    throw new TypeError();
	                }
	                var row = {};
	                row.field = field; // Mandatory
	                if ($.type(this.title) === STRING) {
	                    row.title = this.title;
	                }
	                if ($.type(this.format) === STRING) {
	                    row.format = this.format;
	                }
	                if ($.type(this.template) === STRING) {
	                    row.template = this.template;
	                }
	                if ($.isFunction(this.editor) ||
	                    ($.type(this.editor) === STRING && (kidoju.editors === undefined || $.isFunction(kidoju.editors[this.editor])))) {
	                    row.editor = this.editor;
	                }
	                // TODO: HTML encode????
	                if ($.isPlainObject(this.attributes)) {
	                    row.attributes = this.attributes;
	                }
	                return row;
	            }
	
	        });
	
	        /* jshint +W074 */
	
	        /**
	         * Asset Adapter
	         */
	        adapters.AssetAdapter = BaseAdapter.extend({
	            init: function (options) {
	                var that = this;
	                BaseAdapter.fn.init.call(that, options);
	                that.type = STRING;
	                that.defaultValue = that.defaultValue || (that.nullable ? null : '');
	                // that.editor is the inline editor with a [...] button which triggers this.showDialog
	                that.editor = function (container, settings) {
	                    var table = $('<div/>')
	                        .css({ display: 'table' })
	                        .appendTo(container);
	                    var cell = $('<div/>')
	                        .css({
	                            display: 'table-cell',
	                            width: '100%',
	                            paddingRight: '8px'
	                        })
	                        .appendTo(table);
	                    var input = $('<input/>')
	                        .addClass('k-textbox')
	                        .css({ width: '100%' })
	                        .prop({ readonly: true })
	                        .attr($.extend({}, settings.attributes, { 'data-bind': 'value: ' + settings.field }))// TODO: namespace???
	                        .appendTo(cell);
	                    $('<button/>')
	                        .text('...')
	                        .addClass('k-button')
	                        .css({
	                            display: 'table-cell',
	                            minWidth: '40px',
	                            height: input.css('height'), // to match input,
	                            margin: 0
	                        })
	                        .appendTo(table)
	                        .on(CLICK, $.proxy(that.showDialog, that, settings));
	                };
	            },
	            showDialog: function (options/*, e*/) {
	                var that = this;
	                var dialogWidget = that.getDialog(options);
	                // Create viewModel (Cancel shall not save changes to main model)
	                dialogWidget.viewModel = kendo.observable({
	                    url: options.model.get(options.field)
	                });
	                // Prepare UI
	                dialogWidget.title(options.title);
	                dialogWidget.content('<div data-role="assetmanager" data-bind="value: url"></div>');
	                assert.instanceof(PageComponent, options.model, kendo.format(assert.messages.instanceof.default, 'options.model', 'kidoju.data.PageComponent'));
	                assert.instanceof(ToolAssets, assets[options.model.tool], kendo.format(assert.messages.instanceof.default, 'assets[options.model.tool]', 'kidoju.ToolAssets'));
	                var assetManagerWidget = dialogWidget.element.find(kendo.roleSelector('assetmanager')).kendoAssetManager(assets[options.model.tool]).data('kendoAssetManager');
	                kendo.bind(dialogWidget.element, dialogWidget.viewModel);
	                dialogWidget.element.addClass(NO_PADDING_CLASS);
	                // Show dialog
	                assetManagerWidget.tabStrip.activateTab(0);
	                dialogWidget.open();
	            },
	            onOkAction: function (options, e) {
	                assert.isPlainObject(e, kendo.format(assert.messages.isPlainObject.default, 'e'));
	                assert.instanceof(kendo.ui.Dialog, e.sender, kendo.format(assert.messages.instanceof.default, 'e.sender', 'kendo.ui.Dialog'));
	                options.model.set(options.field, e.sender.viewModel.get('url'));
	            }
	        });
	
	        /**
	         * Boolean adapter
	         */
	        adapters.BooleanAdapter = BaseAdapter.extend({
	            init: function (options, attributes) {
	                BaseAdapter.fn.init.call(this, options);
	                this.type = BOOLEAN;
	                this.defaultValue = this.defaultValue || (this.nullable ? null : false);
	                this.editor = 'input';
	                this.attributes = $.extend({}, this.attributes, attributes);
	                this.attributes[kendo.attr('role')] = 'switch';
	            },
	            library: [
	                {
	                    name: 'equal',
	                    formula: kendo.format(FORMULA, 'return String(value).toLowerCase() === String(solution).toLowerCase();')
	                }
	            ],
	            libraryDefault: 'equal'
	        });
	
	        /**
	         * CharGrid adapter
	         */
	        adapters.CharGridAdapter = BaseAdapter.extend({
	            init: function (options) {
	                var that = this;
	                BaseAdapter.fn.init.call(that, options);
	                that.type = undefined;
	                that.editor = function (container, settings) {
	                    $('<button/>')
	                        .text('...')
	                        .addClass('k-button')
	                        .css({ margin: 0, width: '100%' })
	                        .appendTo(container)
	                        .on(CLICK, $.proxy(that.showDialog, that, settings));
	                };
	            },
	            showDialog: function (options, evt) {
	                var that = this;
	                var dialogWidget = that.getDialog(options);
	                var model = options.model;
	                // Build data (resize array especially after changing rows and columns)
	                var columns = model.get('attributes.columns');
	                var rows = model.get('attributes.rows');
	                var whitelist = model.get('attributes.whitelist');
	                var layout = model.get('attributes.layout');
	                var data = model.get(options.field);
	                // Create viewModel (Cancel shall not save changes to main model)
	                dialogWidget.viewModel = kendo.observable({
	                    chargrid: kendo.ui.CharGrid._getCharGridArray(rows, columns, whitelist, layout, data)
	                });
	                // Prepare UI
	                dialogWidget.title(options.title);
	                dialogWidget.content('<div style="display:flex;flex-direction:row">' +
	                    // character grid
	                    '<div data-role="chargrid" data-bind="value: chargrid" data-scaler=".k-content" data-container=".k-content" ' +
	                    'data-columns="' + model.get('attributes.columns') + '" data-rows="' + model.get('attributes.rows') + '" ' +
	                    'data-blank="' + model.get('attributes.blank') + '" ' +
	                    'data-whitelist="' + (options.field === 'properties.solution' ? model.get('attributes.whitelist') : '\\S') + '" ' +
	                    (options.field === 'properties.solution' ? 'data-locked="' + kendo.htmlEncode(JSON.stringify(layout)) + '" ' : '') +
	                    'data-grid-fill="' + model.get('attributes.gridFill') + '" ' +
	                    'data-grid-stroke="' + model.get('attributes.gridStroke') + '" ' +
	                    'data-blank-fill="' + model.get('attributes.gridStroke') + '" ' +
	                    'data-selected-fill="' + model.get('attributes.selectedFill') + '" ' +
	                    'data-locked-fill="' + model.get('attributes.lockedFill') + '" ' +
	                    'data-locked-color="' + model.get('attributes.fontColor') + '" ' +
	                    'data-value-color="' + model.get('attributes.fontColor') + '" ' +
	                    'style="height:' + 0.7 * options.model.get('height') + 'px;width:' + 0.7 * options.model.get('width') + 'px;flex-shrink:0;padding:20px;"></div>' +
	                    // Explanations
	                    '<div style="padding:20px 0;">' +
	                    (options.field === 'properties.solution' ? kendo.format(this.messages.solution, model.get('attributes.whitelist')) : kendo.format(this.messages.layout, model.get('attributes.blank'))) +
	                    '</div>' +
	                    // Close parent div
	                    '</div>');
	                kendo.bind(dialogWidget.element, dialogWidget.viewModel);
	                dialogWidget.element.addClass(NO_PADDING_CLASS);
	                // Show dialog
	                dialogWidget.open();
	            },
	            onOkAction: function (options, e) {
	                assert.isPlainObject(e, kendo.format(assert.messages.isPlainObject.default, 'e'));
	                assert.instanceof(kendo.ui.Dialog, e.sender, kendo.format(assert.messages.instanceof.default, 'e.sender', 'kendo.ui.Dialog'));
	                options.model.set(options.field, e.sender.viewModel.get('chargrid'));
	            },
	            library: [
	                {
	                    name: 'equal',
	                    formula: kendo.format(FORMULA, 'return value && typeof value.equals === "function" && value.equals(solution);')
	                }
	            ],
	            libraryDefault: 'equal',
	            messages: {
	                layout: i18n.chargridadapter.messages.layout,
	                solution: i18n.chargridadapter.messages.solution
	            }
	        });
	
	        /**
	         * Chart adapter
	         */
	        adapters.ChartAdapter = BaseAdapter.extend({
	            init: function (options) {
	                var that = this;
	                BaseAdapter.fn.init.call(that, options);
	                that.type = undefined;
	                // This is the inline editor with a [...] button which triggers this.showDialog
	                that.editor = function (container, settings) {
	                    $('<button/>')
	                        .text('...')
	                        .addClass('k-button')
	                        .css({ margin: 0, width: '100%' })
	                        .appendTo(container)
	                        .on(CLICK, $.proxy(that.showDialog, that, settings));
	                };
	            },
	            showDialog: function (options/*, e*/) {
	                var that = this;
	                var dialogWidget = that.getDialog(options);
	                var model = options.model;
	                var columns = model.get('attributes.categories') + 1;
	                var rows = model.get('attributes.values') + 1;
	                // Prepare UI
	                dialogWidget.title(options.title);
	                dialogWidget.content('<div data-role="spreadsheet"></div>');
	                var spreadsheet = dialogWidget.element.find(kendo.roleSelector('spreadsheet'));
	                assert.hasLength(spreadsheet, kendo.format(assert.messages.hasLength.default, 'spreadsheet'));
	                var spreadsheetWidget = spreadsheet.kendoSpreadsheet({
	                    columns: columns,
	                    rows: rows,
	                    sheetsbar: false,
	                    toolbar: false
	                }).data('kendoSpreadsheet');
	                assert.instanceof(kendo.ui.Spreadsheet, spreadsheetWidget, kendo.format(assert.messages.instanceof.default, 'spreadsheetWidget', 'kendo.ui.Spreadsheet'));
	                // Workaround for issue described at https://github.com/telerik/kendo-ui-core/issues/1990 and https://github.com/telerik/kendo-ui-core/issues/2156
	                dialogWidget.one('show', function () {
	                    kendo.resize(dialogWidget.element); // spreadsheetWidget.refresh();
	                    spreadsheetWidget.activeSheet().range('A1:A1').select();
	                });
	                // Load JSON after resizing data to the predefined number of rows and columns
	                spreadsheetWidget.fromJSON(util.resizeSpreadsheetData(model.get('attributes.data'), rows, columns));
	                // Disable context menu
	                spreadsheet.find('.k-spreadsheet-fixed-container').off('contextmenu');
	                dialogWidget.element.addClass(NO_PADDING_CLASS);
	                // Show dialog
	                dialogWidget.open();
	            },
	            onOkAction: function (options, e) {
	                assert.isPlainObject(e, kendo.format(assert.messages.isPlainObject.default, 'e'));
	                assert.instanceof(kendo.ui.Dialog, e.sender, kendo.format(assert.messages.instanceof.default, 'e.sender', 'kendo.ui.Dialog'));
	                var spreadsheet = e.sender.element.find(kendo.roleSelector('spreadsheet'));
	                assert.hasLength(spreadsheet, kendo.format(assert.messages.hasLength.default, 'spreadsheet'));
	                var spreadsheetWidget = spreadsheet.data('kendoSpreadsheet');
	                assert.instanceof(kendo.ui.Spreadsheet, spreadsheetWidget, kendo.format(assert.messages.instanceof.default, 'spreadsheetWidget', 'kendo.ui.Spreadsheet'));
	                options.model.set(options.field, spreadsheetWidget.toJSON());
	            }
	        });
	
	        /**
	         * Color adapter
	         */
	        adapters.ColorAdapter = BaseAdapter.extend({
	            init: function (options, attributes) {
	                BaseAdapter.fn.init.call(this, options);
	                this.type = STRING;
	                this.defaultValue = this.defaultValue || (this.nullable ? null : '#000000');
	                this.editor = 'input';
	                this.attributes = $.extend({}, this.attributes, attributes);
	                this.attributes[kendo.attr('role')] = 'colorpicker';
	            },
	            library: [
	                {
	                    name: 'equal',
	                    formula: kendo.format(FORMULA, 'return String(value).trim() === String(solution).trim();')
	                }
	            ],
	            libraryDefault: 'equal'
	        });
	
	        /**
	         * Connector adapter
	         */
	        adapters.ConnectorAdapter = BaseAdapter.extend({
	            init: function (options, attributes) {
	                BaseAdapter.fn.init.call(this, options);
	                this.type = STRING;
	                this.defaultValue = this.defaultValue || (this.nullable ? null : '');
	                // this.editor = 'input';
	                // this.attributes = $.extend({}, this.attributes, { type: 'text', style: 'width: 100%;' });
	                this.editor = function (container, options) {
	                    var input = $('<input/>')
	                        .css({ width: '100%' })
	                        .attr({ 'data-bind': 'value: ' + options.field }) // TODO namespace???
	                        .appendTo(container);
	                    input.kendoComboBox({
	                        // dataSource: { data: [''] }, // We need a non-empty dataSource otherwise open is not triggered
	                        /**
	                         * Fill the drop down list when opening the popup (always up-to-date when adding/removing connectors)
	                         * @param e
	                         */
	                        open: function (e) {
	                            var solutions = [];
	                            // find the design (mode) stage, avoiding navigation
	                            var stage = $('[' + kendo.attr('role') + '="stage"][' + kendo.attr('mode') + '="design"]');
	                            // find the handle box and the selected uid which should be a connector
	                            var handleBox = stage.parent().children('.kj-handle-box');
	                            var uid = handleBox.attr(kendo.attr('uid'));
	                            // find all unselected connectors
	                            assert.instanceof (PageComponent, options.model, kendo.format(assert.messages.instanceof.default, 'options.model', 'kidoju.data.PageModel'));
	                            if (options.model.parent() instanceof kendo.Observable && options.model.parent().selectedPage instanceof Page) {
	                                var components = options.model.parent().selectedPage.components;
	                                $.each(components.data(), function (index, component) {
	                                    if (component.tool === 'connector' && component.uid !== uid) {
	                                        var solution = component.get(options.field);
	                                        if ($.type(solution) === STRING && solution.length && solutions.indexOf(solution) === -1) {
	                                            solutions.push(solution);
	                                        }
	                                    }
	                                });
	                                solutions.sort();
	                            }
	                            e.sender.setDataSource(solutions);
	                        }
	                    });
	                };
	            },
	            library: [
	                {
	                    name: 'equal',
	                    formula: kendo.format(FORMULA, 'return String(value).trim() === String(solution).trim();')
	                }
	            ],
	            libraryDefault: 'equal'
	        });
	
	        /**
	         * Date adapter
	         */
	        adapters.DateAdapter = BaseAdapter.extend({
	            init: function (options, attributes) {
	                BaseAdapter.fn.init.call(this, options);
	                this.type = DATE;
	                this.defaultValue = this.defaultValue || (this.nullable ? null : new Date());
	                this.editor = 'input';
	                this.attributes = $.extend({}, this.attributes, attributes);
	                this.attributes[kendo.attr('role')] = 'datepicker';
	            },
	            library: [
	                {
	                    name: 'equal',
	                    // TODO: parsing raises a culture issue with MM/DD/YYYY in english and DD/MM/YYYY in french
	                    // Note: new Date(1994,1,1) !== new Date(1994,1,1) as they are two different objects
	                    formula: kendo.format(FORMULA, 'return new Date(value) - new Date(solution) === 0;')
	                }
	            ],
	            libraryDefault: 'equal'
	        });
	
	        /**
	         * Description Adapter
	         */
	        adapters.DescriptionAdapter = BaseAdapter.extend({
	            init: function (options) {
	                BaseAdapter.fn.init.call(this, options);
	                this.type = STRING;
	                this.defaultValue = this.defaultValue || (this.nullable ? null : '');
	                // this.editor = 'input';
	                // this.attributes = $.extend({}, this.attributes, { type: 'text', style: 'width: 100%;' });
	                this.editor = function (container, options) {
	                    var input = $('<input/>')
	                        .css({ width: '100%' })
	                        .attr({ 'data-bind': 'value: ' + options.field }) // TODO namespace???
	                        .appendTo(container);
	                    input.kendoComboBox({
	                        // dataSource: { data: [] }, // We need a non-empty dataSource otherwise open is not triggered
	                        /**
	                         * Fill the drop down list when opening the popup (always up-to-date when adding/removing connectors)
	                         * @param e
	                         */
	                        open: function (e) {
	                            var texts = [];
	                            // find the design (mode) stage, avoiding navigation
	                            var stage = $('[' + kendo.attr('role') + '="stage"][' + kendo.attr('mode') + '="design"]');
	                            // find all labels
	                            var labels = stage.find('.kj-element[' + kendo.attr('tool') + '="label"]>div');
	                            labels.each(function (index, label) {
	                                var text = $(label).html().replace(/<br\/?>/g, ' ');
	                                if ($.type(text) === STRING && text.length) {
	                                    texts.push(text);
	                                }
	                            });
	                            texts.sort();
	                            e.sender.setDataSource(texts);
	                        }
	                    });
	                };
	            }
	        });
	
	        /**
	         * Enum adapter
	         */
	        adapters.EnumAdapter = BaseAdapter.extend({
	            init: function (options, attributes) {
	                BaseAdapter.fn.init.call(this, options);
	                this.type = STRING;
	                this.defaultValue = this.defaultValue || (this.nullable ? null : '');
	                this.editor = 'input';
	                this.attributes = $.extend({}, this.attributes, attributes);
	                this.attributes[kendo.attr('role')] = 'dropdownlist';
	                this.attributes[kendo.attr('source')] = JSON.stringify(options && options.enum ? options.enum : []); // kendo.htmlEncode??
	            }
	        });
	
	        /**
	         * Property name adapter
	         */
	        adapters.NameAdapter = BaseAdapter.extend({
	            init: function (options, attributes) {
	                BaseAdapter.fn.init.call(this, options);
	                this.type = STRING;
	                this.defaultValue = this.defaultValue || (this.nullable ? null : '');
	                this.editor = 'input';
	                this.attributes = $.extend({}, this.attributes, attributes, { type: 'text', class: 'k-textbox',  readonly: true });
	            }
	        });
	
	        /**
	         * Number adapter
	         */
	        adapters.NumberAdapter = BaseAdapter.extend({
	            init: function (options, attributes) {
	                BaseAdapter.fn.init.call(this, options);
	                this.type = NUMBER;
	                this.defaultValue = this.defaultValue || (this.nullable ? null : 0);
	                this.editor = 'input';
	                this.attributes = $.extend({}, this.attributes, attributes);
	                this.attributes[kendo.attr('role')] = 'numerictextbox';
	            },
	            library: [
	                {
	                    name: 'equal',
	                    // TODO: parsing raises a culture issue with 5.3 in english and 5,3 in french
	                    formula: kendo.format(FORMULA, 'return Number(value) === Number(solution);')
	                },
	                {
	                    name: 'greaterThan',
	                    formula: kendo.format(FORMULA, 'return Number(value) > Number(solution);')
	                },
	                {
	                    name: 'greaterThanOrEqual',
	                    formula: kendo.format(FORMULA, 'return Number(value) >= Number(solution);')
	                },
	                {
	                    name: 'lowerThan',
	                    formula: kendo.format(FORMULA, 'return Number(value) < Number(solution);')
	                },
	                {
	                    name: 'lowerThanOrEqual',
	                    formula: kendo.format(FORMULA, 'return Number(value) <= Number(solution);')
	                }
	            ],
	            libraryDefault: 'equal'
	        });
	
	        /**
	         * Quiz adapter
	         */
	        adapters.QuizAdapter = BaseAdapter.extend({
	            init: function (options, attributes) {
	                BaseAdapter.fn.init.call(this, options);
	                this.type = STRING;
	                this.defaultValue = this.defaultValue || (this.nullable ? null : '');
	                // this.editor = 'input';
	                // this.attributes = $.extend({}, this.attributes, { type: 'text', style: 'width: 100%;' });
	                this.editor = function (container, options) {
	                    var input = $('<input/>')
	                        .css({ width: '100%' })
	                        .attr({ 'data-bind': 'value: ' + options.field }) // TODO namespace???
	                        .appendTo(container);
	                    input.kendoComboBox({
	                        // dataSource: { data: [''] }, // We need a non-empty dataSource otherwise open is not triggered
	                        /**
	                         * Fill the drop down list when opening the popup (always up-to-date when adding/removing connectors)
	                         * @param e
	                         */
	                        open: function (e) {
	                            var data = options.model.get('attributes.data');
	                            data = $.type(data) === STRING ? data.split('\n') : [];
	                            data.sort();
	                            e.sender.setDataSource(data);
	                        }
	                    });
	                };
	            },
	            library: [
	                {
	                    name: 'equal',
	                    formula: kendo.format(FORMULA, 'return String(value).trim() === String(solution).trim();')
	                }
	            ],
	            libraryDefault: 'equal'
	        });
	
	        /**
	         * Score adapter
	         */
	        adapters.ScoreAdapter = BaseAdapter.extend({
	            init: function (options, attributes) {
	                BaseAdapter.fn.init.call(this, options);
	                this.type = NUMBER;
	                this.defaultValue = this.defaultValue || (this.nullable ? null : 0);
	                this.editor = 'input';
	                this.attributes = $.extend({}, this.attributes, attributes);
	                this.attributes[kendo.attr('role')] = 'numerictextbox';
	            }
	        });
	
	        /**
	         * String adapter
	         */
	        adapters.StringAdapter = BaseAdapter.extend({
	            init: function (options, attributes) {
	                BaseAdapter.fn.init.call(this, options);
	                this.type = STRING;
	                this.defaultValue = this.defaultValue || (this.nullable ? null : '');
	                this.editor = 'input';
	                this.attributes = $.extend({}, this.attributes, attributes, { type: 'text', class: 'k-textbox' });
	            },
	            library: [
	                {
	                    name: 'equal',
	                    formula: kendo.format(FORMULA, 'return String(value).trim() === String(solution).trim();')
	                },
	                {
	                    name: 'ignoreCaseEqual',
	                    formula: kendo.format(FORMULA, 'return String(value).trim().toUpperCase() === String(solution).trim().toUpperCase();')
	                },
	                {
	                    name: 'ignoreCaseMatch',
	                    formula: kendo.format(FORMULA, 'return (new RegExp(\'^\' + String(solution).trim() + \'$\', \'i\')).test(String(value).trim());')
	                },
	                {
	                    name: 'ignoreDiacriticsEqual',
	                    formula: kendo.format(FORMULA, 'return removeDiacritics(String(value).trim().toUpperCase()) === removeDiacritics(String(solution).trim().toUpperCase());')
	                },
	                {
	                    name: 'match',
	                    formula: kendo.format(FORMULA, 'return (new RegExp(\'^\' + String(solution).trim() + \'$\')).test(String(value).trim());')
	                },
	                {
	                    name: 'metaphone',
	                    formula: kendo.format(FORMULA, 'return metaphone(removeDiacritics(String(value).trim().toUpperCase())) === metaphone(removeDiacritics(String(solution).trim().toUpperCase()));')
	                },
	                {
	                    name: 'soundex',
	                    formula: kendo.format(FORMULA, 'return soundex(removeDiacritics(String(value).trim().toUpperCase())) === soundex(removeDiacritics(String(solution).trim().toUpperCase()));')
	                }
	            ],
	            libraryDefault: 'equal'
	        });
	
	        /**
	         * String Array adapter
	         */
	        adapters.StringArrayAdapter = BaseAdapter.extend({
	            init: function (options, attributes) {
	                BaseAdapter.fn.init.call(this, options);
	                this.type = STRING;
	                this.defaultValue = this.defaultValue || (this.nullable ? null : '');
	                this.editor = 'textarea';
	                this.attributes = $.extend({}, this.attributes, attributes);
	            },
	            library: [
	                {
	                    name: 'equal',
	                    formula: kendo.format(FORMULA, '// Note: value is an array and solution is a multiline string\n\t' +
	                        'return String(value.sort()) === String(solution.trim().split("\\n").sort());')
	                },
	                {
	                    name: 'sumEqual',
	                    formula: kendo.format(FORMULA, '// Note: value is an array and solution is a multiline string\n\t' +
	                        'var ret = 0;\t' +
	                        'value.forEach(function(val){ ret += parseFloat((val || "").trim() || 0); });\t' +
	                        'return ret === parseFloat(solution.trim());')
	                }
	            ],
	            libraryDefault: 'equal'
	        });
	
	        /**
	         * Style adapter
	         */
	        adapters.StyleAdapter = BaseAdapter.extend({
	            init: function (options) {
	                var that = this;
	                BaseAdapter.fn.init.call(that, options);
	                that.type = STRING;
	                that.defaultValue = that.defaultValue || (that.nullable ? null : '');
	                // This is the inline editor with a [...] button which triggers this.showDialog
	                that.editor = function (container, settings) {
	                    var table = $('<div/>')
	                        .css({ display: 'table' })
	                        .appendTo(container);
	                    var cell = $('<div/>')
	                        .css({
	                            display: 'table-cell',
	                            width: '100%',
	                            paddingRight: '8px'
	                        })
	                        .appendTo(table);
	                    var input = $('<input/>')
	                        .addClass('k-textbox') // or k-input
	                        .css({ width: '100%' })
	                        .attr($.extend({}, settings.attributes, { 'data-bind': 'value: ' + settings.field })) // TODO namespace?
	                        .appendTo(cell);
	                    $('<button/>')
	                        .text('...')
	                        .addClass('k-button')
	                        .css({
	                            display: 'table-cell',
	                            minWidth: '40px',
	                            height: input.css('height'), // to match input,
	                            margin: 0
	                        })
	                        .appendTo(table)
	                        .on(CLICK, $.proxy(that.showDialog, that, settings));
	                };
	            },
	            showDialog: function (options/*, e*/) {
	                var that = this;
	                var dialogWidget = that.getDialog(options);
	                // Create viewModel (Cancel shall not save changes to main model)
	                dialogWidget.viewModel = kendo.observable({
	                    style: options.model.get(options.field)
	                });
	                // Prepare UI
	                dialogWidget.title(options.title);
	                dialogWidget.content('<div data-role="styleeditor" data-bind="value: style" data-height="400"></div>');
	                kendo.bind(dialogWidget.element, dialogWidget.viewModel);
	                var styleEditor = dialogWidget.element.find(kendo.roleSelector('styleeditor'));
	                assert.hasLength(styleEditor, kendo.format(assert.messages.hasLength.default, 'styleEditor'));
	                var styleEditorWidget = styleEditor.data('kendoStyleEditor');
	                assert.instanceof(kendo.ui.StyleEditor, styleEditorWidget, kendo.format(assert.messages.instanceof.default, 'styleEditorWidget', 'kendo.ui.StyleEditor'));
	                // Workaround for issue described at https://github.com/telerik/kendo-ui-core/issues/1990 and https://github.com/telerik/kendo-ui-core/issues/2156
	                dialogWidget.one('show', function () {
	                    styleEditorWidget.refresh();
	                });
	                dialogWidget.element.addClass(NO_PADDING_CLASS);
	                // Show dialog
	                dialogWidget.open();
	            },
	            onOkAction: function (options, e) {
	                assert.isPlainObject(e, kendo.format(assert.messages.isPlainObject.default, 'e'));
	                assert.instanceof(kendo.ui.Dialog, e.sender, kendo.format(assert.messages.instanceof.default, 'e.sender', 'kendo.ui.Dialog'));
	                options.model.set(options.field, e.sender.viewModel.get('style'));
	            }
	        });
	
	        /**
	         * Table adapter
	         */
	        adapters.TableAdapter = BaseAdapter.extend({
	            init: function (options) {
	                var that = this;
	                BaseAdapter.fn.init.call(that, options);
	                that.type = undefined;
	                // This is the inline editor with a [...] button which triggers this.showDialog
	                that.editor = function (container, settings) {
	                    $('<button/>')
	                        .text('...')
	                        .addClass('k-button')
	                        .css({ margin: 0, width: '100%' })
	                        .appendTo(container)
	                        .on(CLICK, $.proxy(that.showDialog, that, settings));
	                };
	            },
	            showDialog: function (options/*, e*/) {
	                var that = this;
	                var dialogWidget = that.getDialog(options);
	                var model = options.model;
	                var columns = model.get('attributes.columns');
	                var rows = model.get('attributes.rows');
	                // Prepare UI
	                dialogWidget.title(options.title);
	                dialogWidget.content('<div data-role="spreadsheet"></div>');
	                var spreadsheet = dialogWidget.element.find(kendo.roleSelector('spreadsheet'));
	                assert.hasLength(spreadsheet, kendo.format(assert.messages.hasLength.default, 'spreadsheet'));
	                var spreadsheetWidget = spreadsheet.kendoSpreadsheet({
	                    columns: columns,
	                    rows: rows,
	                    columnWidth: 150,
	                    rowHeight: 58,
	                    sheetsbar: false,
	                    toolbar: {
	                        // TODO: merge and hide not included in v1
	                        home: [['bold', 'italic', 'underline'], 'backgroundColor', 'textColor', 'borders', 'fontSize', 'fontFamily', 'alignment', 'textWrap', ['formatDecreaseDecimal', 'formatIncreateDecimal'], 'format'],
	                        insert: false,
	                        data: false
	                    }
	                }).data('kendoSpreadsheet');
	                assert.instanceof(kendo.ui.Spreadsheet, spreadsheetWidget, kendo.format(assert.messages.instanceof.default, 'spreadsheetWidget', 'kendo.ui.Spreadsheet'));
	                // Workaround for issue described at https://github.com/telerik/kendo-ui-core/issues/1990 and https://github.com/telerik/kendo-ui-core/issues/2156
	                dialogWidget.one('show', function () {
	                    kendo.resize(dialogWidget.element); // spreadsheetWidget.refresh();
	                    spreadsheetWidget.activeSheet().range('A1:A1').select();
	                });
	                // Load JSON after resizing data to the predefined number of rows and columns
	                spreadsheetWidget.fromJSON(util.resizeSpreadsheetData(model.get('attributes.data'), rows, columns));
	                // Disable context menu
	                spreadsheet.find('.k-spreadsheet-fixed-container').off('contextmenu');
	                // Set default font size
	                var activeSheet = spreadsheetWidget.activeSheet();
	                activeSheet.range('R1C1:R' + rows + 'C' + columns).forEachCell(function (rowIndex, columnIndex) {
	                    var range = activeSheet.range('R' + (rowIndex + 1) + 'C' + (columnIndex + 1));
	                    range.fontSize(range.fontSize() || 48);
	                });
	                dialogWidget.element.addClass(NO_PADDING_CLASS);
	                // Show dialog
	                dialogWidget.open();
	            },
	            onOkAction: function (options, e) {
	                assert.isPlainObject(e, kendo.format(assert.messages.isPlainObject.default, 'e'));
	                assert.instanceof(kendo.ui.Dialog, e.sender, kendo.format(assert.messages.instanceof.default, 'e.sender', 'kendo.ui.Dialog'));
	                var spreadsheet = e.sender.element.find(kendo.roleSelector('spreadsheet'));
	                assert.hasLength(spreadsheet, kendo.format(assert.messages.hasLength.default, 'spreadsheet'));
	                var spreadsheetWidget = spreadsheet.data('kendoSpreadsheet');
	                assert.instanceof(kendo.ui.Spreadsheet, spreadsheetWidget, kendo.format(assert.messages.instanceof.default, 'spreadsheetWidget', 'kendo.ui.Spreadsheet'));
	                options.model.set(options.field, spreadsheetWidget.toJSON());
	            }
	        });
	
	        /**
	         * Text (multiline) adapter
	         */
	        adapters.TextAdapter = BaseAdapter.extend({
	            init: function (options, attributes) {
	                BaseAdapter.fn.init.call(this, options);
	                this.type = STRING;
	                this.defaultValue = this.defaultValue || (this.nullable ? null : '');
	                this.editor = 'textarea';
	                this.attributes = $.extend({}, this.attributes, attributes);
	            },
	            library: [
	                {
	                    name: 'equal',
	                    formula: kendo.format(FORMULA, 'return String(value).trim() === String(solution).trim();')
	                },
	                {
	                    name: 'ignoreSpacesEqual',
	                    formula: kendo.format(FORMULA, 'return String(value).replace(/\\s+/g, " ").trim() === String(solution).replace(/\\s+/g, " ").trim();')
	                },
	                {
	                    name: 'ignorePunctiationEqual',
	                    formula: kendo.format(FORMULA, 'return String(value).replace(/[\\.,;:\\?!\'"\\(\\)\\s]+/g, " ").trim() === String(solution).replace(/[\\.,;:\\?!\'"\\(\\)\\s]+/g, " ").trim();')
	                }
	            ],
	            libraryDefault: 'equal'
	        });
	
	        /**
	         * Property validation adapter
	         */
	        adapters.ValidationAdapter = BaseAdapter.extend({
	            init: function (options) {
	                var that = this;
	                BaseAdapter.fn.init.call(that, options);
	                that.type = STRING;
	                // this.defaultValue = this.defaultValue || (this.nullable ? null : '');
	                that.editor = function (container, settings) {
	                    var table = $('<div/>')
	                        .css({ display: 'table' })
	                        .appendTo(container);
	                    var cell = $('<div/>')
	                        .css({
	                            display: 'table-cell',
	                            width: '100%',
	                            paddingRight: '8px'
	                        })
	                        .appendTo(table);
	                    var input = $('<div data-role="codeinput" />') // TODO namespace???
	                    // Note: _library is added to the data bound PageComponent in its init method
	                        .attr($.extend({}, settings.attributes, { 'data-bind': 'value: ' + settings.field + ', source: _library' })) // TODO namespace???
	                        .appendTo(cell);
	                    // We need a temporary textbox to calculate the height and align the button
	                    var temp = $('<input type="text" class="k-textbox">')
	                        .css({ visibility: 'hidden' })
	                        .appendTo(cell);
	                    $('<button/>')
	                        .text('...')
	                        .addClass('k-button')
	                        .css({
	                            display: 'table-cell',
	                            minWidth: '40px',
	                            height: temp.css('height'), // $('input.k-textbox').last().css('height'),
	                            margin: 0
	                        })
	                        .appendTo(table)
	                        .on(CLICK, $.proxy(that.showDialog, that, settings));
	                    temp.remove();
	                };
	            },
	            showDialog: function (options/*, e*/) {
	                var that = this;
	                var dialogWidget = that.getDialog(options);
	                // Create viewModel (Cancel shall not save changes to main model)
	                dialogWidget.viewModel = kendo.observable({
	                    code: options.model.get(options.field),
	                    library: [CUSTOM].concat(that.library)
	                });
	                // Prepare UI
	                dialogWidget.title(options.title);
	                dialogWidget.content('<div data-role="codeeditor" data-bind="value: code, source: library" data-default="' + that.defaultValue + '" data-solution="' + kendo.htmlEncode(JSON.stringify(options.model.get('properties.solution'))) + '"></div>');
	                kendo.bind(dialogWidget.element, dialogWidget.viewModel);
	                dialogWidget.element.addClass(NO_PADDING_CLASS);
	                // Bind window activate handler
	                dialogWidget.one('show', function () {
	                    // IMPORTANT, we need13 to refresh codemirror here
	                    // otherwise the open animation messes with CodeMirror calculations
	                    // and gutter and line numbers are displayed at the wrong coordinates
	                    var codeEditor = dialogWidget.element
	                        .find('.kj-codeeditor')
	                        .data('kendoCodeEditor');
	                    if (codeEditor instanceof kendo.ui.CodeEditor && codeEditor.codeMirror && $.isFunction(codeEditor.codeMirror.refresh)) {
	                        codeEditor.codeMirror.refresh();
	                    }
	                });
	                // Show dialog
	                dialogWidget.open();
	            },
	            onOkAction: function (options, e) {
	                assert.isPlainObject(e, kendo.format(assert.messages.isPlainObject.default, 'e'));
	                assert.instanceof(kendo.ui.Dialog, e.sender, kendo.format(assert.messages.instanceof.default, 'e.sender', 'kendo.ui.Dialog'));
	                options.model.set(options.field, e.sender.viewModel.get('code'));
	            }
	        });
	
	        /*******************************************************************************************
	         * Tool classes
	         *******************************************************************************************/
	
	        /**
	         * @class Pointer tool
	         * @type {void|*}
	         */
	        var Pointer = Tool.extend({
	            id: POINTER,
	            icon: 'mouse_pointer',
	            description: i18n.pointer.description,
	            cursor: CURSOR_DEFAULT,
	            height: 0,
	            width: 0,
	            getHtmlContent: undefined
	        });
	        tools.register(Pointer);
	
	        /**
	         * Audio tool
	         * @class Audio
	         */
	        var Audio = Tool.extend({
	            id: 'audio',
	            icon: 'loudspeaker3',
	            description: i18n.audio.description,
	            cursor: CURSOR_CROSSHAIR,
	            templates: {
	                default: '<div data-#= ns #role="mediaplayer" data-#= ns #mode="audio" data-#= ns #autoplay="#: attributes.autoplay #" data-#= ns #files="#: attributes.files$() #"></div>'
	            },
	            height: 100,
	            width: 400,
	            attributes: {
	                autoplay: new adapters.BooleanAdapter({ title: i18n.audio.attributes.autoplay.title, defaultValue: false }),
	                mp3: new adapters.AssetAdapter({ title: i18n.audio.attributes.mp3.title }),
	                ogg: new adapters.AssetAdapter({ title: i18n.audio.attributes.ogg.title })
	            },
	
	            /**
	             * Get Html or jQuery content
	             * @method getHtmlContent
	             * @param component
	             * @param mode
	             * @returns {*}
	             */
	            getHtmlContent: function (component, mode) {
	                var that = this;
	                assert.instanceof(Audio, that, kendo.format(assert.messages.instanceof.default, 'this', 'Audio'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                assert.enum(Object.keys(kendo.ui.Stage.fn.modes), mode, kendo.format(assert.messages.enum.default, 'mode', Object.keys(kendo.ui.Stage.fn.modes)));
	                assert.instanceof(ToolAssets, assets.audio, kendo.format(assert.messages.instanceof.default, 'assets.audio', 'kidoju.ToolAssets'));
	                var template = kendo.template(that.templates.default);
	                // The files$ function resolves urls with schemes like cdn://audio.mp3 and returns a stringified array
	                component.attributes.files$ = function () {
	                    var mp3 = component.attributes.get('mp3');
	                    var ogg = component.attributes.get('ogg');
	                    var schemes = assets.audio.schemes;
	                    for (var scheme in schemes) {
	                        if (schemes.hasOwnProperty(scheme)) {
	                            var schemeRx = new RegExp('^' + scheme + '://');
	                            if (schemeRx.test(mp3)) {
	                                mp3 = mp3.replace(scheme + '://', schemes[scheme]);
	                            }
	                            if (schemeRx.test(ogg)) {
	                                ogg = ogg.replace(scheme + '://', schemes[scheme]);
	                            }
	                        }
	                    }
	                    var files = [];
	                    if (RX_HTTP_S.test(mp3)) {
	                        files.push(mp3);
	                    }
	                    if (RX_HTTP_S.test(ogg)) {
	                        files.push(ogg);
	                    }
	                    return JSON.stringify(files);
	                };
	                return template($.extend(component, { ns: kendo.ns }));
	            },
	
	            /**
	             * onResize Event Handler
	             * @method onResize
	             * @param e
	             * @param component
	             */
	            onResize: function (e, component) {
	                var stageElement = $(e.currentTarget);
	                assert.ok(stageElement.is(ELEMENT_CLASS), kendo.format('e.currentTarget is expected to be a stage element'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                var content = stageElement.children('div' + kendo.roleSelector('mediaplayer'));
	                var widget = content.data('kendoMediaPlayer');
	                if ($.type(component.width) === NUMBER) {
	                    content.outerWidth(component.get('width') - content.outerWidth(true) + content.outerWidth());
	                }
	                if ($.type(component.height) === NUMBER) {
	                    content.outerHeight(component.get('height') - content.outerHeight(true) + content.outerHeight());
	                }
	                widget.resize();
	                // prevent any side effect
	                e.preventDefault();
	                // prevent event to bubble on stage
	                e.stopPropagation();
	            },
	
	            /**
	             * Component validation
	             * @param component
	             * @param pageIdx
	             */
	            validate: function (component, pageIdx) {
	                var ret = Tool.fn.validate.call(this, component, pageIdx);
	                var description = this.description; // tool description
	                var messages = this.i18n.messages;
	                if (component.attributes) {
	                    if (!RX_AUDIO.test(component.attributes.mp3)) {
	                        ret.push({
	                            type: ERROR,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidAudioFile, description, pageIdx + 1)
	                        });
	                    }
	                    // Note: we are not testing for an ogg file
	                }
	                return ret;
	            }
	
	        });
	        tools.register(Audio);
	
	        /**
	         * Build default chart data
	         * @param categories
	         * @param values
	         * @returns {{sheets: *[]}}
	         */
	        util.defaultChartData = function (categories, values) {
	            var YEAR = 1999;
	            var MAX_VALUE = 500;
	            var rowTotal = values + 1;
	            var columnTotal = categories + 1;
	            var rowIndex;
	            var columnIndex;
	            var data = { sheets: [{ name: 'Sheet1', rows: [] }] };
	            var rows = data.sheets[0].rows;
	            // Build the categories row
	            var row = { index: 0, cells: [] };
	            for (columnIndex = 1; columnIndex < columnTotal; columnIndex++) {
	                row.cells.push({ index: columnIndex, value: YEAR + columnIndex });
	            }
	            rows.push(row);
	            // Build the values rows
	            for (rowIndex = 1; rowIndex < rowTotal; rowIndex++) {
	                row = { index: rowIndex, cells: [] };
	                row.cells.push({ index: 0, value: 'Series' + rowIndex });
	                for (columnIndex = 1; columnIndex < columnTotal; columnIndex++) {
	                    row.cells.push({ index: columnIndex, value: Math.floor(MAX_VALUE * Math.random()) });
	                }
	                rows.push(row);
	            }
	            return data;
	        };
	
	        /**
	         * A utility function to resize spreadsheet data to a specified number of rows and columns
	         * @param json
	         * @param rowMax
	         * @param columnMax
	         */
	        util.resizeSpreadsheetData = function (json, rowMax, columnMax) {
	            var rows = json.sheets[0].rows;
	            var rowFilter = function (row) { return row.index < rowMax; };
	            var columnFilter = function (column) { return column.index < columnMax; };
	            rows = rows.filter(rowFilter);
	            for (var rowIndex = 0, rowTotal = rows.length; rowIndex < rowTotal; rowIndex++) {
	                var cells = rows[rowIndex].cells;
	                cells = cells.filter(columnFilter);
	                rows[rowIndex].cells = cells;
	            }
	            json.sheets[0].rows = rows;
	            return json;
	        };
	
	        /**
	         * Chart tool
	         * @class Chart
	         */
	        var Chart = Tool.extend({
	            id: 'chart',
	            icon: 'chart_area',
	            description: i18n.chart.description,
	            cursor: CURSOR_CROSSHAIR,
	            templates: {
	                default: '<div data-#= ns #role="chart" data-#= ns #chart-area="#: attributes.chartArea$() #" data-#= ns #series-defaults="#: attributes.seriesDefaults$() #" data-#= ns #title="#: attributes.title$() #" data-#= ns #legend="#: attributes.legend$() #" data-#= ns #series="#: attributes.series$() #" data-#= ns #category-axis="#: attributes.categoryAxis$() #" data-#= ns #value-axis="#: attributes.valueAxis$() #" style="#: attributes.style #"></div>'
	            },
	            height: 400,
	            width: 400,
	            attributes: {
	                type: new adapters.EnumAdapter({ title: i18n.chart.attributes.type.title, defaultValue: 'column', enum: ['area', 'bar', 'column', 'line', 'radarArea', 'radarColumn', 'radarLine', 'smoothLine', 'stackBar', 'waterfall', 'verticalArea', 'verticalLine'] }, { style: 'width: 100%;' }),
	                title: new adapters.StringAdapter({ title: i18n.chart.attributes.title.title }),
	                categories: new adapters.NumberAdapter({ title: i18n.chart.attributes.categories.title, defaultValue: 4 }, { 'data-decimals': 0, 'data-format': 'n0', 'data-min': 1, 'data-max': 10 }),
	                values: new adapters.NumberAdapter({ title: i18n.chart.attributes.values.title, defaultValue: 2 }, { 'data-decimals': 0, 'data-format': 'n0', 'data-min': 1, 'data-max': 10 }),
	                legend: new adapters.EnumAdapter({ title: i18n.chart.attributes.legend.title, defaultValue: 'none', enum: ['none', 'top', 'bottom', 'left', 'right'] }, { style: 'width: 100%;' }),
	                data: new adapters.ChartAdapter({ title: i18n.chart.attributes.data.title, defaultValue: util.defaultChartData(4, 2) }),
	                style: new adapters.StyleAdapter({ title: i18n.chart.attributes.style.title })
	            },
	
	            /* This function's cyclomatic complexity is too high. */
	            /* jshint -W074 */
	
	            /**
	             * Get Html or jQuery content
	             * @method getHtmlContent
	             * @param component
	             * @param mode
	             * @returns {*}
	             */
	            getHtmlContent: function (component, mode) {
	                var that = this;
	                var types = {
	                    area : { type: 'area' },
	                    bar : { type: 'bar' },
	                    // bubble : { type: 'bubble' },
	                    // bullet : { type: 'bullet' },
	                    // candlestick : { type: 'candlestick' },
	                    column : { type: 'column' },
	                    // donut: { type: 'donut' },                 // <--- Could work with a little bit of work to display labels
	                    // funnel: { type: 'funnel' },
	                    line: { type: 'line' },
	                    // ohlc: { type: 'ohlc' },
	                    // pie: { type: 'pie' },                     // <--- Nice to have
	                    // polarArea: { type: 'polarArea' },
	                    // polarLine: { type: 'polarLine' },
	                    // polarScatter: { type: 'polarScatter' },
	                    radarArea : { type: 'radarArea' },
	                    radarColumn : { type: 'radarColumn' },
	                    radarLine: { type: 'radarLine' },
	                    smoothLine: { type: 'line', style: 'smooth' },
	                    // scatter: { type: 'scatter' },
	                    // scatterLine: { type: 'scatterLine' },     // <--- Nice to have
	                    stackBar: { type: 'bar', stack: 'true' },
	                    waterfall: { type: 'waterfall' },
	                    verticalArea: { type: 'verticalArea' },
	                    // verticalBullet: { type: 'verticalBullet' },
	                    verticalLine: { type: 'verticalLine' }
	                };
	                assert.instanceof(Chart, that, kendo.format(assert.messages.instanceof.default, 'this', 'Chart'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                var template = kendo.template(that.templates.default);
	                var style = component.attributes.get('style');
	                // Get font from style - @see http://www.telerik.com/forums/charts---changing-the-default-font
	                var font = style.match(/font:([^;]+)/);
	                font = $.isArray(font) ? font[1] : font;
	                var fontSize = style.match(/font-size:([^;]+)/);
	                fontSize = $.isArray(fontSize) ? fontSize[1] : fontSize;
	                var fontFamily = style.match(/font-family:([^;]+)/);
	                fontFamily = $.isArray(fontFamily) ? fontFamily[1] : fontFamily;
	                // TODO: consider font-weight and font-style
	                font = font || ((fontSize || '50px') + ' ' + (fontFamily || 'Arial'));
	                var smallerFont = font;
	                var numbersInFont = font.match(/([0-9])+/g);
	                if ($.isArray(numbersInFont)) {
	                    for (var i = 0, length = numbersInFont.length; i < length; i++) {
	                        smallerFont = smallerFont.replace(numbersInFont[i], Math.ceil(0.6 * parseInt(numbersInFont[i], 10)));
	                    }
	                }
	                // Get colors from style (a null color is transparent, wheras undefined reverts to chart defaults)
	                var color = style.match(/color:([^;]+)/);
	                color = $.isArray(color) ? color[1] : color || undefined;
	                var background = style.match(/background-color:([^;]+)/);
	                background = $.isArray(background) ? background[1] : background || undefined;
	                // The chartArea$ function returns an object for chart's data-chart-area attribute binding
	                component.attributes.chartArea$ = function () {
	                    return JSON.stringify({
	                        background: background
	                    });
	                };
	                // The axisDefaults$ function returns an object chart's data-axis-defaults attribute binding
	                // component.attributes.axisDefaults$ = function () {
	                // We can't use axisDefaults, so we have categoryAxis$ and valueAxis$
	                // because of https://github.com/telerik/kendo-ui-core/issues/2165
	                // };
	                // The seriesDefaults$ function returns an object for chart's data-series-defaults attribute binding
	                component.attributes.seriesDefaults$ = function () {
	                    return JSON.stringify(types[component.attributes.get('type')]);
	                };
	                // The title$ function returns an object for chart's data-title attribute binding
	                component.attributes.title$ = function () {
	                    var title = component.attributes.get('title');
	                    return JSON.stringify({
	                        text: title,
	                        visible: !!(title.trim()),
	                        font: font,
	                        color: color
	                    });
	                };
	                // The legend$ function returns an object for chart's data-legend attribute binding
	                component.attributes.legend$ = function () {
	                    var legend = component.attributes.get('legend');
	                    return JSON.stringify({
	                        position: legend !== 'none' ? legend : 'right',
	                        visible: legend !== 'none',
	                        labels: {
	                            font: smallerFont,
	                            color: color
	                        }
	                    });
	                };
	                // The series$ function returns an object for chart's data-series attribute binding
	                component.attributes.series$ = function () {
	                    var series = [];
	                    var rowTotal = component.attributes.get('values') + 1;
	                    var columnTotal = component.attributes.get('categories') + 1;
	                    var rowIndex;
	                    var columnIndex;
	                    var rowFinder = function (row) { return row.index === rowIndex; };
	                    var columnFinder = function (column) { return column.index === columnIndex; };
	                    var json = component.attributes.get('data');
	                    for (rowIndex = 1; rowIndex < rowTotal; rowIndex++) {
	                        var serie = { name: '', data: [] };
	                        var row = json.sheets[0].rows.find(rowFinder);
	                        if (row && row.cells) {
	                            columnIndex = 0;
	                            var cell = row.cells.find(columnFinder);
	                            if (cell && cell.value) {
	                                serie.name = cell.value;
	                            }
	                            for (columnIndex = 1; columnIndex < columnTotal; columnIndex++) {
	                                var data = 0;
	                                cell = row.cells.find(columnFinder);
	                                if (cell && $.type(cell.value) === 'number') {
	                                    data = cell.value;
	                                }
	                                serie.data.push(data);
	                            }
	                        }
	                        series.push(serie);
	                    }
	                    /*
	                     return [
	                     { name: 'Series 1', data: [200, 450, 300, 125] },
	                     { name: 'Series 2', data: [200, 450, 300, 125] }
	                     ];
	                     */
	                    return JSON.stringify(series);
	                };
	                // The categoryAxis$ function returns an object for chart's data-category-axis attribute binding
	                component.attributes.categoryAxis$ = function () {
	                    var categories = [];
	                    var columnTotal = component.attributes.get('categories') + 1;
	                    var rowIndex = 0;
	                    var columnIndex;
	                    var rowFinder = function (row) { return row.index === rowIndex; };
	                    var columnFinder = function (column) { return column.index === columnIndex; };
	                    var json = component.attributes.get('data');
	                    var row = json.sheets[0].rows.find(rowFinder);
	                    for (columnIndex = 1; columnIndex < columnTotal; columnIndex++) {
	                        var category = '';
	                        if (row && row.cells) {
	                            var cell = row.cells.find(columnFinder);
	                            if (cell && cell.value) {
	                                category = cell.value;
	                            }
	                        }
	                        categories.push(category);
	                    }
	                    // return { categories: [2000, 2001, 2002, 2003] }
	                    return JSON.stringify({
	                        categories: categories,
	                        color: color,
	                        labels: {
	                            font: smallerFont,
	                            color: color
	                        }
	                    });
	                };
	                // The valueAxis$ function returns an object for chart's data-value-axis attribute binding
	                component.attributes.valueAxis$ = function () {
	                    return JSON.stringify({
	                        color: color,
	                        labels: {
	                            font: smallerFont,
	                            color: color
	                        }
	                    });
	                };
	                return template($.extend(component, { ns: kendo.ns }));
	            },
	
	            /* jshint +W074 */
	
	            /**
	             * onResize Event Handler
	             * @method onResize
	             * @param e
	             * @param component
	             */
	            onResize: function (e, component) {
	                var stageElement = $(e.currentTarget);
	                assert.ok(stageElement.is(ELEMENT_CLASS), kendo.format('e.currentTarget is expected to be a stage element'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                var content = stageElement.children('div' + kendo.roleSelector('chart'));
	                var widget = content.data('kendoChart');
	                if ($.type(component.width) === NUMBER) {
	                    content.outerWidth(component.get('width') - content.outerWidth(true) + content.outerWidth());
	                }
	                if ($.type(component.height) === NUMBER) {
	                    content.outerHeight(component.get('height') - content.outerHeight(true) + content.outerHeight());
	                }
	                widget.resize();
	                // prevent any side effect
	                e.preventDefault();
	                // prevent event to bubble on stage
	                e.stopPropagation();
	            }
	
	            /**
	             * Component validation
	             * @param component
	             * @param pageIdx
	             */
	            /*
	            validate: function (component, pageIdx) {
	                var ret = Tool.fn.validate.call(this, component, pageIdx);
	                var description = this.description; // tool description
	                var messages = this.i18n.messages;
	                if (component.attributes) {
	                    if (!RX_AUDIO.test(component.attributes.mp3)) {
	                        ret.push({
	                            type: ERROR,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidAudioFile, description, pageIdx + 1)
	                        });
	                    }
	                    // Note: we are not testing for an ogg file
	                }
	                return ret;
	            }
	            */
	
	        });
	        tools.register(Chart);
	
	        var CHARGRID = '<div data-#= ns #role="chargrid" data-#= ns #scaler=".kj-stage" data-#= ns #container=".kj-stage>div[data-role=stage]" data-#= ns #columns="#: attributes.columns #" data-#= ns #rows="#: attributes.rows #" data-#= ns #blank="#: attributes.blank #" data-#= ns #whitelist="#: attributes.whitelist #" data-#= ns #grid-fill="#: attributes.gridFill #" data-#= ns #grid-stroke="#: attributes.gridStroke #" data-#= ns #blank-fill="#: attributes.gridStroke #" data-#= ns #selected-fill="#: attributes.selectedFill #" data-#= ns #locked-fill="#: attributes.lockedFill #" data-#= ns #locked-color="#: attributes.fontColor #" data-#= ns #value-color="#: attributes.fontColor #" {0}></div>';
	        /**
	         * @class CharGrid tool
	         * @type {void|*}
	         */
	        var CharGrid = Tool.extend({
	            id: 'chargrid',
	            icon: 'dot_matrix',
	            description: i18n.chargrid.description,
	            cursor: CURSOR_CROSSHAIR,
	            weight: 8,
	            templates: {
	                design: kendo.format(CHARGRID, 'data-#= ns #value="#: JSON.stringify(attributes.layout) #" data-#= ns #locked="#: JSON.stringify(attributes.layout) #" data-#= ns #enable="false"'),
	                play: kendo.format(CHARGRID, 'data-#= ns #bind="value: #: properties.name #.value" data-#= ns #locked="#: JSON.stringify(attributes.layout) #"'),
	                review: kendo.format(CHARGRID, 'data-#= ns #bind="value: #: properties.name #.value" data-#= ns #locked="#: JSON.stringify(attributes.layout) #" data-#= ns #enable="false"') + Tool.fn.showResult()
	            },
	            height: 400,
	            width: 400,
	            attributes: {
	                columns: new adapters.NumberAdapter({ title: i18n.chargrid.attributes.columns.title, defaultValue: 9 }, { 'data-decimals': 0, 'data-format': 'n0', 'data-min': 1, 'data-max': 20 }),
	                rows: new adapters.NumberAdapter({ title: i18n.chargrid.attributes.rows.title, defaultValue: 9 }, { 'data-decimals': 0, 'data-format': 'n0', 'data-min': 1, 'data-max': 20 }),
	                blank: new adapters.StringAdapter({ title: i18n.chargrid.attributes.blank.title, defaultValue: '.' }),
	                whitelist: new adapters.StringAdapter({ title: i18n.chargrid.attributes.whitelist.title, defaultValue: '1-9' }),
	                layout: new adapters.CharGridAdapter({ title: i18n.chargrid.attributes.layout.title, defaultValue: null }),
	                gridFill: new adapters.ColorAdapter({ title: i18n.chargrid.attributes.gridFill.title, defaultValue: '#ffffff' }),
	                gridStroke: new adapters.ColorAdapter({ title: i18n.chargrid.attributes.gridStroke.title, defaultValue: '#000000' }),
	                // blankFill = gridStroke
	                selectedFill: new adapters.ColorAdapter({ title: i18n.chargrid.attributes.selectedFill.title, defaultValue: '#ffffcc' }),
	                lockedFill: new adapters.ColorAdapter({ title: i18n.chargrid.attributes.lockedFill.title, defaultValue: '#e6e6e6' }),
	                // lockedColor = valueColor = fontColor
	                fontColor: new adapters.ColorAdapter({ title: i18n.chargrid.attributes.fontColor.title, defaultValue: '#9999b6' })
	            },
	            properties: {
	                name: new adapters.NameAdapter({ title: i18n.chargrid.properties.name.title }),
	                description: new adapters.DescriptionAdapter({ title: i18n.chargrid.properties.description.title }),
	                solution: new adapters.CharGridAdapter({ title: i18n.chargrid.properties.solution.title }),
	                validation: new adapters.ValidationAdapter({ title: i18n.chargrid.properties.validation.title }),
	                success: new adapters.ScoreAdapter({ title: i18n.chargrid.properties.success.title, defaultValue: 1 }),
	                failure: new adapters.ScoreAdapter({ title: i18n.chargrid.properties.failure.title, defaultValue: 0 }),
	                omit: new adapters.ScoreAdapter({ title: i18n.chargrid.properties.omit.title, defaultValue: 0 })
	            },
	
	            /**
	             * Improved display of value in score grid
	             * @param value
	             */
	            value$: function (value) {
	                // var ret = '<table>';
	                var ret = '';
	                if ($.isArray(value) || value instanceof ObservableArray) {
	                    for (var r = 0, rowTotal = value.length; r < rowTotal; r++) {
	                        var row = value[r];
	                        // ret += '<tr>';
	                        for (var c = 0, colTotal = row.length; c < colTotal; c++) {
	                            // ret += '<td>' + kendo.htmlEncode(row[c] || '') + '</td>';
	                            ret += kendo.htmlEncode(row[c] || '') + (c === colTotal - 1 ? '' : ',');
	                        }
	                        // ret += '</tr>';
	                        ret += '<br/>';
	                    }
	                }
	                // ret += '</table>';
	                return ret;
	            },
	
	            /**
	             * Improved display of solution in score grid
	             * @param solution
	             */
	            solution$: function (solution) {
	                // var ret = '<table>';
	                var ret = '';
	                if ($.isArray(solution) || solution instanceof ObservableArray) {
	                    for (var r = 0, rowTotal = solution.length; r < rowTotal; r++) {
	                        var row = solution[r];
	                        // ret += '<tr>';
	                        for (var c = 0, colTotal = row.length; c < colTotal; c++) {
	                            // ret += '<td>' + kendo.htmlEncode(row[c] || '') + '</td>';
	                            ret += kendo.htmlEncode(row[c] || '') + (c === colTotal - 1 ? '' : ',');
	                        }
	                        // ret += '</tr>';
	                        ret += '<br/>';
	                    }
	                }
	                // ret += '</table>';
	                return ret;
	            },
	
	            /**
	             * onResize Event Handler
	             * @method onResize
	             * @param e
	             * @param component
	             */
	            onResize: function (e, component) {
	                var stageElement = $(e.currentTarget);
	                assert.ok(stageElement.is(ELEMENT_CLASS), kendo.format('e.currentTarget is expected to be a stage element'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                var content = stageElement.children('div.kj-chargrid');
	                if ($.type(component.width) === NUMBER) {
	                    content.outerWidth(component.get('width') - content.outerWidth(true) + content.outerWidth());
	                }
	                if ($.type(component.height) === NUMBER) {
	                    content.outerHeight(component.get('height') - content.outerHeight(true) + content.outerHeight());
	                }
	                // Redraw the charGrid widget
	                var charGridWidget = content.data('kendoCharGrid');
	                assert.instanceof(kendo.ui.CharGrid, charGridWidget, kendo.format(assert.messages.instanceof.default, 'charGridWidget', 'kendo.ui.CharGrid'));
	                charGridWidget.refresh();
	                // prevent any side effect
	                e.preventDefault();
	                // prevent event to bubble on stage
	                e.stopPropagation();
	            }
	
	        });
	        tools.register(CharGrid);
	
	        var CHECKBOX = '<div data-#= ns #role="multicheckbox" {0} data-#= ns #source="#: JSON.stringify(attributes.data.trim().split(\'\\n\')) #" style="#: attributes.groupStyle #" data-#= ns #item-style="#: attributes.itemStyle #" data-#= ns #selected-style="#: attributes.selectedStyle #"></div>';
	        /**
	         * Checkbox tool
	         * @class CheckBox
	         * @type {void|*}
	         */
	        var CheckBox = Tool.extend({
	            id: 'checkbox',
	            icon: 'checkbox',
	            description: i18n.checkbox.description,
	            cursor: CURSOR_CROSSHAIR,
	            weight: 1,
	            templates: {
	                design: kendo.format(CHECKBOX, 'data-#= ns #enable="false"'),
	                play: kendo.format(CHECKBOX, 'data-#= ns #bind="value: #: properties.name #.value"'),
	                review: kendo.format(CHECKBOX, 'data-#= ns #bind="value: #: properties.name #.value" data-#= ns #enable="false"') + Tool.fn.showResult()
	            },
	            height: 200,
	            width: 350,
	            attributes: {
	                groupStyle: new adapters.StyleAdapter({ title: i18n.checkbox.attributes.groupStyle.title, defaultValue: 'font-size: 60px;' }),
	                itemStyle: new adapters.StyleAdapter({ title: i18n.checkbox.attributes.itemStyle.title }),
	                selectedStyle: new adapters.StyleAdapter({ title: i18n.checkbox.attributes.selectedStyle.title }),
	                data: new adapters.TextAdapter(
	                    { title: i18n.checkbox.attributes.data.title, defaultValue: i18n.checkbox.attributes.data.defaultValue },
	                    { rows: 4, style: 'resize:vertical; width: 100%;' }
	                )
	            },
	            properties: {
	                name: new adapters.NameAdapter({ title: i18n.checkbox.properties.name.title }),
	                description: new adapters.DescriptionAdapter({ title: i18n.checkbox.properties.description.title }),
	                solution: new adapters.StringArrayAdapter({ title: i18n.checkbox.properties.solution.title }),
	                validation: new adapters.ValidationAdapter({ title: i18n.checkbox.properties.validation.title }),
	                success: new adapters.ScoreAdapter({ title: i18n.checkbox.properties.success.title, defaultValue: 1 }),
	                failure: new adapters.ScoreAdapter({ title: i18n.checkbox.properties.failure.title, defaultValue: 0 }),
	                omit: new adapters.ScoreAdapter({ title: i18n.checkbox.properties.omit.title, defaultValue: 0 })
	            },
	
	            /**
	             * Improved display of value in score grid
	             * @param value
	             */
	            value$: function (value) {
	                var ret = (value || []).slice();
	                for (var i = 0; i < ret.length; i++) {
	                    ret[i] = kendo.htmlEncode(ret[i]);
	                }
	                return ret.join('<br/>');
	            },
	
	            /**
	             * Improved display of solution in score grid
	             * @param solution
	             */
	            solution$: function (solution) {
	                return kendo.htmlEncode(solution || '').split('\n').join('<br/>');
	            },
	
	            /**
	             * onResize Event Handler
	             * @method onResize
	             * @param e
	             * @param component
	             */
	            onResize: function (e, component) {
	                var stageElement = $(e.currentTarget);
	                assert.ok(stageElement.is(ELEMENT_CLASS), kendo.format('e.currentTarget is expected to be a stage element'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                var content = stageElement.children('div').first();
	                if ($.type(component.width) === NUMBER) {
	                    content.outerWidth(component.get('width') - content.outerWidth(true) + content.outerWidth());
	                }
	                if ($.type(component.height) === NUMBER) {
	                    content.outerHeight(component.get('height') - content.outerHeight(true) + content.outerHeight());
	                    // if (component.attributes && !RX_FONT_SIZE.test(component.attributes.style)) {
	                    //     content.css('font-size', Math.floor(0.85 * content.height()));
	                    // }
	                }
	                // prevent any side effect
	                e.preventDefault();
	                // prevent event to bubble on stage
	                e.stopPropagation();
	            },
	
	            /**
	             * Component validation
	             * @param component
	             * @param pageIdx
	             */
	            validate: function (component, pageIdx) {
	                var ret = Tool.fn.validate.call(this, component, pageIdx);
	                var description = this.description; // tool description
	                var messages = this.i18n.messages;
	                if (component.attributes) {
	                    if ((component.attributes.groupStyle && !RX_STYLE.test(component.attributes.groupStyle)) ||
	                        (component.attributes.itemStyle && !RX_STYLE.test(component.attributes.itemStyle)) ||
	                        (component.attributes.selectedStyle && !RX_STYLE.test(component.attributes.selectedStyle))) {
	                        ret.push({
	                            type: ERROR,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidStyle, description, pageIdx + 1)
	                        });
	                    }
	                    if (!RX_DATA.test(component.attributes.data)) {
	                        ret.push({
	                            type: ERROR,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidData, description, pageIdx + 1)
	                        });
	                    }
	                }
	                return ret;
	            }
	
	        });
	        tools.register(CheckBox);
	
	        var CONNECTOR = '<div data-#= ns #role="connector" data-#= ns #id="#: properties.name #" data-#= ns #target-value="#: properties.solution #" data-#= ns #scaler=".kj-stage" data-#= ns #container=".kj-stage>div[data-#= ns #role=stage]" data-#= ns #color="#: attributes.color #" {0}></div>';
	        /**
	         * @class Connector tool
	         * @type {void|*}
	         */
	        var Connector = Tool.extend({
	            id: 'connector',
	            icon: 'target',
	            description: i18n.connector.description,
	            cursor: CURSOR_CROSSHAIR,
	            weight: 0.25,
	            templates: {
	                design: kendo.format(CONNECTOR, 'data-#= ns #enable="false" data-#= ns #has-surface="false"'),
	                play: kendo.format(CONNECTOR, 'data-#= ns #bind="value: #: properties.name #.value, source: connections"'),
	                review: kendo.format(CONNECTOR, 'data-#= ns #bind="value: #: properties.name #.value, source: connections" data-#= ns #enable="false"') + Tool.fn.showResult()
	            },
	            height: 70,
	            width: 70,
	            attributes: {
	                color: new adapters.ColorAdapter({ title: i18n.connector.attributes.color.title, defaultValue: '#FF0000' })
	            },
	            properties: {
	                name: new adapters.NameAdapter({ title: i18n.connector.properties.name.title }),
	                description: new adapters.DescriptionAdapter({ title: i18n.connector.properties.description.title }),
	                solution: new adapters.ConnectorAdapter({ title: i18n.connector.properties.solution.title }),
	                validation: new adapters.ValidationAdapter({ title: i18n.connector.properties.validation.title }),
	                success: new adapters.ScoreAdapter({ title: i18n.connector.properties.success.title, defaultValue: 0.5 }),
	                failure: new adapters.ScoreAdapter({ title: i18n.connector.properties.failure.title, defaultValue: 0 }),
	                omit: new adapters.ScoreAdapter({ title: i18n.connector.properties.omit.title, defaultValue: 0 })
	            },
	
	            /**
	             * onResize Event Handler
	             * @method onResize
	             * @param e
	             * @param component
	             */
	            onResize: function (e, component) {
	                var stageElement = $(e.currentTarget);
	                assert.ok(stageElement.is(ELEMENT_CLASS), kendo.format('e.currentTarget is expected to be a stage element'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                var content = stageElement.children('div[' + kendo.attr('role') + '="connector"]');
	                if ($.type(component.width) === NUMBER) {
	                    content.outerWidth(component.get('width') - content.outerWidth(true) + content.outerWidth());
	                }
	                if ($.type(component.height) === NUMBER) {
	                    content.outerHeight(component.get('height') - content.outerHeight(true) + content.outerHeight());
	                }
	                // Redraw the connector widget
	                var connectorWidget = content.data('kendoConnector');
	                assert.instanceof(kendo.ui.Connector, connectorWidget, kendo.format(assert.messages.instanceof.default, 'connectorWidget', 'kendo.ui.Connector'));
	                connectorWidget._drawConnector();
	
	                // prevent any side effect
	                e.preventDefault();
	                // prevent event to bubble on stage
	                e.stopPropagation();
	            },
	
	            /**
	             * Component validation
	             * @param component
	             * @param pageIdx
	             */
	            validate: function (component, pageIdx) {
	                var ret = Tool.fn.validate.call(this, component, pageIdx);
	                var description = this.description; // tool description
	                var messages = this.i18n.messages;
	                if (component.attributes) {
	                    if (component.attributes.color && !RX_COLOR.test(component.attributes.color)) {
	                        ret.push({
	                            type: WARNING,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidColor, description, pageIdx + 1)
	                        });
	                    }
	                }
	                return ret;
	            }
	
	        });
	        tools.register(Connector);
	
	        var DROPZONE = '<div id="#: properties.name #" data-#= ns #role="dropzone" data-#= ns #scaler=".kj-stage" data-#= ns #container=".kj-stage>div[data-role=stage]" data-#= ns #draggable=".kj-element:has([data-draggable=true])" style="#: attributes.style #" {0}><div>#: attributes.text #</div></div>';
	        /**
	         * @class Connector tool
	         * @type {void|*}
	         */
	        var DropZone = Tool.extend({
	            id: 'dropzone',
	            icon: 'elements_selection',
	            description: i18n.dropzone.description,
	            cursor: CURSOR_CROSSHAIR,
	            weight: 1,
	            templates: {
	                design: kendo.format(DROPZONE, 'data-#= ns #enable="false"'),
	                play: kendo.format(DROPZONE, 'data-#= ns #bind="value: #: properties.name #.value, source: draggables"'),
	                review: kendo.format(DROPZONE, 'data-#= ns #bind="value: #: properties.name #.value, source: draggables" data-#= ns #enable="false"') + Tool.fn.showResult()
	            },
	            height: 250,
	            width: 250,
	            attributes: {
	                text: new adapters.StringAdapter({ title: i18n.dropzone.attributes.text.title, defaultValue: i18n.dropzone.attributes.text.defaultValue }),
	                style: new adapters.StyleAdapter({ title: i18n.dropzone.attributes.style.title, defaultValue: 'font-size: 30px; border: dashed 3px #e1e1e1;' })
	            },
	            properties: {
	                name: new adapters.NameAdapter({ title: i18n.dropzone.properties.name.title }),
	                description: new adapters.DescriptionAdapter({ title: i18n.dropzone.properties.description.title }),
	                solution: new adapters.StringArrayAdapter({ title: i18n.dropzone.properties.solution.title }),
	                validation: new adapters.ValidationAdapter({ title: i18n.dropzone.properties.validation.title }),
	                success: new adapters.ScoreAdapter({ title: i18n.dropzone.properties.success.title, defaultValue: 1 }),
	                failure: new adapters.ScoreAdapter({ title: i18n.dropzone.properties.failure.title, defaultValue: 0 }),
	                omit: new adapters.ScoreAdapter({ title: i18n.dropzone.properties.omit.title, defaultValue: 0 })
	            },
	
	            /**
	             * Improved display of value in score grid
	             * @param value
	             */
	            value$: function (value) {
	                var ret = (value || []).slice();
	                for (var i = 0; i < ret.length; i++) {
	                    ret[i] = kendo.htmlEncode(ret[i]);
	                }
	                return ret.join('<br/>');
	            },
	
	            /**
	             * Improved display of solution in score grid
	             * @param solution
	             */
	            solution$: function (solution) {
	                return kendo.htmlEncode(solution || '').split('\n').join('<br/>');
	            },
	
	            /**
	             * onResize Event Handler
	             * @method onResize
	             * @param e
	             * @param component
	             */
	            onResize: function (e, component) {
	                var stageElement = $(e.currentTarget);
	                assert.ok(stageElement.is(ELEMENT_CLASS), kendo.format('e.currentTarget is expected to be a stage element'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                var content = stageElement.children('div');
	                if ($.type(component.width) === NUMBER) {
	                    content.outerWidth(component.get('width') - content.outerWidth(true) + content.outerWidth());
	                }
	                if ($.type(component.height) === NUMBER) {
	                    content.outerHeight(component.get('height') - content.outerHeight(true) + content.outerHeight());
	                }
	                // prevent any side effect
	                e.preventDefault();
	                // prevent event to bubble on stage
	                e.stopPropagation();
	            },
	
	            /**
	             * Component validation
	             * @param component
	             * @param pageIdx
	             */
	            validate: function (component, pageIdx) {
	                var ret = Tool.fn.validate.call(this, component, pageIdx);
	                var description = this.description; // tool description
	                var messages = this.i18n.messages;
	                if (component.attributes) {
	                    // Note: any text is acceptable
	                    if (component.attributes.style && !RX_STYLE.test(component.attributes.style)) {
	                        ret.push({
	                            type: ERROR,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidStyle, description, pageIdx + 1)
	                        });
	                    }
	                }
	                return ret;
	            }
	
	        });
	        tools.register(DropZone);
	
	        /**
	         * @class Image tool
	         * @type {void|*}
	         */
	        var Image = Tool.extend({
	            id: 'image',
	            icon: 'painting_landscape',
	            description: i18n.image.description,
	            cursor: CURSOR_CROSSHAIR,
	            templates: {
	                default: '<img src="#: attributes.src$() #" alt="#: attributes.alt #" style="#: attributes.style #" data-#= ns #id="#: properties.id$() #" data-#= ns #draggable="#: properties.draggable #" data-#= ns #drop-value="#: properties.dropValue #">'
	            },
	            height: 250,
	            width: 250,
	            attributes: {
	                alt: new adapters.StringAdapter({ title: i18n.image.attributes.alt.title, defaultValue: i18n.image.attributes.alt.defaultValue }),
	                src: new adapters.AssetAdapter({ title: i18n.image.attributes.src.title, defaultValue: i18n.image.attributes.src.defaultValue }),
	                style: new adapters.StyleAdapter({ title: i18n.image.attributes.style.title })
	            },
	            properties: {
	                draggable: new adapters.BooleanAdapter({ title: i18n.image.properties.draggable.title, defaultValue: false }),
	                dropValue: new adapters.StringAdapter({ title: i18n.image.properties.dropValue.title })
	            },
	
	            /**
	             * Get Html or jQuery content
	             * @method getHtmlContent
	             * @param component
	             * @param mode
	             * @returns {*}
	             */
	            getHtmlContent: function (component, mode) {
	                var that = this;
	                assert.instanceof(Image, that, kendo.format(assert.messages.instanceof.default, 'this', 'Image'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                assert.enum(Object.keys(kendo.ui.Stage.fn.modes), mode, kendo.format(assert.messages.enum.default, 'mode', Object.keys(kendo.ui.Stage.fn.modes)));
	                assert.instanceof(ToolAssets, assets.image, kendo.format(assert.messages.instanceof.default, 'assets.image', 'kidoju.ToolAssets'));
	                var template = kendo.template(that.templates.default);
	                // The src$ function resolves urls with schemes like cdn://sample.jpg
	                component.attributes.src$ = function () {
	                    var src = component.attributes.get('src');
	                    var schemes = assets.image.schemes;
	                    for (var scheme in schemes) {
	                        if (schemes.hasOwnProperty(scheme) && (new RegExp('^' + scheme + '://')).test(src)) {
	                            src = src.replace(scheme + '://', schemes[scheme]);
	                            break;
	                        }
	                    }
	                    return src;
	                };
	                // The id$ function returns the component id for draggable components
	                component.properties.id$ = function () {
	                    return component.properties.draggable && $.type(component.id) === STRING && component.id.length ? component.id : '';
	                };
	                return template($.extend(component, { ns: kendo.ns }));
	            },
	
	            /**
	             * onResize Event Handler
	             * @method onResize
	             * @param e
	             * @param component
	             */
	            onResize: function (e, component) {
	                var stageElement = $(e.currentTarget);
	                assert.ok(stageElement.is(ELEMENT_CLASS), kendo.format('e.currentTarget is expected to be a stage element'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                var content = stageElement.children('img');
	                // Assuming we can get the natural size of the image, we shall keep proportions
	                var naturalHeight = content[0].naturalHeight;
	                var naturalWidth = content[0].naturalWidth;
	                if (naturalHeight && naturalWidth) {
	                    var height = component.get('height');
	                    var width = component.get('width');
	                    var rectLimitedByHeight = {
	                        height: Math.round(height),
	                        width: Math.round(height * naturalWidth / naturalHeight)
	                    };
	                    /*
	                     // Note: comparing rectLimitedByHeight and rectLimitedByWidth does not work because
	                     // we are using the component size and not the mouse position
	                     // therefore, we can only reduce the size proportionnaly, not increase it
	                     var rectLimitedByWidth = {
	                     height: Math.round(width * naturalHeight / naturalWidth),
	                     width: Math.round(width)
	                     };
	                     // if (rectLimitedByHeight.height * rectLimitedByHeight.width <= rectLimitedByWidth.height * rectLimitedByWidth.width) {
	                     if (rectLimitedByHeight.width <= width) {
	                     */
	                    if (height !== rectLimitedByHeight.height) { // avoids a stack overflow
	                        component.set('height', rectLimitedByHeight.height);
	                    }
	                    if (width !== rectLimitedByHeight.width) { // avoids a stack overflow
	                        component.set('width', rectLimitedByHeight.width);
	                    }
	                    /*
	                     } else if(rectLimitedByWidth.height <= height) {
	                     if (height !== rectLimitedByWidth.height) {
	                     component.set('height', rectLimitedByWidth.height);
	                     }
	                     if (width !== rectLimitedByWidth.width) {
	                     component.set('width', rectLimitedByWidth.width);
	                     }
	                     }
	                     */
	                }
	                // Set content size
	                content.outerHeight(component.get('height') - content.outerHeight(true) + content.outerHeight());
	                content.outerWidth(component.get('width') - content.outerWidth(true) + content.outerWidth());
	                // prevent any side effect
	                e.preventDefault();
	                // prevent event to bubble on stage
	                e.stopPropagation();
	            },
	
	            /* This function's cyclomatic complexity is too high. */
	            /* jshint -W074 */
	
	            /**
	             * Component validation
	             * @param component
	             * @param pageIdx
	             */
	            validate: function (component, pageIdx) {
	                /* jshint maxcomplexity: 8 */
	                var ret = Tool.fn.validate.call(this, component, pageIdx);
	                var description = this.description; // tool description
	                var messages = this.i18n.messages;
	                if (component.attributes) {
	                    if ((component.attributes.alt === i18n.image.attributes.alt.defaultValue) || !RX_TEXT.test(component.attributes.alt)) {
	                        ret.push({
	                            type: WARNING,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidAltText, description, pageIdx + 1)
	                        });
	                    }
	                    if ((component.attributes.src === i18n.image.attributes.src.defaultValue) || !RX_IMAGE.test(component.attributes.src)) {
	                        ret.push({
	                            type: (component.attributes.src === i18n.image.attributes.src.defaultValue) ? WARNING : ERROR,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidImageFile, description, pageIdx + 1)
	                        });
	                    }
	                    if (component.attributes.style && !RX_STYLE.test(component.attributes.style)) {
	                        ret.push({
	                            type: ERROR,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidStyle, description, pageIdx + 1)
	                        });
	                    }
	                }
	                return ret;
	            }
	
	            /* jshint +W074 */
	
	        });
	        tools.register(Image);
	
	        /**
	         * @class Label tool
	         * @type {void|*}
	         */
	        var Label = Tool.extend({
	            id: 'label',
	            icon: 'font',
	            description: i18n.label.description,
	            cursor: CURSOR_CROSSHAIR,
	            templates: {
	                default: '<div style="#: attributes.style #" data-#= ns #id="#: properties.id$() #" data-#= ns #draggable="#: properties.draggable #" data-#= ns #drop-value="#: properties.dropValue #">#= (kendo.htmlEncode(attributes.text) || "").replace(/\\n/g, "<br/>") #</div>'
	            },
	            height: 80,
	            width: 300,
	            attributes: {
	                // text: new adapters.StringAdapter({ title: i18n.label.attributes.text.title, defaultValue: i18n.label.attributes.text.defaultValue }),
	                text: new adapters.TextAdapter(
	                    { title:i18n.label.attributes.text.title, defaultValue: i18n.label.attributes.text.defaultValue },
	                    { rows: 2, style: 'resize:vertical; width: 100%;' }
	                ),
	                style: new adapters.StyleAdapter({ title: i18n.label.attributes.style.title, defaultValue: 'font-size: 60px;' })
	            },
	            properties: {
	                draggable: new adapters.BooleanAdapter({ title: i18n.label.properties.draggable.title, defaultValue: false }),
	                dropValue: new adapters.StringAdapter({ title: i18n.label.properties.dropValue.title })
	            },
	
	            /**
	             * Get Html or jQuery content
	             * @method getHtmlContent
	             * @param component
	             * @param mode
	             * @returns {*}
	             */
	            getHtmlContent: function (component, mode) {
	                var that = this;
	                assert.instanceof(Label, that, kendo.format(assert.messages.instanceof.default, 'this', 'Label'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                assert.enum(Object.keys(kendo.ui.Stage.fn.modes), mode, kendo.format(assert.messages.enum.default, 'mode', Object.keys(kendo.ui.Stage.fn.modes)));
	                var template = kendo.template(that.templates.default);
	                // The id$ function returns the component id for draggable components
	                component.properties.id$ = function () {
	                    return component.properties.draggable && $.type(component.id) === STRING && component.id.length ? component.id : '';
	                };
	                return template($.extend(component, { ns: kendo.ns }));
	            },
	
	            /**
	             * onResize Event Handler
	             * @method onResize
	             * @param e
	             * @param component
	             */
	            onResize: function (e, component) {
	                var stageElement = $(e.currentTarget);
	                assert.ok(stageElement.is(ELEMENT_CLASS), kendo.format('e.currentTarget is expected to be a stage element'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                var content = stageElement.children('div');
	                if ($.type(component.width) === NUMBER) {
	                    content.outerWidth(component.get('width') - content.outerWidth(true) + content.outerWidth());
	                }
	                if ($.type(component.height) === NUMBER) {
	                    content.outerHeight(component.get('height') - content.outerHeight(true) + content.outerHeight());
	                    // if (component.attributes && !RX_FONT_SIZE.test(component.attributes.style)) {
	                    /*
	                     * We make a best guess for the number of lines as follows
	                     * Let's suppose the height (line-height, not font-size) and width of a character are respectively y and x
	                     * We have y = x * sizeRatio
	                     * How many of these character rectangles (x, y) can we fit in the content div (width, height)?
	                     *
	                     * the label only takes 1 line, if we have:
	                     * y = height and length <= width/x, that is length <= width*sizeRatio/y or y = height <= length*sizeRatio/width, which is length >= width*sizeRatio/height
	                     *
	                     * the label takes 2 lines, if we have:
	                     * y = height/2 and length <= width/x, that is length <= 2*width*sizeRatio/y or y = height/2 <= length*sizeRatio/width, which is length >= 4*width*sizeRatio/height
	                     *
	                     * the label takes n lines if we have sqrt((length*height)/sizeRatio*width) <= lines < sqrt(((length + 1)*height)/sizeRatio*width)
	                     *
	                     */
	                    // var length = component.attributes.text.length;
	                    // var sizeRatio = 1.6; // font-size being the height, this is the line-height/char-width ratio
	                    // var lines = Math.max(1, Math.floor(Math.sqrt((length * component.height) / (width * sizeRatio))));
	                    // We can now make a best guess for the font size
	                    // var fontRatio = 1.2; // this is the line-height/font-size ration
	                    // content.css('font-size', Math.floor(component.height / lines / fontRatio));
	                    // Note: in previous versions, we have tried to iterate through a hidden clone
	                    // to find that font size that does not trigger an overflow but it is too slow
	                    // }
	                }
	                // prevent any side effect
	                e.preventDefault();
	                // prevent event to bubble on stage
	                e.stopPropagation();
	            },
	
	            /**
	             * Component validation
	             * @param component
	             * @param pageIdx
	             */
	            validate: function (component, pageIdx) {
	                var ret = Tool.fn.validate.call(this, component, pageIdx);
	                var description = this.description; // tool description
	                var messages = this.i18n.messages;
	                if (component.attributes) {
	                    if ((component.attributes.text === i18n.label.attributes.text.defaultValue) || !RX_TEXT.test(component.attributes.text)) {
	                        ret.push({
	                            type: WARNING,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidText, description, pageIdx + 1)
	                        });
	                    }
	                    if (component.attributes.style && !RX_STYLE.test(component.attributes.style)) {
	                        // TODO: test small font-size incompatible with mobile devices
	                        ret.push({
	                            type: ERROR,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidStyle, description, pageIdx + 1)
	                        });
	                    }
	                }
	                return ret;
	            }
	
	        });
	        tools.register(Label);
	
	        /**
	         * @class MathExpression tool
	         * @type {void|*}
	         */
	        var MathExpression = Tool.extend({
	            id: 'mathexpression',
	            icon: 'formula',
	            description: i18n.mathexpression.description,
	            cursor: CURSOR_CROSSHAIR,
	            templates: {
	                default: '<div data-#= ns #role="mathexpression" style="#: attributes.style #" data-#= ns #value="#: attributes.formula #"></div>'
	            },
	            height: 150,
	            width: 480,
	            attributes: {
	                formula: new adapters.TextAdapter(
	                    { title: i18n.mathexpression.attributes.formula.title, defaultValue: i18n.mathexpression.attributes.formula.defaultValue },
	                    { rows: 4, style: 'resize:vertical; width: 100%;' }
	                ),
	                style: new adapters.StyleAdapter({ title: i18n.mathexpression.attributes.style.title, defaultValue: 'font-size: 40px;' })
	            },
	
	            /**
	             * onResize Event Handler
	             * @method onResize
	             * @param e
	             * @param component
	             */
	            onResize: function (e, component) {
	                var stageElement = $(e.currentTarget);
	                assert.ok(stageElement.is(ELEMENT_CLASS), kendo.format('e.currentTarget is expected to be a stage element'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                var content = stageElement.children('div');
	                if ($.type(component.width) === NUMBER) {
	                    content.outerWidth(component.get('width') - content.outerWidth(true) + content.outerWidth());
	                }
	                if ($.type(component.height) === NUMBER) {
	                    content.outerHeight(component.get('height') - content.outerHeight(true) + content.outerHeight());
	                }
	                // prevent any side effect
	                e.preventDefault();
	                // prevent event to bubble on stage
	                e.stopPropagation();
	            },
	
	            /**
	             * Component validation
	             * @param component
	             * @param pageIdx
	             */
	            validate: function (component, pageIdx) {
	                var ret = Tool.fn.validate.call(this, component, pageIdx);
	                var description = this.description; // tool description
	                var messages = this.i18n.messages;
	                if (component.attributes) {
	                    if ((component.attributes.formula === i18n.mathexpression.attributes.formula.defaultValue) || !RX_FORMULA.test(component.attributes.formula)) {
	                        // TODO: improve RX_FORMULA
	                        ret.push({
	                            type: WARNING,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidFormula, description, pageIdx + 1)
	                        });
	                    }
	                    if (component.attributes.style && !RX_STYLE.test(component.attributes.style)) {
	                        ret.push({
	                            type: ERROR,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidStyle, description, pageIdx + 1)
	                        });
	                    }
	                }
	                return ret;
	            }
	
	        });
	        tools.register(MathExpression);
	
	        var QUIZ = '<div data-#= ns #role="quiz" data-#= ns #mode="#: attributes.mode #" {0} data-#= ns #source="#: JSON.stringify(attributes.data.trim().split(\'\\n\')) #" style="#: attributes.groupStyle #" data-#= ns #item-style="#: attributes.itemStyle #" data-#= ns #selected-style="#: attributes.selectedStyle #"></div>';
	        /**
	         * Quiz tool
	         * @class Quiz
	         * @type {void|*}
	         */
	        var Quiz = Tool.extend({
	            id: 'quiz',
	            icon: 'radio_button_group',
	            description: i18n.quiz.description,
	            cursor: CURSOR_CROSSHAIR,
	            weight: 1,
	            templates: {
	                design: kendo.format(QUIZ, 'data-#= ns #enable="false"'),
	                play: kendo.format(QUIZ, 'data-#= ns #bind="value: #: properties.name #.value"'),
	                review: kendo.format(QUIZ, 'data-#= ns #bind="value: #: properties.name #.value" data-#= ns #enable="false"') + Tool.fn.showResult()
	            },
	            height: 200,
	            width: 350,
	            attributes: {
	                mode: new adapters.EnumAdapter(
	                    { title: i18n.quiz.attributes.mode.title, defaultValue: 'button', enum: ['button', 'dropdown', 'radio'] },
	                    { style: 'width: 100%;' }
	                ),
	                groupStyle: new adapters.StyleAdapter({ title: i18n.quiz.attributes.groupStyle.title, defaultValue: 'font-size: 60px;' }),
	                itemStyle: new adapters.StyleAdapter({ title: i18n.quiz.attributes.itemStyle.title }),
	                selectedStyle: new adapters.StyleAdapter({ title: i18n.quiz.attributes.selectedStyle.title }),
	                data: new adapters.TextAdapter(
	                    { title: i18n.quiz.attributes.data.title, defaultValue: i18n.quiz.attributes.data.defaultValue },
	                    { rows: 4, style: 'resize:vertical; width: 100%;' }
	                )
	            },
	            properties: {
	                name: new adapters.NameAdapter({ title: i18n.quiz.properties.name.title }),
	                description: new adapters.DescriptionAdapter({ title: i18n.quiz.properties.description.title }),
	                solution: new adapters.QuizAdapter({ title: i18n.quiz.properties.solution.title }),
	                validation: new adapters.ValidationAdapter({ title: i18n.quiz.properties.validation.title }),
	                success: new adapters.ScoreAdapter({ title: i18n.quiz.properties.success.title, defaultValue: 1 }),
	                failure: new adapters.ScoreAdapter({ title: i18n.quiz.properties.failure.title, defaultValue: 0 }),
	                omit: new adapters.ScoreAdapter({ title: i18n.quiz.properties.omit.title, defaultValue: 0 })
	            },
	
	            /* This function's cyclomatic complexity is too high. */
	            /* jshint -W074 */
	
	            /**
	             * onResize Event Handler
	             * @method onResize
	             * @param e
	             * @param component
	             */
	            onResize: function (e, component) {
	                /* jshint maxcomplexity: 8 */
	                var stageElement = $(e.currentTarget);
	                assert.ok(stageElement.is(ELEMENT_CLASS), kendo.format('e.currentTarget is expected to be a stage element'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                var content = stageElement.children('div' + kendo.roleSelector('quiz'));
	                if ($.type(component.width) === NUMBER) {
	                    content.outerWidth(component.get('width') - content.outerWidth(true) + content.outerWidth());
	                }
	                if ($.type(component.height) === NUMBER) {
	                    content.outerHeight(component.get('height') - content.outerHeight(true) + content.outerHeight());
	                }
	                /*
	                 // Auto-resize algorithm is not great so let's wait until we find a better solution
	                 var data = component.attributes.data;
	                 var length = data.trim().split('\n').length || 1;
	                 switch (component.attributes.mode) {
	                 case 'button':
	                 content.css('font-size', Math.floor(0.57 * component.height));
	                 break;
	                 case 'dropdown':
	                 content.css('font-size', Math.floor(0.5 * component.height));
	                 break;
	                 case 'radio':
	                 var h = component.height / (length || 1);
	                 content.css('font-size', Math.floor(0.9 * h));
	                 content.find('input')
	                 .height(0.6 * h)
	                 .width(0.6 * h);
	                 break;
	                 }
	                 */
	                // prevent any side effect
	                e.preventDefault();
	                // prevent event to bubble on stage
	                e.stopPropagation();
	            },
	
	            /* jshint +W074 */
	
	            /**
	             * Component validation
	             * @param component
	             * @param pageIdx
	             */
	            validate: function (component, pageIdx) {
	                var ret = Tool.fn.validate.call(this, component, pageIdx);
	                var description = this.description; // tool description
	                var messages = this.i18n.messages;
	                if (component.attributes) {
	                    if ((component.attributes.groupStyle && !RX_STYLE.test(component.attributes.groupStyle)) ||
	                        (component.attributes.itemStyle && !RX_STYLE.test(component.attributes.itemStyle)) ||
	                        (component.attributes.selectedStyle && !RX_STYLE.test(component.attributes.selectedStyle))) {
	                        ret.push({
	                            type: ERROR,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidStyle, description, pageIdx + 1)
	                        });
	                    }
	                    if (!RX_DATA.test(component.attributes.data)) {
	                        ret.push({
	                            type: ERROR,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidData, description, pageIdx + 1)
	                        });
	                    }
	                }
	                return ret;
	            }
	
	        });
	        tools.register(Quiz);
	
	        /**
	         * @class Static table tool
	         * @type {void|*}
	         */
	        var Table = Tool.extend({
	            id: 'table',
	            icon: 'table',
	            description: i18n.table.description,
	            cursor: CURSOR_CROSSHAIR,
	            templates: {
	                default: '<div data-#= ns #role="table" style="#: attributes.style #" data-#= ns #columns="#: attributes.columns #" data-#= ns #rows="#: attributes.rows #" data-#= ns #value="#: JSON.stringify(attributes.data) #"></div>'
	            },
	            height: 350,
	            width: 600,
	            attributes: {
	                columns: new adapters.NumberAdapter({ title: i18n.table.attributes.columns.title, defaultValue: 4 }, { 'data-decimals': 0, 'data-format': 'n0', 'data-min': 1, 'data-max': 20 }),
	                rows: new adapters.NumberAdapter({ title: i18n.table.attributes.rows.title, defaultValue: 6 }, { 'data-decimals': 0, 'data-format': 'n0', 'data-min': 1, 'data-max': 20 }),
	                data: new adapters.TableAdapter({ title: i18n.table.attributes.data.title, defaultValue: { sheets: [{ rows: [{ index:0, cells: [{ index:0, value: 'Table', fontSize: 48 }] }] }] } })
	            },
	
	            /**
	             * onResize Event Handler
	             * @method onResize
	             * @param e
	             * @param component
	             */
	            onResize: function (e, component) {
	                var stageElement = $(e.currentTarget);
	                assert.ok(stageElement.is(ELEMENT_CLASS), kendo.format('e.currentTarget is expected to be a stage element'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                var content = stageElement.children(kendo.roleSelector('table'));
	                if ($.type(component.width) === NUMBER) {
	                    content.outerWidth(component.get('width') - content.outerWidth(true) + content.outerWidth());
	                }
	                if ($.type(component.height) === NUMBER) {
	                    content.outerHeight(component.get('height') - content.outerHeight(true) + content.outerHeight());
	                }
	                // prevent any side effect
	                e.preventDefault();
	                // prevent event to bubble on stage
	                e.stopPropagation();
	            },
	
	            /**
	             * Component validation
	             * @param component
	             * @param pageIdx
	             */
	            validate: function (component, pageIdx) {
	                var ret = Tool.fn.validate.call(this, component, pageIdx);
	                var description = this.description; // tool description
	                var messages = this.i18n.messages;
	                if (component.attributes) {
	                    if ((component.attributes.style && !RX_STYLE.test(component.attributes.style))) {
	                        ret.push({
	                            type: ERROR,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidStyle, description, pageIdx + 1)
	                        });
	                    }
	                }
	                return ret;
	            }
	
	        });
	        tools.register(Table);
	
	        var TEXTAREA = '<textarea id="#: properties.name #" class="k-textbox" style="#: attributes.style #" {0}></textarea>';
	        /**
	         * @class Textarea tool
	         * @type {void|*}
	         */
	        var Textarea = Tool.extend({
	            id: 'textarea',
	            icon: 'document_orientation_landscape',
	            description: i18n.textarea.description,
	            cursor: CURSOR_CROSSHAIR,
	            weight: 2,
	            templates: {
	                design: kendo.format(TEXTAREA, ''),
	                play: kendo.format(TEXTAREA, 'data-#= ns #bind="value: #: properties.name #.value"'),
	                review: kendo.format(TEXTAREA, 'data-#= ns #bind="value: #: properties.name #.value"') + Tool.fn.showResult()
	            },
	            height: 300,
	            width: 500,
	            attributes: {
	                style: new adapters.StyleAdapter({ title: i18n.textarea.attributes.style.title, defaultValue: 'font-size:40px; resize:none;' })
	            },
	            properties: {
	                name: new adapters.NameAdapter({ title: i18n.textarea.properties.name.title }),
	                description: new adapters.DescriptionAdapter({ title: i18n.textarea.properties.description.title }),
	                solution: new adapters.TextAdapter({ title: i18n.textarea.properties.solution.title }),
	                validation: new adapters.ValidationAdapter({ title: i18n.textarea.properties.validation.title }),
	                success: new adapters.ScoreAdapter({ title: i18n.textarea.properties.success.title, defaultValue: 1 }),
	                failure: new adapters.ScoreAdapter({ title: i18n.textarea.properties.failure.title, defaultValue: 0 }),
	                omit: new adapters.ScoreAdapter({ title: i18n.textarea.properties.omit.title, defaultValue: 0 })
	            },
	
	            /**
	             * onEnable event handler
	             * @class Textarea
	             * @method onEnable
	             * @param e
	             * @param component
	             * @param enabled
	             */
	            onEnable: function (e, component, enabled) {
	                var stageElement = $(e.currentTarget);
	                if (stageElement.is(ELEMENT_CLASS) && component instanceof PageComponent) {
	                    stageElement.children('textarea')
	                        .prop({
	                            // disabled: !enabled, // disabled elements do not receive mousedown events in Edge and cannot be selected in design mode
	                            readonly: !enabled
	                        });
	                }
	            },
	
	            /**
	             * onResize Event Handler
	             * @method onResize
	             * @param e
	             * @param component
	             */
	            onResize: function (e, component) {
	                var stageElement = $(e.currentTarget);
	                assert.ok(stageElement.is(ELEMENT_CLASS), kendo.format('e.currentTarget is expected to be a stage element'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                var content = stageElement.children('textarea');
	                if ($.type(component.width) === NUMBER) {
	                    content.outerWidth(component.get('width') - content.outerWidth(true) + content.outerWidth());
	                }
	                if ($.type(component.height) === NUMBER) {
	                    content.outerHeight(component.get('height') - content.outerHeight(true) + content.outerHeight());
	                }
	                // prevent any side effect
	                e.preventDefault();
	                // prevent event to bubble on stage
	                e.stopPropagation();
	            },
	
	            /**
	             * Component validation
	             * @param component
	             * @param pageIdx
	             */
	            validate: function (component, pageIdx) {
	                var ret = Tool.fn.validate.call(this, component, pageIdx);
	                var description = this.description; // tool description
	                var messages = this.i18n.messages;
	                if (component.attributes) {
	                    if ((component.attributes.style && !RX_STYLE.test(component.attributes.style))) {
	                        ret.push({
	                            type: ERROR,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidStyle, description, pageIdx + 1)
	                        });
	                    }
	                }
	                return ret;
	            }
	
	        });
	        tools.register(Textarea);
	
	        // Masks cannot be properly set via data attributes. An error is raised when masks only contain digits. See the workaround in onResize for more information
	        var TEXTBOX = '<input type="text" id="#: properties.name #" data-#= ns #role="maskedtextbox" data-#= ns #prompt-char="\u25CA" style="#: attributes.style #" {0}>';
	        /**
	         * @class Textbox tool
	         * @type {void|*}
	         */
	        var Textbox = Tool.extend({
	            id: 'textbox',
	            icon: 'text_field',
	            description: i18n.textbox.description,
	            cursor: CURSOR_CROSSHAIR,
	            weight: 1,
	            templates: {
	                design: kendo.format(TEXTBOX, ''),
	                play: kendo.format(TEXTBOX, 'data-#= ns #bind="value: #: properties.name #.value"'),
	                review: kendo.format(TEXTBOX, 'data-#= ns #bind="value: #: properties.name #.value"') + Tool.fn.showResult()
	            },
	            height: 80,
	            width: 300,
	            attributes: {
	                mask: new adapters.StringAdapter({ title: i18n.textbox.attributes.mask.title }),
	                style: new adapters.StyleAdapter({ title: i18n.textbox.attributes.style.title })
	            },
	            properties: {
	                name: new adapters.NameAdapter({ title: i18n.textbox.properties.name.title }),
	                description: new adapters.DescriptionAdapter({ title: i18n.textbox.properties.description.title }),
	                solution: new adapters.StringAdapter({ title: i18n.textbox.properties.solution.title }),
	                validation: new adapters.ValidationAdapter({ title: i18n.textbox.properties.validation.title }),
	                success: new adapters.ScoreAdapter({ title: i18n.textbox.properties.success.title, defaultValue: 1 }),
	                failure: new adapters.ScoreAdapter({ title: i18n.textbox.properties.failure.title, defaultValue: 0 }),
	                omit: new adapters.ScoreAdapter({ title: i18n.textbox.properties.omit.title, defaultValue: 0 })
	            },
	
	            /**
	             * onEnable event handler
	             * @class Textbox
	             * @method onEnable
	             * @param e
	             * @param component
	             * @param enabled
	             */
	            onEnable: function (e, component, enabled) {
	                var stageElement = $(e.currentTarget);
	                if (stageElement.is(ELEMENT_CLASS) && component instanceof PageComponent) {
	                    stageElement.children('input')
	                        .prop({
	                            // disabled: !enabled, // disabled elements do not receive mousedown events in Edge and cannot be selected in design mode
	                            readonly: !enabled
	                        });
	                }
	            },
	
	            /**
	             * onResize Event Handler
	             * @method onResize
	             * @param e
	             * @param component
	             */
	            onResize: function (e, component) {
	                var stageElement = $(e.currentTarget);
	                assert.ok(stageElement.is(ELEMENT_CLASS), kendo.format('e.currentTarget is expected to be a stage element'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                var content = stageElement.children('input');
	                if ($.type(component.width) === NUMBER) {
	                    content.outerWidth(component.get('width')  - content.outerWidth(true) + content.outerWidth());
	                }
	                if ($.type(component.height) === NUMBER) {
	                    content.outerHeight(component.get('height') - content.outerHeight(true) + content.outerHeight());
	                    if (component.attributes && !RX_FONT_SIZE.test(component.attributes.style)) {
	                        content.css('font-size', Math.floor(0.65 * content.height()));
	                    }
	                }
	                // This is a trick because of http://docs.telerik.com/kendo-ui/framework/mvvm/overview#important-notes
	                // In other words it is impossible to set a mask that only contains digits declaratively (data-mask attribute)
	                // See also http://docs.telerik.com/kendo-ui/api/javascript/ui/maskedtextbox#configuration-mask
	                var maskedTextBoxWidget = content.data('kendoMaskedTextBox');
	                if (kendo.ui.MaskedTextBox && maskedTextBoxWidget instanceof kendo.ui.MaskedTextBox &&
	                    maskedTextBoxWidget.options.mask !== component.attributes.mask) {
	                    maskedTextBoxWidget.setOptions({ mask: component.attributes.mask });
	                }
	                // prevent any side effect
	                e.preventDefault();
	                // prevent event to bubble on stage
	                e.stopPropagation();
	            },
	
	            /**
	             * Component validation
	             * @param component
	             * @param pageIdx
	             */
	            validate: function (component, pageIdx) {
	                var ret = Tool.fn.validate.call(this, component, pageIdx);
	                var description = this.description; // tool description
	                var messages = this.i18n.messages;
	                if (component.attributes) {
	                    // Note: we are allowing any mask
	                    if ((component.attributes.style && !RX_STYLE.test(component.attributes.style))) {
	                        ret.push({
	                            type: ERROR,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidStyle, description, pageIdx + 1)
	                        });
	                    }
	                }
	                return ret;
	            }
	
	        });
	        tools.register(Textbox);
	
	        /**
	         * Video tool
	         * @class Video
	         */
	        var Video = Tool.extend({
	            id: 'video',
	            icon: 'movie',
	            description: i18n.video.description,
	            cursor: CURSOR_CROSSHAIR,
	            templates: {
	                default: '<div data-#= ns #role="mediaplayer" data-#= ns #mode="video" data-#= ns #autoplay="#: attributes.autoplay #" data-#= ns #files="#: attributes.files$() #" data-#= ns #toolbar-height="#: attributes.toolbarHeight #"></div>'
	            },
	            height: 300,
	            width: 600,
	            attributes: {
	                autoplay: new adapters.BooleanAdapter({ title: 'Autoplay', defaultValue: false }),
	                toolbarHeight: new adapters.NumberAdapter({ title: 'Toolbar Height', defaultValue: 48 }),
	                mp4: new adapters.AssetAdapter({ title: 'MP4 File' }),
	                ogv: new adapters.AssetAdapter({ title: 'OGV File' }),
	                wbem: new adapters.AssetAdapter({ title: 'WBEM File' })
	            },
	
	            /**
	             * Get Html or jQuery content
	             * @method getHtmlContent
	             * @param component
	             * @param mode
	             * @returns {*}
	             */
	            getHtmlContent: function (component, mode) {
	                var that = this;
	                assert.instanceof(Video, that, kendo.format(assert.messages.instanceof.default, 'this', 'Image'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                assert.enum(Object.keys(kendo.ui.Stage.fn.modes), mode, kendo.format(assert.messages.enum.default, 'mode', Object.keys(kendo.ui.Stage.fn.modes)));
	                assert.instanceof(ToolAssets, assets.video, kendo.format(assert.messages.instanceof.default, 'assets.video', 'kidoju.ToolAssets'));
	                var template = kendo.template(this.templates.default);
	
	                /* This function's cyclomatic complexity is too high. */
	                /* jshint -W074 */
	
	                // The files$ function resolves urls with schemes like cdn://video.mp4 and returns a stringified array
	                component.attributes.files$ = function () {
	                    var mp4 = component.attributes.get('mp4');
	                    var ogv = component.attributes.get('ogv');
	                    var wbem = component.attributes.get('wbem');
	                    var schemes = assets.video.schemes;
	                    for (var scheme in schemes) {
	                        if (schemes.hasOwnProperty(scheme)) {
	                            var schemeRx = new RegExp('^' + scheme + '://');
	                            if (schemeRx.test(mp4)) {
	                                mp4 = mp4.replace(scheme + '://', schemes[scheme]);
	                            }
	                            if (schemeRx.test(ogv)) {
	                                ogv = ogv.replace(scheme + '://', schemes[scheme]);
	                            }
	                            if (schemeRx.test(wbem)) {
	                                wbem = wbem.replace(scheme + '://', schemes[scheme]);
	                            }
	                        }
	                    }
	                    var files = [];
	                    if (RX_HTTP_S.test(mp4)) {
	                        files.push(mp4);
	                    }
	                    if (RX_HTTP_S.test(ogv)) {
	                        files.push(ogv);
	                    }
	                    if (RX_HTTP_S.test(wbem)) {
	                        files.push(wbem);
	                    }
	                    return JSON.stringify(files);
	                };
	
	                /* jshint +W074 */
	
	                return template($.extend(component, { ns: kendo.ns }));
	            },
	
	            /**
	             * onResize Event Handler
	             * @method onResize
	             * @param e
	             * @param component
	             */
	            onResize: function (e, component) {
	                var stageElement = $(e.currentTarget);
	                assert.ok(stageElement.is(ELEMENT_CLASS), kendo.format('e.currentTarget is expected to be a stage element'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                var content = stageElement.children('div' + kendo.roleSelector('mediaplayer'));
	                if ($.type(component.width) === NUMBER) {
	                    content.outerWidth(component.get('width')  - content.outerWidth(true) + content.outerWidth());
	                }
	                if ($.type(component.height) === NUMBER) {
	                    content.outerHeight(component.get('height') - content.outerHeight(true) + content.outerHeight());
	                }
	                var widget = content.data('kendoMediaPlayer');
	                if (kendo.ui.MediaPlayer && widget instanceof kendo.ui.MediaPlayer) {
	                    widget.resize();
	                }
	                // prevent any side effect
	                e.preventDefault();
	                // prevent event to bubble on stage
	                e.stopPropagation();
	            },
	
	            /**
	             * Component validation
	             * @param component
	             * @param pageIdx
	             */
	            validate: function (component, pageIdx) {
	                var ret = Tool.fn.validate.call(this, component, pageIdx);
	                var description = this.description; // tool description
	                var messages = this.i18n.messages;
	                if (component.attributes) {
	                    if (!RX_VIDEO.test(component.attributes.mp4)) {
	                        ret.push({
	                            type: ERROR,
	                            index: pageIdx,
	                            message: kendo.format(messages.invalidVideoFile, description, pageIdx + 1)
	                        });
	                    }
	                    // Note: we are not testing for an ogv or wbem file
	                }
	                return ret;
	            }
	
	        });
	        tools.register(Video);
	
	        /**
	         * We could also consider
	         * HTML from Markdown (lists, tec)
	         * Drawing surface
	         * Shape
	         * Clock
	         * Text-to-Speech
	         * Geogebra
	         * Spreadsheet
	         */
	
	    }(window.jQuery));
	
	    /* jshint +W071 */
	
	    return window.kidoju;
	
	}, __webpack_require__(200));


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(207),
	        __webpack_require__(236),
	        __webpack_require__(237)
	        // './vendor/kendo/kendo.multiselect' // required because of a test in kendo.binder.js
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    /* This function has too many statements. */
	    /* jshint -W071 */
	
	    (function ($, undefined) {
	
	        var kendo = window.kendo;
	        var data = kendo.data;
	        var drawing = kendo.drawing;
	        var geometry = kendo.geometry;
	        var DataSource = data.DataSource;
	        var Surface = drawing.Surface;
	        var Widget = kendo.ui.Widget;
	        var assert = window.assert;
	        var logger = new window.Logger('kidoju.widgets.connector');
	        var NUMBER = 'number';
	        var STRING = 'string';
	        var NULL = 'null';
	        var UNDEFINED = 'undefined';
	        var CHANGE = 'change';
	        var DOT = '.';
	        var WIDGET = 'kendoConnector';
	        var NS = DOT + WIDGET;
	        var MOUSEDOWN = 'mousedown' + NS + ' ' + 'touchstart' + NS;
	        var MOUSEMOVE = 'mousemove' + NS + ' ' + 'touchmove' + NS;
	        var MOUSEUP = 'mouseup' + NS + ' ' + 'touchend' + NS;
	        var DIV = '<div/>';
	        var WIDGET_CLASS = 'kj-connector';
	        var SURFACE_CLASS = WIDGET_CLASS + '-surface';
	        var DRAGGABLE_CLASS = 'kj-draggable';
	        var PATH_WIDTH = 10;
	        var PATH_LINECAP = 'round';
	        var SURFACE = 'surface';
	        var ATTRIBUTE_SELECTOR = '[{0}="{1}"]';
	        var ID = 'id';
	
	        /*********************************************************************************
	         * Helpers
	         *********************************************************************************/
	
	        var util = {
	
	            /**
	             * Get a random pastel color to draw connections
	             * @returns {string}
	             */
	            getRandomColor: function ()
	            {
	                var r = (Math.round(Math.random() * 127) + 127).toString(16);
	                var g = (Math.round(Math.random() * 127) + 127).toString(16);
	                var b = (Math.round(Math.random() * 127) + 127).toString(16);
	                return '#' + r + g + b;
	            },
	
	            /**
	             * Get the mouse (or touch) position
	             * @param e
	             * @param stage
	             * @returns {{x: *, y: *}}
	             */
	            getMousePosition: function (e, stage) {
	                assert.instanceof($.Event, e, kendo.format(assert.messages.instanceof.default, 'e', 'jQuery.Event'));
	                assert.instanceof($, stage, kendo.format(assert.messages.instanceof.default, 'stage', 'jQuery'));
	                // See http://www.jacklmoore.com/notes/mouse-position/
	                // See http://www.jqwidgets.com/community/topic/dragend-event-properties-clientx-and-clienty-are-undefined-on-ios/
	                // See http://www.devinrolsen.com/basic-jquery-touchmove-event-setup/
	                // ATTENTION: e.originalEvent.changedTouches instanceof TouchList, not Array
	                var originalEvent = e.originalEvent;
	                var clientX = originalEvent && originalEvent.changedTouches ? originalEvent.changedTouches[0].clientX : e.clientX;
	                var clientY = originalEvent && originalEvent.changedTouches ? originalEvent.changedTouches[0].clientY : e.clientY;
	                // IMPORTANT: Position is relative to the stage and e.offsetX / e.offsetY do not work in Firefox
	                // var stage = $(e.target).closest('.kj-stage').find(kendo.roleSelector('stage'));
	                var ownerDocument = $(stage.get(0).ownerDocument);
	                var stageOffset = stage.offset();
	                var mouse = {
	                    x: clientX - stageOffset.left + ownerDocument.scrollLeft(),
	                    y: clientY - stageOffset.top + ownerDocument.scrollTop()
	                };
	                return mouse;
	            },
	
	            /**
	             * Get the position of the center of an element
	             * @param element
	             * @param stage
	             * @param scale
	             */
	            getElementCenter: function (element, stage, scale) {
	                assert.instanceof($, element, kendo.format(assert.messages.instanceof.default, 'element', 'jQuery'));
	                assert.instanceof($, stage, kendo.format(assert.messages.instanceof.default, 'stage', 'jQuery'));
	                assert.type(NUMBER, scale, kendo.format(assert.messages.type.default, 'scale', NUMBER));
	                // We need getBoundingClientRect to especially account for rotation
	                var rect = element[0].getBoundingClientRect();
	                var ownerDocument = $(stage.get(0).ownerDocument);
	                var stageOffset = stage.offset();
	                return {
	                    left: (rect.left - stageOffset.left + rect.width / 2  + ownerDocument.scrollLeft()) / scale,
	                    top: (rect.top - stageOffset.top + rect.height / 2 + ownerDocument.scrollTop()) / scale
	                };
	            },
	
	            /**
	             * Get the scale of an element's CSS transformation
	             * Note: the same function is used in kidoju.widgets.stage
	             * @param element
	             * @returns {Number|number}
	             */
	            getTransformScale: function (element) {
	                assert.instanceof($, element, kendo.format(assert.messages.instanceof.default, 'element', 'jQuery'));
	                // element.css('transform') returns a matrix, so we have to read the style attribute
	                var match = (element.attr('style') || '').match(/scale\([\s]*([0-9\.]+)[\s]*\)/);
	                return $.isArray(match) && match.length > 1 ? parseFloat(match[1]) || 1 : 1;
	            }
	
	        };
	
	        /*********************************************************************************
	         * Widget
	         *********************************************************************************/
	
	        /**
	         * Connector
	         * @class Connector Widget (kendoConnector)
	         */
	        var Connector = Widget.extend({
	
	            /**
	             * Initializes the widget
	             * @param element
	             * @param options
	             */
	            init: function (element, options) {
	                var that = this;
	                options = options || {};
	                Widget.fn.init.call(that, element, options);
	                logger.debug('widget initialized');
	                that._layout();
	                that._ensureSurface();
	                that._dataSource();
	                that._drawConnector();
	                that._addDragAndDrop();
	                that.value(that.options.value);
	                that._enabled = that.element.prop('disabled') ? false : that.options.enable;
	                kendo.notify(that);
	            },
	
	            /**
	             * Widget options
	             * @property options
	             */
	            options: {
	                name: 'Connector',
	                id: null,
	                value: null,
	                targetValue: null, // Cannot be undefined otherwise it won't be read
	                autoBind: true,
	                dataSource: [],
	                scaler: 'div.kj-stage',
	                container: 'div.kj-stage>div[data-role="stage"]',
	                color: '#FF0000',
	                hasSurface: true,
	                enable: true
	            },
	
	            /**
	             * Widget events
	             * @property events
	             */
	            events: [
	                CHANGE
	            ],
	
	            /**
	             * Value for MVVM binding
	             * @param value
	             */
	            value: function (value) {
	                var that = this;
	                if ($.type(value) === STRING || $.type(value) === NULL) {
	                    that._value = value;
	                } else if ($.type(value) === UNDEFINED) {
	                    return that._value;
	                } else {
	                    throw new TypeError('`value` is expected to be a nullable string if not undefined');
	                }
	            },
	
	            /**
	             * Builds the widget layout
	             * @private
	             */
	            _layout: function () {
	                var that = this;
	                that.wrapper = that.element;
	                // touch-action: 'none' is for Internet Explorer - https://github.com/jquery/jquery/issues/2987
	                // DRAGGABLE_WIDGET (which might be shared with other widgets) is used to position the drawing surface below draggable elements
	                that.element
	                    .addClass(WIDGET_CLASS)
	                    .addClass(DRAGGABLE_CLASS)
	                    .css({ touchAction: 'none' });
	                that.surface = drawing.Surface.create(that.element);
	            },
	
	            /**
	             * Ensure connection surface for all connectors
	             * @private
	             */
	            _ensureSurface: function () {
	                var that = this;
	                var options = that.options;
	                var container = that.element.closest(options.container);
	                assert.hasLength(container, kendo.format(assert.messages.hasLength.default, options.container));
	                // ensure surface
	                var surface = container.data(SURFACE);
	                if (options.hasSurface && !(surface instanceof Surface)) {
	                    var surfaceElement = container.find(DOT + SURFACE_CLASS);
	                    if (surfaceElement.length === 0) {
	                        // assert.ok(this.element.hasClass(WIDGET_CLASS), 'this._layout should be called before this._ensureSurface');
	                        var firstElementWithDraggable = container.children().has(DOT + DRAGGABLE_CLASS).first();
	                        assert.hasLength(firstElementWithDraggable, kendo.format(assert.messages.hasLength.default, 'firstElementWithDraggable'));
	                        surfaceElement = $(DIV)
	                            .addClass(SURFACE_CLASS)
	                            .css({ position: 'absolute', top: 0, left: 0 })
	                            .height(container.height())
	                            .width(container.width());
	                        surfaceElement.insertBefore(firstElementWithDraggable);
	                        surfaceElement.empty();
	                        surface = kendo.drawing.Surface.create(surfaceElement);
	                        container.data(SURFACE, surface);
	                    }
	                }
	            },
	
	            /**
	             * Draw the connector circle
	             * @private
	             */
	            _drawConnector: function () {
	                assert.instanceof(Surface, this.surface, kendo.format(assert.messages.instanceof.default, 'this.surface', 'kendo.drawing.Surface'));
	                var that = this; // this is the connector widget
	                var options = that.options;
	                var color = options.color;
	                var element = that.element;
	                var x = element.width() / 2; // parseInt(options.width, 10) / 2;
	                var y = element.height() / 2; // parseInt(options.height, 10) / 2;
	                var radius = Math.max(0, Math.min(x, y) - 10); // Add some space around radius to make it easier to grab on mobile devices
	                var connector = new drawing.Group();
	                var outerCircleGeometry = new geometry.Circle([x, y], 0.8 * radius);
	                var outerCircle = new drawing.Circle(outerCircleGeometry).stroke(color, 0.2 * radius);
	                connector.append(outerCircle);
	                var innerCircleGeometry = new geometry.Circle([x, y], 0.5 * radius);
	                var innerCircle = new drawing.Circle(innerCircleGeometry).stroke(color, 0.1 * radius).fill(color);
	                connector.append(innerCircle);
	                that.surface.clear();
	                that.surface.draw(connector);
	            },
	
	            /**
	             * Add drag and drop handlers
	             * @private
	             */
	            _addDragAndDrop: function () {
	                // IMPORTANT
	                // We can have several containers containing connectors on a page
	                // But we only have on set of event handlers shared across all containers
	                // So we cannot use `this`, which is specific to this connector
	                var element;
	                var path;
	                var target;
	                $(document)
	                    .off(NS)
	                    .on(MOUSEDOWN, DOT + WIDGET_CLASS, function (e) {
	                        e.preventDefault(); // prevents from selecting the div
	                        element = $(e.currentTarget);
	                        var elementOffset = element.offset();
	                        var elementWidget = element.data(WIDGET);
	                        if (elementWidget instanceof Connector && elementWidget._enabled) {
	                            elementWidget._dropConnection();
	                            var scaler = element.closest(elementWidget.options.scaler);
	                            var scale = scaler.length ? util.getTransformScale(scaler) : 1;
	                            var container = element.closest(elementWidget.options.container);
	                            assert.hasLength(container, kendo.format(assert.messages.hasLength.default, elementWidget.options.container));
	                            var mouse = util.getMousePosition(e, container);
	                            var center = util.getElementCenter(element, container, scale);
	                            var surface = container.data(SURFACE);
	                            assert.instanceof(Surface, surface, kendo.format(assert.messages.instanceof.default, 'surface', 'kendo.drawing.Surface'));
	                            path = new drawing.Path({
	                                stroke: {
	                                    color: elementWidget.options.color,
	                                    lineCap: PATH_LINECAP,
	                                    width: PATH_WIDTH
	                                }
	                            });
	                            path.moveTo(center.left, center.top);
	                            path.lineTo(mouse.x / scale, mouse.y / scale);
	                            surface.draw(path);
	                        }
	                    })
	                    .on(MOUSEMOVE, function (e) {
	                        if (element instanceof $ && path instanceof kendo.drawing.Path) {
	                            var elementWidget = element.data(WIDGET);
	                            assert.instanceof(Connector, elementWidget, kendo.format(assert.messages.instanceof.default, 'elementWidget', 'kendo.ui.Connector'));
	                            var scaler = element.closest(elementWidget.options.scaler);
	                            var scale = scaler.length ? util.getTransformScale(scaler) : 1;
	                            var container = element.closest(elementWidget.options.container);
	                            assert.hasLength(container, kendo.format(assert.messages.hasLength.default, elementWidget.options.container));
	                            var mouse = util.getMousePosition(e, container);
	                            path.segments[1].anchor().move(mouse.x / scale, mouse.y / scale);
	                        }
	                    })
	                    .on(MOUSEUP, DOT + WIDGET_CLASS, function (e) {
	                        if (element instanceof $ && path instanceof kendo.drawing.Path) {
	                            var targetElement = e.originalEvent && e.originalEvent.changedTouches ?
	                                document.elementFromPoint(e.originalEvent.changedTouches[0].clientX, e.originalEvent.changedTouches[0].clientY) :
	                                e.currentTarget;
	                            target = $(targetElement).closest(DOT + WIDGET_CLASS);
	                            var targetWidget = target.data(WIDGET);
	                            // with touchend, target === element
	                            // BUG REPORT  here: https://github.com/jquery/jquery/issues/2987
	                            if (element.attr(kendo.attr(ID)) !== target.attr(kendo.attr(ID)) && targetWidget instanceof Connector && targetWidget._enabled) {
	                                var elementWidget = element.data(WIDGET);
	                                assert.instanceof(Connector, elementWidget, kendo.format(assert.messages.instanceof.default, 'elementWidget', 'kendo.ui.Connector'));
	                                var container = element.closest(elementWidget.options.container);
	                                assert.hasLength(container, kendo.format(assert.messages.hasLength.default, elementWidget.options.container));
	                                var targetContainer = target.closest(targetWidget.options.container);
	                                assert.hasLength(targetContainer, kendo.format(assert.messages.hasLength.default, targetWidget.options.container));
	                                if (container[0] === targetContainer[0]) {
	                                    elementWidget._addConnection(target);
	                                } else {
	                                    // We cannot erase so we need to redraw all
	                                    elementWidget.refresh();
	                                }
	                            }  else {
	                                target = undefined;
	                            }
	                        }
	                        // Note: The MOUSEUP events bubble and the following handler is always executed after this one
	                    })
	                    .on(MOUSEUP, function (e) {
	                        if (path instanceof kendo.drawing.Path) {
	                            path.close();
	                        }
	                        if (element instanceof $ && $.type(target) === UNDEFINED) {
	                            var elementWidget = element.data(WIDGET);
	                            if (elementWidget instanceof Connector) {
	                                elementWidget.refresh();
	                            }
	                        }
	                        path = undefined;
	                        element = undefined;
	                        target = undefined;
	                    });
	            },
	
	            /**
	             * _dataSource function to bind refresh to the change event
	             * @private
	             */
	            _dataSource: function () {
	                var that = this;
	
	                // returns the datasource OR creates one if using array or configuration
	                that.dataSource = DataSource.create(that.options.dataSource);
	
	                // bind to the change event to refresh the widget
	                if (that._refreshHandler) {
	                    that.dataSource.unbind(CHANGE, that._refreshHandler);
	                }
	                that._refreshHandler = $.proxy(that.refresh, that);
	                that.dataSource.bind(CHANGE, that._refreshHandler);
	
	                // trigger a read on the dataSource if one hasn't happened yet
	                if (that.options.autoBind) {
	                    that.dataSource.fetch();
	                }
	            },
	
	            /**
	             * sets the dataSource for source binding
	             * @param dataSource
	             */
	            setDataSource: function (dataSource) {
	                var that = this;
	                // set the internal datasource equal to the one passed in by MVVM
	                that.options.dataSource = dataSource;
	                // rebuild the datasource if necessary, or just reassign
	                that._dataSource();
	            },
	
	            /* This function's cyclomatic complexity is too high. */
	            /* jshint -W074 */
	
	            /**
	             * Add connection
	             * Note: use this.value(string)
	             * @param target
	             */
	            _addConnection: function (target) {
	                /* jshint maxstatements: 36 */
	                /* jshint maxcomplexity: 13 */
	                target = $(target);
	                var that = this;
	                var ret = false;
	                var options = that.options;
	                var element = that.element;
	                var id = element.attr(kendo.attr(ID));
	                var container = that.element.closest(options.container);
	                assert.hasLength(container, kendo.format(assert.messages.hasLength.default, options.container));
	                var targetId = target.attr(kendo.attr(ID));
	                var targetWidget = target.data(WIDGET);
	                if (id !== targetId && targetWidget instanceof Connector) {
	                    var targetContainer = target.closest(targetWidget.options.container);
	                    assert.hasLength(targetContainer, kendo.format(assert.messages.hasLength.default, targetWidget.options.container));
	                    if (container[0] === targetContainer[0]) {
	                        assert.instanceof(DataSource, that.dataSource, kendo.format(assert.messages.instanceof.default, 'this.dataSource', 'kendo.data.DataSource'));
	                        var connections = that.dataSource.data();
	                        var originId = id < targetId ? id : targetId;
	                        var destinationId = id < targetId ? targetId : id;
	                        var originWidget = id < targetId ? that : targetWidget;
	                        var destinationWidget = id < targetId ? targetWidget : that;
	                        var originConnection = connections.find(function (connection) {
	                            return connection.originId === originId || connection.destinationId === originId;
	                        });
	                        var destinationConnection = connections.find(function (connection) {
	                            return connection.originId === destinationId || connection.destinationId === destinationId;
	                        });
	                        if (($.type(originConnection) === UNDEFINED && $.type(destinationConnection) === UNDEFINED) ||
	                            (originConnection !== destinationConnection)) {
	                            if (originConnection) {
	                                connections.remove(originConnection);
	                                originWidget._dropConnection();
	                            }
	                            if (destinationConnection) {
	                                connections.remove(destinationConnection);
	                                destinationWidget._dropConnection();
	                            }
	                            that.dataSource.add({
	                                originId: originId,
	                                destinationId: destinationId,
	                                color: util.getRandomColor()
	                            });
	                            originWidget._value = destinationWidget.options.targetValue;
	                            destinationWidget._value = originWidget.options.targetValue;
	                            // if (originWidget.element[0].kendoBindingTarget && !(originWidget.element[0].kendoBindingTarget.source instanceof kidoju.data.PageComponent)) {
	                            if (originWidget.element[0].kendoBindingTarget && !(originWidget.element[0].kendoBindingTarget.source instanceof kendo.data.Model)) {
	                                originWidget.trigger(CHANGE, { value: originWidget._value });
	                            }
	                            // if (destinationWidget.element[0].kendoBindingTarget && !(destinationWidget.element[0].kendoBindingTarget.source instanceof kidoju.data.PageComponent)) {
	                            if (destinationWidget.element[0].kendoBindingTarget && !(destinationWidget.element[0].kendoBindingTarget.source instanceof kendo.data.Model)) {
	                                destinationWidget.trigger(CHANGE, { value: destinationWidget._value });
	                            }
	                        }
	                        ret = true;
	                    }
	                }
	                return ret;
	            },
	
	            /* jshint +W074 */
	
	            /**
	             * Remove connection
	             * Note: use this.value(null)
	             */
	            _dropConnection: function () {
	                var that = this;
	                var options = that.options;
	                var element = that.element;
	                var id = element.attr(kendo.attr(ID));
	                var container = that.element.closest(options.container);
	                assert.hasLength(container, kendo.format(assert.messages.hasLength.default, options.container));
	                assert.instanceof(DataSource, that.dataSource, kendo.format(assert.messages.instanceof.default, 'this.dataSource', 'kendo.data.DataSource'));
	                var connections = that.dataSource.data();
	                var found = connections.find(function (connection) {
	                    return connection.originId === id || connection.destinationId === id;
	                });
	                if (found) {
	                    var targetId = found.originId === id ? found.destinationId : found.originId;
	                    var target = container.find(kendo.format(ATTRIBUTE_SELECTOR, kendo.attr(ID), targetId));
	                    var targetWidget = target.data(WIDGET);
	                    connections.remove(found);
	                    that._value = null;
	                    if (targetWidget instanceof Connector) {
	                        targetWidget._value = null;
	                    }
	                    that.trigger(CHANGE, { value: null });
	                    if (targetWidget instanceof Connector) {
	                        targetWidget.trigger(CHANGE, { value: null });
	                    }
	                }
	            },
	
	            /**
	             * Refresh upon changing the dataSource
	             * Redraw all connections
	             */
	            refresh: function () {
	                var that = this;
	                var options = that.options;
	                var container = that.element.closest(options.container);
	                assert.instanceof($, container, kendo.format(assert.messages.instanceof.default, 'container', 'jQuery'));
	                assert.instanceof(DataSource, that.dataSource, kendo.format(assert.messages.instanceof.default, 'this.dataSource', 'kendo.data.DataSource'));
	                var connections = this.dataSource.data();
	                var surface = container.data(SURFACE);
	                if (surface instanceof kendo.drawing.Surface) {
	                    // Clear surface
	                    surface.clear();
	                    // Redraw all connections
	                    connections.forEach(function (connection) {
	                        var origin = container.find(kendo.format(ATTRIBUTE_SELECTOR, kendo.attr(ID), connection.originId));
	                        var originWidget = origin.data(WIDGET);
	                        var destination = container.find(kendo.format(ATTRIBUTE_SELECTOR, kendo.attr(ID), connection.destinationId));
	                        var destinationWidget = destination.data(WIDGET);
	                        // Only connector widgets can be connected
	                        if (originWidget instanceof Connector && destinationWidget instanceof Connector) {
	                            var scaler = origin.closest(originWidget.options.scaler);
	                            var scale = scaler.length ? util.getTransformScale(scaler) : 1;
	                            var originCenter = util.getElementCenter(origin, container, scale);
	                            var destinationCenter = util.getElementCenter(destination, container, scale);
	                            var path = new drawing.Path({
	                                stroke: {
	                                    color: connection.color,
	                                    lineCap: PATH_LINECAP,
	                                    width: PATH_WIDTH
	                                }
	                            })
	                                .moveTo(originCenter.left, originCenter.top)
	                                .lineTo(destinationCenter.left, destinationCenter.top);
	                            surface.draw(path);
	                        }
	                    });
	                }
	            },
	
	            /**
	             * Enable/disable user interactivity on connector
	             */
	            enable: function (enabled) {
	                // this._enabled is checked in _addDragAndDrop
	                this._enabled = enabled;
	            },
	
	            /**
	             * Destroys the widget including all DOM modifications
	             * @method destroy
	             */
	            destroy: function () {
	                var that = this;
	                var element = that.element;
	                var container = element.closest(that.options.container);
	                var surface = container.data(SURFACE);
	                Widget.fn.destroy.call(that);
	                // unbind document events
	                $(document).off(NS);
	                // unbind and destroy all descendants
	                kendo.unbind(element);
	                kendo.destroy(element);
	                // unbind all other events (probably redundant)
	                element.find('*').off();
	                element.off();
	                // remove descendants
	                element.empty();
	                // remove widget class
	                element.removeClass(WIDGET_CLASS);
	                // If last connector on stage, remove surface
	                if (container.find(DOT + WIDGET_CLASS).length === 0 && surface instanceof Surface) {
	                    kendo.destroy(surface.element);
	                    surface.element.remove();
	                    container.removeData(SURFACE);
	                }
	            }
	        });
	
	        kendo.ui.plugin(Connector);
	
	    }(window.jQuery));
	
	    /* jshint +W071 */
	
	    return window.kendo;
	
	}, __webpack_require__(200));


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(202)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'color',
	        name: 'Color utils',
	        category: 'framework',
	        advanced: true,
	        description: 'Color utilities used across components',
	        depends: ['core']
	    };
	    (function ($, parseFloat, parseInt) {
	        var Color = function (value) {
	            var color = this, formats = Color.formats, re, processor, parts, i, channels;
	            if (arguments.length === 1) {
	                value = color.resolveColor(value);
	                for (i = 0; i < formats.length; i++) {
	                    re = formats[i].re;
	                    processor = formats[i].process;
	                    parts = re.exec(value);
	                    if (parts) {
	                        channels = processor(parts);
	                        color.r = channels[0];
	                        color.g = channels[1];
	                        color.b = channels[2];
	                    }
	                }
	            } else {
	                color.r = arguments[0];
	                color.g = arguments[1];
	                color.b = arguments[2];
	            }
	            color.r = color.normalizeByte(color.r);
	            color.g = color.normalizeByte(color.g);
	            color.b = color.normalizeByte(color.b);
	        };
	        Color.prototype = {
	            toHex: function () {
	                var color = this, pad = color.padDigit, r = color.r.toString(16), g = color.g.toString(16), b = color.b.toString(16);
	                return '#' + pad(r) + pad(g) + pad(b);
	            },
	            resolveColor: function (value) {
	                value = value || 'black';
	                if (value.charAt(0) == '#') {
	                    value = value.substr(1, 6);
	                }
	                value = value.replace(/ /g, '');
	                value = value.toLowerCase();
	                value = Color.namedColors[value] || value;
	                return value;
	            },
	            normalizeByte: function (value) {
	                return value < 0 || isNaN(value) ? 0 : value > 255 ? 255 : value;
	            },
	            padDigit: function (value) {
	                return value.length === 1 ? '0' + value : value;
	            },
	            brightness: function (value) {
	                var color = this, round = Math.round;
	                color.r = round(color.normalizeByte(color.r * value));
	                color.g = round(color.normalizeByte(color.g * value));
	                color.b = round(color.normalizeByte(color.b * value));
	                return color;
	            },
	            percBrightness: function () {
	                var color = this;
	                return Math.sqrt(0.241 * color.r * color.r + 0.691 * color.g * color.g + 0.068 * color.b * color.b);
	            }
	        };
	        Color.formats = [
	            {
	                re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
	                process: function (parts) {
	                    return [
	                        parseInt(parts[1], 10),
	                        parseInt(parts[2], 10),
	                        parseInt(parts[3], 10)
	                    ];
	                }
	            },
	            {
	                re: /^(\w{2})(\w{2})(\w{2})$/,
	                process: function (parts) {
	                    return [
	                        parseInt(parts[1], 16),
	                        parseInt(parts[2], 16),
	                        parseInt(parts[3], 16)
	                    ];
	                }
	            },
	            {
	                re: /^(\w{1})(\w{1})(\w{1})$/,
	                process: function (parts) {
	                    return [
	                        parseInt(parts[1] + parts[1], 16),
	                        parseInt(parts[2] + parts[2], 16),
	                        parseInt(parts[3] + parts[3], 16)
	                    ];
	                }
	            }
	        ];
	        Color.namedColors = {
	            aliceblue: 'f0f8ff',
	            antiquewhite: 'faebd7',
	            aqua: '00ffff',
	            aquamarine: '7fffd4',
	            azure: 'f0ffff',
	            beige: 'f5f5dc',
	            bisque: 'ffe4c4',
	            black: '000000',
	            blanchedalmond: 'ffebcd',
	            blue: '0000ff',
	            blueviolet: '8a2be2',
	            brown: 'a52a2a',
	            burlywood: 'deb887',
	            cadetblue: '5f9ea0',
	            chartreuse: '7fff00',
	            chocolate: 'd2691e',
	            coral: 'ff7f50',
	            cornflowerblue: '6495ed',
	            cornsilk: 'fff8dc',
	            crimson: 'dc143c',
	            cyan: '00ffff',
	            darkblue: '00008b',
	            darkcyan: '008b8b',
	            darkgoldenrod: 'b8860b',
	            darkgray: 'a9a9a9',
	            darkgrey: 'a9a9a9',
	            darkgreen: '006400',
	            darkkhaki: 'bdb76b',
	            darkmagenta: '8b008b',
	            darkolivegreen: '556b2f',
	            darkorange: 'ff8c00',
	            darkorchid: '9932cc',
	            darkred: '8b0000',
	            darksalmon: 'e9967a',
	            darkseagreen: '8fbc8f',
	            darkslateblue: '483d8b',
	            darkslategray: '2f4f4f',
	            darkslategrey: '2f4f4f',
	            darkturquoise: '00ced1',
	            darkviolet: '9400d3',
	            deeppink: 'ff1493',
	            deepskyblue: '00bfff',
	            dimgray: '696969',
	            dimgrey: '696969',
	            dodgerblue: '1e90ff',
	            firebrick: 'b22222',
	            floralwhite: 'fffaf0',
	            forestgreen: '228b22',
	            fuchsia: 'ff00ff',
	            gainsboro: 'dcdcdc',
	            ghostwhite: 'f8f8ff',
	            gold: 'ffd700',
	            goldenrod: 'daa520',
	            gray: '808080',
	            grey: '808080',
	            green: '008000',
	            greenyellow: 'adff2f',
	            honeydew: 'f0fff0',
	            hotpink: 'ff69b4',
	            indianred: 'cd5c5c',
	            indigo: '4b0082',
	            ivory: 'fffff0',
	            khaki: 'f0e68c',
	            lavender: 'e6e6fa',
	            lavenderblush: 'fff0f5',
	            lawngreen: '7cfc00',
	            lemonchiffon: 'fffacd',
	            lightblue: 'add8e6',
	            lightcoral: 'f08080',
	            lightcyan: 'e0ffff',
	            lightgoldenrodyellow: 'fafad2',
	            lightgray: 'd3d3d3',
	            lightgrey: 'd3d3d3',
	            lightgreen: '90ee90',
	            lightpink: 'ffb6c1',
	            lightsalmon: 'ffa07a',
	            lightseagreen: '20b2aa',
	            lightskyblue: '87cefa',
	            lightslategray: '778899',
	            lightslategrey: '778899',
	            lightsteelblue: 'b0c4de',
	            lightyellow: 'ffffe0',
	            lime: '00ff00',
	            limegreen: '32cd32',
	            linen: 'faf0e6',
	            magenta: 'ff00ff',
	            maroon: '800000',
	            mediumaquamarine: '66cdaa',
	            mediumblue: '0000cd',
	            mediumorchid: 'ba55d3',
	            mediumpurple: '9370d8',
	            mediumseagreen: '3cb371',
	            mediumslateblue: '7b68ee',
	            mediumspringgreen: '00fa9a',
	            mediumturquoise: '48d1cc',
	            mediumvioletred: 'c71585',
	            midnightblue: '191970',
	            mintcream: 'f5fffa',
	            mistyrose: 'ffe4e1',
	            moccasin: 'ffe4b5',
	            navajowhite: 'ffdead',
	            navy: '000080',
	            oldlace: 'fdf5e6',
	            olive: '808000',
	            olivedrab: '6b8e23',
	            orange: 'ffa500',
	            orangered: 'ff4500',
	            orchid: 'da70d6',
	            palegoldenrod: 'eee8aa',
	            palegreen: '98fb98',
	            paleturquoise: 'afeeee',
	            palevioletred: 'd87093',
	            papayawhip: 'ffefd5',
	            peachpuff: 'ffdab9',
	            peru: 'cd853f',
	            pink: 'ffc0cb',
	            plum: 'dda0dd',
	            powderblue: 'b0e0e6',
	            purple: '800080',
	            red: 'ff0000',
	            rosybrown: 'bc8f8f',
	            royalblue: '4169e1',
	            saddlebrown: '8b4513',
	            salmon: 'fa8072',
	            sandybrown: 'f4a460',
	            seagreen: '2e8b57',
	            seashell: 'fff5ee',
	            sienna: 'a0522d',
	            silver: 'c0c0c0',
	            skyblue: '87ceeb',
	            slateblue: '6a5acd',
	            slategray: '708090',
	            slategrey: '708090',
	            snow: 'fffafa',
	            springgreen: '00ff7f',
	            steelblue: '4682b4',
	            tan: 'd2b48c',
	            teal: '008080',
	            thistle: 'd8bfd8',
	            tomato: 'ff6347',
	            turquoise: '40e0d0',
	            violet: 'ee82ee',
	            wheat: 'f5deb3',
	            white: 'ffffff',
	            whitesmoke: 'f5f5f5',
	            yellow: 'ffff00',
	            yellowgreen: '9acd32'
	        };
	        var namedColorRegexp = ['transparent'];
	        for (var i in Color.namedColors) {
	            if (Color.namedColors.hasOwnProperty(i)) {
	                namedColorRegexp.push(i);
	            }
	        }
	        namedColorRegexp = new RegExp('^(' + namedColorRegexp.join('|') + ')(\\W|$)', 'i');
	        function parseColor(color, nothrow) {
	            var m, ret;
	            if (color == null || color == 'none') {
	                return null;
	            }
	            if (color instanceof _Color) {
	                return color;
	            }
	            color = color.toLowerCase();
	            if (m = namedColorRegexp.exec(color)) {
	                if (m[1] == 'transparent') {
	                    color = new _RGB(1, 1, 1, 0);
	                } else {
	                    color = parseColor(Color.namedColors[m[1]], nothrow);
	                }
	                color.match = [m[1]];
	                return color;
	            }
	            if (m = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})\b/i.exec(color)) {
	                ret = new _Bytes(parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), 1);
	            } else if (m = /^#?([0-9a-f])([0-9a-f])([0-9a-f])\b/i.exec(color)) {
	                ret = new _Bytes(parseInt(m[1] + m[1], 16), parseInt(m[2] + m[2], 16), parseInt(m[3] + m[3], 16), 1);
	            } else if (m = /^rgb\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/.exec(color)) {
	                ret = new _Bytes(parseInt(m[1], 10), parseInt(m[2], 10), parseInt(m[3], 10), 1);
	            } else if (m = /^rgba\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9.]+)\s*\)/.exec(color)) {
	                ret = new _Bytes(parseInt(m[1], 10), parseInt(m[2], 10), parseInt(m[3], 10), parseFloat(m[4]));
	            } else if (m = /^rgb\(\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*\)/.exec(color)) {
	                ret = new _RGB(parseFloat(m[1]) / 100, parseFloat(m[2]) / 100, parseFloat(m[3]) / 100, 1);
	            } else if (m = /^rgba\(\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9.]+)\s*\)/.exec(color)) {
	                ret = new _RGB(parseFloat(m[1]) / 100, parseFloat(m[2]) / 100, parseFloat(m[3]) / 100, parseFloat(m[4]));
	            }
	            if (ret) {
	                ret.match = m;
	            } else if (!nothrow) {
	                throw new Error('Cannot parse color: ' + color);
	            }
	            return ret;
	        }
	        function hex(n, width, pad) {
	            if (!pad) {
	                pad = '0';
	            }
	            n = n.toString(16);
	            while (width > n.length) {
	                n = '0' + n;
	            }
	            return n;
	        }
	        function hue2rgb(p, q, t) {
	            if (t < 0) {
	                t += 1;
	            }
	            if (t > 1) {
	                t -= 1;
	            }
	            if (t < 1 / 6) {
	                return p + (q - p) * 6 * t;
	            }
	            if (t < 1 / 2) {
	                return q;
	            }
	            if (t < 2 / 3) {
	                return p + (q - p) * (2 / 3 - t) * 6;
	            }
	            return p;
	        }
	        var _Color = kendo.Class.extend({
	            toHSV: function () {
	                return this;
	            },
	            toRGB: function () {
	                return this;
	            },
	            toHex: function () {
	                return this.toBytes().toHex();
	            },
	            toBytes: function () {
	                return this;
	            },
	            toCss: function () {
	                return '#' + this.toHex();
	            },
	            toCssRgba: function () {
	                var rgb = this.toBytes();
	                return 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', ' + parseFloat((+this.a).toFixed(3)) + ')';
	            },
	            toDisplay: function () {
	                if (kendo.support.browser.msie && kendo.support.browser.version < 9) {
	                    return this.toCss();
	                }
	                return this.toCssRgba();
	            },
	            equals: function (c) {
	                return c === this || c !== null && this.toCssRgba() == parseColor(c).toCssRgba();
	            },
	            diff: function (c2) {
	                if (c2 == null) {
	                    return NaN;
	                }
	                var c1 = this.toBytes();
	                c2 = c2.toBytes();
	                return Math.sqrt(Math.pow((c1.r - c2.r) * 0.3, 2) + Math.pow((c1.g - c2.g) * 0.59, 2) + Math.pow((c1.b - c2.b) * 0.11, 2));
	            },
	            clone: function () {
	                var c = this.toBytes();
	                if (c === this) {
	                    c = new _Bytes(c.r, c.g, c.b, c.a);
	                }
	                return c;
	            }
	        });
	        var _RGB = _Color.extend({
	            init: function (r, g, b, a) {
	                this.r = r;
	                this.g = g;
	                this.b = b;
	                this.a = a;
	            },
	            toHSV: function () {
	                var min, max, delta, h, s, v;
	                var r = this.r, g = this.g, b = this.b;
	                min = Math.min(r, g, b);
	                max = Math.max(r, g, b);
	                v = max;
	                delta = max - min;
	                if (delta === 0) {
	                    return new _HSV(0, 0, v, this.a);
	                }
	                if (max !== 0) {
	                    s = delta / max;
	                    if (r == max) {
	                        h = (g - b) / delta;
	                    } else if (g == max) {
	                        h = 2 + (b - r) / delta;
	                    } else {
	                        h = 4 + (r - g) / delta;
	                    }
	                    h *= 60;
	                    if (h < 0) {
	                        h += 360;
	                    }
	                } else {
	                    s = 0;
	                    h = -1;
	                }
	                return new _HSV(h, s, v, this.a);
	            },
	            toHSL: function () {
	                var r = this.r, g = this.g, b = this.b;
	                var max = Math.max(r, g, b), min = Math.min(r, g, b);
	                var h, s, l = (max + min) / 2;
	                if (max == min) {
	                    h = s = 0;
	                } else {
	                    var d = max - min;
	                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
	                    switch (max) {
	                    case r:
	                        h = (g - b) / d + (g < b ? 6 : 0);
	                        break;
	                    case g:
	                        h = (b - r) / d + 2;
	                        break;
	                    case b:
	                        h = (r - g) / d + 4;
	                        break;
	                    }
	                    h *= 60;
	                    s *= 100;
	                    l *= 100;
	                }
	                return new _HSL(h, s, l, this.a);
	            },
	            toBytes: function () {
	                return new _Bytes(this.r * 255, this.g * 255, this.b * 255, this.a);
	            }
	        });
	        var _Bytes = _RGB.extend({
	            init: function (r, g, b, a) {
	                this.r = Math.round(r);
	                this.g = Math.round(g);
	                this.b = Math.round(b);
	                this.a = a;
	            },
	            toRGB: function () {
	                return new _RGB(this.r / 255, this.g / 255, this.b / 255, this.a);
	            },
	            toHSV: function () {
	                return this.toRGB().toHSV();
	            },
	            toHSL: function () {
	                return this.toRGB().toHSL();
	            },
	            toHex: function () {
	                return hex(this.r, 2) + hex(this.g, 2) + hex(this.b, 2);
	            },
	            toBytes: function () {
	                return this;
	            }
	        });
	        var _HSV = _Color.extend({
	            init: function (h, s, v, a) {
	                this.h = h;
	                this.s = s;
	                this.v = v;
	                this.a = a;
	            },
	            toRGB: function () {
	                var h = this.h, s = this.s, v = this.v;
	                var i, r, g, b, f, p, q, t;
	                if (s === 0) {
	                    r = g = b = v;
	                } else {
	                    h /= 60;
	                    i = Math.floor(h);
	                    f = h - i;
	                    p = v * (1 - s);
	                    q = v * (1 - s * f);
	                    t = v * (1 - s * (1 - f));
	                    switch (i) {
	                    case 0:
	                        r = v;
	                        g = t;
	                        b = p;
	                        break;
	                    case 1:
	                        r = q;
	                        g = v;
	                        b = p;
	                        break;
	                    case 2:
	                        r = p;
	                        g = v;
	                        b = t;
	                        break;
	                    case 3:
	                        r = p;
	                        g = q;
	                        b = v;
	                        break;
	                    case 4:
	                        r = t;
	                        g = p;
	                        b = v;
	                        break;
	                    default:
	                        r = v;
	                        g = p;
	                        b = q;
	                        break;
	                    }
	                }
	                return new _RGB(r, g, b, this.a);
	            },
	            toHSL: function () {
	                return this.toRGB().toHSL();
	            },
	            toBytes: function () {
	                return this.toRGB().toBytes();
	            }
	        });
	        var _HSL = _Color.extend({
	            init: function (h, s, l, a) {
	                this.h = h;
	                this.s = s;
	                this.l = l;
	                this.a = a;
	            },
	            toRGB: function () {
	                var h = this.h, s = this.s, l = this.l;
	                var r, g, b;
	                if (s === 0) {
	                    r = g = b = l;
	                } else {
	                    h /= 360;
	                    s /= 100;
	                    l /= 100;
	                    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	                    var p = 2 * l - q;
	                    r = hue2rgb(p, q, h + 1 / 3);
	                    g = hue2rgb(p, q, h);
	                    b = hue2rgb(p, q, h - 1 / 3);
	                }
	                return new _RGB(r, g, b, this.a);
	            },
	            toHSV: function () {
	                return this.toRGB().toHSV();
	            },
	            toBytes: function () {
	                return this.toRGB().toBytes();
	            }
	        });
	        Color.fromBytes = function (r, g, b, a) {
	            return new _Bytes(r, g, b, a != null ? a : 1);
	        };
	        Color.fromRGB = function (r, g, b, a) {
	            return new _RGB(r, g, b, a != null ? a : 1);
	        };
	        Color.fromHSV = function (h, s, v, a) {
	            return new _HSV(h, s, v, a != null ? a : 1);
	        };
	        Color.fromHSL = function (h, s, l, a) {
	            return new _HSL(h, s, l, a != null ? a : 1);
	        };
	        kendo.Color = Color;
	        kendo.parseColor = parseColor;
	    }(window.kendo.jQuery, parseFloat, parseInt));
	}, __webpack_require__(200)));

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_14__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_13__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_12__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_11__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_10__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_9__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_8__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_7__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_6__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_5__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_4__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_3__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_2__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_1__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_0__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(202)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_LOCAL_MODULE_0__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__));
	}(function () {
	    (function () {
	        var math = Math, kendo = window.kendo, deepExtend = kendo.deepExtend;
	        var DEG_TO_RAD = math.PI / 180, MAX_NUM = Number.MAX_VALUE, MIN_NUM = -Number.MAX_VALUE, UNDEFINED = 'undefined';
	        function defined(value) {
	            return typeof value !== UNDEFINED;
	        }
	        function round(value, precision) {
	            var power = pow(precision);
	            return math.round(value * power) / power;
	        }
	        function pow(p) {
	            if (p) {
	                return math.pow(10, p);
	            } else {
	                return 1;
	            }
	        }
	        function limitValue(value, min, max) {
	            return math.max(math.min(value, max), min);
	        }
	        function rad(degrees) {
	            return degrees * DEG_TO_RAD;
	        }
	        function deg(radians) {
	            return radians / DEG_TO_RAD;
	        }
	        function isNumber(val) {
	            return typeof val === 'number' && !isNaN(val);
	        }
	        function valueOrDefault(value, defaultValue) {
	            return defined(value) ? value : defaultValue;
	        }
	        function sqr(value) {
	            return value * value;
	        }
	        function objectKey(object) {
	            var parts = [];
	            for (var key in object) {
	                parts.push(key + object[key]);
	            }
	            return parts.sort().join('');
	        }
	        function hashKey(str) {
	            var hash = 2166136261;
	            for (var i = 0; i < str.length; ++i) {
	                hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
	                hash ^= str.charCodeAt(i);
	            }
	            return hash >>> 0;
	        }
	        function hashObject(object) {
	            return hashKey(objectKey(object));
	        }
	        var now = Date.now;
	        if (!now) {
	            now = function () {
	                return new Date().getTime();
	            };
	        }
	        function arrayLimits(arr) {
	            var length = arr.length, i, min = MAX_NUM, max = MIN_NUM;
	            for (i = 0; i < length; i++) {
	                max = math.max(max, arr[i]);
	                min = math.min(min, arr[i]);
	            }
	            return {
	                min: min,
	                max: max
	            };
	        }
	        function arrayMin(arr) {
	            return arrayLimits(arr).min;
	        }
	        function arrayMax(arr) {
	            return arrayLimits(arr).max;
	        }
	        function sparseArrayMin(arr) {
	            return sparseArrayLimits(arr).min;
	        }
	        function sparseArrayMax(arr) {
	            return sparseArrayLimits(arr).max;
	        }
	        function sparseArrayLimits(arr) {
	            var min = MAX_NUM, max = MIN_NUM;
	            for (var i = 0, length = arr.length; i < length; i++) {
	                var n = arr[i];
	                if (n !== null && isFinite(n)) {
	                    min = math.min(min, n);
	                    max = math.max(max, n);
	                }
	            }
	            return {
	                min: min === MAX_NUM ? undefined : min,
	                max: max === MIN_NUM ? undefined : max
	            };
	        }
	        function last(array) {
	            if (array) {
	                return array[array.length - 1];
	            }
	        }
	        function append(first, second) {
	            first.push.apply(first, second);
	            return first;
	        }
	        function renderTemplate(text) {
	            return kendo.template(text, {
	                useWithBlock: false,
	                paramName: 'd'
	            });
	        }
	        function renderAttr(name, value) {
	            return defined(value) && value !== null ? ' ' + name + '=\'' + value + '\' ' : '';
	        }
	        function renderAllAttr(attrs) {
	            var output = '';
	            for (var i = 0; i < attrs.length; i++) {
	                output += renderAttr(attrs[i][0], attrs[i][1]);
	            }
	            return output;
	        }
	        function renderStyle(attrs) {
	            var output = '';
	            for (var i = 0; i < attrs.length; i++) {
	                var value = attrs[i][1];
	                if (defined(value)) {
	                    output += attrs[i][0] + ':' + value + ';';
	                }
	            }
	            if (output !== '') {
	                return output;
	            }
	        }
	        function renderSize(size) {
	            if (typeof size !== 'string') {
	                size += 'px';
	            }
	            return size;
	        }
	        function renderPos(pos) {
	            var result = [];
	            if (pos) {
	                var parts = kendo.toHyphens(pos).split('-');
	                for (var i = 0; i < parts.length; i++) {
	                    result.push('k-pos-' + parts[i]);
	                }
	            }
	            return result.join(' ');
	        }
	        function isTransparent(color) {
	            return color === '' || color === null || color === 'none' || color === 'transparent' || !defined(color);
	        }
	        function arabicToRoman(n) {
	            var literals = {
	                1: 'i',
	                10: 'x',
	                100: 'c',
	                2: 'ii',
	                20: 'xx',
	                200: 'cc',
	                3: 'iii',
	                30: 'xxx',
	                300: 'ccc',
	                4: 'iv',
	                40: 'xl',
	                400: 'cd',
	                5: 'v',
	                50: 'l',
	                500: 'd',
	                6: 'vi',
	                60: 'lx',
	                600: 'dc',
	                7: 'vii',
	                70: 'lxx',
	                700: 'dcc',
	                8: 'viii',
	                80: 'lxxx',
	                800: 'dccc',
	                9: 'ix',
	                90: 'xc',
	                900: 'cm',
	                1000: 'm'
	            };
	            var values = [
	                1000,
	                900,
	                800,
	                700,
	                600,
	                500,
	                400,
	                300,
	                200,
	                100,
	                90,
	                80,
	                70,
	                60,
	                50,
	                40,
	                30,
	                20,
	                10,
	                9,
	                8,
	                7,
	                6,
	                5,
	                4,
	                3,
	                2,
	                1
	            ];
	            var roman = '';
	            while (n > 0) {
	                if (n < values[0]) {
	                    values.shift();
	                } else {
	                    roman += literals[values[0]];
	                    n -= values[0];
	                }
	            }
	            return roman;
	        }
	        function romanToArabic(r) {
	            r = r.toLowerCase();
	            var digits = {
	                i: 1,
	                v: 5,
	                x: 10,
	                l: 50,
	                c: 100,
	                d: 500,
	                m: 1000
	            };
	            var value = 0, prev = 0;
	            for (var i = 0; i < r.length; ++i) {
	                var v = digits[r.charAt(i)];
	                if (!v) {
	                    return null;
	                }
	                value += v;
	                if (v > prev) {
	                    value -= 2 * prev;
	                }
	                prev = v;
	            }
	            return value;
	        }
	        function memoize(f) {
	            var cache = Object.create(null);
	            return function () {
	                var id = '';
	                for (var i = arguments.length; --i >= 0;) {
	                    id += ':' + arguments[i];
	                }
	                if (id in cache) {
	                    return cache[id];
	                }
	                return f.apply(this, arguments);
	            };
	        }
	        function ucs2decode(string) {
	            var output = [], counter = 0, length = string.length, value, extra;
	            while (counter < length) {
	                value = string.charCodeAt(counter++);
	                if (value >= 55296 && value <= 56319 && counter < length) {
	                    extra = string.charCodeAt(counter++);
	                    if ((extra & 64512) == 56320) {
	                        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
	                    } else {
	                        output.push(value);
	                        counter--;
	                    }
	                } else {
	                    output.push(value);
	                }
	            }
	            return output;
	        }
	        function ucs2encode(array) {
	            return array.map(function (value) {
	                var output = '';
	                if (value > 65535) {
	                    value -= 65536;
	                    output += String.fromCharCode(value >>> 10 & 1023 | 55296);
	                    value = 56320 | value & 1023;
	                }
	                output += String.fromCharCode(value);
	                return output;
	            }).join('');
	        }
	        function mergeSort(a, cmp) {
	            if (a.length < 2) {
	                return a.slice();
	            }
	            function merge(a, b) {
	                var r = [], ai = 0, bi = 0, i = 0;
	                while (ai < a.length && bi < b.length) {
	                    if (cmp(a[ai], b[bi]) <= 0) {
	                        r[i++] = a[ai++];
	                    } else {
	                        r[i++] = b[bi++];
	                    }
	                }
	                if (ai < a.length) {
	                    r.push.apply(r, a.slice(ai));
	                }
	                if (bi < b.length) {
	                    r.push.apply(r, b.slice(bi));
	                }
	                return r;
	            }
	            return function sort(a) {
	                if (a.length <= 1) {
	                    return a;
	                }
	                var m = Math.floor(a.length / 2);
	                var left = a.slice(0, m);
	                var right = a.slice(m);
	                left = sort(left);
	                right = sort(right);
	                return merge(left, right);
	            }(a);
	        }
	        deepExtend(kendo, {
	            util: {
	                MAX_NUM: MAX_NUM,
	                MIN_NUM: MIN_NUM,
	                append: append,
	                arrayLimits: arrayLimits,
	                arrayMin: arrayMin,
	                arrayMax: arrayMax,
	                defined: defined,
	                deg: deg,
	                hashKey: hashKey,
	                hashObject: hashObject,
	                isNumber: isNumber,
	                isTransparent: isTransparent,
	                last: last,
	                limitValue: limitValue,
	                now: now,
	                objectKey: objectKey,
	                round: round,
	                rad: rad,
	                renderAttr: renderAttr,
	                renderAllAttr: renderAllAttr,
	                renderPos: renderPos,
	                renderSize: renderSize,
	                renderStyle: renderStyle,
	                renderTemplate: renderTemplate,
	                sparseArrayLimits: sparseArrayLimits,
	                sparseArrayMin: sparseArrayMin,
	                sparseArrayMax: sparseArrayMax,
	                sqr: sqr,
	                valueOrDefault: valueOrDefault,
	                romanToArabic: romanToArabic,
	                arabicToRoman: arabicToRoman,
	                memoize: memoize,
	                ucs2encode: ucs2encode,
	                ucs2decode: ucs2decode,
	                mergeSort: mergeSort
	            }
	        });
	        kendo.drawing.util = kendo.util;
	        kendo.dataviz.util = kendo.util;
	    }());
	    return window.kendo;
	}, __webpack_require__(200)));
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(202),
	        __WEBPACK_LOCAL_MODULE_0__
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_LOCAL_MODULE_1__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__));
	}(function () {
	    (function ($) {
	        var doc = document, kendo = window.kendo, Class = kendo.Class, util = kendo.util, defined = util.defined;
	        var LRUCache = Class.extend({
	            init: function (size) {
	                this._size = size;
	                this._length = 0;
	                this._map = {};
	            },
	            put: function (key, value) {
	                var lru = this, map = lru._map, entry = {
	                        key: key,
	                        value: value
	                    };
	                map[key] = entry;
	                if (!lru._head) {
	                    lru._head = lru._tail = entry;
	                } else {
	                    lru._tail.newer = entry;
	                    entry.older = lru._tail;
	                    lru._tail = entry;
	                }
	                if (lru._length >= lru._size) {
	                    map[lru._head.key] = null;
	                    lru._head = lru._head.newer;
	                    lru._head.older = null;
	                } else {
	                    lru._length++;
	                }
	            },
	            get: function (key) {
	                var lru = this, entry = lru._map[key];
	                if (entry) {
	                    if (entry === lru._head && entry !== lru._tail) {
	                        lru._head = entry.newer;
	                        lru._head.older = null;
	                    }
	                    if (entry !== lru._tail) {
	                        if (entry.older) {
	                            entry.older.newer = entry.newer;
	                            entry.newer.older = entry.older;
	                        }
	                        entry.older = lru._tail;
	                        entry.newer = null;
	                        lru._tail.newer = entry;
	                        lru._tail = entry;
	                    }
	                    return entry.value;
	                }
	            }
	        });
	        var defaultMeasureBox = $('<div style=\'position: absolute !important; top: -4000px !important; width: auto !important; height: auto !important;' + 'padding: 0 !important; margin: 0 !important; border: 0 !important;' + 'line-height: normal !important; visibility: hidden !important; white-space: nowrap!important;\' />')[0];
	        function zeroSize() {
	            return {
	                width: 0,
	                height: 0,
	                baseline: 0
	            };
	        }
	        var TextMetrics = Class.extend({
	            init: function (options) {
	                this._cache = new LRUCache(1000);
	                this._initOptions(options);
	            },
	            options: { baselineMarkerSize: 1 },
	            measure: function (text, style, box) {
	                if (!text) {
	                    return zeroSize();
	                }
	                var styleKey = util.objectKey(style), cacheKey = util.hashKey(text + styleKey), cachedResult = this._cache.get(cacheKey);
	                if (cachedResult) {
	                    return cachedResult;
	                }
	                var size = zeroSize();
	                var measureBox = box ? box : defaultMeasureBox;
	                var baselineMarker = this._baselineMarker().cloneNode(false);
	                for (var key in style) {
	                    var value = style[key];
	                    if (defined(value)) {
	                        measureBox.style[key] = value;
	                    }
	                }
	                $(measureBox).text(text);
	                measureBox.appendChild(baselineMarker);
	                doc.body.appendChild(measureBox);
	                if ((text + '').length) {
	                    size.width = measureBox.offsetWidth - this.options.baselineMarkerSize;
	                    size.height = measureBox.offsetHeight;
	                    size.baseline = baselineMarker.offsetTop + this.options.baselineMarkerSize;
	                }
	                if (size.width > 0 && size.height > 0) {
	                    this._cache.put(cacheKey, size);
	                }
	                measureBox.parentNode.removeChild(measureBox);
	                return size;
	            },
	            _baselineMarker: function () {
	                return $('<div class=\'k-baseline-marker\' ' + 'style=\'display: inline-block; vertical-align: baseline;' + 'width: ' + this.options.baselineMarkerSize + 'px; height: ' + this.options.baselineMarkerSize + 'px;' + 'overflow: hidden;\' />')[0];
	            }
	        });
	        TextMetrics.current = new TextMetrics();
	        function measureText(text, style, measureBox) {
	            return TextMetrics.current.measure(text, style, measureBox);
	        }
	        function loadFonts(fonts, callback) {
	            var promises = [];
	            if (fonts.length > 0 && document.fonts) {
	                try {
	                    promises = fonts.map(function (font) {
	                        return document.fonts.load(font);
	                    });
	                } catch (e) {
	                    kendo.logToConsole(e);
	                }
	                Promise.all(promises).then(callback, callback);
	            } else {
	                callback();
	            }
	        }
	        kendo.util.TextMetrics = TextMetrics;
	        kendo.util.LRUCache = LRUCache;
	        kendo.util.loadFonts = loadFonts;
	        kendo.util.measureText = measureText;
	    }(window.kendo.jQuery));
	}, __webpack_require__(200)));
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_0__], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_LOCAL_MODULE_2__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__));
	}(function () {
	    (function () {
	        var kendo = window.kendo, deepExtend = kendo.deepExtend, fromCharCode = String.fromCharCode;
	        var KEY_STR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	        function encodeBase64(input) {
	            var output = '';
	            var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
	            var i = 0;
	            input = encodeUTF8(input);
	            while (i < input.length) {
	                chr1 = input.charCodeAt(i++);
	                chr2 = input.charCodeAt(i++);
	                chr3 = input.charCodeAt(i++);
	                enc1 = chr1 >> 2;
	                enc2 = (chr1 & 3) << 4 | chr2 >> 4;
	                enc3 = (chr2 & 15) << 2 | chr3 >> 6;
	                enc4 = chr3 & 63;
	                if (isNaN(chr2)) {
	                    enc3 = enc4 = 64;
	                } else if (isNaN(chr3)) {
	                    enc4 = 64;
	                }
	                output = output + KEY_STR.charAt(enc1) + KEY_STR.charAt(enc2) + KEY_STR.charAt(enc3) + KEY_STR.charAt(enc4);
	            }
	            return output;
	        }
	        function encodeUTF8(input) {
	            var output = '';
	            for (var i = 0; i < input.length; i++) {
	                var c = input.charCodeAt(i);
	                if (c < 128) {
	                    output += fromCharCode(c);
	                } else if (c < 2048) {
	                    output += fromCharCode(192 | c >>> 6);
	                    output += fromCharCode(128 | c & 63);
	                } else if (c < 65536) {
	                    output += fromCharCode(224 | c >>> 12);
	                    output += fromCharCode(128 | c >>> 6 & 63);
	                    output += fromCharCode(128 | c & 63);
	                }
	            }
	            return output;
	        }
	        deepExtend(kendo.util, {
	            encodeBase64: encodeBase64,
	            encodeUTF8: encodeUTF8
	        });
	    }());
	    return window.kendo;
	}, __webpack_require__(200)));
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(202)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_LOCAL_MODULE_3__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__));
	}(function () {
	    (function ($) {
	        var math = Math, kendo = window.kendo, deepExtend = kendo.deepExtend, inArray = $.inArray;
	        var ObserversMixin = {
	            observers: function () {
	                this._observers = this._observers || [];
	                return this._observers;
	            },
	            addObserver: function (element) {
	                if (!this._observers) {
	                    this._observers = [element];
	                } else {
	                    this._observers.push(element);
	                }
	                return this;
	            },
	            removeObserver: function (element) {
	                var observers = this.observers();
	                var index = inArray(element, observers);
	                if (index != -1) {
	                    observers.splice(index, 1);
	                }
	                return this;
	            },
	            trigger: function (methodName, event) {
	                var observers = this._observers;
	                var observer;
	                var idx;
	                if (observers && !this._suspended) {
	                    for (idx = 0; idx < observers.length; idx++) {
	                        observer = observers[idx];
	                        if (observer[methodName]) {
	                            observer[methodName](event);
	                        }
	                    }
	                }
	                return this;
	            },
	            optionsChange: function (e) {
	                e = e || {};
	                e.element = this;
	                this.trigger('optionsChange', e);
	            },
	            geometryChange: function () {
	                this.trigger('geometryChange', { element: this });
	            },
	            suspend: function () {
	                this._suspended = (this._suspended || 0) + 1;
	                return this;
	            },
	            resume: function () {
	                this._suspended = math.max((this._suspended || 0) - 1, 0);
	                return this;
	            },
	            _observerField: function (field, value) {
	                if (this[field]) {
	                    this[field].removeObserver(this);
	                }
	                this[field] = value;
	                value.addObserver(this);
	            }
	        };
	        deepExtend(kendo, { mixins: { ObserversMixin: ObserversMixin } });
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __WEBPACK_LOCAL_MODULE_0__,
	        __WEBPACK_LOCAL_MODULE_3__
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_LOCAL_MODULE_4__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__));
	}(function () {
	    (function () {
	        var math = Math, pow = math.pow, kendo = window.kendo, Class = kendo.Class, deepExtend = kendo.deepExtend, ObserversMixin = kendo.mixins.ObserversMixin, util = kendo.util, defined = util.defined, rad = util.rad, deg = util.deg, round = util.round;
	        var PI_DIV_2 = math.PI / 2, MIN_NUM = util.MIN_NUM, MAX_NUM = util.MAX_NUM, PRECISION = 10;
	        var Point = Class.extend({
	            init: function (x, y) {
	                this.x = x || 0;
	                this.y = y || 0;
	            },
	            equals: function (other) {
	                return other && other.x === this.x && other.y === this.y;
	            },
	            clone: function () {
	                return new Point(this.x, this.y);
	            },
	            rotate: function (angle, origin) {
	                return this.transform(transform().rotate(angle, origin));
	            },
	            translate: function (x, y) {
	                this.x += x;
	                this.y += y;
	                this.geometryChange();
	                return this;
	            },
	            translateWith: function (point) {
	                return this.translate(point.x, point.y);
	            },
	            move: function (x, y) {
	                this.x = this.y = 0;
	                return this.translate(x, y);
	            },
	            scale: function (scaleX, scaleY) {
	                if (!defined(scaleY)) {
	                    scaleY = scaleX;
	                }
	                this.x *= scaleX;
	                this.y *= scaleY;
	                this.geometryChange();
	                return this;
	            },
	            scaleCopy: function (scaleX, scaleY) {
	                return this.clone().scale(scaleX, scaleY);
	            },
	            transform: function (transformation) {
	                var mx = toMatrix(transformation), x = this.x, y = this.y;
	                this.x = mx.a * x + mx.c * y + mx.e;
	                this.y = mx.b * x + mx.d * y + mx.f;
	                this.geometryChange();
	                return this;
	            },
	            transformCopy: function (transformation) {
	                var point = this.clone();
	                if (transformation) {
	                    point.transform(transformation);
	                }
	                return point;
	            },
	            distanceTo: function (point) {
	                var dx = this.x - point.x;
	                var dy = this.y - point.y;
	                return math.sqrt(dx * dx + dy * dy);
	            },
	            round: function (digits) {
	                this.x = round(this.x, digits);
	                this.y = round(this.y, digits);
	                this.geometryChange();
	                return this;
	            },
	            toArray: function (digits) {
	                var doRound = defined(digits);
	                var x = doRound ? round(this.x, digits) : this.x;
	                var y = doRound ? round(this.y, digits) : this.y;
	                return [
	                    x,
	                    y
	                ];
	            }
	        });
	        defineAccessors(Point.fn, [
	            'x',
	            'y'
	        ]);
	        deepExtend(Point.fn, ObserversMixin);
	        Point.fn.toString = function (digits, separator) {
	            var x = this.x, y = this.y;
	            if (defined(digits)) {
	                x = round(x, digits);
	                y = round(y, digits);
	            }
	            separator = separator || ' ';
	            return x + separator + y;
	        };
	        Point.create = function (arg0, arg1) {
	            if (defined(arg0)) {
	                if (arg0 instanceof Point) {
	                    return arg0;
	                } else if (arguments.length === 1 && arg0.length === 2) {
	                    return new Point(arg0[0], arg0[1]);
	                } else {
	                    return new Point(arg0, arg1);
	                }
	            }
	        };
	        Point.min = function () {
	            var minX = util.MAX_NUM;
	            var minY = util.MAX_NUM;
	            for (var i = 0; i < arguments.length; i++) {
	                var pt = arguments[i];
	                minX = math.min(pt.x, minX);
	                minY = math.min(pt.y, minY);
	            }
	            return new Point(minX, minY);
	        };
	        Point.max = function () {
	            var maxX = util.MIN_NUM;
	            var maxY = util.MIN_NUM;
	            for (var i = 0; i < arguments.length; i++) {
	                var pt = arguments[i];
	                maxX = math.max(pt.x, maxX);
	                maxY = math.max(pt.y, maxY);
	            }
	            return new Point(maxX, maxY);
	        };
	        Point.minPoint = function () {
	            return new Point(MIN_NUM, MIN_NUM);
	        };
	        Point.maxPoint = function () {
	            return new Point(MAX_NUM, MAX_NUM);
	        };
	        Point.ZERO = new Point(0, 0);
	        var Size = Class.extend({
	            init: function (width, height) {
	                this.width = width || 0;
	                this.height = height || 0;
	            },
	            equals: function (other) {
	                return other && other.width === this.width && other.height === this.height;
	            },
	            clone: function () {
	                return new Size(this.width, this.height);
	            },
	            toArray: function (digits) {
	                var doRound = defined(digits);
	                var width = doRound ? round(this.width, digits) : this.width;
	                var height = doRound ? round(this.height, digits) : this.height;
	                return [
	                    width,
	                    height
	                ];
	            }
	        });
	        defineAccessors(Size.fn, [
	            'width',
	            'height'
	        ]);
	        deepExtend(Size.fn, ObserversMixin);
	        Size.create = function (arg0, arg1) {
	            if (defined(arg0)) {
	                if (arg0 instanceof Size) {
	                    return arg0;
	                } else if (arguments.length === 1 && arg0.length === 2) {
	                    return new Size(arg0[0], arg0[1]);
	                } else {
	                    return new Size(arg0, arg1);
	                }
	            }
	        };
	        Size.ZERO = new Size(0, 0);
	        var Rect = Class.extend({
	            init: function (origin, size) {
	                this.setOrigin(origin || new Point());
	                this.setSize(size || new Size());
	            },
	            clone: function () {
	                return new Rect(this.origin.clone(), this.size.clone());
	            },
	            equals: function (other) {
	                return other && other.origin.equals(this.origin) && other.size.equals(this.size);
	            },
	            setOrigin: function (value) {
	                this._observerField('origin', Point.create(value));
	                this.geometryChange();
	                return this;
	            },
	            getOrigin: function () {
	                return this.origin;
	            },
	            setSize: function (value) {
	                this._observerField('size', Size.create(value));
	                this.geometryChange();
	                return this;
	            },
	            getSize: function () {
	                return this.size;
	            },
	            width: function () {
	                return this.size.width;
	            },
	            height: function () {
	                return this.size.height;
	            },
	            topLeft: function () {
	                return this.origin.clone();
	            },
	            bottomRight: function () {
	                return this.origin.clone().translate(this.width(), this.height());
	            },
	            topRight: function () {
	                return this.origin.clone().translate(this.width(), 0);
	            },
	            bottomLeft: function () {
	                return this.origin.clone().translate(0, this.height());
	            },
	            center: function () {
	                return this.origin.clone().translate(this.width() / 2, this.height() / 2);
	            },
	            bbox: function (matrix) {
	                var tl = this.topLeft().transformCopy(matrix);
	                var tr = this.topRight().transformCopy(matrix);
	                var br = this.bottomRight().transformCopy(matrix);
	                var bl = this.bottomLeft().transformCopy(matrix);
	                return Rect.fromPoints(tl, tr, br, bl);
	            },
	            transformCopy: function (m) {
	                return Rect.fromPoints(this.topLeft().transform(m), this.bottomRight().transform(m));
	            },
	            expand: function (x, y) {
	                if (!defined(y)) {
	                    y = x;
	                }
	                this.size.width += 2 * x;
	                this.size.height += 2 * y;
	                this.origin.translate(-x, -y);
	                return this;
	            },
	            expandCopy: function (x, y) {
	                return this.clone().expand(x, y);
	            },
	            containsPoint: function (point) {
	                var origin = this.origin;
	                var bottomRight = this.bottomRight();
	                return !(point.x < origin.x || point.y < origin.y || bottomRight.x < point.x || bottomRight.y < point.y);
	            },
	            _isOnPath: function (point, width) {
	                var rectOuter = this.expandCopy(width, width);
	                var rectInner = this.expandCopy(-width, -width);
	                return rectOuter.containsPoint(point) && !rectInner.containsPoint(point);
	            }
	        });
	        deepExtend(Rect.fn, ObserversMixin);
	        Rect.fromPoints = function () {
	            var topLeft = Point.min.apply(this, arguments);
	            var bottomRight = Point.max.apply(this, arguments);
	            var size = new Size(bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
	            return new Rect(topLeft, size);
	        };
	        Rect.union = function (a, b) {
	            return Rect.fromPoints(Point.min(a.topLeft(), b.topLeft()), Point.max(a.bottomRight(), b.bottomRight()));
	        };
	        Rect.intersect = function (a, b) {
	            a = {
	                left: a.topLeft().x,
	                top: a.topLeft().y,
	                right: a.bottomRight().x,
	                bottom: a.bottomRight().y
	            };
	            b = {
	                left: b.topLeft().x,
	                top: b.topLeft().y,
	                right: b.bottomRight().x,
	                bottom: b.bottomRight().y
	            };
	            if (a.left <= b.right && b.left <= a.right && a.top <= b.bottom && b.top <= a.bottom) {
	                return Rect.fromPoints(new Point(math.max(a.left, b.left), math.max(a.top, b.top)), new Point(math.min(a.right, b.right), math.min(a.bottom, b.bottom)));
	            }
	        };
	        var Circle = Class.extend({
	            init: function (center, radius) {
	                this.setCenter(center || new Point());
	                this.setRadius(radius || 0);
	            },
	            setCenter: function (value) {
	                this._observerField('center', Point.create(value));
	                this.geometryChange();
	                return this;
	            },
	            getCenter: function () {
	                return this.center;
	            },
	            equals: function (other) {
	                return other && other.center.equals(this.center) && other.radius === this.radius;
	            },
	            clone: function () {
	                return new Circle(this.center.clone(), this.radius);
	            },
	            pointAt: function (angle) {
	                return this._pointAt(rad(angle));
	            },
	            bbox: function (matrix) {
	                var minPoint = Point.maxPoint();
	                var maxPoint = Point.minPoint();
	                var extremeAngles = ellipseExtremeAngles(this.center, this.radius, this.radius, matrix);
	                for (var i = 0; i < 4; i++) {
	                    var currentPointX = this._pointAt(extremeAngles.x + i * PI_DIV_2).transformCopy(matrix);
	                    var currentPointY = this._pointAt(extremeAngles.y + i * PI_DIV_2).transformCopy(matrix);
	                    var currentPoint = new Point(currentPointX.x, currentPointY.y);
	                    minPoint = Point.min(minPoint, currentPoint);
	                    maxPoint = Point.max(maxPoint, currentPoint);
	                }
	                return Rect.fromPoints(minPoint, maxPoint);
	            },
	            _pointAt: function (angle) {
	                var c = this.center;
	                var r = this.radius;
	                return new Point(c.x - r * math.cos(angle), c.y - r * math.sin(angle));
	            },
	            containsPoint: function (point) {
	                var center = this.center;
	                var inCircle = math.pow(point.x - center.x, 2) + math.pow(point.y - center.y, 2) <= math.pow(this.radius, 2);
	                return inCircle;
	            },
	            _isOnPath: function (point, width) {
	                var center = this.center;
	                var radius = this.radius;
	                var pointDistance = center.distanceTo(point);
	                return radius - width <= pointDistance && pointDistance <= radius + width;
	            }
	        });
	        defineAccessors(Circle.fn, ['radius']);
	        deepExtend(Circle.fn, ObserversMixin);
	        var Arc = Class.extend({
	            init: function (center, options) {
	                this.setCenter(center || new Point());
	                options = options || {};
	                this.radiusX = options.radiusX;
	                this.radiusY = options.radiusY || options.radiusX;
	                this.startAngle = options.startAngle;
	                this.endAngle = options.endAngle;
	                this.anticlockwise = options.anticlockwise || false;
	            },
	            clone: function () {
	                return new Arc(this.center, {
	                    radiusX: this.radiusX,
	                    radiusY: this.radiusY,
	                    startAngle: this.startAngle,
	                    endAngle: this.endAngle,
	                    anticlockwise: this.anticlockwise
	                });
	            },
	            setCenter: function (value) {
	                this._observerField('center', Point.create(value));
	                this.geometryChange();
	                return this;
	            },
	            getCenter: function () {
	                return this.center;
	            },
	            MAX_INTERVAL: 45,
	            pointAt: function (angle) {
	                var center = this.center;
	                var radian = rad(angle);
	                return new Point(center.x + this.radiusX * math.cos(radian), center.y + this.radiusY * math.sin(radian));
	            },
	            curvePoints: function () {
	                var startAngle = this.startAngle;
	                var dir = this.anticlockwise ? -1 : 1;
	                var curvePoints = [this.pointAt(startAngle)];
	                var currentAngle = startAngle;
	                var interval = this._arcInterval();
	                var intervalAngle = interval.endAngle - interval.startAngle;
	                var subIntervalsCount = math.ceil(intervalAngle / this.MAX_INTERVAL);
	                var subIntervalAngle = intervalAngle / subIntervalsCount;
	                for (var i = 1; i <= subIntervalsCount; i++) {
	                    var nextAngle = currentAngle + dir * subIntervalAngle;
	                    var points = this._intervalCurvePoints(currentAngle, nextAngle);
	                    curvePoints.push(points.cp1, points.cp2, points.p2);
	                    currentAngle = nextAngle;
	                }
	                return curvePoints;
	            },
	            bbox: function (matrix) {
	                var arc = this;
	                var interval = arc._arcInterval();
	                var startAngle = interval.startAngle;
	                var endAngle = interval.endAngle;
	                var extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);
	                var extremeX = deg(extremeAngles.x);
	                var extremeY = deg(extremeAngles.y);
	                var currentPoint = arc.pointAt(startAngle).transformCopy(matrix);
	                var endPoint = arc.pointAt(endAngle).transformCopy(matrix);
	                var minPoint = Point.min(currentPoint, endPoint);
	                var maxPoint = Point.max(currentPoint, endPoint);
	                var currentAngleX = bboxStartAngle(extremeX, startAngle);
	                var currentAngleY = bboxStartAngle(extremeY, startAngle);
	                while (currentAngleX < endAngle || currentAngleY < endAngle) {
	                    var currentPointX;
	                    if (currentAngleX < endAngle) {
	                        currentPointX = arc.pointAt(currentAngleX).transformCopy(matrix);
	                        currentAngleX += 90;
	                    }
	                    var currentPointY;
	                    if (currentAngleY < endAngle) {
	                        currentPointY = arc.pointAt(currentAngleY).transformCopy(matrix);
	                        currentAngleY += 90;
	                    }
	                    currentPoint = new Point(currentPointX.x, currentPointY.y);
	                    minPoint = Point.min(minPoint, currentPoint);
	                    maxPoint = Point.max(maxPoint, currentPoint);
	                }
	                return Rect.fromPoints(minPoint, maxPoint);
	            },
	            _arcInterval: function () {
	                var startAngle = this.startAngle;
	                var endAngle = this.endAngle;
	                var anticlockwise = this.anticlockwise;
	                if (anticlockwise) {
	                    var oldStart = startAngle;
	                    startAngle = endAngle;
	                    endAngle = oldStart;
	                }
	                if (startAngle > endAngle || anticlockwise && startAngle === endAngle) {
	                    endAngle += 360;
	                }
	                return {
	                    startAngle: startAngle,
	                    endAngle: endAngle
	                };
	            },
	            _intervalCurvePoints: function (startAngle, endAngle) {
	                var arc = this;
	                var p1 = arc.pointAt(startAngle);
	                var p2 = arc.pointAt(endAngle);
	                var p1Derivative = arc._derivativeAt(startAngle);
	                var p2Derivative = arc._derivativeAt(endAngle);
	                var t = (rad(endAngle) - rad(startAngle)) / 3;
	                var cp1 = new Point(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);
	                var cp2 = new Point(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);
	                return {
	                    p1: p1,
	                    cp1: cp1,
	                    cp2: cp2,
	                    p2: p2
	                };
	            },
	            _derivativeAt: function (angle) {
	                var arc = this;
	                var radian = rad(angle);
	                return new Point(-arc.radiusX * math.sin(radian), arc.radiusY * math.cos(radian));
	            },
	            containsPoint: function (point) {
	                var interval = this._arcInterval();
	                var intervalAngle = interval.endAngle - interval.startAngle;
	                var center = this.center;
	                var distance = center.distanceTo(point);
	                var angleRad = math.atan2(point.y - center.y, point.x - center.x);
	                var pointRadius = this.radiusX * this.radiusY / math.sqrt(math.pow(this.radiusX, 2) * math.pow(math.sin(angleRad), 2) + math.pow(this.radiusY, 2) * math.pow(math.cos(angleRad), 2));
	                var startPoint = this.pointAt(this.startAngle).round(PRECISION);
	                var endPoint = this.pointAt(this.endAngle).round(PRECISION);
	                var intersection = lineIntersection(center, point.round(PRECISION), startPoint, endPoint);
	                var containsPoint;
	                if (intervalAngle < 180) {
	                    containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);
	                } else {
	                    var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);
	                    if (angle != 360) {
	                        angle = (360 + angle) % 360;
	                    }
	                    var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;
	                    containsPoint = inAngleRange && closeOrLess(distance, pointRadius) || !inAngleRange && (!intersection || intersection.equals(point));
	                }
	                return containsPoint;
	            },
	            _isOnPath: function (point, width) {
	                var interval = this._arcInterval();
	                var center = this.center;
	                var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);
	                if (angle != 360) {
	                    angle = (360 + angle) % 360;
	                }
	                var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;
	                return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;
	            }
	        });
	        defineAccessors(Arc.fn, [
	            'radiusX',
	            'radiusY',
	            'startAngle',
	            'endAngle',
	            'anticlockwise'
	        ]);
	        deepExtend(Arc.fn, ObserversMixin);
	        Arc.fromPoints = function (start, end, rx, ry, largeArc, swipe) {
	            var arcParameters = normalizeArcParameters(start.x, start.y, end.x, end.y, rx, ry, largeArc, swipe);
	            return new Arc(arcParameters.center, {
	                startAngle: arcParameters.startAngle,
	                endAngle: arcParameters.endAngle,
	                radiusX: rx,
	                radiusY: ry,
	                anticlockwise: swipe === 0
	            });
	        };
	        var Matrix = Class.extend({
	            init: function (a, b, c, d, e, f) {
	                this.a = a || 0;
	                this.b = b || 0;
	                this.c = c || 0;
	                this.d = d || 0;
	                this.e = e || 0;
	                this.f = f || 0;
	            },
	            multiplyCopy: function (m) {
	                return new Matrix(this.a * m.a + this.c * m.b, this.b * m.a + this.d * m.b, this.a * m.c + this.c * m.d, this.b * m.c + this.d * m.d, this.a * m.e + this.c * m.f + this.e, this.b * m.e + this.d * m.f + this.f);
	            },
	            invert: function () {
	                var a = this.a, b = this.b;
	                var d = this.c, e = this.d;
	                var g = this.e, h = this.f;
	                var det = a * e - b * d;
	                if (det === 0) {
	                    return null;
	                }
	                return new Matrix(e / det, -b / det, -d / det, a / det, (d * h - e * g) / det, (b * g - a * h) / det);
	            },
	            clone: function () {
	                return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
	            },
	            equals: function (other) {
	                if (!other) {
	                    return false;
	                }
	                return this.a === other.a && this.b === other.b && this.c === other.c && this.d === other.d && this.e === other.e && this.f === other.f;
	            },
	            round: function (precision) {
	                this.a = round(this.a, precision);
	                this.b = round(this.b, precision);
	                this.c = round(this.c, precision);
	                this.d = round(this.d, precision);
	                this.e = round(this.e, precision);
	                this.f = round(this.f, precision);
	                return this;
	            },
	            toArray: function (precision) {
	                var arr = [
	                    this.a,
	                    this.b,
	                    this.c,
	                    this.d,
	                    this.e,
	                    this.f
	                ];
	                if (defined(precision)) {
	                    for (var i = 0; i < arr.length; i++) {
	                        arr[i] = round(arr[i], precision);
	                    }
	                }
	                return arr;
	            }
	        });
	        Matrix.fn.toString = function (precision, separator) {
	            return this.toArray(precision).join(separator || ',');
	        };
	        Matrix.translate = function (x, y) {
	            return new Matrix(1, 0, 0, 1, x, y);
	        };
	        Matrix.unit = function () {
	            return new Matrix(1, 0, 0, 1, 0, 0);
	        };
	        Matrix.rotate = function (angle, x, y) {
	            var m = new Matrix();
	            m.a = math.cos(rad(angle));
	            m.b = math.sin(rad(angle));
	            m.c = -m.b;
	            m.d = m.a;
	            m.e = x - x * m.a + y * m.b || 0;
	            m.f = y - y * m.a - x * m.b || 0;
	            return m;
	        };
	        Matrix.scale = function (scaleX, scaleY) {
	            return new Matrix(scaleX, 0, 0, scaleY, 0, 0);
	        };
	        Matrix.IDENTITY = Matrix.unit();
	        var Transformation = Class.extend({
	            init: function (matrix) {
	                this._matrix = matrix || Matrix.unit();
	            },
	            clone: function () {
	                return new Transformation(this._matrix.clone());
	            },
	            equals: function (other) {
	                return other && other._matrix.equals(this._matrix);
	            },
	            _optionsChange: function () {
	                this.optionsChange({
	                    field: 'transform',
	                    value: this
	                });
	            },
	            translate: function (x, y) {
	                this._matrix = this._matrix.multiplyCopy(Matrix.translate(x, y));
	                this._optionsChange();
	                return this;
	            },
	            scale: function (scaleX, scaleY, origin) {
	                if (!defined(scaleY)) {
	                    scaleY = scaleX;
	                }
	                if (origin) {
	                    origin = Point.create(origin);
	                    this._matrix = this._matrix.multiplyCopy(Matrix.translate(origin.x, origin.y));
	                }
	                this._matrix = this._matrix.multiplyCopy(Matrix.scale(scaleX, scaleY));
	                if (origin) {
	                    this._matrix = this._matrix.multiplyCopy(Matrix.translate(-origin.x, -origin.y));
	                }
	                this._optionsChange();
	                return this;
	            },
	            rotate: function (angle, origin) {
	                origin = Point.create(origin) || Point.ZERO;
	                this._matrix = this._matrix.multiplyCopy(Matrix.rotate(angle, origin.x, origin.y));
	                this._optionsChange();
	                return this;
	            },
	            multiply: function (transformation) {
	                var matrix = toMatrix(transformation);
	                this._matrix = this._matrix.multiplyCopy(matrix);
	                this._optionsChange();
	                return this;
	            },
	            matrix: function (matrix) {
	                if (matrix) {
	                    this._matrix = matrix;
	                    this._optionsChange();
	                    return this;
	                } else {
	                    return this._matrix;
	                }
	            }
	        });
	        deepExtend(Transformation.fn, ObserversMixin);
	        function transform(matrix) {
	            if (matrix === null) {
	                return null;
	            }
	            if (matrix instanceof Transformation) {
	                return matrix;
	            }
	            return new Transformation(matrix);
	        }
	        function toMatrix(value) {
	            if (value && kendo.isFunction(value.matrix)) {
	                return value.matrix();
	            }
	            return value;
	        }
	        function ellipseExtremeAngles(center, rx, ry, matrix) {
	            var extremeX = 0, extremeY = 0;
	            if (matrix) {
	                extremeX = math.atan2(matrix.c * ry, matrix.a * rx);
	                if (matrix.b !== 0) {
	                    extremeY = math.atan2(matrix.d * ry, matrix.b * rx);
	                }
	            }
	            return {
	                x: extremeX,
	                y: extremeY
	            };
	        }
	        function bboxStartAngle(angle, start) {
	            while (angle < start) {
	                angle += 90;
	            }
	            return angle;
	        }
	        function defineAccessors(fn, fields) {
	            for (var i = 0; i < fields.length; i++) {
	                var name = fields[i];
	                var capitalized = name.charAt(0).toUpperCase() + name.substring(1, name.length);
	                fn['set' + capitalized] = setAccessor(name);
	                fn['get' + capitalized] = getAccessor(name);
	            }
	        }
	        function setAccessor(field) {
	            return function (value) {
	                if (this[field] !== value) {
	                    this[field] = value;
	                    this.geometryChange();
	                }
	                return this;
	            };
	        }
	        function getAccessor(field) {
	            return function () {
	                return this[field];
	            };
	        }
	        function elipseAngle(start, end, swipe) {
	            if (start > end) {
	                end += 360;
	            }
	            var alpha = math.abs(end - start);
	            if (!swipe) {
	                alpha = 360 - alpha;
	            }
	            return alpha;
	        }
	        function calculateAngle(cx, cy, rx, ry, x, y) {
	            var cos = round((x - cx) / rx, 3);
	            var sin = round((y - cy) / ry, 3);
	            return round(deg(math.atan2(sin, cos)));
	        }
	        function normalizeArcParameters(x1, y1, x2, y2, rx, ry, largeArc, swipe) {
	            var cx, cy;
	            var cx1, cy1;
	            var a, b, c, sqrt;
	            if (y1 !== y2) {
	                var x21 = x2 - x1;
	                var y21 = y2 - y1;
	                var rx2 = pow(rx, 2), ry2 = pow(ry, 2);
	                var k = (ry2 * x21 * (x1 + x2) + rx2 * y21 * (y1 + y2)) / (2 * rx2 * y21);
	                var yk2 = k - y2;
	                var l = -(x21 * ry2) / (rx2 * y21);
	                a = 1 / rx2 + pow(l, 2) / ry2;
	                b = 2 * (l * yk2 / ry2 - x2 / rx2);
	                c = pow(x2, 2) / rx2 + pow(yk2, 2) / ry2 - 1;
	                sqrt = math.sqrt(pow(b, 2) - 4 * a * c);
	                cx = (-b - sqrt) / (2 * a);
	                cy = k + l * cx;
	                cx1 = (-b + sqrt) / (2 * a);
	                cy1 = k + l * cx1;
	            } else if (x1 !== x2) {
	                b = -2 * y2;
	                c = pow((x2 - x1) * ry / (2 * rx), 2) + pow(y2, 2) - pow(ry, 2);
	                sqrt = math.sqrt(pow(b, 2) - 4 * c);
	                cx = cx1 = (x1 + x2) / 2;
	                cy = (-b - sqrt) / 2;
	                cy1 = (-b + sqrt) / 2;
	            } else {
	                return false;
	            }
	            var start = calculateAngle(cx, cy, rx, ry, x1, y1);
	            var end = calculateAngle(cx, cy, rx, ry, x2, y2);
	            var alpha = elipseAngle(start, end, swipe);
	            if (largeArc && alpha <= 180 || !largeArc && alpha > 180) {
	                cx = cx1;
	                cy = cy1;
	                start = calculateAngle(cx, cy, rx, ry, x1, y1);
	                end = calculateAngle(cx, cy, rx, ry, x2, y2);
	            }
	            return {
	                center: new Point(cx, cy),
	                startAngle: start,
	                endAngle: end
	            };
	        }
	        var ComplexNumber = function (real, img) {
	            this.real = real || 0;
	            this.img = img || 0;
	        };
	        ComplexNumber.fn = ComplexNumber.prototype = {
	            add: function (cNumber) {
	                return new ComplexNumber(round(this.real + cNumber.real, PRECISION), round(this.img + cNumber.img, PRECISION));
	            },
	            addConstant: function (value) {
	                return new ComplexNumber(this.real + value, this.img);
	            },
	            negate: function () {
	                return new ComplexNumber(-this.real, -this.img);
	            },
	            multiply: function (cNumber) {
	                return new ComplexNumber(this.real * cNumber.real - this.img * cNumber.img, this.real * cNumber.img + this.img * cNumber.real);
	            },
	            multiplyConstant: function (value) {
	                return new ComplexNumber(this.real * value, this.img * value);
	            },
	            nthRoot: function (n) {
	                var rad = math.atan2(this.img, this.real), r = math.sqrt(math.pow(this.img, 2) + math.pow(this.real, 2)), nthR = math.pow(r, 1 / n);
	                return new ComplexNumber(nthR * math.cos(rad / n), nthR * math.sin(rad / n));
	            },
	            equals: function (cNumber) {
	                return this.real === cNumber.real && this.img === cNumber.img;
	            },
	            isReal: function () {
	                return this.img === 0;
	            }
	        };
	        function solveCubic(a, b, c, d) {
	            if (a === 0) {
	                return solveQuadratic(b, c, d);
	            }
	            var p = (3 * a * c - math.pow(b, 2)) / (3 * math.pow(a, 2)), q = (2 * math.pow(b, 3) - 9 * a * b * c + 27 * math.pow(a, 2) * d) / (27 * math.pow(a, 3)), Q = math.pow(p / 3, 3) + math.pow(q / 2, 2), i = new ComplexNumber(0, 1), b3a = -b / (3 * a), x1, x2, y1, y2, y3, result = [], z1, z2;
	            if (Q < 0) {
	                x1 = new ComplexNumber(-q / 2, math.sqrt(-Q)).nthRoot(3);
	                x2 = new ComplexNumber(-q / 2, -math.sqrt(-Q)).nthRoot(3);
	            } else {
	                x1 = -q / 2 + math.sqrt(Q);
	                x1 = new ComplexNumber(numberSign(x1) * math.pow(math.abs(x1), 1 / 3));
	                x2 = -q / 2 - math.sqrt(Q);
	                x2 = new ComplexNumber(numberSign(x2) * math.pow(math.abs(x2), 1 / 3));
	            }
	            y1 = x1.add(x2);
	            z1 = x1.add(x2).multiplyConstant(-1 / 2);
	            z2 = x1.add(x2.negate()).multiplyConstant(math.sqrt(3) / 2);
	            y2 = z1.add(i.multiply(z2));
	            y3 = z1.add(i.negate().multiply(z2));
	            if (y1.isReal()) {
	                result.push(round(y1.real + b3a, PRECISION));
	            }
	            if (y2.isReal()) {
	                result.push(round(y2.real + b3a, PRECISION));
	            }
	            if (y3.isReal()) {
	                result.push(round(y3.real + b3a, PRECISION));
	            }
	            return result;
	        }
	        function toCubicPolynomial(points, field) {
	            return [
	                -points[0][field] + 3 * points[1][field] - 3 * points[2][field] + points[3][field],
	                3 * (points[0][field] - 2 * points[1][field] + points[2][field]),
	                3 * (-points[0][field] + points[1][field]),
	                points[0][field]
	            ];
	        }
	        function calculateCurveAt(t, field, points) {
	            var t1 = 1 - t;
	            return math.pow(t1, 3) * points[0][field] + 3 * math.pow(t1, 2) * t * points[1][field] + 3 * math.pow(t, 2) * t1 * points[2][field] + math.pow(t, 3) * points[3][field];
	        }
	        function curveIntersectionsCount(points, point, bbox) {
	            var polynomial = toCubicPolynomial(points, 'x');
	            var roots = solveCubic(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point.x);
	            var count = 0;
	            var rayIntersection;
	            var intersectsRay;
	            for (var i = 0; i < roots.length; i++) {
	                rayIntersection = calculateCurveAt(roots[i], 'y', points);
	                intersectsRay = close(rayIntersection, point.y) || rayIntersection > point.y;
	                if (intersectsRay && ((roots[i] === 0 || roots[i] === 1) && bbox.bottomRight().x > point.x || 0 < roots[i] && roots[i] < 1)) {
	                    count++;
	                }
	            }
	            return count;
	        }
	        function lineIntersectionsCount(a, b, point) {
	            var intersects;
	            if (a.x != b.x) {
	                var minX = math.min(a.x, b.x), maxX = math.max(a.x, b.x), minY = math.min(a.y, b.y), maxY = math.max(a.y, b.y), inRange = minX <= point.x && point.x < maxX;
	                if (minY == maxY) {
	                    intersects = point.y <= minY && inRange;
	                } else {
	                    intersects = inRange && (maxY - minY) * ((a.x - b.x) * (a.y - b.y) > 0 ? point.x - minX : maxX - point.x) / (maxX - minX) + minY - point.y >= 0;
	                }
	            }
	            return intersects ? 1 : 0;
	        }
	        function lineIntersection(p0, p1, p2, p3) {
	            var s1x = p1.x - p0.x;
	            var s2x = p3.x - p2.x;
	            var s1y = p1.y - p0.y;
	            var s2y = p3.y - p2.y;
	            var nx = p0.x - p2.x;
	            var ny = p0.y - p2.y;
	            var d = s1x * s2y - s2x * s1y;
	            var s = (s1x * ny - s1y * nx) / d;
	            var t = (s2x * ny - s2y * nx) / d;
	            if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
	                return new Point(p0.x + t * s1x, p0.y + t * s1y);
	            }
	        }
	        function close(a, b, tolerance) {
	            return round(math.abs(a - b), tolerance || PRECISION) === 0;
	        }
	        function closeOrLess(a, b, tolerance) {
	            return a < b || close(a, b, tolerance);
	        }
	        function numberSign(x) {
	            return x < 0 ? -1 : 1;
	        }
	        function isOutOfEndPoint(endPoint, controlPoint, point) {
	            var angle = util.deg(math.atan2(controlPoint.y - endPoint.y, controlPoint.x - endPoint.x));
	            var rotatedPoint = point.transformCopy(transform().rotate(-angle, endPoint));
	            return rotatedPoint.x < endPoint.x;
	        }
	        function hasRootsInRange(points, point, field, rootField, range) {
	            var polynomial = toCubicPolynomial(points, rootField);
	            var roots = solveCubic(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point[rootField]);
	            var intersection;
	            for (var idx = 0; idx < roots.length; idx++) {
	                if (0 <= roots[idx] && roots[idx] <= 1) {
	                    intersection = calculateCurveAt(roots[idx], field, points);
	                    if (math.abs(intersection - point[field]) <= range) {
	                        return true;
	                    }
	                }
	            }
	        }
	        function solveQuadratic(a, b, c) {
	            var squareRoot = math.sqrt(math.pow(b, 2) - 4 * a * c);
	            return [
	                (-b + squareRoot) / (2 * a),
	                (-b - squareRoot) / (2 * a)
	            ];
	        }
	        deepExtend(kendo, {
	            geometry: {
	                Arc: Arc,
	                Circle: Circle,
	                curveIntersectionsCount: curveIntersectionsCount,
	                lineIntersectionsCount: lineIntersectionsCount,
	                Matrix: Matrix,
	                Point: Point,
	                Rect: Rect,
	                Size: Size,
	                Transformation: Transformation,
	                transform: transform,
	                toMatrix: toMatrix,
	                isOutOfEndPoint: isOutOfEndPoint,
	                hasRootsInRange: hasRootsInRange
	            }
	        });
	        kendo.dataviz.geometry = kendo.geometry;
	    }());
	    return window.kendo;
	}, __webpack_require__(200)));
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __WEBPACK_LOCAL_MODULE_4__,
	        __webpack_require__(212)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_LOCAL_MODULE_5__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__));
	}(function () {
	    (function ($) {
	        var noop = $.noop, toString = Object.prototype.toString, kendo = window.kendo, Class = kendo.Class, Widget = kendo.ui.Widget, deepExtend = kendo.deepExtend, util = kendo.util, defined = util.defined, limitValue = util.limitValue, g = kendo.geometry, proxy = $.proxy, NS = '.kendo', TOOLTIP_TEMPLATE = '<div class="k-tooltip">' + '<div class="k-tooltip-content"></div>' + '</div>', TOOLTIP_CLOSE_TEMPLATE = '<div class="k-tooltip-button"><a href="\\#" class="k-icon k-i-close">close</a></div>';
	        var Surface = Widget.extend({
	            init: function (element, options) {
	                this.options = deepExtend({}, this.options, options);
	                Widget.fn.init.call(this, element, this.options);
	                this._click = this._handler('click');
	                this._mouseenter = this._handler('mouseenter');
	                this._mouseleave = this._handler('mouseleave');
	                this._mousemove = this._handler('mousemove');
	                this._visual = new kendo.drawing.Group();
	                if (this.options.width) {
	                    this.element.css('width', this.options.width);
	                }
	                if (this.options.height) {
	                    this.element.css('height', this.options.height);
	                }
	                this._enableTracking();
	            },
	            options: {
	                name: 'Surface',
	                tooltip: {}
	            },
	            events: [
	                'click',
	                'mouseenter',
	                'mouseleave',
	                'mousemove',
	                'resize',
	                'tooltipOpen',
	                'tooltipClose'
	            ],
	            draw: function (element) {
	                this._visual.children.push(element);
	            },
	            clear: function () {
	                this._visual.children = [];
	                this.hideTooltip();
	            },
	            destroy: function () {
	                this._visual = null;
	                if (this._tooltip) {
	                    this._tooltip.destroy();
	                    delete this._tooltip;
	                }
	                Widget.fn.destroy.call(this);
	            },
	            exportVisual: function () {
	                return this._visual;
	            },
	            getSize: function () {
	                return {
	                    width: this.element.width(),
	                    height: this.element.height()
	                };
	            },
	            setSize: function (size) {
	                this.element.css({
	                    width: size.width,
	                    height: size.height
	                });
	                this._size = size;
	                this._resize();
	            },
	            eventTarget: function (e) {
	                var domNode = $(e.touch ? e.touch.initialTouch : e.target);
	                var node;
	                while (!node && domNode.length > 0) {
	                    node = domNode[0]._kendoNode;
	                    if (domNode.is(this.element) || domNode.length === 0) {
	                        break;
	                    }
	                    domNode = domNode.parent();
	                }
	                if (node) {
	                    return node.srcElement;
	                }
	            },
	            showTooltip: function (shape, options) {
	                if (this._tooltip) {
	                    this._tooltip.show(shape, options);
	                }
	            },
	            hideTooltip: function () {
	                if (this._tooltip) {
	                    this._tooltip.hide();
	                }
	            },
	            suspendTracking: function () {
	                this._suspendedTracking = true;
	                this.hideTooltip();
	            },
	            resumeTracking: function () {
	                this._suspendedTracking = false;
	            },
	            _resize: noop,
	            _handler: function (event) {
	                var surface = this;
	                return function (e) {
	                    var node = surface.eventTarget(e);
	                    if (node && !surface._suspendedTracking) {
	                        surface.trigger(event, {
	                            element: node,
	                            originalEvent: e,
	                            type: event
	                        });
	                    }
	                };
	            },
	            _enableTracking: function () {
	                if (kendo.ui.Popup) {
	                    this._tooltip = new SurfaceTooltip(this, this.options.tooltip || {});
	                }
	            },
	            _elementOffset: function () {
	                var element = this.element;
	                var offset = element.offset();
	                var paddingLeft = parseInt(element.css('paddingLeft'), 10);
	                var paddingTop = parseInt(element.css('paddingTop'), 10);
	                return {
	                    left: offset.left + paddingLeft,
	                    top: offset.top + paddingTop
	                };
	            },
	            _surfacePoint: function (event) {
	                var offset = this._elementOffset();
	                var coord = eventCoordinates(event);
	                var x = coord.x - offset.left;
	                var y = coord.y - offset.top;
	                return new g.Point(x, y);
	            }
	        });
	        kendo.ui.plugin(Surface);
	        Surface.create = function (element, options) {
	            return SurfaceFactory.current.create(element, options);
	        };
	        var BaseNode = Class.extend({
	            init: function (srcElement) {
	                this.childNodes = [];
	                this.parent = null;
	                if (srcElement) {
	                    this.srcElement = srcElement;
	                    this.observe();
	                }
	            },
	            destroy: function () {
	                if (this.srcElement) {
	                    this.srcElement.removeObserver(this);
	                }
	                var children = this.childNodes;
	                for (var i = 0; i < children.length; i++) {
	                    this.childNodes[i].destroy();
	                }
	                this.parent = null;
	            },
	            load: noop,
	            observe: function () {
	                if (this.srcElement) {
	                    this.srcElement.addObserver(this);
	                }
	            },
	            append: function (node) {
	                this.childNodes.push(node);
	                node.parent = this;
	            },
	            insertAt: function (node, pos) {
	                this.childNodes.splice(pos, 0, node);
	                node.parent = this;
	            },
	            remove: function (index, count) {
	                var end = index + count;
	                for (var i = index; i < end; i++) {
	                    this.childNodes[i].removeSelf();
	                }
	                this.childNodes.splice(index, count);
	            },
	            removeSelf: function () {
	                this.clear();
	                this.destroy();
	            },
	            clear: function () {
	                this.remove(0, this.childNodes.length);
	            },
	            invalidate: function () {
	                if (this.parent) {
	                    this.parent.invalidate();
	                }
	            },
	            geometryChange: function () {
	                this.invalidate();
	            },
	            optionsChange: function () {
	                this.invalidate();
	            },
	            childrenChange: function (e) {
	                if (e.action === 'add') {
	                    this.load(e.items, e.index);
	                } else if (e.action === 'remove') {
	                    this.remove(e.index, e.items.length);
	                }
	                this.invalidate();
	            }
	        });
	        var OptionsStore = Class.extend({
	            init: function (options, prefix) {
	                var field, member;
	                this.prefix = prefix || '';
	                for (field in options) {
	                    member = options[field];
	                    member = this._wrap(member, field);
	                    this[field] = member;
	                }
	            },
	            get: function (field) {
	                return kendo.getter(field, true)(this);
	            },
	            set: function (field, value) {
	                var current = kendo.getter(field, true)(this);
	                if (current !== value) {
	                    var composite = this._set(field, this._wrap(value, field));
	                    if (!composite) {
	                        this.optionsChange({
	                            field: this.prefix + field,
	                            value: value
	                        });
	                    }
	                }
	            },
	            _set: function (field, value) {
	                var composite = field.indexOf('.') >= 0;
	                if (composite) {
	                    var parts = field.split('.'), path = '', obj;
	                    while (parts.length > 1) {
	                        path += parts.shift();
	                        obj = kendo.getter(path, true)(this);
	                        if (!obj) {
	                            obj = new OptionsStore({}, path + '.');
	                            obj.addObserver(this);
	                            this[path] = obj;
	                        }
	                        if (obj instanceof OptionsStore) {
	                            obj.set(parts.join('.'), value);
	                            return composite;
	                        }
	                        path += '.';
	                    }
	                }
	                this._clear(field);
	                kendo.setter(field)(this, value);
	                return composite;
	            },
	            _clear: function (field) {
	                var current = kendo.getter(field, true)(this);
	                if (current && current.removeObserver) {
	                    current.removeObserver(this);
	                }
	            },
	            _wrap: function (object, field) {
	                var type = toString.call(object);
	                if (object !== null && defined(object) && type === '[object Object]') {
	                    if (!(object instanceof OptionsStore) && !(object instanceof Class)) {
	                        object = new OptionsStore(object, this.prefix + field + '.');
	                    }
	                    object.addObserver(this);
	                }
	                return object;
	            }
	        });
	        deepExtend(OptionsStore.fn, kendo.mixins.ObserversMixin);
	        var SurfaceFactory = function () {
	            this._items = [];
	        };
	        SurfaceFactory.prototype = {
	            register: function (name, type, order) {
	                var items = this._items, first = items[0], entry = {
	                        name: name,
	                        type: type,
	                        order: order
	                    };
	                if (!first || order < first.order) {
	                    items.unshift(entry);
	                } else {
	                    items.push(entry);
	                }
	            },
	            create: function (element, options) {
	                var items = this._items, match = items[0];
	                if (options && options.type) {
	                    var preferred = options.type.toLowerCase();
	                    for (var i = 0; i < items.length; i++) {
	                        if (items[i].name === preferred) {
	                            match = items[i];
	                            break;
	                        }
	                    }
	                }
	                if (match) {
	                    return new match.type(element, options);
	                }
	                kendo.logToConsole('Warning: Unable to create Kendo UI Drawing Surface. Possible causes:\n' + '- The browser does not support SVG, VML and Canvas. User agent: ' + navigator.userAgent + '\n' + '- The Kendo UI scripts are not fully loaded');
	            }
	        };
	        SurfaceFactory.current = new SurfaceFactory();
	        var SurfaceTooltip = Class.extend({
	            init: function (surface, options) {
	                this.element = $(TOOLTIP_TEMPLATE);
	                this.content = this.element.children('.k-tooltip-content');
	                options = options || {};
	                this.options = deepExtend({}, this.options, this._tooltipOptions(options));
	                this.popup = new kendo.ui.Popup(this.element, {
	                    appendTo: options.appendTo,
	                    animation: options.animation,
	                    copyAnchorStyles: false,
	                    collision: 'fit fit'
	                });
	                this._openPopupHandler = $.proxy(this._openPopup, this);
	                this.surface = surface;
	                this._bindEvents();
	            },
	            options: {
	                position: 'top',
	                showOn: 'mouseenter',
	                offset: 7,
	                autoHide: true,
	                hideDelay: 0,
	                showAfter: 100
	            },
	            _bindEvents: function () {
	                this._showHandler = proxy(this._showEvent, this);
	                this._surfaceLeaveHandler = proxy(this._surfaceLeave, this);
	                this._mouseleaveHandler = proxy(this._mouseleave, this);
	                this._mousemoveHandler = proxy(this._mousemove, this);
	                this.surface.bind('click', this._showHandler);
	                this.surface.bind('mouseenter', this._showHandler);
	                this.surface.bind('mouseleave', this._mouseleaveHandler);
	                this.surface.bind('mousemove', this._mousemoveHandler);
	                this.surface.element.on('mouseleave' + NS, this._surfaceLeaveHandler);
	                this.element.on('click' + NS, '.k-tooltip-button', proxy(this._hideClick, this));
	            },
	            destroy: function () {
	                var popup = this.popup;
	                this.surface.unbind('click', this._showHandler);
	                this.surface.unbind('mouseenter', this._showHandler);
	                this.surface.unbind('mouseleave', this._mouseleaveHandler);
	                this.surface.unbind('mousemove', this._mousemoveHandler);
	                this.surface.element.off('mouseleave' + NS, this._surfaceLeaveHandler);
	                this.element.off('click' + NS);
	                if (popup) {
	                    popup.destroy();
	                    delete this.popup;
	                }
	                clearTimeout(this._timeout);
	                delete this.popup;
	                delete this.element;
	                delete this.content;
	                delete this.surface;
	            },
	            _tooltipOptions: function (options) {
	                options = options || {};
	                return {
	                    position: options.position,
	                    showOn: options.showOn,
	                    offset: options.offset,
	                    autoHide: options.autoHide,
	                    width: options.width,
	                    height: options.height,
	                    content: options.content,
	                    shared: options.shared,
	                    hideDelay: options.hideDelay,
	                    showAfter: options.showAfter
	                };
	            },
	            _tooltipShape: function (shape) {
	                while (shape && !shape.options.tooltip) {
	                    shape = shape.parent;
	                }
	                return shape;
	            },
	            _updateContent: function (target, shape, options) {
	                var content = options.content;
	                if (kendo.isFunction(content)) {
	                    content = content({
	                        element: shape,
	                        target: target
	                    });
	                }
	                if (content) {
	                    this.content.html(content);
	                    return true;
	                }
	            },
	            _position: function (shape, options, elementSize, event) {
	                var position = options.position;
	                var tooltipOffset = options.offset || 0;
	                var surface = this.surface;
	                var offset = surface._elementOffset();
	                var size = surface.getSize();
	                var surfaceOffset = surface._offset;
	                var bbox = shape.bbox();
	                var width = elementSize.width;
	                var height = elementSize.height;
	                var left = 0, top = 0;
	                bbox.origin.translate(offset.left, offset.top);
	                if (surfaceOffset) {
	                    bbox.origin.translate(-surfaceOffset.x, -surfaceOffset.y);
	                }
	                if (position == 'cursor' && event) {
	                    var coord = eventCoordinates(event);
	                    left = coord.x - width / 2;
	                    top = coord.y - height - tooltipOffset;
	                } else if (position == 'left') {
	                    left = bbox.origin.x - width - tooltipOffset;
	                    top = bbox.center().y - height / 2;
	                } else if (position == 'right') {
	                    left = bbox.bottomRight().x + tooltipOffset;
	                    top = bbox.center().y - height / 2;
	                } else if (position == 'bottom') {
	                    left = bbox.center().x - width / 2;
	                    top = bbox.bottomRight().y + tooltipOffset;
	                } else {
	                    left = bbox.center().x - width / 2;
	                    top = bbox.origin.y - height - tooltipOffset;
	                }
	                return {
	                    left: limitValue(left, offset.left, offset.left + size.width),
	                    top: limitValue(top, offset.top, offset.top + size.height)
	                };
	            },
	            show: function (shape, options) {
	                this._show(shape, shape, deepExtend({}, this.options, this._tooltipOptions(shape.options.tooltip), options));
	            },
	            hide: function () {
	                var current = this._current;
	                delete this._current;
	                clearTimeout(this._showTimeout);
	                if (this.popup.visible() && current && !this.surface.trigger('tooltipClose', {
	                        element: current.shape,
	                        target: current.target,
	                        popup: this.popup
	                    })) {
	                    this.popup.close();
	                }
	            },
	            _hideClick: function (e) {
	                e.preventDefault();
	                this.hide();
	            },
	            _show: function (target, shape, options, event, delay) {
	                var current = this._current;
	                clearTimeout(this._timeout);
	                if (current && (current.shape === shape && options.shared || current.target === target)) {
	                    return;
	                }
	                clearTimeout(this._showTimeout);
	                if (!this.surface.trigger('tooltipOpen', {
	                        element: shape,
	                        target: target,
	                        popup: this.popup
	                    }) && this._updateContent(target, shape, options)) {
	                    this._autoHide(options);
	                    var elementSize = this._measure(options);
	                    var popup = this.popup;
	                    if (popup.visible()) {
	                        popup.close(true);
	                    }
	                    this._current = {
	                        options: options,
	                        elementSize: elementSize,
	                        shape: shape,
	                        target: target,
	                        position: this._position(options.shared ? shape : target, options, elementSize, event)
	                    };
	                    if (delay) {
	                        this._showTimeout = setTimeout(this._openPopupHandler, options.showAfter || 0);
	                    } else {
	                        this._openPopup();
	                    }
	                }
	            },
	            _openPopup: function () {
	                var current = this._current;
	                var position = current.position;
	                this.popup.open(position.left, position.top);
	            },
	            _autoHide: function (options) {
	                if (options.autoHide && this._closeButton) {
	                    this.element.removeClass('k-tooltip-closable');
	                    this._closeButton.remove();
	                    delete this._closeButton;
	                }
	                if (!options.autoHide && !this._closeButton) {
	                    this.element.addClass('k-tooltip-closable');
	                    this._closeButton = $(TOOLTIP_CLOSE_TEMPLATE).prependTo(this.element);
	                }
	            },
	            _showEvent: function (e) {
	                var shape = this._tooltipShape(e.element);
	                if (shape) {
	                    var options = deepExtend({}, this.options, this._tooltipOptions(shape.options.tooltip));
	                    if (options && options.showOn == e.type) {
	                        this._show(e.element, shape, options, e.originalEvent, true);
	                    }
	                }
	            },
	            _measure: function (options) {
	                var width, height;
	                this.element.css({
	                    width: 'auto',
	                    height: 'auto'
	                });
	                var visible = this.popup.visible();
	                if (!visible) {
	                    this.popup.wrapper.show();
	                }
	                this.element.css({
	                    width: defined(options.width) ? options.width : 'auto',
	                    height: defined(options.height) ? options.height : 'auto'
	                });
	                width = this.element.outerWidth();
	                height = this.element.outerHeight();
	                if (!visible) {
	                    this.popup.wrapper.hide();
	                }
	                return {
	                    width: width,
	                    height: height
	                };
	            },
	            _mouseleave: function (e) {
	                if (!this._popupRelatedTarget(e.originalEvent)) {
	                    var tooltip = this;
	                    var current = tooltip._current;
	                    if (current && current.options.autoHide) {
	                        tooltip._timeout = setTimeout(function () {
	                            clearTimeout(tooltip._showTimeout);
	                            tooltip.hide();
	                        }, current.options.hideDelay || 0);
	                    }
	                }
	            },
	            _mousemove: function (e) {
	                var current = this._current;
	                if (current && e.element) {
	                    var options = current.options;
	                    if (options.position == 'cursor') {
	                        var position = this._position(e.element, options, current.elementSize, e.originalEvent);
	                        current.position = position;
	                        this.popup.wrapper.css({
	                            left: position.left,
	                            top: position.top
	                        });
	                    }
	                }
	            },
	            _surfaceLeave: function (e) {
	                if (!this._popupRelatedTarget(e)) {
	                    clearTimeout(this._showTimeout);
	                    this.hide();
	                }
	            },
	            _popupRelatedTarget: function (e) {
	                return e.relatedTarget && $(e.relatedTarget).closest(this.popup.wrapper).length;
	            }
	        });
	        function eventCoordinates(event) {
	            var x, y;
	            if (event.touch) {
	                x = event.x.location;
	                y = event.y.location;
	            } else {
	                x = event.pageX || event.clientX || 0;
	                y = event.pageY || event.clientY || 0;
	            }
	            return {
	                x: x,
	                y: y
	            };
	        }
	        deepExtend(kendo, {
	            drawing: {
	                DASH_ARRAYS: {
	                    dot: [
	                        1.5,
	                        3.5
	                    ],
	                    dash: [
	                        4,
	                        3.5
	                    ],
	                    longdash: [
	                        8,
	                        3.5
	                    ],
	                    dashdot: [
	                        3.5,
	                        3.5,
	                        1.5,
	                        3.5
	                    ],
	                    longdashdot: [
	                        8,
	                        3.5,
	                        1.5,
	                        3.5
	                    ],
	                    longdashdotdot: [
	                        8,
	                        3.5,
	                        1.5,
	                        3.5,
	                        1.5,
	                        3.5
	                    ]
	                },
	                Color: kendo.Color,
	                BaseNode: BaseNode,
	                OptionsStore: OptionsStore,
	                Surface: Surface,
	                SurfaceFactory: SurfaceFactory,
	                SurfaceTooltip: SurfaceTooltip
	            }
	        });
	        kendo.dataviz.drawing = kendo.drawing;
	    }(window.kendo.jQuery));
	}, __webpack_require__(200)));
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_5__], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_LOCAL_MODULE_6__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__));
	}(function () {
	    (function () {
	        var kendo = window.kendo, deepExtend = kendo.deepExtend, defined = kendo.util.defined, g = kendo.geometry;
	        var GRADIENT = 'gradient';
	        var IDENTITY_MATRIX_HASH = g.Matrix.IDENTITY.toString();
	        var Paintable = {
	            extend: function (proto) {
	                proto.fill = this.fill;
	                proto.stroke = this.stroke;
	            },
	            fill: function (color, opacity) {
	                var options = this.options;
	                if (defined(color)) {
	                    if (color && color.nodeType != GRADIENT) {
	                        var newFill = { color: color };
	                        if (defined(opacity)) {
	                            newFill.opacity = opacity;
	                        }
	                        options.set('fill', newFill);
	                    } else {
	                        options.set('fill', color);
	                    }
	                    return this;
	                } else {
	                    return options.get('fill');
	                }
	            },
	            stroke: function (color, width, opacity) {
	                if (defined(color)) {
	                    this.options.set('stroke.color', color);
	                    if (defined(width)) {
	                        this.options.set('stroke.width', width);
	                    }
	                    if (defined(opacity)) {
	                        this.options.set('stroke.opacity', opacity);
	                    }
	                    return this;
	                } else {
	                    return this.options.get('stroke');
	                }
	            }
	        };
	        var Traversable = {
	            extend: function (proto, childrenField) {
	                proto.traverse = function (callback) {
	                    var children = this[childrenField];
	                    for (var i = 0; i < children.length; i++) {
	                        var child = children[i];
	                        if (child.traverse) {
	                            child.traverse(callback);
	                        } else {
	                            callback(child);
	                        }
	                    }
	                    return this;
	                };
	            }
	        };
	        var Measurable = {
	            extend: function (proto) {
	                proto.bbox = this.bbox;
	                proto.geometryChange = this.geometryChange;
	            },
	            bbox: function (transformation) {
	                var combinedMatrix = g.toMatrix(this.currentTransform(transformation));
	                var matrixHash = combinedMatrix ? combinedMatrix.toString() : IDENTITY_MATRIX_HASH;
	                var bbox;
	                if (this._bboxCache && this._matrixHash == matrixHash) {
	                    bbox = this._bboxCache.clone();
	                } else {
	                    bbox = this._bbox(combinedMatrix);
	                    this._bboxCache = bbox ? bbox.clone() : null;
	                    this._matrixHash = matrixHash;
	                }
	                var strokeWidth = this.options.get('stroke.width');
	                if (strokeWidth && bbox) {
	                    bbox.expand(strokeWidth / 2);
	                }
	                return bbox;
	            },
	            geometryChange: function () {
	                delete this._bboxCache;
	                this.trigger('geometryChange', { element: this });
	            }
	        };
	        deepExtend(kendo.drawing, {
	            mixins: {
	                Paintable: Paintable,
	                Traversable: Traversable,
	                Measurable: Measurable
	            }
	        });
	    }());
	}, __webpack_require__(200)));
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __WEBPACK_LOCAL_MODULE_5__,
	        __WEBPACK_LOCAL_MODULE_6__,
	        __WEBPACK_LOCAL_MODULE_1__,
	        __WEBPACK_LOCAL_MODULE_3__
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_LOCAL_MODULE_7__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__));
	}(function () {
	    (function ($) {
	        var kendo = window.kendo, Class = kendo.Class, deepExtend = kendo.deepExtend, g = kendo.geometry, Point = g.Point, Size = g.Size, Matrix = g.Matrix, toMatrix = g.toMatrix, drawing = kendo.drawing, OptionsStore = drawing.OptionsStore, math = Math, pow = math.pow, util = kendo.util, append = util.append, arrayLimits = util.arrayLimits, defined = util.defined, last = util.last, valueOrDefault = util.valueOrDefault, ObserversMixin = kendo.mixins.ObserversMixin, inArray = $.inArray, push = [].push, pop = [].pop, splice = [].splice, shift = [].shift, slice = [].slice, unshift = [].unshift, defId = 1, START = 'start', END = 'end', HORIZONTAL = 'horizontal';
	        var Element = Class.extend({
	            nodeType: 'Element',
	            init: function (options) {
	                this._initOptions(options);
	            },
	            _initOptions: function (options) {
	                options = options || {};
	                var transform = options.transform;
	                var clip = options.clip;
	                if (transform) {
	                    options.transform = g.transform(transform);
	                }
	                if (clip && !clip.id) {
	                    clip.id = generateDefinitionId();
	                }
	                this.options = new OptionsStore(options);
	                this.options.addObserver(this);
	            },
	            transform: function (transform) {
	                if (defined(transform)) {
	                    this.options.set('transform', g.transform(transform));
	                } else {
	                    return this.options.get('transform');
	                }
	            },
	            parentTransform: function () {
	                var element = this, transformation, parentMatrix;
	                while (element.parent) {
	                    element = element.parent;
	                    transformation = element.transform();
	                    if (transformation) {
	                        parentMatrix = transformation.matrix().multiplyCopy(parentMatrix || Matrix.unit());
	                    }
	                }
	                if (parentMatrix) {
	                    return g.transform(parentMatrix);
	                }
	            },
	            currentTransform: function (parentTransform) {
	                var elementTransform = this.transform(), elementMatrix = toMatrix(elementTransform), parentMatrix, combinedMatrix;
	                if (!defined(parentTransform)) {
	                    parentTransform = this.parentTransform();
	                }
	                parentMatrix = toMatrix(parentTransform);
	                if (elementMatrix && parentMatrix) {
	                    combinedMatrix = parentMatrix.multiplyCopy(elementMatrix);
	                } else {
	                    combinedMatrix = elementMatrix || parentMatrix;
	                }
	                if (combinedMatrix) {
	                    return g.transform(combinedMatrix);
	                }
	            },
	            visible: function (visible) {
	                if (defined(visible)) {
	                    this.options.set('visible', visible);
	                    return this;
	                } else {
	                    return this.options.get('visible') !== false;
	                }
	            },
	            clip: function (clip) {
	                var options = this.options;
	                if (defined(clip)) {
	                    if (clip && !clip.id) {
	                        clip.id = generateDefinitionId();
	                    }
	                    options.set('clip', clip);
	                    return this;
	                } else {
	                    return options.get('clip');
	                }
	            },
	            opacity: function (value) {
	                if (defined(value)) {
	                    this.options.set('opacity', value);
	                    return this;
	                } else {
	                    return valueOrDefault(this.options.get('opacity'), 1);
	                }
	            },
	            clippedBBox: function (transformation) {
	                var box = this._clippedBBox(transformation);
	                if (box) {
	                    var clip = this.clip();
	                    return clip ? g.Rect.intersect(box, clip.bbox(transformation)) : box;
	                }
	            },
	            containsPoint: function (point, parentTransform) {
	                if (this.visible()) {
	                    var transform = this.currentTransform(parentTransform);
	                    if (transform) {
	                        point = point.transformCopy(transform.matrix().invert());
	                    }
	                    return this._hasFill() && this._containsPoint(point) || this._isOnPath && this._hasStroke() && this._isOnPath(point);
	                }
	                return false;
	            },
	            _hasFill: function () {
	                var fill = this.options.fill;
	                return fill && !util.isTransparent(fill.color);
	            },
	            _hasStroke: function () {
	                var stroke = this.options.stroke;
	                return stroke && stroke.width > 0 && !util.isTransparent(stroke.color);
	            },
	            _clippedBBox: function (transformation) {
	                return this.bbox(transformation);
	            }
	        });
	        deepExtend(Element.fn, ObserversMixin);
	        var ElementsArray = Class.extend({
	            init: function (array) {
	                array = array || [];
	                this.length = 0;
	                this._splice(0, array.length, array);
	            },
	            elements: function (elements) {
	                if (elements) {
	                    this._splice(0, this.length, elements);
	                    this._change();
	                    return this;
	                } else {
	                    return this.slice(0);
	                }
	            },
	            push: function () {
	                var elements = arguments;
	                var result = push.apply(this, elements);
	                this._add(elements);
	                return result;
	            },
	            slice: slice,
	            pop: function () {
	                var length = this.length;
	                var result = pop.apply(this);
	                if (length) {
	                    this._remove([result]);
	                }
	                return result;
	            },
	            splice: function (index, howMany) {
	                var elements = slice.call(arguments, 2);
	                var result = this._splice(index, howMany, elements);
	                this._change();
	                return result;
	            },
	            shift: function () {
	                var length = this.length;
	                var result = shift.apply(this);
	                if (length) {
	                    this._remove([result]);
	                }
	                return result;
	            },
	            unshift: function () {
	                var elements = arguments;
	                var result = unshift.apply(this, elements);
	                this._add(elements);
	                return result;
	            },
	            indexOf: function (element) {
	                var that = this;
	                var idx;
	                var length;
	                for (idx = 0, length = that.length; idx < length; idx++) {
	                    if (that[idx] === element) {
	                        return idx;
	                    }
	                }
	                return -1;
	            },
	            _splice: function (index, howMany, elements) {
	                var result = splice.apply(this, [
	                    index,
	                    howMany
	                ].concat(elements));
	                this._clearObserver(result);
	                this._setObserver(elements);
	                return result;
	            },
	            _add: function (elements) {
	                this._setObserver(elements);
	                this._change();
	            },
	            _remove: function (elements) {
	                this._clearObserver(elements);
	                this._change();
	            },
	            _setObserver: function (elements) {
	                for (var idx = 0; idx < elements.length; idx++) {
	                    elements[idx].addObserver(this);
	                }
	            },
	            _clearObserver: function (elements) {
	                for (var idx = 0; idx < elements.length; idx++) {
	                    elements[idx].removeObserver(this);
	                }
	            },
	            _change: function () {
	            }
	        });
	        deepExtend(ElementsArray.fn, ObserversMixin);
	        var Group = Element.extend({
	            nodeType: 'Group',
	            init: function (options) {
	                Element.fn.init.call(this, options);
	                this.children = [];
	            },
	            childrenChange: function (action, items, index) {
	                this.trigger('childrenChange', {
	                    action: action,
	                    items: items,
	                    index: index
	                });
	            },
	            append: function () {
	                append(this.children, arguments);
	                this._reparent(arguments, this);
	                this.childrenChange('add', arguments);
	                return this;
	            },
	            insert: function (index, element) {
	                this.children.splice(index, 0, element);
	                element.parent = this;
	                this.childrenChange('add', [element], index);
	                return this;
	            },
	            insertAt: function (element, index) {
	                return this.insert(index, element);
	            },
	            remove: function (element) {
	                var index = inArray(element, this.children);
	                if (index >= 0) {
	                    this.children.splice(index, 1);
	                    element.parent = null;
	                    this.childrenChange('remove', [element], index);
	                }
	                return this;
	            },
	            removeAt: function (index) {
	                if (0 <= index && index < this.children.length) {
	                    var element = this.children[index];
	                    this.children.splice(index, 1);
	                    element.parent = null;
	                    this.childrenChange('remove', [element], index);
	                }
	                return this;
	            },
	            clear: function () {
	                var items = this.children;
	                this.children = [];
	                this._reparent(items, null);
	                this.childrenChange('remove', items, 0);
	                return this;
	            },
	            bbox: function (transformation) {
	                return elementsBoundingBox(this.children, true, this.currentTransform(transformation));
	            },
	            rawBBox: function () {
	                return elementsBoundingBox(this.children, false);
	            },
	            _clippedBBox: function (transformation) {
	                return elementsClippedBoundingBox(this.children, this.currentTransform(transformation));
	            },
	            currentTransform: function (transformation) {
	                return Element.fn.currentTransform.call(this, transformation) || null;
	            },
	            containsPoint: function (point, parentTransform) {
	                if (this.visible()) {
	                    var children = this.children;
	                    var transform = this.currentTransform(parentTransform);
	                    for (var idx = 0; idx < children.length; idx++) {
	                        if (children[idx].containsPoint(point, transform)) {
	                            return true;
	                        }
	                    }
	                }
	                return false;
	            },
	            _reparent: function (elements, newParent) {
	                for (var i = 0; i < elements.length; i++) {
	                    var child = elements[i];
	                    var parent = child.parent;
	                    if (parent && parent != this && parent.remove) {
	                        parent.remove(child);
	                    }
	                    child.parent = newParent;
	                }
	            }
	        });
	        drawing.mixins.Traversable.extend(Group.fn, 'children');
	        var Text = Element.extend({
	            nodeType: 'Text',
	            init: function (content, position, options) {
	                Element.fn.init.call(this, options);
	                this.content(content);
	                this.position(position || new g.Point());
	                if (!this.options.font) {
	                    this.options.font = '12px sans-serif';
	                }
	                if (!defined(this.options.fill)) {
	                    this.fill('#000');
	                }
	            },
	            content: function (value) {
	                if (defined(value)) {
	                    this.options.set('content', value);
	                    return this;
	                } else {
	                    return this.options.get('content');
	                }
	            },
	            measure: function () {
	                var metrics = util.measureText(this.content(), { font: this.options.get('font') });
	                return metrics;
	            },
	            rect: function () {
	                var size = this.measure();
	                var pos = this.position().clone();
	                return new g.Rect(pos, [
	                    size.width,
	                    size.height
	                ]);
	            },
	            bbox: function (transformation) {
	                var combinedMatrix = toMatrix(this.currentTransform(transformation));
	                return this.rect().bbox(combinedMatrix);
	            },
	            rawBBox: function () {
	                return this.rect().bbox();
	            },
	            _containsPoint: function (point) {
	                return this.rect().containsPoint(point);
	            }
	        });
	        drawing.mixins.Paintable.extend(Text.fn);
	        definePointAccessors(Text.fn, ['position']);
	        var Circle = Element.extend({
	            nodeType: 'Circle',
	            init: function (geometry, options) {
	                Element.fn.init.call(this, options);
	                this.geometry(geometry || new g.Circle());
	                if (!defined(this.options.stroke)) {
	                    this.stroke('#000');
	                }
	            },
	            _bbox: function (matrix) {
	                return this._geometry.bbox(matrix);
	            },
	            rawBBox: function () {
	                return this._geometry.bbox();
	            },
	            _containsPoint: function (point) {
	                return this.geometry().containsPoint(point);
	            },
	            _isOnPath: function (point) {
	                return this.geometry()._isOnPath(point, this.options.stroke.width / 2);
	            }
	        });
	        drawing.mixins.Paintable.extend(Circle.fn);
	        drawing.mixins.Measurable.extend(Circle.fn);
	        defineGeometryAccessors(Circle.fn, ['geometry']);
	        var Arc = Element.extend({
	            nodeType: 'Arc',
	            init: function (geometry, options) {
	                Element.fn.init.call(this, options);
	                this.geometry(geometry || new g.Arc());
	                if (!defined(this.options.stroke)) {
	                    this.stroke('#000');
	                }
	            },
	            _bbox: function (matrix) {
	                return this._geometry.bbox(matrix);
	            },
	            rawBBox: function () {
	                return this.geometry().bbox();
	            },
	            toPath: function () {
	                var path = new Path();
	                var curvePoints = this.geometry().curvePoints();
	                if (curvePoints.length > 0) {
	                    path.moveTo(curvePoints[0].x, curvePoints[0].y);
	                    for (var i = 1; i < curvePoints.length; i += 3) {
	                        path.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);
	                    }
	                }
	                return path;
	            },
	            _containsPoint: function (point) {
	                return this.geometry().containsPoint(point);
	            },
	            _isOnPath: function (point) {
	                return this.geometry()._isOnPath(point, this.options.stroke.width / 2);
	            }
	        });
	        drawing.mixins.Paintable.extend(Arc.fn);
	        drawing.mixins.Measurable.extend(Arc.fn);
	        defineGeometryAccessors(Arc.fn, ['geometry']);
	        var GeometryElementsArray = ElementsArray.extend({
	            _change: function () {
	                this.geometryChange();
	            }
	        });
	        var Segment = Class.extend({
	            init: function (anchor, controlIn, controlOut) {
	                this.anchor(anchor || new Point());
	                this.controlIn(controlIn);
	                this.controlOut(controlOut);
	            },
	            bboxTo: function (toSegment, matrix) {
	                var rect;
	                var segmentAnchor = this.anchor().transformCopy(matrix);
	                var toSegmentAnchor = toSegment.anchor().transformCopy(matrix);
	                if (this.controlOut() && toSegment.controlIn()) {
	                    rect = this._curveBoundingBox(segmentAnchor, this.controlOut().transformCopy(matrix), toSegment.controlIn().transformCopy(matrix), toSegmentAnchor);
	                } else {
	                    rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);
	                }
	                return rect;
	            },
	            _lineBoundingBox: function (p1, p2) {
	                return g.Rect.fromPoints(p1, p2);
	            },
	            _curveBoundingBox: function (p1, cp1, cp2, p2) {
	                var points = [
	                        p1,
	                        cp1,
	                        cp2,
	                        p2
	                    ], extremesX = this._curveExtremesFor(points, 'x'), extremesY = this._curveExtremesFor(points, 'y'), xLimits = arrayLimits([
	                        extremesX.min,
	                        extremesX.max,
	                        p1.x,
	                        p2.x
	                    ]), yLimits = arrayLimits([
	                        extremesY.min,
	                        extremesY.max,
	                        p1.y,
	                        p2.y
	                    ]);
	                return g.Rect.fromPoints(new Point(xLimits.min, yLimits.min), new Point(xLimits.max, yLimits.max));
	            },
	            _curveExtremesFor: function (points, field) {
	                var extremes = this._curveExtremes(points[0][field], points[1][field], points[2][field], points[3][field]);
	                return {
	                    min: this._calculateCurveAt(extremes.min, field, points),
	                    max: this._calculateCurveAt(extremes.max, field, points)
	                };
	            },
	            _calculateCurveAt: function (t, field, points) {
	                var t1 = 1 - t;
	                return pow(t1, 3) * points[0][field] + 3 * pow(t1, 2) * t * points[1][field] + 3 * pow(t, 2) * t1 * points[2][field] + pow(t, 3) * points[3][field];
	            },
	            _curveExtremes: function (x1, x2, x3, x4) {
	                var a = x1 - 3 * x2 + 3 * x3 - x4;
	                var b = -2 * (x1 - 2 * x2 + x3);
	                var c = x1 - x2;
	                var sqrt = math.sqrt(b * b - 4 * a * c);
	                var t1 = 0;
	                var t2 = 1;
	                if (a === 0) {
	                    if (b !== 0) {
	                        t1 = t2 = -c / b;
	                    }
	                } else if (!isNaN(sqrt)) {
	                    t1 = (-b + sqrt) / (2 * a);
	                    t2 = (-b - sqrt) / (2 * a);
	                }
	                var min = math.max(math.min(t1, t2), 0);
	                if (min < 0 || min > 1) {
	                    min = 0;
	                }
	                var max = math.min(math.max(t1, t2), 1);
	                if (max > 1 || max < 0) {
	                    max = 1;
	                }
	                return {
	                    min: min,
	                    max: max
	                };
	            },
	            _intersectionsTo: function (segment, point) {
	                var intersectionsCount;
	                if (this.controlOut() && segment.controlIn()) {
	                    intersectionsCount = g.curveIntersectionsCount([
	                        this.anchor(),
	                        this.controlOut(),
	                        segment.controlIn(),
	                        segment.anchor()
	                    ], point, this.bboxTo(segment));
	                } else {
	                    intersectionsCount = g.lineIntersectionsCount(this.anchor(), segment.anchor(), point);
	                }
	                return intersectionsCount;
	            },
	            _isOnCurveTo: function (segment, point, width, endSegment) {
	                var bbox = this.bboxTo(segment).expand(width, width);
	                if (bbox.containsPoint(point)) {
	                    var p1 = this.anchor();
	                    var p2 = this.controlOut();
	                    var p3 = segment.controlIn();
	                    var p4 = segment.anchor();
	                    if (endSegment == 'start' && p1.distanceTo(point) <= width) {
	                        return !g.isOutOfEndPoint(p1, p2, point);
	                    } else if (endSegment == 'end' && p4.distanceTo(point) <= width) {
	                        return !g.isOutOfEndPoint(p4, p3, point);
	                    }
	                    var hasRootsInRange = g.hasRootsInRange;
	                    var points = [
	                        p1,
	                        p2,
	                        p3,
	                        p4
	                    ];
	                    if (hasRootsInRange(points, point, 'x', 'y', width) || hasRootsInRange(points, point, 'y', 'x', width)) {
	                        return true;
	                    }
	                    var rotation = g.transform().rotate(45, point);
	                    var rotatedPoints = [
	                        p1.transformCopy(rotation),
	                        p2.transformCopy(rotation),
	                        p3.transformCopy(rotation),
	                        p4.transformCopy(rotation)
	                    ];
	                    return hasRootsInRange(rotatedPoints, point, 'x', 'y', width) || hasRootsInRange(rotatedPoints, point, 'y', 'x', width);
	                }
	            },
	            _isOnLineTo: function (segment, point, width) {
	                var p1 = this.anchor();
	                var p2 = segment.anchor();
	                var angle = util.deg(math.atan2(p2.y - p1.y, p2.x - p1.x));
	                var rect = new g.Rect([
	                    p1.x,
	                    p1.y - width / 2
	                ], [
	                    p1.distanceTo(p2),
	                    width
	                ]);
	                return rect.containsPoint(point.transformCopy(g.transform().rotate(-angle, p1)));
	            },
	            _isOnPathTo: function (segment, point, width, endSegment) {
	                var isOnPath;
	                if (this.controlOut() && segment.controlIn()) {
	                    isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);
	                } else {
	                    isOnPath = this._isOnLineTo(segment, point, width);
	                }
	                return isOnPath;
	            }
	        });
	        definePointAccessors(Segment.fn, [
	            'anchor',
	            'controlIn',
	            'controlOut'
	        ]);
	        deepExtend(Segment.fn, ObserversMixin);
	        var Path = Element.extend({
	            nodeType: 'Path',
	            init: function (options) {
	                Element.fn.init.call(this, options);
	                this.segments = new GeometryElementsArray();
	                this.segments.addObserver(this);
	                if (!defined(this.options.stroke)) {
	                    this.stroke('#000');
	                    if (!defined(this.options.stroke.lineJoin)) {
	                        this.options.set('stroke.lineJoin', 'miter');
	                    }
	                }
	            },
	            moveTo: function (x, y) {
	                this.suspend();
	                this.segments.elements([]);
	                this.resume();
	                this.lineTo(x, y);
	                return this;
	            },
	            lineTo: function (x, y) {
	                var point = defined(y) ? new Point(x, y) : x, segment = new Segment(point);
	                this.segments.push(segment);
	                return this;
	            },
	            curveTo: function (controlOut, controlIn, point) {
	                if (this.segments.length > 0) {
	                    var lastSegment = last(this.segments);
	                    var segment = new Segment(point, controlIn);
	                    this.suspend();
	                    lastSegment.controlOut(controlOut);
	                    this.resume();
	                    this.segments.push(segment);
	                }
	                return this;
	            },
	            arc: function (startAngle, endAngle, radiusX, radiusY, anticlockwise) {
	                if (this.segments.length > 0) {
	                    var lastSegment = last(this.segments);
	                    var anchor = lastSegment.anchor();
	                    var start = util.rad(startAngle);
	                    var center = new Point(anchor.x - radiusX * math.cos(start), anchor.y - radiusY * math.sin(start));
	                    var arc = new g.Arc(center, {
	                        startAngle: startAngle,
	                        endAngle: endAngle,
	                        radiusX: radiusX,
	                        radiusY: radiusY,
	                        anticlockwise: anticlockwise
	                    });
	                    this._addArcSegments(arc);
	                }
	                return this;
	            },
	            arcTo: function (end, rx, ry, largeArc, swipe) {
	                if (this.segments.length > 0) {
	                    var lastSegment = last(this.segments);
	                    var anchor = lastSegment.anchor();
	                    var arc = g.Arc.fromPoints(anchor, end, rx, ry, largeArc, swipe);
	                    this._addArcSegments(arc);
	                }
	                return this;
	            },
	            _addArcSegments: function (arc) {
	                this.suspend();
	                var curvePoints = arc.curvePoints();
	                for (var i = 1; i < curvePoints.length; i += 3) {
	                    this.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);
	                }
	                this.resume();
	                this.geometryChange();
	            },
	            close: function () {
	                this.options.closed = true;
	                this.geometryChange();
	                return this;
	            },
	            rawBBox: function () {
	                return this._bbox();
	            },
	            _containsPoint: function (point) {
	                var segments = this.segments;
	                var length = segments.length;
	                var intersectionsCount = 0;
	                var previous, current;
	                for (var idx = 1; idx < length; idx++) {
	                    previous = segments[idx - 1];
	                    current = segments[idx];
	                    intersectionsCount += previous._intersectionsTo(current, point);
	                }
	                if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {
	                    intersectionsCount += g.lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point);
	                }
	                return intersectionsCount % 2 !== 0;
	            },
	            _isOnPath: function (point, width) {
	                var segments = this.segments;
	                var length = segments.length;
	                width = width || this.options.stroke.width;
	                if (length > 1) {
	                    if (segments[0]._isOnPathTo(segments[1], point, width, 'start')) {
	                        return true;
	                    }
	                    for (var idx = 2; idx <= length - 2; idx++) {
	                        if (segments[idx - 1]._isOnPathTo(segments[idx], point, width)) {
	                            return true;
	                        }
	                    }
	                    if (segments[length - 2]._isOnPathTo(segments[length - 1], point, width, 'end')) {
	                        return true;
	                    }
	                }
	                return false;
	            },
	            _bbox: function (matrix) {
	                var segments = this.segments;
	                var length = segments.length;
	                var boundingBox;
	                if (length === 1) {
	                    var anchor = segments[0].anchor().transformCopy(matrix);
	                    boundingBox = new g.Rect(anchor, Size.ZERO);
	                } else if (length > 0) {
	                    for (var i = 1; i < length; i++) {
	                        var segmentBox = segments[i - 1].bboxTo(segments[i], matrix);
	                        if (boundingBox) {
	                            boundingBox = g.Rect.union(boundingBox, segmentBox);
	                        } else {
	                            boundingBox = segmentBox;
	                        }
	                    }
	                }
	                return boundingBox;
	            }
	        });
	        drawing.mixins.Paintable.extend(Path.fn);
	        drawing.mixins.Measurable.extend(Path.fn);
	        Path.fromRect = function (rect, options) {
	            return new Path(options).moveTo(rect.topLeft()).lineTo(rect.topRight()).lineTo(rect.bottomRight()).lineTo(rect.bottomLeft()).close();
	        };
	        Path.fromPoints = function (points, options) {
	            if (points) {
	                var path = new Path(options);
	                for (var i = 0; i < points.length; i++) {
	                    var pt = Point.create(points[i]);
	                    if (pt) {
	                        if (i === 0) {
	                            path.moveTo(pt);
	                        } else {
	                            path.lineTo(pt);
	                        }
	                    }
	                }
	                return path;
	            }
	        };
	        Path.fromArc = function (arc, options) {
	            var path = new Path(options);
	            var startAngle = arc.startAngle;
	            var start = arc.pointAt(startAngle);
	            path.moveTo(start.x, start.y);
	            path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);
	            return path;
	        };
	        var MultiPath = Element.extend({
	            nodeType: 'MultiPath',
	            init: function (options) {
	                Element.fn.init.call(this, options);
	                this.paths = new GeometryElementsArray();
	                this.paths.addObserver(this);
	                if (!defined(this.options.stroke)) {
	                    this.stroke('#000');
	                }
	            },
	            moveTo: function (x, y) {
	                var path = new Path();
	                path.moveTo(x, y);
	                this.paths.push(path);
	                return this;
	            },
	            lineTo: function (x, y) {
	                if (this.paths.length > 0) {
	                    last(this.paths).lineTo(x, y);
	                }
	                return this;
	            },
	            curveTo: function (controlOut, controlIn, point) {
	                if (this.paths.length > 0) {
	                    last(this.paths).curveTo(controlOut, controlIn, point);
	                }
	                return this;
	            },
	            arc: function (startAngle, endAngle, radiusX, radiusY, anticlockwise) {
	                if (this.paths.length > 0) {
	                    last(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);
	                }
	                return this;
	            },
	            arcTo: function (end, rx, ry, largeArc, swipe) {
	                if (this.paths.length > 0) {
	                    last(this.paths).arcTo(end, rx, ry, largeArc, swipe);
	                }
	                return this;
	            },
	            close: function () {
	                if (this.paths.length > 0) {
	                    last(this.paths).close();
	                }
	                return this;
	            },
	            _bbox: function (matrix) {
	                return elementsBoundingBox(this.paths, true, matrix);
	            },
	            rawBBox: function () {
	                return elementsBoundingBox(this.paths, false);
	            },
	            _containsPoint: function (point) {
	                var paths = this.paths;
	                for (var idx = 0; idx < paths.length; idx++) {
	                    if (paths[idx]._containsPoint(point)) {
	                        return true;
	                    }
	                }
	                return false;
	            },
	            _isOnPath: function (point) {
	                var paths = this.paths;
	                var width = this.options.stroke.width;
	                for (var idx = 0; idx < paths.length; idx++) {
	                    if (paths[idx]._isOnPath(point, width)) {
	                        return true;
	                    }
	                }
	                return false;
	            },
	            _clippedBBox: function (transformation) {
	                return elementsClippedBoundingBox(this.paths, this.currentTransform(transformation));
	            }
	        });
	        drawing.mixins.Paintable.extend(MultiPath.fn);
	        drawing.mixins.Measurable.extend(MultiPath.fn);
	        var Image = Element.extend({
	            nodeType: 'Image',
	            init: function (src, rect, options) {
	                Element.fn.init.call(this, options);
	                this.src(src);
	                this.rect(rect || new g.Rect());
	            },
	            src: function (value) {
	                if (defined(value)) {
	                    this.options.set('src', value);
	                    return this;
	                } else {
	                    return this.options.get('src');
	                }
	            },
	            bbox: function (transformation) {
	                var combinedMatrix = toMatrix(this.currentTransform(transformation));
	                return this._rect.bbox(combinedMatrix);
	            },
	            rawBBox: function () {
	                return this._rect.bbox();
	            },
	            _containsPoint: function (point) {
	                return this._rect.containsPoint(point);
	            },
	            _hasFill: function () {
	                return this.src();
	            }
	        });
	        defineGeometryAccessors(Image.fn, ['rect']);
	        var GradientStop = Class.extend({
	            init: function (offset, color, opacity) {
	                this.options = new OptionsStore({
	                    offset: offset,
	                    color: color,
	                    opacity: defined(opacity) ? opacity : 1
	                });
	                this.options.addObserver(this);
	            }
	        });
	        defineOptionsAccessors(GradientStop.fn, [
	            'offset',
	            'color',
	            'opacity'
	        ]);
	        deepExtend(GradientStop.fn, ObserversMixin);
	        GradientStop.create = function (arg) {
	            if (defined(arg)) {
	                var stop;
	                if (arg instanceof GradientStop) {
	                    stop = arg;
	                } else if (arg.length > 1) {
	                    stop = new GradientStop(arg[0], arg[1], arg[2]);
	                } else {
	                    stop = new GradientStop(arg.offset, arg.color, arg.opacity);
	                }
	                return stop;
	            }
	        };
	        var StopsArray = ElementsArray.extend({
	            _change: function () {
	                this.optionsChange({ field: 'stops' });
	            }
	        });
	        var Gradient = Class.extend({
	            nodeType: 'gradient',
	            init: function (options) {
	                this.stops = new StopsArray(this._createStops(options.stops));
	                this.stops.addObserver(this);
	                this._userSpace = options.userSpace;
	                this.id = generateDefinitionId();
	            },
	            userSpace: function (value) {
	                if (defined(value)) {
	                    this._userSpace = value;
	                    this.optionsChange();
	                    return this;
	                } else {
	                    return this._userSpace;
	                }
	            },
	            _createStops: function (stops) {
	                var result = [];
	                var idx;
	                stops = stops || [];
	                for (idx = 0; idx < stops.length; idx++) {
	                    result.push(GradientStop.create(stops[idx]));
	                }
	                return result;
	            },
	            addStop: function (offset, color, opacity) {
	                this.stops.push(new GradientStop(offset, color, opacity));
	            },
	            removeStop: function (stop) {
	                var index = this.stops.indexOf(stop);
	                if (index >= 0) {
	                    this.stops.splice(index, 1);
	                }
	            }
	        });
	        deepExtend(Gradient.fn, ObserversMixin, {
	            optionsChange: function (e) {
	                this.trigger('optionsChange', {
	                    field: 'gradient' + (e ? '.' + e.field : ''),
	                    value: this
	                });
	            },
	            geometryChange: function () {
	                this.optionsChange();
	            }
	        });
	        var LinearGradient = Gradient.extend({
	            init: function (options) {
	                options = options || {};
	                Gradient.fn.init.call(this, options);
	                this.start(options.start || new Point());
	                this.end(options.end || new Point(1, 0));
	            }
	        });
	        definePointAccessors(LinearGradient.fn, [
	            'start',
	            'end'
	        ]);
	        var RadialGradient = Gradient.extend({
	            init: function (options) {
	                options = options || {};
	                Gradient.fn.init.call(this, options);
	                this.center(options.center || new Point());
	                this._radius = defined(options.radius) ? options.radius : 1;
	                this._fallbackFill = options.fallbackFill;
	            },
	            radius: function (value) {
	                if (defined(value)) {
	                    this._radius = value;
	                    this.geometryChange();
	                    return this;
	                } else {
	                    return this._radius;
	                }
	            },
	            fallbackFill: function (value) {
	                if (defined(value)) {
	                    this._fallbackFill = value;
	                    this.optionsChange();
	                    return this;
	                } else {
	                    return this._fallbackFill;
	                }
	            }
	        });
	        definePointAccessors(RadialGradient.fn, ['center']);
	        var Rect = Element.extend({
	            nodeType: 'Rect',
	            init: function (geometry, options) {
	                Element.fn.init.call(this, options);
	                this.geometry(geometry || new g.Rect());
	                if (!defined(this.options.stroke)) {
	                    this.stroke('#000');
	                }
	            },
	            _bbox: function (matrix) {
	                return this._geometry.bbox(matrix);
	            },
	            rawBBox: function () {
	                return this._geometry.bbox();
	            },
	            _containsPoint: function (point) {
	                return this._geometry.containsPoint(point);
	            },
	            _isOnPath: function (point) {
	                return this.geometry()._isOnPath(point, this.options.stroke.width / 2);
	            }
	        });
	        drawing.mixins.Paintable.extend(Rect.fn);
	        drawing.mixins.Measurable.extend(Rect.fn);
	        defineGeometryAccessors(Rect.fn, ['geometry']);
	        var Layout = Group.extend({
	            init: function (rect, options) {
	                Group.fn.init.call(this, kendo.deepExtend({}, this._defaults, options));
	                this._rect = rect;
	                this._fieldMap = {};
	            },
	            _defaults: {
	                alignContent: START,
	                justifyContent: START,
	                alignItems: START,
	                spacing: 0,
	                orientation: HORIZONTAL,
	                lineSpacing: 0,
	                wrap: true
	            },
	            rect: function (value) {
	                if (value) {
	                    this._rect = value;
	                    return this;
	                } else {
	                    return this._rect;
	                }
	            },
	            _initMap: function () {
	                var options = this.options;
	                var fieldMap = this._fieldMap;
	                if (options.orientation == HORIZONTAL) {
	                    fieldMap.sizeField = 'width';
	                    fieldMap.groupsSizeField = 'height';
	                    fieldMap.groupAxis = 'x';
	                    fieldMap.groupsAxis = 'y';
	                } else {
	                    fieldMap.sizeField = 'height';
	                    fieldMap.groupsSizeField = 'width';
	                    fieldMap.groupAxis = 'y';
	                    fieldMap.groupsAxis = 'x';
	                }
	            },
	            reflow: function () {
	                if (!this._rect || this.children.length === 0) {
	                    return;
	                }
	                this._initMap();
	                if (this.options.transform) {
	                    this.transform(null);
	                }
	                var options = this.options;
	                var fieldMap = this._fieldMap;
	                var rect = this._rect;
	                var groupOptions = this._initGroups();
	                var groups = groupOptions.groups;
	                var groupsSize = groupOptions.groupsSize;
	                var sizeField = fieldMap.sizeField;
	                var groupsSizeField = fieldMap.groupsSizeField;
	                var groupAxis = fieldMap.groupAxis;
	                var groupsAxis = fieldMap.groupsAxis;
	                var groupStart = alignStart(groupsSize, rect, options.alignContent, groupsAxis, groupsSizeField);
	                var groupOrigin = new Point();
	                var elementOrigin = new Point();
	                var size = new g.Size();
	                var elementStart, bbox, element, group, groupBox;
	                for (var groupIdx = 0; groupIdx < groups.length; groupIdx++) {
	                    group = groups[groupIdx];
	                    groupOrigin[groupAxis] = elementStart = alignStart(group.size, rect, options.justifyContent, groupAxis, sizeField);
	                    groupOrigin[groupsAxis] = groupStart;
	                    size[sizeField] = group.size;
	                    size[groupsSizeField] = group.lineSize;
	                    groupBox = new g.Rect(groupOrigin, size);
	                    for (var idx = 0; idx < group.bboxes.length; idx++) {
	                        element = group.elements[idx];
	                        bbox = group.bboxes[idx];
	                        elementOrigin[groupAxis] = elementStart;
	                        elementOrigin[groupsAxis] = alignStart(bbox.size[groupsSizeField], groupBox, options.alignItems, groupsAxis, groupsSizeField);
	                        translateToPoint(elementOrigin, bbox, element);
	                        elementStart += bbox.size[sizeField] + options.spacing;
	                    }
	                    groupStart += group.lineSize + options.lineSpacing;
	                }
	                if (!options.wrap && group.size > rect.size[sizeField]) {
	                    var scale = rect.size[sizeField] / groupBox.size[sizeField];
	                    var scaledStart = groupBox.topLeft().scale(scale, scale);
	                    var scaledSize = groupBox.size[groupsSizeField] * scale;
	                    var newStart = alignStart(scaledSize, rect, options.alignContent, groupsAxis, groupsSizeField);
	                    var transform = g.transform();
	                    if (groupAxis === 'x') {
	                        transform.translate(rect.origin.x - scaledStart.x, newStart - scaledStart.y);
	                    } else {
	                        transform.translate(newStart - scaledStart.x, rect.origin.y - scaledStart.y);
	                    }
	                    transform.scale(scale, scale);
	                    this.transform(transform);
	                }
	            },
	            _initGroups: function () {
	                var options = this.options;
	                var children = this.children;
	                var lineSpacing = options.lineSpacing;
	                var sizeField = this._fieldMap.sizeField;
	                var groupsSize = -lineSpacing;
	                var groups = [];
	                var group = this._newGroup();
	                var addGroup = function () {
	                    groups.push(group);
	                    groupsSize += group.lineSize + lineSpacing;
	                };
	                var bbox, element;
	                for (var idx = 0; idx < children.length; idx++) {
	                    element = children[idx];
	                    bbox = children[idx].clippedBBox();
	                    if (element.visible() && bbox) {
	                        if (options.wrap && group.size + bbox.size[sizeField] + options.spacing > this._rect.size[sizeField]) {
	                            if (group.bboxes.length === 0) {
	                                this._addToGroup(group, bbox, element);
	                                addGroup();
	                                group = this._newGroup();
	                            } else {
	                                addGroup();
	                                group = this._newGroup();
	                                this._addToGroup(group, bbox, element);
	                            }
	                        } else {
	                            this._addToGroup(group, bbox, element);
	                        }
	                    }
	                }
	                if (group.bboxes.length) {
	                    addGroup();
	                }
	                return {
	                    groups: groups,
	                    groupsSize: groupsSize
	                };
	            },
	            _addToGroup: function (group, bbox, element) {
	                group.size += bbox.size[this._fieldMap.sizeField] + this.options.spacing;
	                group.lineSize = Math.max(bbox.size[this._fieldMap.groupsSizeField], group.lineSize);
	                group.bboxes.push(bbox);
	                group.elements.push(element);
	            },
	            _newGroup: function () {
	                return {
	                    lineSize: 0,
	                    size: -this.options.spacing,
	                    bboxes: [],
	                    elements: []
	                };
	            }
	        });
	        function elementsBoundingBox(elements, applyTransform, transformation) {
	            var boundingBox;
	            for (var i = 0; i < elements.length; i++) {
	                var element = elements[i];
	                if (element.visible()) {
	                    var elementBoundingBox = applyTransform ? element.bbox(transformation) : element.rawBBox();
	                    if (elementBoundingBox) {
	                        if (boundingBox) {
	                            boundingBox = g.Rect.union(boundingBox, elementBoundingBox);
	                        } else {
	                            boundingBox = elementBoundingBox;
	                        }
	                    }
	                }
	            }
	            return boundingBox;
	        }
	        function elementsClippedBoundingBox(elements, transformation) {
	            var boundingBox;
	            for (var i = 0; i < elements.length; i++) {
	                var element = elements[i];
	                if (element.visible()) {
	                    var elementBoundingBox = element.clippedBBox(transformation);
	                    if (elementBoundingBox) {
	                        if (boundingBox) {
	                            boundingBox = g.Rect.union(boundingBox, elementBoundingBox);
	                        } else {
	                            boundingBox = elementBoundingBox;
	                        }
	                    }
	                }
	            }
	            return boundingBox;
	        }
	        function defineGeometryAccessors(fn, names) {
	            for (var i = 0; i < names.length; i++) {
	                fn[names[i]] = geometryAccessor(names[i]);
	            }
	        }
	        function geometryAccessor(name) {
	            var fieldName = '_' + name;
	            return function (value) {
	                if (defined(value)) {
	                    this._observerField(fieldName, value);
	                    this.geometryChange();
	                    return this;
	                } else {
	                    return this[fieldName];
	                }
	            };
	        }
	        function definePointAccessors(fn, names) {
	            for (var i = 0; i < names.length; i++) {
	                fn[names[i]] = pointAccessor(names[i]);
	            }
	        }
	        function pointAccessor(name) {
	            var fieldName = '_' + name;
	            return function (value) {
	                if (defined(value)) {
	                    this._observerField(fieldName, Point.create(value));
	                    this.geometryChange();
	                    return this;
	                } else {
	                    return this[fieldName];
	                }
	            };
	        }
	        function defineOptionsAccessors(fn, names) {
	            for (var i = 0; i < names.length; i++) {
	                fn[names[i]] = optionsAccessor(names[i]);
	            }
	        }
	        function optionsAccessor(name) {
	            return function (value) {
	                if (defined(value)) {
	                    this.options.set(name, value);
	                    return this;
	                } else {
	                    return this.options.get(name);
	                }
	            };
	        }
	        function generateDefinitionId() {
	            return 'kdef' + defId++;
	        }
	        function align(elements, rect, alignment) {
	            alignElements(elements, rect, alignment, 'x', 'width');
	        }
	        function vAlign(elements, rect, alignment) {
	            alignElements(elements, rect, alignment, 'y', 'height');
	        }
	        function stack(elements) {
	            stackElements(getStackElements(elements), 'x', 'y', 'width');
	        }
	        function vStack(elements) {
	            stackElements(getStackElements(elements), 'y', 'x', 'height');
	        }
	        function wrap(elements, rect) {
	            return wrapElements(elements, rect, 'x', 'y', 'width');
	        }
	        function vWrap(elements, rect) {
	            return wrapElements(elements, rect, 'y', 'x', 'height');
	        }
	        function wrapElements(elements, rect, axis, otherAxis, sizeField) {
	            var result = [];
	            var stacks = getStacks(elements, rect, sizeField);
	            var origin = rect.origin.clone();
	            var startElement;
	            var elementIdx;
	            var stack;
	            var idx;
	            for (idx = 0; idx < stacks.length; idx++) {
	                stack = stacks[idx];
	                startElement = stack[0];
	                origin[otherAxis] = startElement.bbox.origin[otherAxis];
	                translateToPoint(origin, startElement.bbox, startElement.element);
	                startElement.bbox.origin[axis] = origin[axis];
	                stackElements(stack, axis, otherAxis, sizeField);
	                result.push([]);
	                for (elementIdx = 0; elementIdx < stack.length; elementIdx++) {
	                    result[idx].push(stack[elementIdx].element);
	                }
	            }
	            return result;
	        }
	        function fit(element, rect) {
	            var bbox = element.clippedBBox();
	            var elementSize = bbox.size;
	            var rectSize = rect.size;
	            if (rectSize.width < elementSize.width || rectSize.height < elementSize.height) {
	                var scale = math.min(rectSize.width / elementSize.width, rectSize.height / elementSize.height);
	                var transform = element.transform() || g.transform();
	                transform.scale(scale, scale);
	                element.transform(transform);
	            }
	        }
	        function getStacks(elements, rect, sizeField) {
	            var maxSize = rect.size[sizeField];
	            var stackSize = 0;
	            var stacks = [];
	            var stack = [];
	            var element;
	            var size;
	            var bbox;
	            var addElementToStack = function () {
	                stack.push({
	                    element: element,
	                    bbox: bbox
	                });
	            };
	            for (var idx = 0; idx < elements.length; idx++) {
	                element = elements[idx];
	                bbox = element.clippedBBox();
	                if (bbox) {
	                    size = bbox.size[sizeField];
	                    if (stackSize + size > maxSize) {
	                        if (stack.length) {
	                            stacks.push(stack);
	                            stack = [];
	                            addElementToStack();
	                            stackSize = size;
	                        } else {
	                            addElementToStack();
	                            stacks.push(stack);
	                            stack = [];
	                            stackSize = 0;
	                        }
	                    } else {
	                        addElementToStack();
	                        stackSize += size;
	                    }
	                }
	            }
	            if (stack.length) {
	                stacks.push(stack);
	            }
	            return stacks;
	        }
	        function getStackElements(elements) {
	            var stackElements = [];
	            var element;
	            var bbox;
	            for (var idx = 0; idx < elements.length; idx++) {
	                element = elements[idx];
	                bbox = element.clippedBBox();
	                if (bbox) {
	                    stackElements.push({
	                        element: element,
	                        bbox: bbox
	                    });
	                }
	            }
	            return stackElements;
	        }
	        function stackElements(elements, stackAxis, otherAxis, sizeField) {
	            if (elements.length > 1) {
	                var previousBBox = elements[0].bbox;
	                var origin = new Point();
	                var element;
	                var bbox;
	                for (var idx = 1; idx < elements.length; idx++) {
	                    element = elements[idx].element;
	                    bbox = elements[idx].bbox;
	                    origin[stackAxis] = previousBBox.origin[stackAxis] + previousBBox.size[sizeField];
	                    origin[otherAxis] = bbox.origin[otherAxis];
	                    translateToPoint(origin, bbox, element);
	                    bbox.origin[stackAxis] = origin[stackAxis];
	                    previousBBox = bbox;
	                }
	            }
	        }
	        function alignElements(elements, rect, alignment, axis, sizeField) {
	            var bbox, point;
	            alignment = alignment || 'start';
	            for (var idx = 0; idx < elements.length; idx++) {
	                bbox = elements[idx].clippedBBox();
	                if (bbox) {
	                    point = bbox.origin.clone();
	                    point[axis] = alignStart(bbox.size[sizeField], rect, alignment, axis, sizeField);
	                    translateToPoint(point, bbox, elements[idx]);
	                }
	            }
	        }
	        function alignStart(size, rect, align, axis, sizeField) {
	            var start;
	            if (align == START) {
	                start = rect.origin[axis];
	            } else if (align == END) {
	                start = rect.origin[axis] + rect.size[sizeField] - size;
	            } else {
	                start = rect.origin[axis] + (rect.size[sizeField] - size) / 2;
	            }
	            return start;
	        }
	        function translate(x, y, element) {
	            var transofrm = element.transform() || g.transform();
	            var matrix = transofrm.matrix();
	            matrix.e += x;
	            matrix.f += y;
	            transofrm.matrix(matrix);
	            element.transform(transofrm);
	        }
	        function translateToPoint(point, bbox, element) {
	            translate(point.x - bbox.origin.x, point.y - bbox.origin.y, element);
	        }
	        deepExtend(drawing, {
	            align: align,
	            Arc: Arc,
	            Circle: Circle,
	            Element: Element,
	            ElementsArray: ElementsArray,
	            fit: fit,
	            Gradient: Gradient,
	            GradientStop: GradientStop,
	            Group: Group,
	            Image: Image,
	            Layout: Layout,
	            LinearGradient: LinearGradient,
	            MultiPath: MultiPath,
	            Path: Path,
	            RadialGradient: RadialGradient,
	            Rect: Rect,
	            Segment: Segment,
	            stack: stack,
	            Text: Text,
	            vAlign: vAlign,
	            vStack: vStack,
	            vWrap: vWrap,
	            wrap: wrap
	        });
	    }(window.kendo.jQuery));
	}, __webpack_require__(200)));
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_7__], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_LOCAL_MODULE_8__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__));
	}(function () {
	    (function ($) {
	        var kendo = window.kendo, drawing = kendo.drawing, geometry = kendo.geometry, Class = kendo.Class, Point = geometry.Point, deepExtend = kendo.deepExtend, trim = $.trim, util = kendo.util, last = util.last;
	        var SEGMENT_REGEX = /([a-df-z]{1})([^a-df-z]*)(z)?/gi, SPLIT_REGEX = /[,\s]?([+\-]?(?:\d*\.\d+|\d+)(?:[eE][+\-]?\d+)?)/g, MOVE = 'm', CLOSE = 'z';
	        var PathParser = Class.extend({
	            parse: function (str, options) {
	                var multiPath = new drawing.MultiPath(options);
	                var position = new Point();
	                var previousCommand;
	                str.replace(SEGMENT_REGEX, function (match, element, params, closePath) {
	                    var command = element.toLowerCase();
	                    var isRelative = command === element;
	                    var parameters = parseParameters(trim(params));
	                    if (command === MOVE) {
	                        if (isRelative) {
	                            position.x += parameters[0];
	                            position.y += parameters[1];
	                        } else {
	                            position.x = parameters[0];
	                            position.y = parameters[1];
	                        }
	                        multiPath.moveTo(position.x, position.y);
	                        if (parameters.length > 2) {
	                            command = 'l';
	                            parameters.splice(0, 2);
	                        }
	                    }
	                    if (ShapeMap[command]) {
	                        ShapeMap[command](multiPath, {
	                            parameters: parameters,
	                            position: position,
	                            isRelative: isRelative,
	                            previousCommand: previousCommand
	                        });
	                        if (closePath && closePath.toLowerCase() === CLOSE) {
	                            multiPath.close();
	                        }
	                    } else if (command !== MOVE) {
	                        throw new Error('Error while parsing SVG path. Unsupported command: ' + command);
	                    }
	                    previousCommand = command;
	                });
	                return multiPath;
	            }
	        });
	        var ShapeMap = {
	            l: function (path, options) {
	                var parameters = options.parameters;
	                var position = options.position;
	                for (var i = 0; i < parameters.length; i += 2) {
	                    var point = new Point(parameters[i], parameters[i + 1]);
	                    if (options.isRelative) {
	                        point.translateWith(position);
	                    }
	                    path.lineTo(point.x, point.y);
	                    position.x = point.x;
	                    position.y = point.y;
	                }
	            },
	            c: function (path, options) {
	                var parameters = options.parameters;
	                var position = options.position;
	                var controlOut, controlIn, point;
	                for (var i = 0; i < parameters.length; i += 6) {
	                    controlOut = new Point(parameters[i], parameters[i + 1]);
	                    controlIn = new Point(parameters[i + 2], parameters[i + 3]);
	                    point = new Point(parameters[i + 4], parameters[i + 5]);
	                    if (options.isRelative) {
	                        controlIn.translateWith(position);
	                        controlOut.translateWith(position);
	                        point.translateWith(position);
	                    }
	                    path.curveTo(controlOut, controlIn, point);
	                    position.x = point.x;
	                    position.y = point.y;
	                }
	            },
	            v: function (path, options) {
	                var value = options.isRelative ? 0 : options.position.x;
	                toLineParamaters(options.parameters, true, value);
	                this.l(path, options);
	            },
	            h: function (path, options) {
	                var value = options.isRelative ? 0 : options.position.y;
	                toLineParamaters(options.parameters, false, value);
	                this.l(path, options);
	            },
	            a: function (path, options) {
	                var parameters = options.parameters;
	                var position = options.position;
	                for (var i = 0; i < parameters.length; i += 7) {
	                    var radiusX = parameters[i];
	                    var radiusY = parameters[i + 1];
	                    var largeArc = parameters[i + 3];
	                    var swipe = parameters[i + 4];
	                    var endPoint = new Point(parameters[i + 5], parameters[i + 6]);
	                    if (options.isRelative) {
	                        endPoint.translateWith(position);
	                    }
	                    path.arcTo(endPoint, radiusX, radiusY, largeArc, swipe);
	                    position.x = endPoint.x;
	                    position.y = endPoint.y;
	                }
	            },
	            s: function (path, options) {
	                var parameters = options.parameters;
	                var position = options.position;
	                var previousCommand = options.previousCommand;
	                var controlOut, endPoint, controlIn, lastControlIn;
	                if (previousCommand == 's' || previousCommand == 'c') {
	                    lastControlIn = last(last(path.paths).segments).controlIn();
	                }
	                for (var i = 0; i < parameters.length; i += 4) {
	                    controlIn = new Point(parameters[i], parameters[i + 1]);
	                    endPoint = new Point(parameters[i + 2], parameters[i + 3]);
	                    if (options.isRelative) {
	                        controlIn.translateWith(position);
	                        endPoint.translateWith(position);
	                    }
	                    if (lastControlIn) {
	                        controlOut = reflectionPoint(lastControlIn, position);
	                    } else {
	                        controlOut = position.clone();
	                    }
	                    lastControlIn = controlIn;
	                    path.curveTo(controlOut, controlIn, endPoint);
	                    position.x = endPoint.x;
	                    position.y = endPoint.y;
	                }
	            },
	            q: function (path, options) {
	                var parameters = options.parameters;
	                var position = options.position;
	                var cubicControlPoints, endPoint, controlPoint;
	                for (var i = 0; i < parameters.length; i += 4) {
	                    controlPoint = new Point(parameters[i], parameters[i + 1]);
	                    endPoint = new Point(parameters[i + 2], parameters[i + 3]);
	                    if (options.isRelative) {
	                        controlPoint.translateWith(position);
	                        endPoint.translateWith(position);
	                    }
	                    cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);
	                    path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);
	                    position.x = endPoint.x;
	                    position.y = endPoint.y;
	                }
	            },
	            t: function (path, options) {
	                var parameters = options.parameters;
	                var position = options.position;
	                var previousCommand = options.previousCommand;
	                var cubicControlPoints, controlPoint, endPoint;
	                if (previousCommand == 'q' || previousCommand == 't') {
	                    var lastSegment = last(last(path.paths).segments);
	                    controlPoint = lastSegment.controlIn().clone().translateWith(position.scaleCopy(-1 / 3)).scale(3 / 2);
	                }
	                for (var i = 0; i < parameters.length; i += 2) {
	                    endPoint = new Point(parameters[i], parameters[i + 1]);
	                    if (options.isRelative) {
	                        endPoint.translateWith(position);
	                    }
	                    if (controlPoint) {
	                        controlPoint = reflectionPoint(controlPoint, position);
	                    } else {
	                        controlPoint = position.clone();
	                    }
	                    cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);
	                    path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);
	                    position.x = endPoint.x;
	                    position.y = endPoint.y;
	                }
	            }
	        };
	        function parseParameters(str) {
	            var parameters = [];
	            str.replace(SPLIT_REGEX, function (match, number) {
	                parameters.push(parseFloat(number));
	            });
	            return parameters;
	        }
	        function toLineParamaters(parameters, isVertical, value) {
	            var insertPosition = isVertical ? 0 : 1;
	            for (var i = 0; i < parameters.length; i += 2) {
	                parameters.splice(i + insertPosition, 0, value);
	            }
	        }
	        function reflectionPoint(point, center) {
	            if (point && center) {
	                return center.scaleCopy(2).translate(-point.x, -point.y);
	            }
	        }
	        function quadraticToCubicControlPoints(position, controlPoint, endPoint) {
	            var third = 1 / 3;
	            controlPoint = controlPoint.clone().scale(2 / 3);
	            return {
	                controlOut: controlPoint.clone().translateWith(position.scaleCopy(third)),
	                controlIn: controlPoint.translateWith(endPoint.scaleCopy(third))
	            };
	        }
	        PathParser.current = new PathParser();
	        drawing.Path.parse = function (str, options) {
	            return PathParser.current.parse(str, options);
	        };
	        deepExtend(drawing, { PathParser: PathParser });
	    }(window.kendo.jQuery));
	}, __webpack_require__(200)));
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_7__], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_LOCAL_MODULE_9__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__));
	}(function () {
	    (function ($) {
	        var kendo = window.kendo, drawing = kendo.drawing, geometry = kendo.geometry, Class = kendo.Class, Rect = geometry.Rect, deepExtend = kendo.deepExtend, isArray = $.isArray, inArray = $.inArray, math = Math, LEVEL_STEP = 10000, MAX_LEVEL = 75;
	        var QuadRoot = Class.extend({
	            init: function () {
	                this.shapes = [];
	            },
	            _add: function (shape, bbox) {
	                this.shapes.push({
	                    bbox: bbox,
	                    shape: shape
	                });
	                shape._quadNode = this;
	            },
	            pointShapes: function (point) {
	                var shapes = this.shapes;
	                var length = shapes.length;
	                var result = [];
	                for (var idx = 0; idx < length; idx++) {
	                    if (shapes[idx].bbox.containsPoint(point)) {
	                        result.push(shapes[idx].shape);
	                    }
	                }
	                return result;
	            },
	            insert: function (shape, bbox) {
	                this._add(shape, bbox);
	            },
	            remove: function (shape) {
	                var shapes = this.shapes;
	                var length = shapes.length;
	                for (var idx = 0; idx < length; idx++) {
	                    if (shapes[idx].shape === shape) {
	                        shapes.splice(idx, 1);
	                        break;
	                    }
	                }
	            }
	        });
	        var QuadNode = QuadRoot.extend({
	            init: function (rect) {
	                QuadRoot.fn.init.call(this);
	                this.children = [];
	                this.rect = rect;
	            },
	            inBounds: function (rect) {
	                var nodeRect = this.rect;
	                var nodeBottomRight = nodeRect.bottomRight();
	                var bottomRight = rect.bottomRight();
	                var inBounds = nodeRect.origin.x <= rect.origin.x && nodeRect.origin.y <= rect.origin.y && bottomRight.x <= nodeBottomRight.x && bottomRight.y <= nodeBottomRight.y;
	                return inBounds;
	            },
	            pointShapes: function (point) {
	                var children = this.children;
	                var length = children.length;
	                var result = QuadRoot.fn.pointShapes.call(this, point);
	                for (var idx = 0; idx < length; idx++) {
	                    result = result.concat(children[idx].pointShapes(point));
	                }
	                return result;
	            },
	            insert: function (shape, bbox) {
	                var inserted = false;
	                var children = this.children;
	                if (this.inBounds(bbox)) {
	                    if (this.shapes.length < 4) {
	                        this._add(shape, bbox);
	                    } else {
	                        if (!children.length) {
	                            this._initChildren();
	                        }
	                        for (var idx = 0; idx < children.length; idx++) {
	                            if (children[idx].insert(shape, bbox)) {
	                                inserted = true;
	                                break;
	                            }
	                        }
	                        if (!inserted) {
	                            this._add(shape, bbox);
	                        }
	                    }
	                    inserted = true;
	                }
	                return inserted;
	            },
	            _initChildren: function () {
	                var rect = this.rect, children = this.children, center = rect.center(), halfWidth = rect.width() / 2, halfHeight = rect.height() / 2;
	                children.push(new QuadNode(new Rect([
	                    rect.origin.x,
	                    rect.origin.y
	                ], [
	                    halfWidth,
	                    halfHeight
	                ])), new QuadNode(new Rect([
	                    center.x,
	                    rect.origin.y
	                ], [
	                    halfWidth,
	                    halfHeight
	                ])), new QuadNode(new Rect([
	                    rect.origin.x,
	                    center.y
	                ], [
	                    halfWidth,
	                    halfHeight
	                ])), new QuadNode(new Rect([
	                    center.x,
	                    center.y
	                ], [
	                    halfWidth,
	                    halfHeight
	                ])));
	            }
	        });
	        var ShapesQuadTree = Class.extend({
	            ROOT_SIZE: 1000,
	            init: function () {
	                this.initRoots();
	            },
	            initRoots: function () {
	                this.rootMap = {};
	                this.root = new QuadRoot();
	                this.rootElements = [];
	            },
	            clear: function () {
	                var that = this;
	                var rootElements = that.rootElements;
	                for (var idx = 0; idx < rootElements.length; idx++) {
	                    this.remove(rootElements[idx]);
	                }
	                this.initRoots();
	            },
	            pointShape: function (point) {
	                var size = this.ROOT_SIZE;
	                var result = this.root.pointShapes(point);
	                var sectorRoot = (this.rootMap[math.floor(point.x / size)] || {})[math.floor(point.y / size)];
	                if (sectorRoot) {
	                    result = result.concat(sectorRoot.pointShapes(point));
	                }
	                this.assignZindex(result);
	                result.sort(zIndexComparer);
	                for (var idx = 0; idx < result.length; idx++) {
	                    if (result[idx].containsPoint(point)) {
	                        return result[idx];
	                    }
	                }
	            },
	            assignZindex: function (elements) {
	                var element, levelWeight, zIndex, parents;
	                for (var idx = 0; idx < elements.length; idx++) {
	                    element = elements[idx];
	                    zIndex = 0;
	                    levelWeight = math.pow(LEVEL_STEP, MAX_LEVEL);
	                    parents = [];
	                    while (element) {
	                        parents.push(element);
	                        element = element.parent;
	                    }
	                    while (parents.length) {
	                        element = parents.pop();
	                        zIndex += (inArray(element, element.parent ? element.parent.children : this.rootElements) + 1) * levelWeight;
	                        levelWeight /= LEVEL_STEP;
	                    }
	                    elements[idx]._zIndex = zIndex;
	                }
	            },
	            optionsChange: function (e) {
	                if (e.field == 'transform' || e.field == 'stroke.width') {
	                    this.bboxChange(e.element);
	                }
	            },
	            geometryChange: function (e) {
	                this.bboxChange(e.element);
	            },
	            bboxChange: function (element) {
	                if (element.nodeType === 'Group') {
	                    for (var idx = 0; idx < element.children.length; idx++) {
	                        this.bboxChange(element.children[idx]);
	                    }
	                } else {
	                    if (element._quadNode) {
	                        element._quadNode.remove(element);
	                    }
	                    this._insertShape(element);
	                }
	            },
	            add: function (elements) {
	                var elementsArray = isArray(elements) ? elements.slice(0) : [elements];
	                this.rootElements.push.apply(this.rootElements, elementsArray);
	                this._insert(elementsArray);
	            },
	            childrenChange: function (e) {
	                if (e.action == 'remove') {
	                    for (var idx = 0; idx < e.items.length; idx++) {
	                        this.remove(e.items[idx]);
	                    }
	                } else {
	                    this._insert(Array.prototype.slice.call(e.items, 0));
	                }
	            },
	            _insert: function (elements) {
	                var element;
	                while (elements.length > 0) {
	                    element = elements.pop();
	                    element.addObserver(this);
	                    if (element.nodeType == 'Group') {
	                        elements.push.apply(elements, element.children);
	                    } else {
	                        this._insertShape(element);
	                    }
	                }
	            },
	            _insertShape: function (shape) {
	                var bbox = shape.bbox();
	                if (bbox) {
	                    var rootSize = this.ROOT_SIZE;
	                    var sectors = this.getSectors(bbox);
	                    var x = sectors[0][0];
	                    var y = sectors[1][0];
	                    if (this.inRoot(sectors)) {
	                        this.root.insert(shape, bbox);
	                    } else {
	                        if (!this.rootMap[x]) {
	                            this.rootMap[x] = {};
	                        }
	                        if (!this.rootMap[x][y]) {
	                            this.rootMap[x][y] = new QuadNode(new Rect([
	                                x * rootSize,
	                                y * rootSize
	                            ], [
	                                rootSize,
	                                rootSize
	                            ]));
	                        }
	                        this.rootMap[x][y].insert(shape, bbox);
	                    }
	                }
	            },
	            remove: function (element) {
	                element.removeObserver(this);
	                if (element.nodeType == 'Group') {
	                    var children = element.children;
	                    for (var idx = 0; idx < children.length; idx++) {
	                        this.remove(children[idx]);
	                    }
	                } else if (element._quadNode) {
	                    element._quadNode.remove(element);
	                    delete element._quadNode;
	                }
	            },
	            inRoot: function (sectors) {
	                return sectors[0].length > 1 || sectors[1].length > 1;
	            },
	            getSectors: function (rect) {
	                var rootSize = this.ROOT_SIZE;
	                var bottomRight = rect.bottomRight();
	                var bottomX = math.floor(bottomRight.x / rootSize);
	                var bottomY = math.floor(bottomRight.y / rootSize);
	                var sectors = [
	                    [],
	                    []
	                ];
	                for (var x = math.floor(rect.origin.x / rootSize); x <= bottomX; x++) {
	                    sectors[0].push(x);
	                }
	                for (var y = math.floor(rect.origin.y / rootSize); y <= bottomY; y++) {
	                    sectors[1].push(y);
	                }
	                return sectors;
	            }
	        });
	        function zIndexComparer(x1, x2) {
	            if (x1._zIndex < x2._zIndex) {
	                return 1;
	            }
	            if (x1._zIndex > x2._zIndex) {
	                return -1;
	            }
	            return 0;
	        }
	        deepExtend(drawing, {
	            ShapesQuadTree: ShapesQuadTree,
	            QuadNode: QuadNode
	        });
	    }(window.kendo.jQuery));
	}, __webpack_require__(200)));
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __WEBPACK_LOCAL_MODULE_7__,
	        __WEBPACK_LOCAL_MODULE_0__
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_LOCAL_MODULE_10__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__));
	}(function () {
	    (function ($) {
	        var doc = document, kendo = window.kendo, deepExtend = kendo.deepExtend, g = kendo.geometry, d = kendo.drawing, BaseNode = d.BaseNode, util = kendo.util, defined = util.defined, isTransparent = util.isTransparent, renderAttr = util.renderAttr, renderAllAttr = util.renderAllAttr, renderTemplate = util.renderTemplate, inArray = $.inArray;
	        var BUTT = 'butt', DASH_ARRAYS = d.DASH_ARRAYS, GRADIENT = 'gradient', NONE = 'none', NS = '.kendo', SOLID = 'solid', SPACE = ' ', SVG_NS = 'http://www.w3.org/2000/svg', TRANSFORM = 'transform', UNDEFINED = 'undefined';
	        var Surface = d.Surface.extend({
	            init: function (element, options) {
	                d.Surface.fn.init.call(this, element, options);
	                this._root = new RootNode(this.options);
	                renderSVG(this.element[0], this._template(this));
	                this._rootElement = this.element[0].firstElementChild;
	                alignToScreen(this._rootElement);
	                this._root.attachTo(this._rootElement);
	                this.element.on('click' + NS, this._click);
	                this.element.on('mouseover' + NS, this._mouseenter);
	                this.element.on('mouseout' + NS, this._mouseleave);
	                this.element.on('mousemove' + NS, this._mousemove);
	                this.resize();
	            },
	            type: 'svg',
	            destroy: function () {
	                if (this._root) {
	                    this._root.destroy();
	                    this._root = null;
	                    this._rootElement = null;
	                    this.element.off(NS);
	                }
	                d.Surface.fn.destroy.call(this);
	            },
	            translate: function (offset) {
	                var viewBox = kendo.format('{0} {1} {2} {3}', Math.round(offset.x), Math.round(offset.y), this._size.width, this._size.height);
	                this._offset = offset;
	                this._rootElement.setAttribute('viewBox', viewBox);
	            },
	            draw: function (element) {
	                d.Surface.fn.draw.call(this, element);
	                this._root.load([element]);
	            },
	            clear: function () {
	                d.Surface.fn.clear.call(this);
	                this._root.clear();
	            },
	            svg: function () {
	                return '<?xml version=\'1.0\' ?>' + this._template(this);
	            },
	            exportVisual: function () {
	                var visual = this._visual;
	                var offset = this._offset;
	                if (offset) {
	                    var wrap = new d.Group();
	                    wrap.children.push(visual);
	                    wrap.transform(g.transform().translate(-offset.x, -offset.y));
	                    visual = wrap;
	                }
	                return visual;
	            },
	            _resize: function () {
	                if (this._offset) {
	                    this.translate(this._offset);
	                }
	            },
	            _template: renderTemplate('<svg style=\'width: 100%; height: 100%; overflow: hidden;\' ' + 'xmlns=\'' + SVG_NS + '\' ' + 'xmlns:xlink=\'http://www.w3.org/1999/xlink\' ' + 'version=\'1.1\'>#= d._root.render() #</svg>')
	        });
	        var Node = BaseNode.extend({
	            init: function (srcElement) {
	                BaseNode.fn.init.call(this, srcElement);
	                this.definitions = {};
	            },
	            destroy: function () {
	                if (this.element) {
	                    this.element._kendoNode = null;
	                    this.element = null;
	                }
	                this.clearDefinitions();
	                BaseNode.fn.destroy.call(this);
	            },
	            load: function (elements, pos) {
	                var node = this, element = node.element, childNode, srcElement, children, i;
	                for (i = 0; i < elements.length; i++) {
	                    srcElement = elements[i];
	                    children = srcElement.children;
	                    childNode = new nodeMap[srcElement.nodeType](srcElement);
	                    if (defined(pos)) {
	                        node.insertAt(childNode, pos);
	                    } else {
	                        node.append(childNode);
	                    }
	                    childNode.createDefinitions();
	                    if (children && children.length > 0) {
	                        childNode.load(children);
	                    }
	                    if (element) {
	                        childNode.attachTo(element, pos);
	                    }
	                }
	            },
	            root: function () {
	                var root = this;
	                while (root.parent) {
	                    root = root.parent;
	                }
	                return root;
	            },
	            attachTo: function (domElement, pos) {
	                var container = doc.createElement('div');
	                renderSVG(container, '<svg xmlns=\'' + SVG_NS + '\' version=\'1.1\'>' + this.render() + '</svg>');
	                var element = container.firstChild.firstChild;
	                if (element) {
	                    if (defined(pos)) {
	                        domElement.insertBefore(element, domElement.childNodes[pos] || null);
	                    } else {
	                        domElement.appendChild(element);
	                    }
	                    this.setElement(element);
	                }
	            },
	            setElement: function (element) {
	                var nodes = this.childNodes, childElement, i;
	                if (this.element) {
	                    this.element._kendoNode = null;
	                }
	                this.element = element;
	                this.element._kendoNode = this;
	                for (i = 0; i < nodes.length; i++) {
	                    childElement = element.childNodes[i];
	                    nodes[i].setElement(childElement);
	                }
	            },
	            clear: function () {
	                this.clearDefinitions();
	                if (this.element) {
	                    this.element.innerHTML = '';
	                }
	                var children = this.childNodes;
	                for (var i = 0; i < children.length; i++) {
	                    children[i].destroy();
	                }
	                this.childNodes = [];
	            },
	            removeSelf: function () {
	                if (this.element) {
	                    var parentNode = this.element.parentNode;
	                    if (parentNode) {
	                        parentNode.removeChild(this.element);
	                    }
	                    this.element = null;
	                }
	                BaseNode.fn.removeSelf.call(this);
	            },
	            template: renderTemplate('#= d.renderChildren() #'),
	            render: function () {
	                return this.template(this);
	            },
	            renderChildren: function () {
	                var nodes = this.childNodes, output = '', i;
	                for (i = 0; i < nodes.length; i++) {
	                    output += nodes[i].render();
	                }
	                return output;
	            },
	            optionsChange: function (e) {
	                var field = e.field;
	                var value = e.value;
	                if (field === 'visible') {
	                    this.css('display', value ? '' : NONE);
	                } else if (DefinitionMap[field] && isDefinition(field, value)) {
	                    this.updateDefinition(field, value);
	                } else if (field === 'opacity') {
	                    this.attr('opacity', value);
	                }
	                BaseNode.fn.optionsChange.call(this, e);
	            },
	            attr: function (name, value) {
	                if (this.element) {
	                    this.element.setAttribute(name, value);
	                }
	            },
	            allAttr: function (attrs) {
	                for (var i = 0; i < attrs.length; i++) {
	                    this.attr(attrs[i][0], attrs[i][1]);
	                }
	            },
	            css: function (name, value) {
	                if (this.element) {
	                    this.element.style[name] = value;
	                }
	            },
	            allCss: function (styles) {
	                for (var i = 0; i < styles.length; i++) {
	                    this.css(styles[i][0], styles[i][1]);
	                }
	            },
	            removeAttr: function (name) {
	                if (this.element) {
	                    this.element.removeAttribute(name);
	                }
	            },
	            mapTransform: function (transform) {
	                var attrs = [];
	                if (transform) {
	                    attrs.push([
	                        TRANSFORM,
	                        'matrix(' + transform.matrix().toString(6) + ')'
	                    ]);
	                }
	                return attrs;
	            },
	            renderTransform: function () {
	                return renderAllAttr(this.mapTransform(this.srcElement.transform()));
	            },
	            transformChange: function (value) {
	                if (value) {
	                    this.allAttr(this.mapTransform(value));
	                } else {
	                    this.removeAttr(TRANSFORM);
	                }
	            },
	            mapStyle: function () {
	                var options = this.srcElement.options;
	                var style = [[
	                        'cursor',
	                        options.cursor
	                    ]];
	                if (options.visible === false) {
	                    style.push([
	                        'display',
	                        NONE
	                    ]);
	                }
	                return style;
	            },
	            renderStyle: function () {
	                return renderAttr('style', util.renderStyle(this.mapStyle(true)));
	            },
	            renderOpacity: function () {
	                return renderAttr('opacity', this.srcElement.options.opacity);
	            },
	            createDefinitions: function () {
	                var srcElement = this.srcElement;
	                var definitions = this.definitions;
	                var definition, field, options, hasDefinitions;
	                if (srcElement) {
	                    options = srcElement.options;
	                    for (field in DefinitionMap) {
	                        definition = options.get(field);
	                        if (definition && isDefinition(field, definition)) {
	                            definitions[field] = definition;
	                            hasDefinitions = true;
	                        }
	                    }
	                    if (hasDefinitions) {
	                        this.definitionChange({
	                            action: 'add',
	                            definitions: definitions
	                        });
	                    }
	                }
	            },
	            definitionChange: function (e) {
	                if (this.parent) {
	                    this.parent.definitionChange(e);
	                }
	            },
	            updateDefinition: function (type, value) {
	                var definitions = this.definitions;
	                var current = definitions[type];
	                var attr = DefinitionMap[type];
	                var definition = {};
	                if (current) {
	                    definition[type] = current;
	                    this.definitionChange({
	                        action: 'remove',
	                        definitions: definition
	                    });
	                    delete definitions[type];
	                }
	                if (!value) {
	                    if (current) {
	                        this.removeAttr(attr);
	                    }
	                } else {
	                    definition[type] = value;
	                    this.definitionChange({
	                        action: 'add',
	                        definitions: definition
	                    });
	                    definitions[type] = value;
	                    this.attr(attr, refUrl(value.id));
	                }
	            },
	            clearDefinitions: function () {
	                var definitions = this.definitions;
	                var field;
	                for (field in definitions) {
	                    this.definitionChange({
	                        action: 'remove',
	                        definitions: definitions
	                    });
	                    this.definitions = {};
	                    break;
	                }
	            },
	            renderDefinitions: function () {
	                return renderAllAttr(this.mapDefinitions());
	            },
	            mapDefinitions: function () {
	                var definitions = this.definitions;
	                var attrs = [];
	                var field;
	                for (field in definitions) {
	                    attrs.push([
	                        DefinitionMap[field],
	                        refUrl(definitions[field].id)
	                    ]);
	                }
	                return attrs;
	            }
	        });
	        var RootNode = Node.extend({
	            init: function (options) {
	                Node.fn.init.call(this);
	                this.options = options;
	                this.defs = new DefinitionNode();
	            },
	            attachTo: function (domElement) {
	                this.element = domElement;
	                this.defs.attachTo(domElement.firstElementChild);
	            },
	            clear: function () {
	                BaseNode.fn.clear.call(this);
	            },
	            template: renderTemplate('#=d.defs.render()##= d.renderChildren() #'),
	            definitionChange: function (e) {
	                this.defs.definitionChange(e);
	            }
	        });
	        var DefinitionNode = Node.extend({
	            init: function () {
	                Node.fn.init.call(this);
	                this.definitionMap = {};
	            },
	            attachTo: function (domElement) {
	                this.element = domElement;
	            },
	            template: renderTemplate('<defs>#= d.renderChildren()#</defs>'),
	            definitionChange: function (e) {
	                var definitions = e.definitions;
	                var action = e.action;
	                if (action == 'add') {
	                    this.addDefinitions(definitions);
	                } else if (action == 'remove') {
	                    this.removeDefinitions(definitions);
	                }
	            },
	            createDefinition: function (type, item) {
	                var nodeType;
	                if (type == 'clip') {
	                    nodeType = ClipNode;
	                } else if (type == 'fill') {
	                    if (item instanceof d.LinearGradient) {
	                        nodeType = LinearGradientNode;
	                    } else if (item instanceof d.RadialGradient) {
	                        nodeType = RadialGradientNode;
	                    }
	                }
	                return new nodeType(item);
	            },
	            addDefinitions: function (definitions) {
	                for (var field in definitions) {
	                    this.addDefinition(field, definitions[field]);
	                }
	            },
	            addDefinition: function (type, srcElement) {
	                var definitionMap = this.definitionMap;
	                var id = srcElement.id;
	                var element = this.element;
	                var node, mapItem;
	                mapItem = definitionMap[id];
	                if (!mapItem) {
	                    node = this.createDefinition(type, srcElement);
	                    definitionMap[id] = {
	                        element: node,
	                        count: 1
	                    };
	                    this.append(node);
	                    if (element) {
	                        node.attachTo(this.element);
	                    }
	                } else {
	                    mapItem.count++;
	                }
	            },
	            removeDefinitions: function (definitions) {
	                for (var field in definitions) {
	                    this.removeDefinition(definitions[field]);
	                }
	            },
	            removeDefinition: function (srcElement) {
	                var definitionMap = this.definitionMap;
	                var id = srcElement.id;
	                var mapItem;
	                mapItem = definitionMap[id];
	                if (mapItem) {
	                    mapItem.count--;
	                    if (mapItem.count === 0) {
	                        this.remove(inArray(mapItem.element, this.childNodes), 1);
	                        delete definitionMap[id];
	                    }
	                }
	            }
	        });
	        var ClipNode = Node.extend({
	            init: function (srcElement) {
	                Node.fn.init.call(this);
	                this.srcElement = srcElement;
	                this.id = srcElement.id;
	                this.load([srcElement]);
	            },
	            template: renderTemplate('<clipPath id=\'#=d.id#\'>#= d.renderChildren()#</clipPath>')
	        });
	        var GroupNode = Node.extend({
	            template: renderTemplate('<g#= d.renderTransform() + d.renderStyle() + d.renderOpacity() + d.renderDefinitions()#>#= d.renderChildren() #</g>'),
	            optionsChange: function (e) {
	                if (e.field == TRANSFORM) {
	                    this.transformChange(e.value);
	                }
	                Node.fn.optionsChange.call(this, e);
	            }
	        });
	        var PathNode = Node.extend({
	            geometryChange: function () {
	                this.attr('d', this.renderData());
	                this.invalidate();
	            },
	            optionsChange: function (e) {
	                switch (e.field) {
	                case 'fill':
	                    if (e.value) {
	                        this.allAttr(this.mapFill(e.value));
	                    } else {
	                        this.removeAttr('fill');
	                    }
	                    break;
	                case 'fill.color':
	                    this.allAttr(this.mapFill({ color: e.value }));
	                    break;
	                case 'stroke':
	                    if (e.value) {
	                        this.allAttr(this.mapStroke(e.value));
	                    } else {
	                        this.removeAttr('stroke');
	                    }
	                    break;
	                case TRANSFORM:
	                    this.transformChange(e.value);
	                    break;
	                default:
	                    var name = this.attributeMap[e.field];
	                    if (name) {
	                        this.attr(name, e.value);
	                    }
	                    break;
	                }
	                Node.fn.optionsChange.call(this, e);
	            },
	            attributeMap: {
	                'fill.opacity': 'fill-opacity',
	                'stroke.color': 'stroke',
	                'stroke.width': 'stroke-width',
	                'stroke.opacity': 'stroke-opacity'
	            },
	            content: function () {
	                if (this.element) {
	                    this.element.textContent = this.srcElement.content();
	                }
	            },
	            renderData: function () {
	                return this.printPath(this.srcElement);
	            },
	            printPath: function (path) {
	                var segments = path.segments, length = segments.length;
	                if (length > 0) {
	                    var parts = [], output, segmentType, currentType, i;
	                    for (i = 1; i < length; i++) {
	                        segmentType = this.segmentType(segments[i - 1], segments[i]);
	                        if (segmentType !== currentType) {
	                            currentType = segmentType;
	                            parts.push(segmentType);
	                        }
	                        if (segmentType === 'L') {
	                            parts.push(this.printPoints(segments[i].anchor()));
	                        } else {
	                            parts.push(this.printPoints(segments[i - 1].controlOut(), segments[i].controlIn(), segments[i].anchor()));
	                        }
	                    }
	                    output = 'M' + this.printPoints(segments[0].anchor()) + SPACE + parts.join(SPACE);
	                    if (path.options.closed) {
	                        output += 'Z';
	                    }
	                    return output;
	                }
	            },
	            printPoints: function () {
	                var points = arguments, length = points.length, i, result = [];
	                for (i = 0; i < length; i++) {
	                    result.push(points[i].toString(3));
	                }
	                return result.join(SPACE);
	            },
	            segmentType: function (segmentStart, segmentEnd) {
	                return segmentStart.controlOut() && segmentEnd.controlIn() ? 'C' : 'L';
	            },
	            mapStroke: function (stroke) {
	                var attrs = [];
	                if (stroke && !isTransparent(stroke.color)) {
	                    attrs.push([
	                        'stroke',
	                        stroke.color
	                    ]);
	                    attrs.push([
	                        'stroke-width',
	                        stroke.width
	                    ]);
	                    attrs.push([
	                        'stroke-linecap',
	                        this.renderLinecap(stroke)
	                    ]);
	                    attrs.push([
	                        'stroke-linejoin',
	                        stroke.lineJoin
	                    ]);
	                    if (defined(stroke.opacity)) {
	                        attrs.push([
	                            'stroke-opacity',
	                            stroke.opacity
	                        ]);
	                    }
	                    if (defined(stroke.dashType)) {
	                        attrs.push([
	                            'stroke-dasharray',
	                            this.renderDashType(stroke)
	                        ]);
	                    }
	                } else {
	                    attrs.push([
	                        'stroke',
	                        NONE
	                    ]);
	                }
	                return attrs;
	            },
	            renderStroke: function () {
	                return renderAllAttr(this.mapStroke(this.srcElement.options.stroke));
	            },
	            renderDashType: function (stroke) {
	                var width = stroke.width || 1, dashType = stroke.dashType;
	                if (dashType && dashType != SOLID) {
	                    var dashArray = DASH_ARRAYS[dashType.toLowerCase()], result = [], i;
	                    for (i = 0; i < dashArray.length; i++) {
	                        result.push(dashArray[i] * width);
	                    }
	                    return result.join(' ');
	                }
	            },
	            renderLinecap: function (stroke) {
	                var dashType = stroke.dashType, lineCap = stroke.lineCap;
	                return dashType && dashType != SOLID ? BUTT : lineCap;
	            },
	            mapFill: function (fill) {
	                var attrs = [];
	                if (!(fill && fill.nodeType == GRADIENT)) {
	                    if (fill && !isTransparent(fill.color)) {
	                        attrs.push([
	                            'fill',
	                            fill.color
	                        ]);
	                        if (defined(fill.opacity)) {
	                            attrs.push([
	                                'fill-opacity',
	                                fill.opacity
	                            ]);
	                        }
	                    } else {
	                        attrs.push([
	                            'fill',
	                            NONE
	                        ]);
	                    }
	                }
	                return attrs;
	            },
	            renderFill: function () {
	                return renderAllAttr(this.mapFill(this.srcElement.options.fill));
	            },
	            template: renderTemplate('<path #= d.renderStyle() # #= d.renderOpacity() # ' + '#= kendo.util.renderAttr(\'d\', d.renderData()) # ' + '#= d.renderStroke() # ' + '#= d.renderFill() # ' + '#= d.renderDefinitions() # ' + '#= d.renderTransform() #></path>')
	        });
	        var ArcNode = PathNode.extend({
	            renderData: function () {
	                return this.printPath(this.srcElement.toPath());
	            }
	        });
	        var MultiPathNode = PathNode.extend({
	            renderData: function () {
	                var paths = this.srcElement.paths;
	                if (paths.length > 0) {
	                    var result = [], i;
	                    for (i = 0; i < paths.length; i++) {
	                        result.push(this.printPath(paths[i]));
	                    }
	                    return result.join(' ');
	                }
	            }
	        });
	        var CircleNode = PathNode.extend({
	            geometryChange: function () {
	                var center = this.center();
	                this.attr('cx', center.x);
	                this.attr('cy', center.y);
	                this.attr('r', this.radius());
	                this.invalidate();
	            },
	            center: function () {
	                return this.srcElement.geometry().center;
	            },
	            radius: function () {
	                return this.srcElement.geometry().radius;
	            },
	            template: renderTemplate('<circle #= d.renderStyle() # #= d.renderOpacity() # ' + 'cx=\'#= d.center().x #\' cy=\'#= d.center().y #\' ' + 'r=\'#= d.radius() #\' ' + '#= d.renderStroke() # ' + '#= d.renderFill() # ' + '#= d.renderDefinitions() # ' + '#= d.renderTransform() # ></circle>')
	        });
	        var TextNode = PathNode.extend({
	            geometryChange: function () {
	                var pos = this.pos();
	                this.attr('x', pos.x);
	                this.attr('y', pos.y);
	                this.invalidate();
	            },
	            optionsChange: function (e) {
	                if (e.field === 'font') {
	                    this.attr('style', util.renderStyle(this.mapStyle()));
	                    this.geometryChange();
	                } else if (e.field === 'content') {
	                    PathNode.fn.content.call(this, this.srcElement.content());
	                }
	                PathNode.fn.optionsChange.call(this, e);
	            },
	            mapStyle: function (encode) {
	                var style = PathNode.fn.mapStyle.call(this, encode);
	                var font = this.srcElement.options.font;
	                if (encode) {
	                    font = kendo.htmlEncode(font);
	                }
	                style.push([
	                    'font',
	                    font
	                ]);
	                return style;
	            },
	            pos: function () {
	                var pos = this.srcElement.position();
	                var size = this.srcElement.measure();
	                return pos.clone().setY(pos.y + size.baseline);
	            },
	            renderContent: function () {
	                var content = this.srcElement.content();
	                content = decodeEntities(content);
	                content = kendo.htmlEncode(content);
	                return content;
	            },
	            template: renderTemplate('<text #= d.renderStyle() # #= d.renderOpacity() # ' + 'x=\'#= this.pos().x #\' y=\'#= this.pos().y #\' ' + '#= d.renderStroke() # ' + '#= d.renderTransform() # ' + '#= d.renderDefinitions() # ' + '#= d.renderFill() #>#= d.renderContent() #</text>')
	        });
	        var ImageNode = PathNode.extend({
	            geometryChange: function () {
	                this.allAttr(this.mapPosition());
	                this.invalidate();
	            },
	            optionsChange: function (e) {
	                if (e.field === 'src') {
	                    this.allAttr(this.mapSource());
	                }
	                PathNode.fn.optionsChange.call(this, e);
	            },
	            mapPosition: function () {
	                var rect = this.srcElement.rect();
	                var tl = rect.topLeft();
	                return [
	                    [
	                        'x',
	                        tl.x
	                    ],
	                    [
	                        'y',
	                        tl.y
	                    ],
	                    [
	                        'width',
	                        rect.width() + 'px'
	                    ],
	                    [
	                        'height',
	                        rect.height() + 'px'
	                    ]
	                ];
	            },
	            renderPosition: function () {
	                return renderAllAttr(this.mapPosition());
	            },
	            mapSource: function (encode) {
	                var src = this.srcElement.src();
	                if (encode) {
	                    src = kendo.htmlEncode(src);
	                }
	                return [[
	                        'xlink:href',
	                        src
	                    ]];
	            },
	            renderSource: function () {
	                return renderAllAttr(this.mapSource(true));
	            },
	            template: renderTemplate('<image preserveAspectRatio=\'none\' #= d.renderStyle() # #= d.renderTransform()# #= d.renderOpacity() # ' + '#= d.renderPosition() # #= d.renderSource() # #= d.renderDefinitions()#>' + '</image>')
	        });
	        var GradientStopNode = Node.extend({
	            template: renderTemplate('<stop #=d.renderOffset()# #=d.renderStyle()# />'),
	            renderOffset: function () {
	                return renderAttr('offset', this.srcElement.offset());
	            },
	            mapStyle: function () {
	                var srcElement = this.srcElement;
	                return [
	                    [
	                        'stop-color',
	                        srcElement.color()
	                    ],
	                    [
	                        'stop-opacity',
	                        srcElement.opacity()
	                    ]
	                ];
	            },
	            optionsChange: function (e) {
	                if (e.field == 'offset') {
	                    this.attr(e.field, e.value);
	                } else if (e.field == 'color' || e.field == 'opacity') {
	                    this.css('stop-' + e.field, e.value);
	                }
	            }
	        });
	        var GradientNode = Node.extend({
	            init: function (srcElement) {
	                Node.fn.init.call(this, srcElement);
	                this.id = srcElement.id;
	                this.loadStops();
	            },
	            loadStops: function () {
	                var srcElement = this.srcElement;
	                var stops = srcElement.stops;
	                var element = this.element;
	                var stopNode;
	                var idx;
	                for (idx = 0; idx < stops.length; idx++) {
	                    stopNode = new GradientStopNode(stops[idx]);
	                    this.append(stopNode);
	                    if (element) {
	                        stopNode.attachTo(element);
	                    }
	                }
	            },
	            optionsChange: function (e) {
	                if (e.field == 'gradient.stops') {
	                    BaseNode.fn.clear.call(this);
	                    this.loadStops();
	                } else if (e.field == GRADIENT) {
	                    this.allAttr(this.mapCoordinates());
	                }
	            },
	            renderCoordinates: function () {
	                return renderAllAttr(this.mapCoordinates());
	            },
	            mapSpace: function () {
	                return [
	                    'gradientUnits',
	                    this.srcElement.userSpace() ? 'userSpaceOnUse' : 'objectBoundingBox'
	                ];
	            }
	        });
	        var LinearGradientNode = GradientNode.extend({
	            template: renderTemplate('<linearGradient id=\'#=d.id#\' #=d.renderCoordinates()#>' + '#= d.renderChildren()#' + '</linearGradient>'),
	            mapCoordinates: function () {
	                var srcElement = this.srcElement;
	                var start = srcElement.start();
	                var end = srcElement.end();
	                var attrs = [
	                    [
	                        'x1',
	                        start.x
	                    ],
	                    [
	                        'y1',
	                        start.y
	                    ],
	                    [
	                        'x2',
	                        end.x
	                    ],
	                    [
	                        'y2',
	                        end.y
	                    ],
	                    this.mapSpace()
	                ];
	                return attrs;
	            }
	        });
	        var RadialGradientNode = GradientNode.extend({
	            template: renderTemplate('<radialGradient id=\'#=d.id#\' #=d.renderCoordinates()#>' + '#= d.renderChildren()#' + '</radialGradient>'),
	            mapCoordinates: function () {
	                var srcElement = this.srcElement;
	                var center = srcElement.center();
	                var radius = srcElement.radius();
	                var attrs = [
	                    [
	                        'cx',
	                        center.x
	                    ],
	                    [
	                        'cy',
	                        center.y
	                    ],
	                    [
	                        'r',
	                        radius
	                    ],
	                    this.mapSpace()
	                ];
	                return attrs;
	            }
	        });
	        var RectNode = PathNode.extend({
	            geometryChange: function () {
	                var geometry = this.srcElement.geometry();
	                this.attr('x', geometry.origin.x);
	                this.attr('y', geometry.origin.y);
	                this.attr('width', geometry.size.width);
	                this.attr('height', geometry.size.height);
	                this.invalidate();
	            },
	            size: function () {
	                return this.srcElement.geometry().size;
	            },
	            origin: function () {
	                return this.srcElement.geometry().origin;
	            },
	            template: renderTemplate('<rect #= d.renderStyle() # #= d.renderOpacity() # ' + 'x=\'#= d.origin().x #\' y=\'#= d.origin().y #\' ' + 'width=\'#= d.size().width #\' height=\'#= d.size().height #\'' + '#= d.renderStroke() # ' + '#= d.renderFill() # ' + '#= d.renderDefinitions() # ' + '#= d.renderTransform() # />')
	        });
	        var nodeMap = {
	            Group: GroupNode,
	            Text: TextNode,
	            Path: PathNode,
	            MultiPath: MultiPathNode,
	            Circle: CircleNode,
	            Arc: ArcNode,
	            Image: ImageNode,
	            Rect: RectNode
	        };
	        var renderSVG = function (container, svg) {
	            container.innerHTML = svg;
	        };
	        (function () {
	            var testFragment = '<svg xmlns=\'' + SVG_NS + '\'></svg>', testContainer = doc.createElement('div'), hasParser = typeof DOMParser != UNDEFINED;
	            testContainer.innerHTML = testFragment;
	            if (hasParser && testContainer.firstChild.namespaceURI != SVG_NS) {
	                renderSVG = function (container, svg) {
	                    var parser = new DOMParser(), chartDoc = parser.parseFromString(svg, 'text/xml'), importedDoc = doc.adoptNode(chartDoc.documentElement);
	                    container.innerHTML = '';
	                    container.appendChild(importedDoc);
	                };
	            }
	        }());
	        function alignToScreen(element) {
	            var ctm;
	            try {
	                ctm = element.getScreenCTM ? element.getScreenCTM() : null;
	            } catch (e) {
	            }
	            if (ctm) {
	                var left = -ctm.e % 1, top = -ctm.f % 1, style = element.style;
	                if (left !== 0 || top !== 0) {
	                    style.left = left + 'px';
	                    style.top = top + 'px';
	                }
	            }
	        }
	        function baseUrl() {
	            var base = document.getElementsByTagName('base')[0], url = '', href = document.location.href, hashIndex = href.indexOf('#');
	            if (base && !kendo.support.browser.msie) {
	                if (hashIndex !== -1) {
	                    href = href.substring(0, hashIndex);
	                }
	                url = href;
	            }
	            return url;
	        }
	        function refUrl(id) {
	            return 'url(' + baseUrl() + '#' + id + ')';
	        }
	        function exportGroup(group) {
	            var root = new RootNode();
	            var bbox = group.clippedBBox();
	            if (bbox) {
	                var origin = bbox.getOrigin();
	                var exportRoot = new d.Group();
	                exportRoot.transform(g.transform().translate(-origin.x, -origin.y));
	                exportRoot.children.push(group);
	                group = exportRoot;
	            }
	            root.load([group]);
	            var svg = '<?xml version=\'1.0\' ?>' + '<svg xmlns=\'' + SVG_NS + '\' ' + 'xmlns:xlink=\'http://www.w3.org/1999/xlink\' ' + 'version=\'1.1\'>' + root.render() + '</svg>';
	            root.destroy();
	            return svg;
	        }
	        function exportSVG(group, options) {
	            var svg = exportGroup(group);
	            if (!options || !options.raw) {
	                svg = 'data:image/svg+xml;base64,' + util.encodeBase64(svg);
	            }
	            return $.Deferred().resolve(svg).promise();
	        }
	        function isDefinition(type, value) {
	            return type == 'clip' || type == 'fill' && (!value || value.nodeType == GRADIENT);
	        }
	        function decodeEntities(text) {
	            if (!text || !text.indexOf || text.indexOf('&') < 0) {
	                return text;
	            } else {
	                var element = decodeEntities._element;
	                element.innerHTML = text;
	                return element.textContent || element.innerText;
	            }
	        }
	        decodeEntities._element = document.createElement('span');
	        var DefinitionMap = {
	            clip: 'clip-path',
	            fill: 'fill'
	        };
	        kendo.support.svg = function () {
	            return doc.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
	        }();
	        if (kendo.support.svg) {
	            d.SurfaceFactory.current.register('svg', Surface, 10);
	        }
	        deepExtend(d, {
	            exportSVG: exportSVG,
	            svg: {
	                ArcNode: ArcNode,
	                CircleNode: CircleNode,
	                ClipNode: ClipNode,
	                DefinitionNode: DefinitionNode,
	                GradientStopNode: GradientStopNode,
	                GroupNode: GroupNode,
	                ImageNode: ImageNode,
	                LinearGradientNode: LinearGradientNode,
	                MultiPathNode: MultiPathNode,
	                Node: Node,
	                PathNode: PathNode,
	                RadialGradientNode: RadialGradientNode,
	                RectNode: RectNode,
	                RootNode: RootNode,
	                Surface: Surface,
	                TextNode: TextNode,
	                _exportGroup: exportGroup
	            }
	        });
	    }(window.kendo.jQuery));
	}, __webpack_require__(200)));
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __WEBPACK_LOCAL_MODULE_9__,
	        __webpack_require__(236)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_LOCAL_MODULE_11__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__));
	}(function () {
	    (function ($) {
	        var doc = document, kendo = window.kendo, deepExtend = kendo.deepExtend, util = kendo.util, defined = util.defined, isTransparent = util.isTransparent, renderTemplate = util.renderTemplate, valueOrDefault = util.valueOrDefault, g = kendo.geometry, d = kendo.drawing, BaseNode = d.BaseNode, proxy = $.proxy;
	        var BUTT = 'butt', DASH_ARRAYS = d.DASH_ARRAYS, FRAME_DELAY = 1000 / 60, SOLID = 'solid', NS = '.kendo';
	        var Surface = d.Surface.extend({
	            init: function (element, options) {
	                d.Surface.fn.init.call(this, element, options);
	                this.element[0].innerHTML = this._template(this);
	                var canvas = this.element[0].firstElementChild;
	                canvas.width = $(element).width();
	                canvas.height = $(element).height();
	                this._rootElement = canvas;
	                this._root = new RootNode(canvas);
	            },
	            destroy: function () {
	                d.Surface.fn.destroy.call(this);
	                if (this._root) {
	                    this._root.destroy();
	                    this._root = null;
	                }
	                if (this._searchTree) {
	                    this._searchTree.clear();
	                    delete this._searchTree;
	                }
	                this.element.off(NS);
	            },
	            type: 'canvas',
	            draw: function (element) {
	                d.Surface.fn.draw.call(this, element);
	                this._root.load([element], undefined, this.options.cors);
	                if (this._searchTree) {
	                    this._searchTree.add([element]);
	                }
	            },
	            clear: function () {
	                d.Surface.fn.clear.call(this);
	                this._root.clear();
	                if (this._searchTree) {
	                    this._searchTree.clear();
	                }
	            },
	            eventTarget: function (e) {
	                if (this._searchTree) {
	                    var point = this._surfacePoint(e);
	                    var shape = this._searchTree.pointShape(point);
	                    return shape;
	                }
	            },
	            image: function () {
	                var root = this._root;
	                var rootElement = this._rootElement;
	                var loadingStates = [];
	                root.traverse(function (childNode) {
	                    if (childNode.loading) {
	                        loadingStates.push(childNode.loading);
	                    }
	                });
	                var defer = $.Deferred();
	                $.when.apply($, loadingStates).done(function () {
	                    root._invalidate();
	                    try {
	                        var data = rootElement.toDataURL();
	                        defer.resolve(data);
	                    } catch (e) {
	                        defer.reject(e);
	                    }
	                }).fail(function (e) {
	                    defer.reject(e);
	                });
	                return defer.promise();
	            },
	            suspendTracking: function () {
	                d.Surface.fn.suspendTracking.call(this);
	                if (this._searchTree) {
	                    this._searchTree.clear();
	                    delete this._searchTree;
	                }
	            },
	            resumeTracking: function () {
	                d.Surface.fn.resumeTracking.call(this);
	                if (!this._searchTree) {
	                    this._searchTree = new d.ShapesQuadTree();
	                    var childNodes = this._root.childNodes;
	                    var rootElements = [];
	                    for (var idx = 0; idx < childNodes.length; idx++) {
	                        rootElements.push(childNodes[idx].srcElement);
	                    }
	                    this._searchTree.add(rootElements);
	                }
	            },
	            _resize: function () {
	                this._rootElement.width = this._size.width;
	                this._rootElement.height = this._size.height;
	                this._root.invalidate();
	            },
	            _template: renderTemplate('<canvas style=\'width: 100%; height: 100%;\'></canvas>'),
	            _enableTracking: function () {
	                this._searchTree = new d.ShapesQuadTree();
	                this._mouseTrackHandler = proxy(this._trackMouse, this);
	                this.element.on('click' + NS, this._mouseTrackHandler);
	                this.element.on('mousemove' + NS, this._mouseTrackHandler);
	                d.Surface.fn._enableTracking.call(this);
	            },
	            _trackMouse: function (e) {
	                if (this._suspendedTracking) {
	                    return;
	                }
	                var shape = this.eventTarget(e);
	                if (e.type != 'click') {
	                    var currentShape = this._currentShape;
	                    if (currentShape && currentShape !== shape) {
	                        this.trigger('mouseleave', {
	                            element: currentShape,
	                            originalEvent: e,
	                            type: 'mouseleave'
	                        });
	                    }
	                    if (shape && currentShape !== shape) {
	                        this.trigger('mouseenter', {
	                            element: shape,
	                            originalEvent: e,
	                            type: 'mouseenter'
	                        });
	                    }
	                    this.trigger('mousemove', {
	                        element: shape,
	                        originalEvent: e,
	                        type: 'mousemove'
	                    });
	                    this._currentShape = shape;
	                } else if (shape) {
	                    this.trigger('click', {
	                        element: shape,
	                        originalEvent: e,
	                        type: 'click'
	                    });
	                }
	            }
	        });
	        var Node = BaseNode.extend({
	            init: function (srcElement) {
	                BaseNode.fn.init.call(this, srcElement);
	                if (srcElement) {
	                    this.initClip();
	                }
	            },
	            initClip: function () {
	                var clip = this.srcElement.clip();
	                if (clip) {
	                    this.clip = clip;
	                    clip.addObserver(this);
	                }
	            },
	            clear: function () {
	                if (this.srcElement) {
	                    this.srcElement.removeObserver(this);
	                }
	                this.clearClip();
	                BaseNode.fn.clear.call(this);
	            },
	            clearClip: function () {
	                if (this.clip) {
	                    this.clip.removeObserver(this);
	                    delete this.clip;
	                }
	            },
	            setClip: function (ctx) {
	                if (this.clip) {
	                    ctx.beginPath();
	                    PathNode.fn.renderPoints(ctx, this.clip);
	                    ctx.clip();
	                }
	            },
	            optionsChange: function (e) {
	                if (e.field == 'clip') {
	                    this.clearClip();
	                    this.initClip();
	                }
	                BaseNode.fn.optionsChange.call(this, e);
	            },
	            setTransform: function (ctx) {
	                if (this.srcElement) {
	                    var transform = this.srcElement.transform();
	                    if (transform) {
	                        ctx.transform.apply(ctx, transform.matrix().toArray(6));
	                    }
	                }
	            },
	            loadElements: function (elements, pos, cors) {
	                var node = this, childNode, srcElement, children, i;
	                for (i = 0; i < elements.length; i++) {
	                    srcElement = elements[i];
	                    children = srcElement.children;
	                    childNode = new nodeMap[srcElement.nodeType](srcElement, cors);
	                    if (children && children.length > 0) {
	                        childNode.load(children, pos, cors);
	                    }
	                    if (defined(pos)) {
	                        node.insertAt(childNode, pos);
	                    } else {
	                        node.append(childNode);
	                    }
	                }
	            },
	            load: function (elements, pos, cors) {
	                this.loadElements(elements, pos, cors);
	                this.invalidate();
	            },
	            setOpacity: function (ctx) {
	                if (this.srcElement) {
	                    var opacity = this.srcElement.opacity();
	                    if (defined(opacity)) {
	                        this.globalAlpha(ctx, opacity);
	                    }
	                }
	            },
	            globalAlpha: function (ctx, value) {
	                if (value && ctx.globalAlpha) {
	                    value *= ctx.globalAlpha;
	                }
	                ctx.globalAlpha = value;
	            },
	            visible: function () {
	                var src = this.srcElement;
	                return !src || src && src.options.visible !== false;
	            }
	        });
	        var GroupNode = Node.extend({
	            renderTo: function (ctx) {
	                if (!this.visible()) {
	                    return;
	                }
	                ctx.save();
	                this.setTransform(ctx);
	                this.setClip(ctx);
	                this.setOpacity(ctx);
	                var childNodes = this.childNodes;
	                for (var i = 0; i < childNodes.length; i++) {
	                    var child = childNodes[i];
	                    if (child.visible()) {
	                        child.renderTo(ctx);
	                    }
	                }
	                ctx.restore();
	            }
	        });
	        d.mixins.Traversable.extend(GroupNode.fn, 'childNodes');
	        var RootNode = GroupNode.extend({
	            init: function (canvas) {
	                GroupNode.fn.init.call(this);
	                this.canvas = canvas;
	                this.ctx = canvas.getContext('2d');
	                var invalidateHandler = proxy(this._invalidate, this);
	                this.invalidate = kendo.throttle(function () {
	                    kendo.animationFrame(invalidateHandler);
	                }, FRAME_DELAY);
	            },
	            destroy: function () {
	                GroupNode.fn.destroy.call(this);
	                this.canvas = null;
	                this.ctx = null;
	            },
	            load: function (elements, pos, cors) {
	                this.loadElements(elements, pos, cors);
	                this._invalidate();
	            },
	            _invalidate: function () {
	                if (!this.ctx) {
	                    return;
	                }
	                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
	                this.renderTo(this.ctx);
	            }
	        });
	        d.mixins.Traversable.extend(RootNode.fn, 'childNodes');
	        var PathNode = Node.extend({
	            renderTo: function (ctx) {
	                ctx.save();
	                this.setTransform(ctx);
	                this.setClip(ctx);
	                this.setOpacity(ctx);
	                ctx.beginPath();
	                this.renderPoints(ctx, this.srcElement);
	                this.setLineDash(ctx);
	                this.setLineCap(ctx);
	                this.setLineJoin(ctx);
	                this.setFill(ctx);
	                this.setStroke(ctx);
	                ctx.restore();
	            },
	            setFill: function (ctx) {
	                var fill = this.srcElement.options.fill;
	                var hasFill = false;
	                if (fill) {
	                    if (fill.nodeType == 'gradient') {
	                        this.setGradientFill(ctx, fill);
	                        hasFill = true;
	                    } else if (!isTransparent(fill.color)) {
	                        ctx.fillStyle = fill.color;
	                        ctx.save();
	                        this.globalAlpha(ctx, fill.opacity);
	                        ctx.fill();
	                        ctx.restore();
	                        hasFill = true;
	                    }
	                }
	                return hasFill;
	            },
	            setGradientFill: function (ctx, fill) {
	                var bbox = this.srcElement.rawBBox();
	                var gradient;
	                if (fill instanceof d.LinearGradient) {
	                    var start = fill.start();
	                    var end = fill.end();
	                    gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
	                } else if (fill instanceof d.RadialGradient) {
	                    var center = fill.center();
	                    gradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, fill.radius());
	                }
	                addGradientStops(gradient, fill.stops);
	                ctx.save();
	                if (!fill.userSpace()) {
	                    ctx.transform(bbox.width(), 0, 0, bbox.height(), bbox.origin.x, bbox.origin.y);
	                }
	                ctx.fillStyle = gradient;
	                ctx.fill();
	                ctx.restore();
	            },
	            setStroke: function (ctx) {
	                var stroke = this.srcElement.options.stroke;
	                if (stroke && !isTransparent(stroke.color) && stroke.width > 0) {
	                    ctx.strokeStyle = stroke.color;
	                    ctx.lineWidth = valueOrDefault(stroke.width, 1);
	                    ctx.save();
	                    this.globalAlpha(ctx, stroke.opacity);
	                    ctx.stroke();
	                    ctx.restore();
	                    return true;
	                }
	            },
	            dashType: function () {
	                var stroke = this.srcElement.options.stroke;
	                if (stroke && stroke.dashType) {
	                    return stroke.dashType.toLowerCase();
	                }
	            },
	            setLineDash: function (ctx) {
	                var dashType = this.dashType();
	                if (dashType && dashType != SOLID) {
	                    var dashArray = DASH_ARRAYS[dashType];
	                    if (ctx.setLineDash) {
	                        ctx.setLineDash(dashArray);
	                    } else {
	                        ctx.mozDash = dashArray;
	                        ctx.webkitLineDash = dashArray;
	                    }
	                }
	            },
	            setLineCap: function (ctx) {
	                var dashType = this.dashType();
	                var stroke = this.srcElement.options.stroke;
	                if (dashType && dashType !== SOLID) {
	                    ctx.lineCap = BUTT;
	                } else if (stroke && stroke.lineCap) {
	                    ctx.lineCap = stroke.lineCap;
	                }
	            },
	            setLineJoin: function (ctx) {
	                var stroke = this.srcElement.options.stroke;
	                if (stroke && stroke.lineJoin) {
	                    ctx.lineJoin = stroke.lineJoin;
	                }
	            },
	            renderPoints: function (ctx, path) {
	                var segments = path.segments;
	                if (segments.length === 0) {
	                    return;
	                }
	                var seg = segments[0];
	                var anchor = seg.anchor();
	                ctx.moveTo(anchor.x, anchor.y);
	                for (var i = 1; i < segments.length; i++) {
	                    seg = segments[i];
	                    anchor = seg.anchor();
	                    var prevSeg = segments[i - 1];
	                    var prevOut = prevSeg.controlOut();
	                    var controlIn = seg.controlIn();
	                    if (prevOut && controlIn) {
	                        ctx.bezierCurveTo(prevOut.x, prevOut.y, controlIn.x, controlIn.y, anchor.x, anchor.y);
	                    } else {
	                        ctx.lineTo(anchor.x, anchor.y);
	                    }
	                }
	                if (path.options.closed) {
	                    ctx.closePath();
	                }
	            }
	        });
	        var MultiPathNode = PathNode.extend({
	            renderPoints: function (ctx) {
	                var paths = this.srcElement.paths;
	                for (var i = 0; i < paths.length; i++) {
	                    PathNode.fn.renderPoints(ctx, paths[i]);
	                }
	            }
	        });
	        var CircleNode = PathNode.extend({
	            renderPoints: function (ctx) {
	                var geometry = this.srcElement.geometry();
	                var c = geometry.center;
	                var r = geometry.radius;
	                ctx.arc(c.x, c.y, r, 0, Math.PI * 2);
	            }
	        });
	        var ArcNode = PathNode.extend({
	            renderPoints: function (ctx) {
	                var path = this.srcElement.toPath();
	                PathNode.fn.renderPoints.call(this, ctx, path);
	            }
	        });
	        var TextNode = PathNode.extend({
	            renderTo: function (ctx) {
	                var text = this.srcElement;
	                var pos = text.position();
	                var size = text.measure();
	                ctx.save();
	                this.setTransform(ctx);
	                this.setClip(ctx);
	                this.setOpacity(ctx);
	                ctx.beginPath();
	                ctx.font = text.options.font;
	                if (this.setFill(ctx)) {
	                    ctx.fillText(text.content(), pos.x, pos.y + size.baseline);
	                }
	                if (this.setStroke(ctx)) {
	                    this.setLineDash(ctx);
	                    ctx.strokeText(text.content(), pos.x, pos.y + size.baseline);
	                }
	                ctx.restore();
	            }
	        });
	        var ImageNode = PathNode.extend({
	            init: function (srcElement, cors) {
	                PathNode.fn.init.call(this, srcElement);
	                this.onLoad = proxy(this.onLoad, this);
	                this.onError = proxy(this.onError, this);
	                this.loading = $.Deferred();
	                var img = this.img = new Image();
	                if (cors && !/^data:/i.test(srcElement.src())) {
	                    img.crossOrigin = cors;
	                }
	                img.src = srcElement.src();
	                if (img.complete) {
	                    this.onLoad();
	                } else {
	                    img.onload = this.onLoad;
	                    img.onerror = this.onError;
	                }
	            },
	            renderTo: function (ctx) {
	                if (this.loading.state() === 'resolved') {
	                    ctx.save();
	                    this.setTransform(ctx);
	                    this.setClip(ctx);
	                    this.drawImage(ctx);
	                    ctx.restore();
	                }
	            },
	            optionsChange: function (e) {
	                if (e.field === 'src') {
	                    this.loading = $.Deferred();
	                    this.img.src = this.srcElement.src();
	                } else {
	                    PathNode.fn.optionsChange.call(this, e);
	                }
	            },
	            onLoad: function () {
	                this.loading.resolve();
	                this.invalidate();
	            },
	            onError: function () {
	                this.loading.reject(new Error('Unable to load image \'' + this.img.src + '\'. Check for connectivity and verify CORS headers.'));
	            },
	            drawImage: function (ctx) {
	                var rect = this.srcElement.rect();
	                var tl = rect.topLeft();
	                ctx.drawImage(this.img, tl.x, tl.y, rect.width(), rect.height());
	            }
	        });
	        var RectNode = PathNode.extend({
	            renderPoints: function (ctx) {
	                var geometry = this.srcElement.geometry();
	                var origin = geometry.origin;
	                var size = geometry.size;
	                ctx.rect(origin.x, origin.y, size.width, size.height);
	            }
	        });
	        function exportImage(group, options) {
	            var defaults = {
	                width: '800px',
	                height: '600px',
	                cors: 'Anonymous'
	            };
	            var bbox = group.clippedBBox();
	            if (bbox) {
	                var origin = bbox.getOrigin();
	                var exportRoot = new d.Group();
	                exportRoot.transform(g.transform().translate(-origin.x, -origin.y));
	                exportRoot.children.push(group);
	                group = exportRoot;
	                var size = bbox.getSize();
	                defaults.width = size.width + 'px';
	                defaults.height = size.height + 'px';
	            }
	            options = deepExtend(defaults, options);
	            var container = $('<div />').css({
	                display: 'none',
	                width: options.width,
	                height: options.height
	            }).appendTo(document.body);
	            var surface = new Surface(container, options);
	            surface.suspendTracking();
	            surface.draw(group);
	            var promise = surface.image();
	            promise.always(function () {
	                surface.destroy();
	                container.remove();
	            });
	            return promise;
	        }
	        var nodeMap = {
	            Group: GroupNode,
	            Text: TextNode,
	            Path: PathNode,
	            MultiPath: MultiPathNode,
	            Circle: CircleNode,
	            Arc: ArcNode,
	            Image: ImageNode,
	            Rect: RectNode
	        };
	        function addGradientStops(gradient, stops) {
	            var color, stop, idx;
	            for (idx = 0; idx < stops.length; idx++) {
	                stop = stops[idx];
	                color = kendo.parseColor(stop.color());
	                color.a *= stop.opacity();
	                gradient.addColorStop(stop.offset(), color.toCssRgba());
	            }
	        }
	        kendo.support.canvas = function () {
	            return !!doc.createElement('canvas').getContext;
	        }();
	        if (kendo.support.canvas) {
	            d.SurfaceFactory.current.register('canvas', Surface, 20);
	        }
	        deepExtend(kendo.drawing, {
	            exportImage: exportImage,
	            canvas: {
	                ArcNode: ArcNode,
	                CircleNode: CircleNode,
	                GroupNode: GroupNode,
	                ImageNode: ImageNode,
	                MultiPathNode: MultiPathNode,
	                Node: Node,
	                PathNode: PathNode,
	                RectNode: RectNode,
	                RootNode: RootNode,
	                Surface: Surface,
	                TextNode: TextNode
	            }
	        });
	    }(window.kendo.jQuery));
	}, __webpack_require__(200)));
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __WEBPACK_LOCAL_MODULE_7__,
	        __webpack_require__(236)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_LOCAL_MODULE_12__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__));
	}(function () {
	    (function ($) {
	        var doc = document, math = Math, atan2 = math.atan2, ceil = math.ceil, sqrt = math.sqrt, kendo = window.kendo, deepExtend = kendo.deepExtend, noop = $.noop, d = kendo.drawing, BaseNode = d.BaseNode, g = kendo.geometry, toMatrix = g.toMatrix, Color = kendo.Color, util = kendo.util, isTransparent = util.isTransparent, defined = util.defined, deg = util.deg, round = util.round, valueOrDefault = util.valueOrDefault;
	        var NONE = 'none', NS = '.kendo', COORDINATE_MULTIPLE = 100, COORDINATE_SIZE = COORDINATE_MULTIPLE * COORDINATE_MULTIPLE, GRADIENT = 'gradient', TRANSFORM_PRECISION = 4;
	        var Surface = d.Surface.extend({
	            init: function (element, options) {
	                d.Surface.fn.init.call(this, element, options);
	                enableVML();
	                this.element.empty();
	                this._root = new RootNode();
	                this._root.attachTo(this.element[0]);
	                this.element.on('click' + NS, this._click);
	                this.element.on('mouseover' + NS, this._mouseenter);
	                this.element.on('mouseout' + NS, this._mouseleave);
	                this.element.on('mousemove' + NS, this._mousemove);
	            },
	            type: 'vml',
	            destroy: function () {
	                if (this._root) {
	                    this._root.destroy();
	                    this._root = null;
	                    this.element.off(NS);
	                }
	                d.Surface.fn.destroy.call(this);
	            },
	            draw: function (element) {
	                d.Surface.fn.draw.call(this, element);
	                this._root.load([element], undefined, null);
	            },
	            clear: function () {
	                d.Surface.fn.clear.call(this);
	                this._root.clear();
	            }
	        });
	        var Node = BaseNode.extend({
	            init: function (srcElement) {
	                BaseNode.fn.init.call(this, srcElement);
	                this.createElement();
	                this.attachReference();
	            },
	            observe: noop,
	            destroy: function () {
	                if (this.element) {
	                    this.element._kendoNode = null;
	                    this.element = null;
	                }
	                BaseNode.fn.destroy.call(this);
	            },
	            clear: function () {
	                if (this.element) {
	                    this.element.innerHTML = '';
	                }
	                var children = this.childNodes;
	                for (var i = 0; i < children.length; i++) {
	                    children[i].destroy();
	                }
	                this.childNodes = [];
	            },
	            removeSelf: function () {
	                if (this.element) {
	                    this.element.parentNode.removeChild(this.element);
	                    this.element = null;
	                }
	                BaseNode.fn.removeSelf.call(this);
	            },
	            createElement: function () {
	                this.element = doc.createElement('div');
	            },
	            attachReference: function () {
	                this.element._kendoNode = this;
	            },
	            load: function (elements, pos, transform, opacity) {
	                opacity = valueOrDefault(opacity, 1);
	                if (this.srcElement) {
	                    opacity *= valueOrDefault(this.srcElement.options.opacity, 1);
	                }
	                for (var i = 0; i < elements.length; i++) {
	                    var srcElement = elements[i];
	                    var children = srcElement.children;
	                    var combinedTransform = srcElement.currentTransform(transform);
	                    var currentOpacity = opacity * valueOrDefault(srcElement.options.opacity, 1);
	                    var childNode = new nodeMap[srcElement.nodeType](srcElement, combinedTransform, currentOpacity);
	                    if (children && children.length > 0) {
	                        childNode.load(children, pos, combinedTransform, opacity);
	                    }
	                    if (defined(pos)) {
	                        this.insertAt(childNode, pos);
	                    } else {
	                        this.append(childNode);
	                    }
	                    childNode.attachTo(this.element, pos);
	                }
	            },
	            attachTo: function (domElement, pos) {
	                if (defined(pos)) {
	                    domElement.insertBefore(this.element, domElement.children[pos] || null);
	                } else {
	                    domElement.appendChild(this.element);
	                }
	            },
	            optionsChange: function (e) {
	                if (e.field == 'visible') {
	                    this.css('display', e.value !== false ? '' : NONE);
	                }
	            },
	            setStyle: function () {
	                this.allCss(this.mapStyle());
	            },
	            mapStyle: function () {
	                var style = [];
	                if (this.srcElement && this.srcElement.options.visible === false) {
	                    style.push([
	                        'display',
	                        NONE
	                    ]);
	                }
	                return style;
	            },
	            mapOpacityTo: function (attrs, multiplier) {
	                var opacity = valueOrDefault(this.opacity, 1);
	                opacity *= valueOrDefault(multiplier, 1);
	                attrs.push([
	                    'opacity',
	                    opacity
	                ]);
	            },
	            attr: function (name, value) {
	                if (this.element) {
	                    this.element[name] = value;
	                }
	            },
	            allAttr: function (attrs) {
	                for (var i = 0; i < attrs.length; i++) {
	                    this.attr(attrs[i][0], attrs[i][1]);
	                }
	            },
	            css: function (name, value) {
	                if (this.element) {
	                    this.element.style[name] = value;
	                }
	            },
	            allCss: function (styles) {
	                for (var i = 0; i < styles.length; i++) {
	                    this.css(styles[i][0], styles[i][1]);
	                }
	            }
	        });
	        var RootNode = Node.extend({
	            createElement: function () {
	                Node.fn.createElement.call(this);
	                this.allCss([
	                    [
	                        'width',
	                        '100%'
	                    ],
	                    [
	                        'height',
	                        '100%'
	                    ],
	                    [
	                        'position',
	                        'relative'
	                    ],
	                    [
	                        'visibility',
	                        'visible'
	                    ]
	                ]);
	            },
	            attachReference: noop
	        });
	        var ClipObserver = kendo.Class.extend({
	            init: function (srcElement, observer) {
	                this.srcElement = srcElement;
	                this.observer = observer;
	                srcElement.addObserver(this);
	            },
	            geometryChange: function () {
	                this.observer.optionsChange({
	                    field: 'clip',
	                    value: this.srcElement
	                });
	            },
	            clear: function () {
	                this.srcElement.removeObserver(this);
	            }
	        });
	        var ObserverNode = Node.extend({
	            init: function (srcElement) {
	                Node.fn.init.call(this, srcElement);
	                if (srcElement) {
	                    this.initClip();
	                }
	            },
	            observe: function () {
	                BaseNode.fn.observe.call(this);
	            },
	            mapStyle: function () {
	                var style = Node.fn.mapStyle.call(this);
	                if (this.srcElement && this.srcElement.clip()) {
	                    style.push([
	                        'clip',
	                        this.clipRect()
	                    ]);
	                }
	                return style;
	            },
	            optionsChange: function (e) {
	                if (e.field == 'clip') {
	                    this.clearClip();
	                    this.initClip();
	                    this.setClip();
	                }
	                Node.fn.optionsChange.call(this, e);
	            },
	            clear: function () {
	                this.clearClip();
	                Node.fn.clear.call(this);
	            },
	            initClip: function () {
	                if (this.srcElement.clip()) {
	                    this.clip = new ClipObserver(this.srcElement.clip(), this);
	                    this.clip.observer = this;
	                }
	            },
	            clearClip: function () {
	                if (this.clip) {
	                    this.clip.clear();
	                    this.clip = null;
	                    this.css('clip', this.clipRect());
	                }
	            },
	            setClip: function () {
	                if (this.clip) {
	                    this.css('clip', this.clipRect());
	                }
	            },
	            clipRect: function () {
	                var clipRect = EMPTY_CLIP;
	                var clip = this.srcElement.clip();
	                if (clip) {
	                    var bbox = this.clipBBox(clip);
	                    var topLeft = bbox.topLeft();
	                    var bottomRight = bbox.bottomRight();
	                    clipRect = kendo.format('rect({0}px {1}px {2}px {3}px)', topLeft.y, bottomRight.x, bottomRight.y, topLeft.x);
	                }
	                return clipRect;
	            },
	            clipBBox: function (clip) {
	                var topLeft = this.srcElement.rawBBox().topLeft();
	                var clipBBox = clip.rawBBox();
	                clipBBox.origin.translate(-topLeft.x, -topLeft.y);
	                return clipBBox;
	            }
	        });
	        var GroupNode = ObserverNode.extend({
	            createElement: function () {
	                Node.fn.createElement.call(this);
	                this.setStyle();
	            },
	            attachTo: function (domElement, pos) {
	                this.css('display', NONE);
	                Node.fn.attachTo.call(this, domElement, pos);
	                if (this.srcElement.options.visible !== false) {
	                    this.css('display', '');
	                }
	            },
	            _attachTo: function (domElement) {
	                var frag = document.createDocumentFragment();
	                frag.appendChild(this.element);
	                domElement.appendChild(frag);
	            },
	            mapStyle: function () {
	                var style = ObserverNode.fn.mapStyle.call(this);
	                style.push([
	                    'position',
	                    'absolute'
	                ]);
	                style.push([
	                    'white-space',
	                    'nowrap'
	                ]);
	                return style;
	            },
	            optionsChange: function (e) {
	                if (e.field === 'transform') {
	                    this.refreshTransform();
	                }
	                if (e.field === 'opacity') {
	                    this.refreshOpacity();
	                }
	                ObserverNode.fn.optionsChange.call(this, e);
	            },
	            refreshTransform: function (transform) {
	                var currentTransform = this.srcElement.currentTransform(transform), children = this.childNodes, length = children.length, i;
	                this.setClip();
	                for (i = 0; i < length; i++) {
	                    children[i].refreshTransform(currentTransform);
	                }
	            },
	            currentOpacity: function () {
	                var opacity = valueOrDefault(this.srcElement.options.opacity, 1);
	                if (this.parent && this.parent.currentOpacity) {
	                    opacity *= this.parent.currentOpacity();
	                }
	                return opacity;
	            },
	            refreshOpacity: function () {
	                var children = this.childNodes, length = children.length, i;
	                var opacity = this.currentOpacity();
	                for (i = 0; i < length; i++) {
	                    children[i].refreshOpacity(opacity);
	                }
	            },
	            initClip: function () {
	                ObserverNode.fn.initClip.call(this);
	                if (this.clip) {
	                    var bbox = this.clip.srcElement.bbox(this.srcElement.currentTransform());
	                    if (bbox) {
	                        this.css('width', bbox.width() + bbox.origin.x);
	                        this.css('height', bbox.height() + bbox.origin.y);
	                    }
	                }
	            },
	            clipBBox: function (clip) {
	                return clip.bbox(this.srcElement.currentTransform());
	            },
	            clearClip: function () {
	                ObserverNode.fn.clearClip.call(this);
	            }
	        });
	        var StrokeNode = Node.extend({
	            init: function (srcElement, opacity) {
	                this.opacity = opacity;
	                Node.fn.init.call(this, srcElement);
	            },
	            createElement: function () {
	                this.element = createElementVML('stroke');
	                this.setOpacity();
	            },
	            optionsChange: function (e) {
	                if (e.field.indexOf('stroke') === 0) {
	                    this.setStroke();
	                }
	            },
	            refreshOpacity: function (opacity) {
	                this.opacity = opacity;
	                this.setStroke();
	            },
	            setStroke: function () {
	                this.allAttr(this.mapStroke());
	            },
	            setOpacity: function () {
	                this.setStroke();
	            },
	            mapStroke: function () {
	                var stroke = this.srcElement.options.stroke;
	                var attrs = [];
	                if (stroke && !isTransparent(stroke.color) && stroke.width !== 0) {
	                    attrs.push([
	                        'on',
	                        'true'
	                    ]);
	                    attrs.push([
	                        'color',
	                        stroke.color
	                    ]);
	                    attrs.push([
	                        'weight',
	                        (stroke.width || 1) + 'px'
	                    ]);
	                    this.mapOpacityTo(attrs, stroke.opacity);
	                    if (defined(stroke.dashType)) {
	                        attrs.push([
	                            'dashstyle',
	                            stroke.dashType
	                        ]);
	                    }
	                    if (defined(stroke.lineJoin)) {
	                        attrs.push([
	                            'joinstyle',
	                            stroke.lineJoin
	                        ]);
	                    }
	                    if (defined(stroke.lineCap)) {
	                        var lineCap = stroke.lineCap.toLowerCase();
	                        if (lineCap === 'butt') {
	                            lineCap = lineCap === 'butt' ? 'flat' : lineCap;
	                        }
	                        attrs.push([
	                            'endcap',
	                            lineCap
	                        ]);
	                    }
	                } else {
	                    attrs.push([
	                        'on',
	                        'false'
	                    ]);
	                }
	                return attrs;
	            }
	        });
	        var FillNode = Node.extend({
	            init: function (srcElement, transform, opacity) {
	                this.opacity = opacity;
	                Node.fn.init.call(this, srcElement);
	            },
	            createElement: function () {
	                this.element = createElementVML('fill');
	                this.setFill();
	            },
	            optionsChange: function (e) {
	                if (fillField(e.field)) {
	                    this.setFill();
	                }
	            },
	            refreshOpacity: function (opacity) {
	                this.opacity = opacity;
	                this.setOpacity();
	            },
	            setFill: function () {
	                this.allAttr(this.mapFill());
	            },
	            setOpacity: function () {
	                this.setFill();
	            },
	            attr: function (name, value) {
	                var element = this.element;
	                if (element) {
	                    var fields = name.split('.');
	                    while (fields.length > 1) {
	                        element = element[fields.shift()];
	                    }
	                    element[fields[0]] = value;
	                }
	            },
	            mapFill: function () {
	                var fill = this.srcElement.fill();
	                var attrs = [[
	                        'on',
	                        'false'
	                    ]];
	                if (fill) {
	                    if (fill.nodeType == GRADIENT) {
	                        attrs = this.mapGradient(fill);
	                    } else if (!isTransparent(fill.color)) {
	                        attrs = this.mapFillColor(fill);
	                    }
	                }
	                return attrs;
	            },
	            mapFillColor: function (fill) {
	                var attrs = [
	                    [
	                        'on',
	                        'true'
	                    ],
	                    [
	                        'color',
	                        fill.color
	                    ]
	                ];
	                this.mapOpacityTo(attrs, fill.opacity);
	                return attrs;
	            },
	            mapGradient: function (fill) {
	                var options = this.srcElement.options;
	                var fallbackFill = options.fallbackFill || fill.fallbackFill && fill.fallbackFill();
	                var attrs;
	                if (fill instanceof d.LinearGradient) {
	                    attrs = this.mapLinearGradient(fill);
	                } else if (fill instanceof d.RadialGradient && fill.supportVML) {
	                    attrs = this.mapRadialGradient(fill);
	                } else if (fallbackFill) {
	                    attrs = this.mapFillColor(fallbackFill);
	                } else {
	                    attrs = [[
	                            'on',
	                            'false'
	                        ]];
	                }
	                return attrs;
	            },
	            mapLinearGradient: function (fill) {
	                var start = fill.start();
	                var end = fill.end();
	                var angle = util.deg(atan2(end.y - start.y, end.x - start.x));
	                var attrs = [
	                    [
	                        'on',
	                        'true'
	                    ],
	                    [
	                        'type',
	                        GRADIENT
	                    ],
	                    [
	                        'focus',
	                        0
	                    ],
	                    [
	                        'method',
	                        'none'
	                    ],
	                    [
	                        'angle',
	                        270 - angle
	                    ]
	                ];
	                this.addColors(attrs);
	                return attrs;
	            },
	            mapRadialGradient: function (fill) {
	                var bbox = this.srcElement.rawBBox();
	                var center = fill.center();
	                var focusx = (center.x - bbox.origin.x) / bbox.width();
	                var focusy = (center.y - bbox.origin.y) / bbox.height();
	                var attrs = [
	                    [
	                        'on',
	                        'true'
	                    ],
	                    [
	                        'type',
	                        'gradienttitle'
	                    ],
	                    [
	                        'focus',
	                        '100%'
	                    ],
	                    [
	                        'focusposition',
	                        focusx + ' ' + focusy
	                    ],
	                    [
	                        'method',
	                        'none'
	                    ]
	                ];
	                this.addColors(attrs);
	                return attrs;
	            },
	            addColors: function (attrs) {
	                var options = this.srcElement.options;
	                var opacity = valueOrDefault(this.opacity, 1);
	                var stopColors = [];
	                var stops = options.fill.stops;
	                var baseColor = options.baseColor;
	                var colorsField = this.element.colors ? 'colors.value' : 'colors';
	                var color = stopColor(baseColor, stops[0], opacity);
	                var color2 = stopColor(baseColor, stops[stops.length - 1], opacity);
	                var stop;
	                for (var idx = 0; idx < stops.length; idx++) {
	                    stop = stops[idx];
	                    stopColors.push(math.round(stop.offset() * 100) + '% ' + stopColor(baseColor, stop, opacity));
	                }
	                attrs.push([
	                    colorsField,
	                    stopColors.join(',')
	                ], [
	                    'color',
	                    color
	                ], [
	                    'color2',
	                    color2
	                ]);
	            }
	        });
	        var TransformNode = Node.extend({
	            init: function (srcElement, transform) {
	                this.transform = transform;
	                Node.fn.init.call(this, srcElement);
	            },
	            createElement: function () {
	                this.element = createElementVML('skew');
	                this.setTransform();
	            },
	            optionsChange: function (e) {
	                if (e.field === 'transform') {
	                    this.refresh(this.srcElement.currentTransform());
	                }
	            },
	            refresh: function (transform) {
	                this.transform = transform;
	                this.setTransform();
	            },
	            transformOrigin: function () {
	                return '-0.5,-0.5';
	            },
	            setTransform: function () {
	                this.allAttr(this.mapTransform());
	            },
	            mapTransform: function () {
	                var transform = this.transform;
	                var attrs = [], matrix = toMatrix(transform);
	                if (matrix) {
	                    matrix.round(TRANSFORM_PRECISION);
	                    attrs.push([
	                        'on',
	                        'true'
	                    ], [
	                        'matrix',
	                        [
	                            matrix.a,
	                            matrix.c,
	                            matrix.b,
	                            matrix.d,
	                            0,
	                            0
	                        ].join(',')
	                    ], [
	                        'offset',
	                        matrix.e + 'px,' + matrix.f + 'px'
	                    ], [
	                        'origin',
	                        this.transformOrigin()
	                    ]);
	                } else {
	                    attrs.push([
	                        'on',
	                        'false'
	                    ]);
	                }
	                return attrs;
	            }
	        });
	        var ShapeNode = ObserverNode.extend({
	            init: function (srcElement, transform, opacity) {
	                this.fill = this.createFillNode(srcElement, transform, opacity);
	                this.stroke = new StrokeNode(srcElement, opacity);
	                this.transform = this.createTransformNode(srcElement, transform);
	                ObserverNode.fn.init.call(this, srcElement);
	            },
	            attachTo: function (domElement, pos) {
	                this.fill.attachTo(this.element);
	                this.stroke.attachTo(this.element);
	                this.transform.attachTo(this.element);
	                Node.fn.attachTo.call(this, domElement, pos);
	            },
	            createFillNode: function (srcElement, transform, opacity) {
	                return new FillNode(srcElement, transform, opacity);
	            },
	            createTransformNode: function (srcElement, transform) {
	                return new TransformNode(srcElement, transform);
	            },
	            createElement: function () {
	                this.element = createElementVML('shape');
	                this.setCoordsize();
	                this.setStyle();
	            },
	            optionsChange: function (e) {
	                if (fillField(e.field)) {
	                    this.fill.optionsChange(e);
	                } else if (e.field.indexOf('stroke') === 0) {
	                    this.stroke.optionsChange(e);
	                } else if (e.field === 'transform') {
	                    this.transform.optionsChange(e);
	                } else if (e.field === 'opacity') {
	                    this.fill.setOpacity();
	                    this.stroke.setOpacity();
	                }
	                ObserverNode.fn.optionsChange.call(this, e);
	            },
	            refreshTransform: function (transform) {
	                this.transform.refresh(this.srcElement.currentTransform(transform));
	            },
	            refreshOpacity: function (opacity) {
	                opacity *= valueOrDefault(this.srcElement.options.opacity, 1);
	                this.fill.refreshOpacity(opacity);
	                this.stroke.refreshOpacity(opacity);
	            },
	            mapStyle: function (width, height) {
	                var styles = ObserverNode.fn.mapStyle.call(this);
	                if (!width || !height) {
	                    width = height = COORDINATE_MULTIPLE;
	                }
	                styles.push([
	                    'position',
	                    'absolute'
	                ], [
	                    'width',
	                    width + 'px'
	                ], [
	                    'height',
	                    height + 'px'
	                ]);
	                var cursor = this.srcElement.options.cursor;
	                if (cursor) {
	                    styles.push([
	                        'cursor',
	                        cursor
	                    ]);
	                }
	                return styles;
	            },
	            setCoordsize: function () {
	                this.allAttr([
	                    [
	                        'coordorigin',
	                        '0 0'
	                    ],
	                    [
	                        'coordsize',
	                        COORDINATE_SIZE + ' ' + COORDINATE_SIZE
	                    ]
	                ]);
	            }
	        });
	        var PathDataNode = Node.extend({
	            createElement: function () {
	                this.element = createElementVML('path');
	                this.setPathData();
	            },
	            geometryChange: function () {
	                this.setPathData();
	            },
	            setPathData: function () {
	                this.attr('v', this.renderData());
	            },
	            renderData: function () {
	                return printPath(this.srcElement);
	            }
	        });
	        var PathNode = ShapeNode.extend({
	            init: function (srcElement, transform, opacity) {
	                this.pathData = this.createDataNode(srcElement);
	                ShapeNode.fn.init.call(this, srcElement, transform, opacity);
	            },
	            attachTo: function (domElement, pos) {
	                this.pathData.attachTo(this.element);
	                ShapeNode.fn.attachTo.call(this, domElement, pos);
	            },
	            createDataNode: function (srcElement) {
	                return new PathDataNode(srcElement);
	            },
	            geometryChange: function () {
	                this.pathData.geometryChange();
	                ShapeNode.fn.geometryChange.call(this);
	            }
	        });
	        var MultiPathDataNode = PathDataNode.extend({
	            renderData: function () {
	                var paths = this.srcElement.paths;
	                if (paths.length > 0) {
	                    var result = [], i, open;
	                    for (i = 0; i < paths.length; i++) {
	                        open = i < paths.length - 1;
	                        result.push(printPath(paths[i], open));
	                    }
	                    return result.join(' ');
	                }
	            }
	        });
	        var MultiPathNode = PathNode.extend({
	            createDataNode: function (srcElement) {
	                return new MultiPathDataNode(srcElement);
	            }
	        });
	        var CircleTransformNode = TransformNode.extend({
	            transformOrigin: function () {
	                var boundingBox = this.srcElement.geometry().bbox(), center = boundingBox.center(), originX = -ceil(center.x) / ceil(boundingBox.width()), originY = -ceil(center.y) / ceil(boundingBox.height());
	                return originX + ',' + originY;
	            }
	        });
	        var CircleNode = ShapeNode.extend({
	            createElement: function () {
	                this.element = createElementVML('oval');
	                this.setStyle();
	            },
	            createTransformNode: function (srcElement, transform) {
	                return new CircleTransformNode(srcElement, transform);
	            },
	            geometryChange: function () {
	                ShapeNode.fn.geometryChange.call(this);
	                this.setStyle();
	                this.refreshTransform();
	            },
	            mapStyle: function () {
	                var geometry = this.srcElement.geometry();
	                var radius = geometry.radius;
	                var center = geometry.center;
	                var diameter = ceil(radius * 2);
	                var styles = ShapeNode.fn.mapStyle.call(this, diameter, diameter);
	                styles.push([
	                    'left',
	                    ceil(center.x - radius) + 'px'
	                ], [
	                    'top',
	                    ceil(center.y - radius) + 'px'
	                ]);
	                return styles;
	            }
	        });
	        var ArcDataNode = PathDataNode.extend({
	            renderData: function () {
	                return printPath(this.srcElement.toPath());
	            }
	        });
	        var ArcNode = PathNode.extend({
	            createDataNode: function (srcElement) {
	                return new ArcDataNode(srcElement);
	            }
	        });
	        var TextPathDataNode = PathDataNode.extend({
	            createElement: function () {
	                PathDataNode.fn.createElement.call(this);
	                this.attr('textpathok', true);
	            },
	            renderData: function () {
	                var rect = this.srcElement.rect();
	                var center = rect.center();
	                return 'm ' + printPoints([new g.Point(rect.topLeft().x, center.y)]) + ' l ' + printPoints([new g.Point(rect.bottomRight().x, center.y)]);
	            }
	        });
	        var TextPathNode = Node.extend({
	            createElement: function () {
	                this.element = createElementVML('textpath');
	                this.attr('on', true);
	                this.attr('fitpath', false);
	                this.setStyle();
	                this.setString();
	            },
	            optionsChange: function (e) {
	                if (e.field === 'content') {
	                    this.setString();
	                } else {
	                    this.setStyle();
	                }
	                Node.fn.optionsChange.call(this, e);
	            },
	            mapStyle: function () {
	                return [[
	                        'font',
	                        this.srcElement.options.font
	                    ]];
	            },
	            setString: function () {
	                this.attr('string', this.srcElement.content());
	            }
	        });
	        var TextNode = PathNode.extend({
	            init: function (srcElement, transform, opacity) {
	                this.path = new TextPathNode(srcElement);
	                PathNode.fn.init.call(this, srcElement, transform, opacity);
	            },
	            createDataNode: function (srcElement) {
	                return new TextPathDataNode(srcElement);
	            },
	            attachTo: function (domElement, pos) {
	                this.path.attachTo(this.element);
	                PathNode.fn.attachTo.call(this, domElement, pos);
	            },
	            optionsChange: function (e) {
	                if (e.field === 'font' || e.field === 'content') {
	                    this.path.optionsChange(e);
	                    this.pathData.geometryChange(e);
	                }
	                PathNode.fn.optionsChange.call(this, e);
	            }
	        });
	        var ImagePathDataNode = PathDataNode.extend({
	            renderData: function () {
	                var rect = this.srcElement.rect();
	                var path = new d.Path().moveTo(rect.topLeft()).lineTo(rect.topRight()).lineTo(rect.bottomRight()).lineTo(rect.bottomLeft()).close();
	                return printPath(path);
	            }
	        });
	        var ImageFillNode = TransformNode.extend({
	            init: function (srcElement, transform, opacity) {
	                this.opacity = opacity;
	                TransformNode.fn.init.call(this, srcElement, transform);
	            },
	            createElement: function () {
	                this.element = createElementVML('fill');
	                this.attr('type', 'frame');
	                this.attr('rotate', true);
	                this.setOpacity();
	                this.setSrc();
	                this.setTransform();
	            },
	            optionsChange: function (e) {
	                if (e.field === 'src') {
	                    this.setSrc();
	                }
	                TransformNode.fn.optionsChange.call(this, e);
	            },
	            geometryChange: function () {
	                this.refresh();
	            },
	            refreshOpacity: function (opacity) {
	                this.opacity = opacity;
	                this.setOpacity();
	            },
	            setOpacity: function () {
	                var attrs = [];
	                this.mapOpacityTo(attrs, this.srcElement.options.opacity);
	                this.allAttr(attrs);
	            },
	            setSrc: function () {
	                this.attr('src', this.srcElement.src());
	            },
	            mapTransform: function () {
	                var img = this.srcElement;
	                var rawbbox = img.rawBBox();
	                var rawcenter = rawbbox.center();
	                var fillOrigin = COORDINATE_MULTIPLE / 2;
	                var fillSize = COORDINATE_MULTIPLE;
	                var x;
	                var y;
	                var width = rawbbox.width() / fillSize;
	                var height = rawbbox.height() / fillSize;
	                var angle = 0;
	                var transform = this.transform;
	                if (transform) {
	                    var matrix = toMatrix(transform);
	                    var sx = sqrt(matrix.a * matrix.a + matrix.b * matrix.b);
	                    var sy = sqrt(matrix.c * matrix.c + matrix.d * matrix.d);
	                    width *= sx;
	                    height *= sy;
	                    var ax = deg(atan2(matrix.b, matrix.d));
	                    var ay = deg(atan2(-matrix.c, matrix.a));
	                    angle = (ax + ay) / 2;
	                    if (angle !== 0) {
	                        var center = img.bbox().center();
	                        x = (center.x - fillOrigin) / fillSize;
	                        y = (center.y - fillOrigin) / fillSize;
	                    } else {
	                        x = (rawcenter.x * sx + matrix.e - fillOrigin) / fillSize;
	                        y = (rawcenter.y * sy + matrix.f - fillOrigin) / fillSize;
	                    }
	                } else {
	                    x = (rawcenter.x - fillOrigin) / fillSize;
	                    y = (rawcenter.y - fillOrigin) / fillSize;
	                }
	                width = round(width, TRANSFORM_PRECISION);
	                height = round(height, TRANSFORM_PRECISION);
	                x = round(x, TRANSFORM_PRECISION);
	                y = round(y, TRANSFORM_PRECISION);
	                angle = round(angle, TRANSFORM_PRECISION);
	                return [
	                    [
	                        'size',
	                        width + ',' + height
	                    ],
	                    [
	                        'position',
	                        x + ',' + y
	                    ],
	                    [
	                        'angle',
	                        angle
	                    ]
	                ];
	            }
	        });
	        var ImageNode = PathNode.extend({
	            createFillNode: function (srcElement, transform, opacity) {
	                return new ImageFillNode(srcElement, transform, opacity);
	            },
	            createDataNode: function (srcElement) {
	                return new ImagePathDataNode(srcElement);
	            },
	            optionsChange: function (e) {
	                if (e.field === 'src' || e.field === 'transform') {
	                    this.fill.optionsChange(e);
	                }
	                PathNode.fn.optionsChange.call(this, e);
	            },
	            geometryChange: function () {
	                this.fill.geometryChange();
	                PathNode.fn.geometryChange.call(this);
	            },
	            refreshTransform: function (transform) {
	                PathNode.fn.refreshTransform.call(this, transform);
	                this.fill.refresh(this.srcElement.currentTransform(transform));
	            }
	        });
	        var RectDataNode = PathDataNode.extend({
	            renderData: function () {
	                var rect = this.srcElement.geometry();
	                var parts = [
	                    'm',
	                    printPoints([rect.topLeft()]),
	                    'l',
	                    printPoints([
	                        rect.topRight(),
	                        rect.bottomRight(),
	                        rect.bottomLeft()
	                    ]),
	                    'x e'
	                ];
	                return parts.join(' ');
	            }
	        });
	        var RectNode = PathNode.extend({
	            createDataNode: function (srcElement) {
	                return new RectDataNode(srcElement);
	            }
	        });
	        var nodeMap = {
	            Group: GroupNode,
	            Text: TextNode,
	            Path: PathNode,
	            MultiPath: MultiPathNode,
	            Circle: CircleNode,
	            Arc: ArcNode,
	            Image: ImageNode,
	            Rect: RectNode
	        };
	        function enableVML() {
	            if (doc.namespaces && !doc.namespaces.kvml) {
	                doc.namespaces.add('kvml', 'urn:schemas-microsoft-com:vml');
	                var stylesheet = doc.styleSheets.length > 30 ? doc.styleSheets[0] : doc.createStyleSheet();
	                stylesheet.addRule('.kvml', 'behavior:url(#default#VML)');
	            }
	        }
	        function createElementVML(type) {
	            var element = doc.createElement('kvml:' + type);
	            element.className = 'kvml';
	            return element;
	        }
	        function printPoints(points) {
	            var length = points.length;
	            var result = [];
	            for (var i = 0; i < length; i++) {
	                result.push(points[i].scaleCopy(COORDINATE_MULTIPLE).toString(0, ','));
	            }
	            return result.join(' ');
	        }
	        function printPath(path, open) {
	            var segments = path.segments, length = segments.length;
	            if (length > 0) {
	                var parts = [], output, type, currentType, i;
	                for (i = 1; i < length; i++) {
	                    type = segmentType(segments[i - 1], segments[i]);
	                    if (type !== currentType) {
	                        currentType = type;
	                        parts.push(type);
	                    }
	                    if (type === 'l') {
	                        parts.push(printPoints([segments[i].anchor()]));
	                    } else {
	                        parts.push(printPoints([
	                            segments[i - 1].controlOut(),
	                            segments[i].controlIn(),
	                            segments[i].anchor()
	                        ]));
	                    }
	                }
	                output = 'm ' + printPoints([segments[0].anchor()]) + ' ' + parts.join(' ');
	                if (path.options.closed) {
	                    output += ' x';
	                }
	                if (open !== true) {
	                    output += ' e';
	                }
	                return output;
	            }
	        }
	        function segmentType(segmentStart, segmentEnd) {
	            return segmentStart.controlOut() && segmentEnd.controlIn() ? 'c' : 'l';
	        }
	        function fillField(field) {
	            return field.indexOf('fill') === 0 || field.indexOf(GRADIENT) === 0;
	        }
	        function stopColor(baseColor, stop, baseOpacity) {
	            var opacity = baseOpacity * valueOrDefault(stop.opacity(), 1);
	            var color;
	            if (baseColor) {
	                color = blendColors(baseColor, stop.color(), opacity);
	            } else {
	                color = blendColors(stop.color(), '#fff', 1 - opacity);
	            }
	            return color;
	        }
	        function blendColors(base, overlay, alpha) {
	            var baseColor = new Color(base), overlayColor = new Color(overlay), r = blendChannel(baseColor.r, overlayColor.r, alpha), g = blendChannel(baseColor.g, overlayColor.g, alpha), b = blendChannel(baseColor.b, overlayColor.b, alpha);
	            return new Color(r, g, b).toHex();
	        }
	        function blendChannel(a, b, alpha) {
	            return math.round(alpha * b + (1 - alpha) * a);
	        }
	        kendo.support.vml = function () {
	            var browser = kendo.support.browser;
	            return browser.msie && browser.version < 9;
	        }();
	        var EMPTY_CLIP = 'inherit';
	        if (kendo.support.browser.msie && kendo.support.browser.version < 8) {
	            EMPTY_CLIP = 'rect(auto auto auto auto)';
	        }
	        if (kendo.support.vml) {
	            d.SurfaceFactory.current.register('vml', Surface, 30);
	        }
	        deepExtend(d, {
	            vml: {
	                ArcDataNode: ArcDataNode,
	                ArcNode: ArcNode,
	                CircleTransformNode: CircleTransformNode,
	                CircleNode: CircleNode,
	                FillNode: FillNode,
	                GroupNode: GroupNode,
	                ImageNode: ImageNode,
	                ImageFillNode: ImageFillNode,
	                ImagePathDataNode: ImagePathDataNode,
	                MultiPathDataNode: MultiPathDataNode,
	                MultiPathNode: MultiPathNode,
	                Node: Node,
	                PathDataNode: PathDataNode,
	                PathNode: PathNode,
	                RectDataNode: RectDataNode,
	                RectNode: RectNode,
	                RootNode: RootNode,
	                StrokeNode: StrokeNode,
	                Surface: Surface,
	                TextNode: TextNode,
	                TextPathNode: TextPathNode,
	                TextPathDataNode: TextPathDataNode,
	                TransformNode: TransformNode
	            }
	        });
	    }(window.kendo.jQuery));
	}, __webpack_require__(200)));
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(236),
	        __WEBPACK_LOCAL_MODULE_7__,
	        __WEBPACK_LOCAL_MODULE_0__,
	        __WEBPACK_LOCAL_MODULE_1__
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_LOCAL_MODULE_13__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__));
	}(function () {
	    (function ($, parseFloat, Math) {
	        'use strict';
	        var drawing = kendo.drawing;
	        var geo = kendo.geometry;
	        var slice = Array.prototype.slice;
	        var browser = kendo.support.browser;
	        var romanNumeral = kendo.util.arabicToRoman;
	        var mergeSort = kendo.util.mergeSort;
	        var KENDO_PSEUDO_ELEMENT = 'KENDO-PSEUDO-ELEMENT';
	        var IMAGE_CACHE = {};
	        var nodeInfo = {};
	        nodeInfo._root = nodeInfo;
	        var TextRect = drawing.Text.extend({
	            nodeType: 'Text',
	            init: function (str, rect, options) {
	                drawing.Text.fn.init.call(this, str, rect.getOrigin(), options);
	                this._pdfRect = rect;
	            },
	            rect: function () {
	                return this._pdfRect;
	            },
	            rawBBox: function () {
	                return this._pdfRect;
	            }
	        });
	        function getXY(thing) {
	            if (typeof thing == 'number') {
	                return {
	                    x: thing,
	                    y: thing
	                };
	            }
	            if (Array.isArray(thing)) {
	                return {
	                    x: thing[0],
	                    y: thing[1]
	                };
	            }
	            return {
	                x: thing.x,
	                y: thing.y
	            };
	        }
	        function drawDOM(element, options) {
	            if (!options) {
	                options = {};
	            }
	            var defer = $.Deferred();
	            element = $(element)[0];
	            if (!element) {
	                return defer.reject('No element to export');
	            }
	            if (typeof window.getComputedStyle != 'function') {
	                throw new Error('window.getComputedStyle is missing.  You are using an unsupported browser, or running in IE8 compatibility mode.  Drawing HTML is supported in Chrome, Firefox, Safari and IE9+.');
	            }
	            if (kendo.pdf) {
	                kendo.pdf.defineFont(getFontFaces(element.ownerDocument));
	            }
	            var scale = getXY(options.scale || 1);
	            function doOne(element) {
	                var group = new drawing.Group();
	                var pos = element.getBoundingClientRect();
	                setTransform(group, [
	                    scale.x,
	                    0,
	                    0,
	                    scale.y,
	                    -pos.left * scale.x,
	                    -pos.top * scale.y
	                ]);
	                nodeInfo._clipbox = false;
	                nodeInfo._matrix = geo.Matrix.unit();
	                nodeInfo._stackingContext = {
	                    element: element,
	                    group: group
	                };
	                if (options.avoidLinks === true) {
	                    nodeInfo._avoidLinks = 'a';
	                } else {
	                    nodeInfo._avoidLinks = options.avoidLinks;
	                }
	                $(element).addClass('k-pdf-export');
	                renderElement(element, group);
	                $(element).removeClass('k-pdf-export');
	                return group;
	            }
	            cacheImages(element, function () {
	                var forceBreak = options && options.forcePageBreak;
	                var hasPaperSize = options && options.paperSize && options.paperSize != 'auto';
	                var paperOptions = kendo.pdf.getPaperOptions(function (key, def) {
	                    if (key == 'paperSize') {
	                        return hasPaperSize ? options[key] : 'A4';
	                    }
	                    return key in options ? options[key] : def;
	                });
	                var pageWidth = hasPaperSize && paperOptions.paperSize[0];
	                var pageHeight = hasPaperSize && paperOptions.paperSize[1];
	                var margin = options.margin && paperOptions.margin;
	                var hasMargin = !!margin;
	                if (forceBreak || pageHeight) {
	                    if (!margin) {
	                        margin = {
	                            left: 0,
	                            top: 0,
	                            right: 0,
	                            bottom: 0
	                        };
	                    }
	                    if (pageWidth) {
	                        pageWidth /= scale.x;
	                    }
	                    if (pageHeight) {
	                        pageHeight /= scale.y;
	                    }
	                    margin.left /= scale.x;
	                    margin.right /= scale.x;
	                    margin.top /= scale.y;
	                    margin.bottom /= scale.y;
	                    var group = new drawing.Group({
	                        pdf: {
	                            multiPage: true,
	                            paperSize: hasPaperSize ? paperOptions.paperSize : 'auto',
	                            _ignoreMargin: hasMargin
	                        }
	                    });
	                    handlePageBreaks(function (x) {
	                        if (options.progress) {
	                            var canceled = false, pageNum = 0;
	                            (function next() {
	                                if (pageNum < x.pages.length) {
	                                    var page = doOne(x.pages[pageNum]);
	                                    group.append(page);
	                                    options.progress({
	                                        page: page,
	                                        pageNum: ++pageNum,
	                                        totalPages: x.pages.length,
	                                        cancel: function () {
	                                            canceled = true;
	                                        }
	                                    });
	                                    if (!canceled) {
	                                        setTimeout(next);
	                                    } else {
	                                        x.container.parentNode.removeChild(x.container);
	                                    }
	                                } else {
	                                    x.container.parentNode.removeChild(x.container);
	                                    defer.resolve(group);
	                                }
	                            }());
	                        } else {
	                            x.pages.forEach(function (page) {
	                                group.append(doOne(page));
	                            });
	                            x.container.parentNode.removeChild(x.container);
	                            defer.resolve(group);
	                        }
	                    }, element, forceBreak, pageWidth ? pageWidth - margin.left - margin.right : null, pageHeight ? pageHeight - margin.top - margin.bottom : null, margin, options);
	                } else {
	                    defer.resolve(doOne(element));
	                }
	            });
	            function makeTemplate(template) {
	                if (template != null) {
	                    if (typeof template == 'string') {
	                        template = kendo.template(template.replace(/^\s+|\s+$/g, ''));
	                    }
	                    if (typeof template == 'function') {
	                        return function (data) {
	                            var el = template(data);
	                            if (el) {
	                                if (typeof el == 'string') {
	                                    el = el.replace(/^\s+|\s+$/g, '');
	                                }
	                                return $(el)[0];
	                            }
	                        };
	                    }
	                    return function () {
	                        return $(template).clone()[0];
	                    };
	                }
	            }
	            function cloneNodes(el) {
	                var clone = el.cloneNode(false);
	                if (el.nodeType == 1) {
	                    var $el = $(el), $clone = $(clone), i;
	                    var data = $el.data();
	                    for (i in data) {
	                        $clone.data(i, data[i]);
	                    }
	                    if (/^canvas$/i.test(el.tagName)) {
	                        clone.getContext('2d').drawImage(el, 0, 0);
	                    } else if (/^input$/i.test(el.tagName)) {
	                        el.removeAttribute('name');
	                    } else {
	                        for (i = el.firstChild; i; i = i.nextSibling) {
	                            clone.appendChild(cloneNodes(i));
	                        }
	                    }
	                }
	                return clone;
	            }
	            function handlePageBreaks(callback, element, forceBreak, pageWidth, pageHeight, margin, options) {
	                var template = makeTemplate(options.template);
	                var doc = element.ownerDocument;
	                var pages = [];
	                var copy = options._destructive ? element : cloneNodes(element);
	                var container = doc.createElement('KENDO-PDF-DOCUMENT');
	                var adjust = 0;
	                $(copy).find('tfoot').each(function () {
	                    this.parentNode.appendChild(this);
	                });
	                $(copy).find('ol').each(function () {
	                    $(this).children().each(function (index) {
	                        this.setAttribute('kendo-split-index', index);
	                    });
	                });
	                $(container).css({
	                    display: 'block',
	                    position: 'absolute',
	                    boxSizing: 'content-box',
	                    left: '-10000px',
	                    top: '-10000px'
	                });
	                if (pageWidth) {
	                    $(container).css({
	                        width: pageWidth,
	                        paddingLeft: margin.left,
	                        paddingRight: margin.right
	                    });
	                    $(copy).css({ overflow: 'hidden' });
	                }
	                element.parentNode.insertBefore(container, element);
	                container.appendChild(copy);
	                if (options.beforePageBreak) {
	                    setTimeout(function () {
	                        options.beforePageBreak(container, doPageBreak);
	                    }, 15);
	                } else {
	                    setTimeout(doPageBreak, 15);
	                }
	                function doPageBreak() {
	                    if (forceBreak != '-' || pageHeight) {
	                        splitElement(copy);
	                    }
	                    var page = makePage();
	                    copy.parentNode.insertBefore(page, copy);
	                    page.appendChild(copy);
	                    if (template) {
	                        var count = pages.length;
	                        pages.forEach(function (page, i) {
	                            var el = template({
	                                element: page,
	                                pageNum: i + 1,
	                                totalPages: pages.length
	                            });
	                            if (el) {
	                                page.appendChild(el);
	                                cacheImages(el, function () {
	                                    if (--count === 0) {
	                                        next();
	                                    }
	                                });
	                            }
	                        });
	                    } else {
	                        next();
	                    }
	                    function next() {
	                        whenImagesAreActuallyLoaded(pages, function () {
	                            callback({
	                                pages: pages,
	                                container: container
	                            });
	                        });
	                    }
	                }
	                function keepTogether(jqel) {
	                    if (options.keepTogether && jqel.is(options.keepTogether) && jqel.height() <= pageHeight - adjust) {
	                        return true;
	                    }
	                    return jqel.data('kendoChart') || /^(?:img|tr|thead|th|tfoot|iframe|svg|object|canvas|input|textarea|select|video|h[1-6])/i.test(jqel[0].tagName);
	                }
	                function splitElement(element) {
	                    var style = getComputedStyle(element);
	                    var bottomPadding = parseFloat(getPropertyValue(style, 'padding-bottom'));
	                    var bottomBorder = parseFloat(getPropertyValue(style, 'border-bottom-width'));
	                    var saveAdjust = adjust;
	                    adjust += bottomPadding + bottomBorder;
	                    var isFirst = true;
	                    for (var el = element.firstChild; el; el = el.nextSibling) {
	                        if (el.nodeType == 1) {
	                            isFirst = false;
	                            var jqel = $(el);
	                            if (jqel.is(forceBreak)) {
	                                breakAtElement(el);
	                                continue;
	                            }
	                            if (!pageHeight) {
	                                splitElement(el);
	                                continue;
	                            }
	                            if (!/^(?:static|relative)$/.test(getPropertyValue(getComputedStyle(el), 'position'))) {
	                                continue;
	                            }
	                            var fall = fallsOnMargin(el);
	                            if (fall == 1) {
	                                breakAtElement(el);
	                            } else if (fall) {
	                                if (keepTogether(jqel)) {
	                                    breakAtElement(el);
	                                } else {
	                                    splitElement(el);
	                                }
	                            } else {
	                                splitElement(el);
	                            }
	                        } else if (el.nodeType == 3 && pageHeight) {
	                            splitText(el, isFirst);
	                            isFirst = false;
	                        }
	                    }
	                    adjust = saveAdjust;
	                }
	                function firstInParent(el) {
	                    var p = el.parentNode, first = p.firstChild;
	                    if (el === first) {
	                        return true;
	                    }
	                    if (el === p.children[0]) {
	                        if (first.nodeType == 7 || first.nodeType == 8) {
	                            return true;
	                        }
	                        if (first.nodeType == 3) {
	                            return !/\S/.test(first.data);
	                        }
	                    }
	                    return false;
	                }
	                function breakAtElement(el) {
	                    if (el.nodeType == 1 && el !== copy && firstInParent(el)) {
	                        return breakAtElement(el.parentNode);
	                    }
	                    var table, colgroup, thead, grid, gridHead;
	                    table = $(el).closest('table');
	                    colgroup = table.find('colgroup:first');
	                    if (options.repeatHeaders) {
	                        thead = table.find('thead:first');
	                        grid = $(el).closest('.k-grid[data-role="grid"]');
	                        if (grid[0] && grid[0].querySelector('.k-auto-scrollable')) {
	                            gridHead = grid.find('.k-grid-header:first');
	                        }
	                    }
	                    var page = makePage();
	                    var range = doc.createRange();
	                    range.setStartBefore(copy);
	                    range.setEndBefore(el);
	                    page.appendChild(range.extractContents());
	                    copy.parentNode.insertBefore(page, copy);
	                    if (table[0]) {
	                        table = $(el).closest('table');
	                        if (options.repeatHeaders && thead[0]) {
	                            thead.clone().prependTo(table);
	                        }
	                        if (colgroup[0]) {
	                            colgroup.clone().prependTo(table);
	                        }
	                    }
	                    if (options.repeatHeaders && gridHead && gridHead[0]) {
	                        grid = $(el).closest('.k-grid[data-role="grid"]');
	                        if (gridHead[0]) {
	                            gridHead.clone().prependTo(grid);
	                        }
	                    }
	                }
	                function makePage() {
	                    var page = doc.createElement('KENDO-PDF-PAGE');
	                    $(page).css({
	                        display: 'block',
	                        boxSizing: 'content-box',
	                        width: pageWidth || 'auto',
	                        padding: margin.top + 'px ' + margin.right + 'px ' + margin.bottom + 'px ' + margin.left + 'px',
	                        position: 'relative',
	                        height: pageHeight || 'auto',
	                        overflow: pageHeight || pageWidth ? 'hidden' : 'visible',
	                        clear: 'both'
	                    });
	                    if (options && options.pageClassName) {
	                        page.className = options.pageClassName;
	                    }
	                    pages.push(page);
	                    return page;
	                }
	                function fallsOnMargin(thing) {
	                    var box = thing.getBoundingClientRect();
	                    if (box.width === 0 || box.height === 0) {
	                        return 0;
	                    }
	                    var top = copy.getBoundingClientRect().top;
	                    var available = pageHeight - adjust;
	                    return box.height > available ? 3 : box.top - top > available ? 1 : box.bottom - top > available ? 2 : 0;
	                }
	                function splitText(node, isFirst) {
	                    if (!/\S/.test(node.data)) {
	                        return;
	                    }
	                    var len = node.data.length;
	                    var range = doc.createRange();
	                    range.selectNodeContents(node);
	                    var fall = fallsOnMargin(range);
	                    if (!fall) {
	                        return;
	                    }
	                    var nextnode = node;
	                    if (fall == 1) {
	                        if (isFirst) {
	                            breakAtElement(node.parentNode);
	                        } else {
	                            breakAtElement(node);
	                        }
	                    } else {
	                        (function findEOP(min, pos, max) {
	                            range.setEnd(node, pos);
	                            if (min == pos || pos == max) {
	                                return pos;
	                            }
	                            if (fallsOnMargin(range)) {
	                                return findEOP(min, min + pos >> 1, pos);
	                            } else {
	                                return findEOP(pos, pos + max >> 1, max);
	                            }
	                        }(0, len >> 1, len));
	                        if (!/\S/.test(range.toString()) && isFirst) {
	                            breakAtElement(node.parentNode);
	                        } else {
	                            nextnode = node.splitText(range.endOffset);
	                            var page = makePage();
	                            range.setStartBefore(copy);
	                            page.appendChild(range.extractContents());
	                            copy.parentNode.insertBefore(page, copy);
	                        }
	                    }
	                    splitText(nextnode);
	                }
	            }
	            return defer.promise();
	        }
	        drawing.drawDOM = drawDOM;
	        drawDOM.getFontFaces = getFontFaces;
	        var parseBackgroundImage = function () {
	            var tok_linear_gradient = /^((-webkit-|-moz-|-o-|-ms-)?linear-gradient\s*)\(/;
	            var tok_percent = /^([-0-9.]+%)/;
	            var tok_length = /^([-0-9.]+px)/;
	            var tok_keyword = /^(left|right|top|bottom|to|center)\W/;
	            var tok_angle = /^([-0-9.]+(deg|grad|rad|turn))/;
	            var tok_whitespace = /^(\s+)/;
	            var tok_popen = /^(\()/;
	            var tok_pclose = /^(\))/;
	            var tok_comma = /^(,)/;
	            var tok_url = /^(url)\(/;
	            var tok_content = /^(.*?)\)/;
	            var cache1 = {}, cache2 = {};
	            function parse(input) {
	                var orig = input;
	                if (hasOwnProperty(cache1, orig)) {
	                    return cache1[orig];
	                }
	                function skip_ws() {
	                    var m = tok_whitespace.exec(input);
	                    if (m) {
	                        input = input.substr(m[1].length);
	                    }
	                }
	                function read(token) {
	                    skip_ws();
	                    var m = token.exec(input);
	                    if (m) {
	                        input = input.substr(m[1].length);
	                        return m[1];
	                    }
	                }
	                function read_stop() {
	                    var color = kendo.parseColor(input, true);
	                    var length, percent;
	                    if (color) {
	                        input = input.substr(color.match[0].length);
	                        color = color.toRGB();
	                        if (!(length = read(tok_length))) {
	                            percent = read(tok_percent);
	                        }
	                        return {
	                            color: color,
	                            length: length,
	                            percent: percent
	                        };
	                    }
	                }
	                function read_linear_gradient(propName) {
	                    var angle;
	                    var to1, to2;
	                    var stops = [];
	                    var reverse = false;
	                    if (read(tok_popen)) {
	                        angle = read(tok_angle);
	                        if (angle) {
	                            angle = parseAngle(angle);
	                            read(tok_comma);
	                        } else {
	                            to1 = read(tok_keyword);
	                            if (to1 == 'to') {
	                                to1 = read(tok_keyword);
	                            } else if (to1 && /^-/.test(propName)) {
	                                reverse = true;
	                            }
	                            to2 = read(tok_keyword);
	                            read(tok_comma);
	                        }
	                        if (/-moz-/.test(propName) && angle == null && to1 == null) {
	                            var x = read(tok_percent), y = read(tok_percent);
	                            reverse = true;
	                            if (x == '0%') {
	                                to1 = 'left';
	                            } else if (x == '100%') {
	                                to1 = 'right';
	                            }
	                            if (y == '0%') {
	                                to2 = 'top';
	                            } else if (y == '100%') {
	                                to2 = 'bottom';
	                            }
	                            read(tok_comma);
	                        }
	                        while (input && !read(tok_pclose)) {
	                            var stop = read_stop();
	                            if (!stop) {
	                                break;
	                            }
	                            stops.push(stop);
	                            read(tok_comma);
	                        }
	                        return {
	                            type: 'linear',
	                            angle: angle,
	                            to: to1 && to2 ? to1 + ' ' + to2 : to1 ? to1 : to2 ? to2 : null,
	                            stops: stops,
	                            reverse: reverse
	                        };
	                    }
	                }
	                function read_url() {
	                    if (read(tok_popen)) {
	                        var url = read(tok_content);
	                        url = url.replace(/^['"]+|["']+$/g, '');
	                        read(tok_pclose);
	                        return {
	                            type: 'url',
	                            url: url
	                        };
	                    }
	                }
	                var tok;
	                if (tok = read(tok_linear_gradient)) {
	                    tok = read_linear_gradient(tok);
	                } else if (tok = read(tok_url)) {
	                    tok = read_url();
	                }
	                return cache1[orig] = tok || { type: 'none' };
	            }
	            return function (input) {
	                if (hasOwnProperty(cache2, input)) {
	                    return cache2[input];
	                }
	                return cache2[input] = splitProperty(input).map(parse);
	            };
	        }();
	        var splitProperty = function () {
	            var cache = {};
	            return function (input, separator) {
	                if (!separator) {
	                    separator = /^\s*,\s*/;
	                }
	                var cacheKey = input + separator;
	                if (hasOwnProperty(cache, cacheKey)) {
	                    return cache[cacheKey];
	                }
	                var ret = [];
	                var last = 0, pos = 0;
	                var in_paren = 0;
	                var in_string = false;
	                var m;
	                function looking_at(rx) {
	                    return m = rx.exec(input.substr(pos));
	                }
	                function trim(str) {
	                    return str.replace(/^\s+|\s+$/g, '');
	                }
	                while (pos < input.length) {
	                    if (!in_string && looking_at(/^[\(\[\{]/)) {
	                        in_paren++;
	                        pos++;
	                    } else if (!in_string && looking_at(/^[\)\]\}]/)) {
	                        in_paren--;
	                        pos++;
	                    } else if (!in_string && looking_at(/^[\"\']/)) {
	                        in_string = m[0];
	                        pos++;
	                    } else if (in_string == '\'' && looking_at(/^\\\'/)) {
	                        pos += 2;
	                    } else if (in_string == '"' && looking_at(/^\\\"/)) {
	                        pos += 2;
	                    } else if (in_string == '\'' && looking_at(/^\'/)) {
	                        in_string = false;
	                        pos++;
	                    } else if (in_string == '"' && looking_at(/^\"/)) {
	                        in_string = false;
	                        pos++;
	                    } else if (looking_at(separator)) {
	                        if (!in_string && !in_paren && pos > last) {
	                            ret.push(trim(input.substring(last, pos)));
	                            last = pos + m[0].length;
	                        }
	                        pos += m[0].length;
	                    } else {
	                        pos++;
	                    }
	                }
	                if (last < pos) {
	                    ret.push(trim(input.substring(last, pos)));
	                }
	                return cache[cacheKey] = ret;
	            };
	        }();
	        var getFontURL = function () {
	            var cache = {};
	            return function (el) {
	                var url = cache[el];
	                if (!url) {
	                    var m;
	                    if (m = /url\((['"]?)([^'")]*?)\1\)\s+format\((['"]?)truetype\3\)/.exec(el)) {
	                        url = cache[el] = m[2];
	                    } else if (m = /url\((['"]?)([^'")]*?\.ttf)\1\)/.exec(el)) {
	                        url = cache[el] = m[2];
	                    }
	                }
	                return url;
	            };
	        }();
	        function getFontFaces(doc) {
	            if (doc == null) {
	                doc = document;
	            }
	            var result = {};
	            for (var i = 0; i < doc.styleSheets.length; ++i) {
	                doStylesheet(doc.styleSheets[i]);
	            }
	            return result;
	            function doStylesheet(ss) {
	                if (ss) {
	                    var rules = null;
	                    try {
	                        rules = ss.cssRules;
	                    } catch (ex) {
	                    }
	                    if (rules) {
	                        addRules(ss, rules);
	                    }
	                }
	            }
	            function findFonts(rule) {
	                var src = getPropertyValue(rule.style, 'src');
	                if (src) {
	                    return splitProperty(src).reduce(function (a, el) {
	                        var font = getFontURL(el);
	                        if (font) {
	                            a.push(font);
	                        }
	                        return a;
	                    }, []);
	                } else {
	                    var font = getFontURL(rule.cssText);
	                    return font ? [font] : [];
	                }
	            }
	            function addRules(styleSheet, rules) {
	                for (var i = 0; i < rules.length; ++i) {
	                    var r = rules[i];
	                    switch (r.type) {
	                    case 3:
	                        doStylesheet(r.styleSheet);
	                        break;
	                    case 5:
	                        var style = r.style;
	                        var family = splitProperty(getPropertyValue(style, 'font-family'));
	                        var bold = /^([56789]00|bold)$/i.test(getPropertyValue(style, 'font-weight'));
	                        var italic = 'italic' == getPropertyValue(style, 'font-style');
	                        var src = findFonts(r);
	                        if (src.length > 0) {
	                            addRule(styleSheet, family, bold, italic, src[0]);
	                        }
	                    }
	                }
	            }
	            function addRule(styleSheet, names, bold, italic, url) {
	                if (!/^data:/i.test(url)) {
	                    if (!(/^[^\/:]+:\/\//.test(url) || /^\//.test(url))) {
	                        url = String(styleSheet.href).replace(/[^\/]*$/, '') + url;
	                    }
	                }
	                names.forEach(function (name) {
	                    name = name.replace(/^(['"]?)(.*?)\1$/, '$2');
	                    if (bold) {
	                        name += '|bold';
	                    }
	                    if (italic) {
	                        name += '|italic';
	                    }
	                    result[name] = url;
	                });
	            }
	        }
	        function hasOwnProperty(obj, key) {
	            return Object.prototype.hasOwnProperty.call(obj, key);
	        }
	        function getCounter(name) {
	            name = '_counter_' + name;
	            return nodeInfo[name];
	        }
	        function getAllCounters(name) {
	            var values = [], p = nodeInfo;
	            name = '_counter_' + name;
	            while (p) {
	                if (hasOwnProperty(p, name)) {
	                    values.push(p[name]);
	                }
	                p = Object.getPrototypeOf(p);
	            }
	            return values.reverse();
	        }
	        function incCounter(name, inc) {
	            var p = nodeInfo;
	            name = '_counter_' + name;
	            while (p && !hasOwnProperty(p, name)) {
	                p = Object.getPrototypeOf(p);
	            }
	            if (!p) {
	                p = nodeInfo._root;
	            }
	            p[name] = (p[name] || 0) + (inc == null ? 1 : inc);
	        }
	        function resetCounter(name, val) {
	            name = '_counter_' + name;
	            nodeInfo[name] = val == null ? 0 : val;
	        }
	        function doCounters(a, f, def) {
	            for (var i = 0; i < a.length;) {
	                var name = a[i++];
	                var val = parseFloat(a[i]);
	                if (isNaN(val)) {
	                    f(name, def);
	                } else {
	                    f(name, val);
	                    ++i;
	                }
	            }
	        }
	        function parseColor(str, css) {
	            var color = kendo.parseColor(str);
	            if (color) {
	                color = color.toRGB();
	                if (css) {
	                    color = color.toCssRgba();
	                } else if (color.a === 0) {
	                    color = null;
	                }
	            }
	            return color;
	        }
	        function whenImagesAreActuallyLoaded(elements, callback) {
	            var pending = 0;
	            elements.forEach(function (el) {
	                var images = el.querySelectorAll('img');
	                for (var i = 0; i < images.length; ++i) {
	                    var img = images[i];
	                    if (!img.complete) {
	                        pending++;
	                        img.onload = img.onerror = next;
	                    }
	                }
	            });
	            if (!pending) {
	                next();
	            }
	            function next() {
	                if (--pending <= 0) {
	                    callback();
	                }
	            }
	        }
	        function cacheImages(element, callback) {
	            var urls = [];
	            function add(url) {
	                if (!IMAGE_CACHE[url]) {
	                    IMAGE_CACHE[url] = true;
	                    urls.push(url);
	                }
	            }
	            (function dive(element) {
	                if (/^img$/i.test(element.tagName)) {
	                    add(element.src);
	                }
	                parseBackgroundImage(getPropertyValue(getComputedStyle(element), 'background-image')).forEach(function (bg) {
	                    if (bg.type == 'url') {
	                        add(bg.url);
	                    }
	                });
	                if (element.children) {
	                    slice.call(element.children).forEach(dive);
	                }
	            }(element));
	            var count = urls.length;
	            function next() {
	                if (--count <= 0) {
	                    callback();
	                }
	            }
	            if (count === 0) {
	                next();
	            }
	            urls.forEach(function (url) {
	                var img = IMAGE_CACHE[url] = new Image();
	                if (!/^data:/i.test(url)) {
	                    img.crossOrigin = 'Anonymous';
	                }
	                img.src = url;
	                if (img.complete) {
	                    next();
	                } else {
	                    img.onload = next;
	                    img.onerror = function () {
	                        IMAGE_CACHE[url] = null;
	                        next();
	                    };
	                }
	            });
	        }
	        function alphaNumeral(n) {
	            var result = '';
	            do {
	                var r = n % 26;
	                result = String.fromCharCode(97 + r) + result;
	                n = Math.floor(n / 26);
	            } while (n > 0);
	            return result;
	        }
	        function pushNodeInfo(element, style, group) {
	            nodeInfo = Object.create(nodeInfo);
	            nodeInfo[element.tagName.toLowerCase()] = {
	                element: element,
	                style: style
	            };
	            var decoration = getPropertyValue(style, 'text-decoration');
	            if (decoration && decoration != 'none') {
	                var color = getPropertyValue(style, 'color');
	                decoration.split(/\s+/g).forEach(function (name) {
	                    if (!nodeInfo[name]) {
	                        nodeInfo[name] = color;
	                    }
	                });
	            }
	            if (createsStackingContext(style)) {
	                nodeInfo._stackingContext = {
	                    element: element,
	                    group: group
	                };
	            }
	        }
	        function popNodeInfo() {
	            nodeInfo = Object.getPrototypeOf(nodeInfo);
	        }
	        function updateClipbox(path) {
	            if (nodeInfo._clipbox != null) {
	                var box = path.bbox(nodeInfo._matrix);
	                if (nodeInfo._clipbox) {
	                    nodeInfo._clipbox = geo.Rect.intersect(nodeInfo._clipbox, box);
	                } else {
	                    nodeInfo._clipbox = box;
	                }
	            }
	        }
	        function emptyClipbox() {
	            var cb = nodeInfo._clipbox;
	            if (cb == null) {
	                return true;
	            }
	            if (cb) {
	                return cb.width() === 0 || cb.height() === 0;
	            }
	        }
	        function createsStackingContext(style) {
	            function prop(name) {
	                return getPropertyValue(style, name);
	            }
	            if (prop('transform') != 'none' || prop('position') != 'static' && prop('z-index') != 'auto' || prop('opacity') < 1) {
	                return true;
	            }
	        }
	        function getComputedStyle(element, pseudoElt) {
	            return window.getComputedStyle(element, pseudoElt || null);
	        }
	        function getPropertyValue(style, prop) {
	            var val = style.getPropertyValue(prop);
	            if (val == null || val === '') {
	                if (browser.webkit) {
	                    val = style.getPropertyValue('-webkit-' + prop);
	                } else if (browser.mozilla) {
	                    val = style.getPropertyValue('-moz-' + prop);
	                } else if (browser.opera) {
	                    val = style.getPropertyValue('-o-' + prop);
	                } else if (browser.msie) {
	                    val = style.getPropertyValue('-ms-' + prop);
	                }
	            }
	            return val;
	        }
	        function pleaseSetPropertyValue(style, prop, value, important) {
	            style.setProperty(prop, value, important);
	            if (browser.webkit) {
	                style.setProperty('-webkit-' + prop, value, important);
	            } else if (browser.mozilla) {
	                style.setProperty('-moz-' + prop, value, important);
	            } else if (browser.opera) {
	                style.setProperty('-o-' + prop, value, important);
	            } else if (browser.msie) {
	                style.setProperty('-ms-' + prop, value, important);
	                prop = 'ms' + prop.replace(/(^|-)([a-z])/g, function (s, p1, p2) {
	                    return p1 + p2.toUpperCase();
	                });
	                style[prop] = value;
	            }
	        }
	        function getBorder(style, side) {
	            side = 'border-' + side;
	            return {
	                width: parseFloat(getPropertyValue(style, side + '-width')),
	                style: getPropertyValue(style, side + '-style'),
	                color: parseColor(getPropertyValue(style, side + '-color'), true)
	            };
	        }
	        function saveStyle(element, func) {
	            var prev = element.style.cssText;
	            var result = func();
	            element.style.cssText = prev;
	            return result;
	        }
	        function getBorderRadius(style, side) {
	            var r = getPropertyValue(style, 'border-' + side + '-radius').split(/\s+/g).map(parseFloat);
	            if (r.length == 1) {
	                r.push(r[0]);
	            }
	            return sanitizeRadius({
	                x: r[0],
	                y: r[1]
	            });
	        }
	        function getContentBox(element) {
	            var box = element.getBoundingClientRect();
	            box = innerBox(box, 'border-*-width', element);
	            box = innerBox(box, 'padding-*', element);
	            return box;
	        }
	        function innerBox(box, prop, element) {
	            var style, wt, wr, wb, wl;
	            if (typeof prop == 'string') {
	                style = getComputedStyle(element);
	                wt = parseFloat(getPropertyValue(style, prop.replace('*', 'top')));
	                wr = parseFloat(getPropertyValue(style, prop.replace('*', 'right')));
	                wb = parseFloat(getPropertyValue(style, prop.replace('*', 'bottom')));
	                wl = parseFloat(getPropertyValue(style, prop.replace('*', 'left')));
	            } else if (typeof prop == 'number') {
	                wt = wr = wb = wl = prop;
	            }
	            return {
	                top: box.top + wt,
	                right: box.right - wr,
	                bottom: box.bottom - wb,
	                left: box.left + wl,
	                width: box.right - box.left - wr - wl,
	                height: box.bottom - box.top - wb - wt
	            };
	        }
	        function getTransform(style) {
	            var transform = getPropertyValue(style, 'transform');
	            if (transform == 'none') {
	                return null;
	            }
	            var matrix = /^\s*matrix\(\s*(.*?)\s*\)\s*$/.exec(transform);
	            if (matrix) {
	                var origin = getPropertyValue(style, 'transform-origin');
	                matrix = matrix[1].split(/\s*,\s*/g).map(parseFloat);
	                origin = origin.split(/\s+/g).map(parseFloat);
	                return {
	                    matrix: matrix,
	                    origin: origin
	                };
	            }
	        }
	        function radiansToDegrees(radians) {
	            return 180 * radians / Math.PI % 360;
	        }
	        function parseAngle(angle) {
	            var num = parseFloat(angle);
	            if (/grad$/.test(angle)) {
	                return Math.PI * num / 200;
	            } else if (/rad$/.test(angle)) {
	                return num;
	            } else if (/turn$/.test(angle)) {
	                return Math.PI * num * 2;
	            } else if (/deg$/.test(angle)) {
	                return Math.PI * num / 180;
	            }
	        }
	        function setTransform(shape, m) {
	            m = new geo.Matrix(m[0], m[1], m[2], m[3], m[4], m[5]);
	            shape.transform(m);
	            return m;
	        }
	        function setClipping(shape, clipPath) {
	            shape.clip(clipPath);
	        }
	        function addArcToPath(path, x, y, options) {
	            var points = new geo.Arc([
	                    x,
	                    y
	                ], options).curvePoints(), i = 1;
	            while (i < points.length) {
	                path.curveTo(points[i++], points[i++], points[i++]);
	            }
	        }
	        function sanitizeRadius(r) {
	            if (r.x <= 0 || r.y <= 0) {
	                r.x = r.y = 0;
	            }
	            return r;
	        }
	        function adjustBorderRadiusForBox(box, rTL, rTR, rBR, rBL) {
	            var tl_x = Math.max(0, rTL.x), tl_y = Math.max(0, rTL.y);
	            var tr_x = Math.max(0, rTR.x), tr_y = Math.max(0, rTR.y);
	            var br_x = Math.max(0, rBR.x), br_y = Math.max(0, rBR.y);
	            var bl_x = Math.max(0, rBL.x), bl_y = Math.max(0, rBL.y);
	            var f = Math.min(box.width / (tl_x + tr_x), box.height / (tr_y + br_y), box.width / (br_x + bl_x), box.height / (bl_y + tl_y));
	            if (f < 1) {
	                tl_x *= f;
	                tl_y *= f;
	                tr_x *= f;
	                tr_y *= f;
	                br_x *= f;
	                br_y *= f;
	                bl_x *= f;
	                bl_y *= f;
	            }
	            return {
	                tl: {
	                    x: tl_x,
	                    y: tl_y
	                },
	                tr: {
	                    x: tr_x,
	                    y: tr_y
	                },
	                br: {
	                    x: br_x,
	                    y: br_y
	                },
	                bl: {
	                    x: bl_x,
	                    y: bl_y
	                }
	            };
	        }
	        function elementRoundBox(element, box, type) {
	            var style = getComputedStyle(element);
	            var rTL = getBorderRadius(style, 'top-left');
	            var rTR = getBorderRadius(style, 'top-right');
	            var rBL = getBorderRadius(style, 'bottom-left');
	            var rBR = getBorderRadius(style, 'bottom-right');
	            if (type == 'padding' || type == 'content') {
	                var bt = getBorder(style, 'top');
	                var br = getBorder(style, 'right');
	                var bb = getBorder(style, 'bottom');
	                var bl = getBorder(style, 'left');
	                rTL.x -= bl.width;
	                rTL.y -= bt.width;
	                rTR.x -= br.width;
	                rTR.y -= bt.width;
	                rBR.x -= br.width;
	                rBR.y -= bb.width;
	                rBL.x -= bl.width;
	                rBL.y -= bb.width;
	                if (type == 'content') {
	                    var pt = parseFloat(getPropertyValue(style, 'padding-top'));
	                    var pr = parseFloat(getPropertyValue(style, 'padding-right'));
	                    var pb = parseFloat(getPropertyValue(style, 'padding-bottom'));
	                    var pl = parseFloat(getPropertyValue(style, 'padding-left'));
	                    rTL.x -= pl;
	                    rTL.y -= pt;
	                    rTR.x -= pr;
	                    rTR.y -= pt;
	                    rBR.x -= pr;
	                    rBR.y -= pb;
	                    rBL.x -= pl;
	                    rBL.y -= pb;
	                }
	            }
	            if (typeof type == 'number') {
	                rTL.x -= type;
	                rTL.y -= type;
	                rTR.x -= type;
	                rTR.y -= type;
	                rBR.x -= type;
	                rBR.y -= type;
	                rBL.x -= type;
	                rBL.y -= type;
	            }
	            return roundBox(box, rTL, rTR, rBR, rBL);
	        }
	        function roundBox(box, rTL0, rTR0, rBR0, rBL0) {
	            var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);
	            var rTL = tmp.tl;
	            var rTR = tmp.tr;
	            var rBR = tmp.br;
	            var rBL = tmp.bl;
	            var path = new drawing.Path({
	                fill: null,
	                stroke: null
	            });
	            path.moveTo(box.left, box.top + rTL.y);
	            if (rTL.x) {
	                addArcToPath(path, box.left + rTL.x, box.top + rTL.y, {
	                    startAngle: -180,
	                    endAngle: -90,
	                    radiusX: rTL.x,
	                    radiusY: rTL.y
	                });
	            }
	            path.lineTo(box.right - rTR.x, box.top);
	            if (rTR.x) {
	                addArcToPath(path, box.right - rTR.x, box.top + rTR.y, {
	                    startAngle: -90,
	                    endAngle: 0,
	                    radiusX: rTR.x,
	                    radiusY: rTR.y
	                });
	            }
	            path.lineTo(box.right, box.bottom - rBR.y);
	            if (rBR.x) {
	                addArcToPath(path, box.right - rBR.x, box.bottom - rBR.y, {
	                    startAngle: 0,
	                    endAngle: 90,
	                    radiusX: rBR.x,
	                    radiusY: rBR.y
	                });
	            }
	            path.lineTo(box.left + rBL.x, box.bottom);
	            if (rBL.x) {
	                addArcToPath(path, box.left + rBL.x, box.bottom - rBL.y, {
	                    startAngle: 90,
	                    endAngle: 180,
	                    radiusX: rBL.x,
	                    radiusY: rBL.y
	                });
	            }
	            return path.close();
	        }
	        function formatCounter(val, style) {
	            var str = parseFloat(val) + '';
	            switch (style) {
	            case 'decimal-leading-zero':
	                if (str.length < 2) {
	                    str = '0' + str;
	                }
	                return str;
	            case 'lower-roman':
	                return romanNumeral(val).toLowerCase();
	            case 'upper-roman':
	                return romanNumeral(val).toUpperCase();
	            case 'lower-latin':
	            case 'lower-alpha':
	                return alphaNumeral(val - 1);
	            case 'upper-latin':
	            case 'upper-alpha':
	                return alphaNumeral(val - 1).toUpperCase();
	            default:
	                return str;
	            }
	        }
	        function evalPseudoElementContent(element, content) {
	            function displayCounter(name, style, separator) {
	                if (!separator) {
	                    return formatCounter(getCounter(name) || 0, style);
	                }
	                separator = separator.replace(/^\s*(["'])(.*)\1\s*$/, '$2');
	                return getAllCounters(name).map(function (val) {
	                    return formatCounter(val, style);
	                }).join(separator);
	            }
	            var a = splitProperty(content, /^\s+/);
	            var result = [], m;
	            a.forEach(function (el) {
	                var tmp;
	                if (m = /^\s*(["'])(.*)\1\s*$/.exec(el)) {
	                    result.push(m[2].replace(/\\([0-9a-f]{4})/gi, function (s, p) {
	                        return String.fromCharCode(parseInt(p, 16));
	                    }));
	                } else if (m = /^\s*counter\((.*?)\)\s*$/.exec(el)) {
	                    tmp = splitProperty(m[1]);
	                    result.push(displayCounter(tmp[0], tmp[1]));
	                } else if (m = /^\s*counters\((.*?)\)\s*$/.exec(el)) {
	                    tmp = splitProperty(m[1]);
	                    result.push(displayCounter(tmp[0], tmp[2], tmp[1]));
	                } else if (m = /^\s*attr\((.*?)\)\s*$/.exec(el)) {
	                    result.push(element.getAttribute(m[1]) || '');
	                } else {
	                    result.push(el);
	                }
	            });
	            return result.join('');
	        }
	        function getCssText(style) {
	            if (style.cssText) {
	                return style.cssText;
	            }
	            var result = [];
	            for (var i = 0; i < style.length; ++i) {
	                result.push(style[i] + ': ' + getPropertyValue(style, style[i]));
	            }
	            return result.join(';\n');
	        }
	        function _renderWithPseudoElements(element, group) {
	            if (element.tagName == KENDO_PSEUDO_ELEMENT) {
	                _renderElement(element, group);
	                return;
	            }
	            var fake = [];
	            function pseudo(kind, place) {
	                var style = getComputedStyle(element, kind);
	                if (style.content && style.content != 'normal' && style.content != 'none' && style.width != '0px') {
	                    var psel = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);
	                    psel.style.cssText = getCssText(style);
	                    psel.textContent = evalPseudoElementContent(element, style.content);
	                    element.insertBefore(psel, place);
	                    fake.push(psel);
	                }
	            }
	            pseudo(':before', element.firstChild);
	            pseudo(':after', null);
	            var saveClass = element.className;
	            element.className += ' kendo-pdf-hide-pseudo-elements';
	            _renderElement(element, group);
	            element.className = saveClass;
	            fake.forEach(function (el) {
	                element.removeChild(el);
	            });
	        }
	        function _renderElement(element, group) {
	            var style = getComputedStyle(element);
	            var top = getBorder(style, 'top');
	            var right = getBorder(style, 'right');
	            var bottom = getBorder(style, 'bottom');
	            var left = getBorder(style, 'left');
	            var rTL0 = getBorderRadius(style, 'top-left');
	            var rTR0 = getBorderRadius(style, 'top-right');
	            var rBL0 = getBorderRadius(style, 'bottom-left');
	            var rBR0 = getBorderRadius(style, 'bottom-right');
	            var dir = getPropertyValue(style, 'direction');
	            var backgroundColor = getPropertyValue(style, 'background-color');
	            backgroundColor = parseColor(backgroundColor);
	            var backgroundImage = parseBackgroundImage(getPropertyValue(style, 'background-image'));
	            var backgroundRepeat = splitProperty(getPropertyValue(style, 'background-repeat'));
	            var backgroundPosition = splitProperty(getPropertyValue(style, 'background-position'));
	            var backgroundOrigin = splitProperty(getPropertyValue(style, 'background-origin'));
	            var backgroundSize = splitProperty(getPropertyValue(style, 'background-size'));
	            if (browser.msie && browser.version < 10) {
	                backgroundPosition = splitProperty(element.currentStyle.backgroundPosition);
	            }
	            var innerbox = innerBox(element.getBoundingClientRect(), 'border-*-width', element);
	            (function () {
	                var clip = getPropertyValue(style, 'clip');
	                var m = /^\s*rect\((.*)\)\s*$/.exec(clip);
	                if (m) {
	                    var a = m[1].split(/[ ,]+/g);
	                    var top = a[0] == 'auto' ? innerbox.top : parseFloat(a[0]) + innerbox.top;
	                    var right = a[1] == 'auto' ? innerbox.right : parseFloat(a[1]) + innerbox.left;
	                    var bottom = a[2] == 'auto' ? innerbox.bottom : parseFloat(a[2]) + innerbox.top;
	                    var left = a[3] == 'auto' ? innerbox.left : parseFloat(a[3]) + innerbox.left;
	                    var tmp = new drawing.Group();
	                    var clipPath = new drawing.Path().moveTo(left, top).lineTo(right, top).lineTo(right, bottom).lineTo(left, bottom).close();
	                    setClipping(tmp, clipPath);
	                    group.append(tmp);
	                    group = tmp;
	                    updateClipbox(clipPath);
	                }
	            }());
	            var boxes, i, cells;
	            var display = getPropertyValue(style, 'display');
	            if (display == 'table-row') {
	                boxes = [];
	                for (i = 0, cells = element.children; i < cells.length; ++i) {
	                    boxes.push(cells[i].getBoundingClientRect());
	                }
	            } else {
	                boxes = element.getClientRects();
	                if (boxes.length == 1) {
	                    boxes = [element.getBoundingClientRect()];
	                }
	            }
	            boxes = adjustBoxes(boxes);
	            for (i = 0; i < boxes.length; ++i) {
	                drawOneBox(boxes[i], i === 0, i == boxes.length - 1);
	            }
	            if (boxes.length > 0 && display == 'list-item') {
	                drawBullet(boxes[0]);
	            }
	            (function () {
	                function clipit() {
	                    var clipPath = elementRoundBox(element, innerbox, 'padding');
	                    var tmp = new drawing.Group();
	                    setClipping(tmp, clipPath);
	                    group.append(tmp);
	                    group = tmp;
	                    updateClipbox(clipPath);
	                }
	                if (isFormField(element)) {
	                    clipit();
	                } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, 'overflow'))) {
	                    clipit();
	                } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, 'overflow-x'))) {
	                    clipit();
	                } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, 'overflow-y'))) {
	                    clipit();
	                }
	            }());
	            if (!maybeRenderWidget(element, group)) {
	                renderContents(element, group);
	            }
	            return group;
	            function adjustBoxes(boxes) {
	                if (/^td$/i.test(element.tagName)) {
	                    var table = nodeInfo.table;
	                    if (table && getPropertyValue(table.style, 'border-collapse') == 'collapse') {
	                        var tableBorderLeft = getBorder(table.style, 'left').width;
	                        var tableBorderTop = getBorder(table.style, 'top').width;
	                        if (tableBorderLeft === 0 && tableBorderTop === 0) {
	                            return boxes;
	                        }
	                        var tableBox = table.element.getBoundingClientRect();
	                        var firstCell = table.element.rows[0].cells[0];
	                        var firstCellBox = firstCell.getBoundingClientRect();
	                        if (firstCellBox.top == tableBox.top || firstCellBox.left == tableBox.left) {
	                            return slice.call(boxes).map(function (box) {
	                                return {
	                                    left: box.left + tableBorderLeft,
	                                    top: box.top + tableBorderTop,
	                                    right: box.right + tableBorderLeft,
	                                    bottom: box.bottom + tableBorderTop,
	                                    height: box.height,
	                                    width: box.width
	                                };
	                            });
	                        }
	                    }
	                }
	                return boxes;
	            }
	            function drawEdge(color, len, Wtop, Wleft, Wright, rl, rr, transform) {
	                if (Wtop <= 0) {
	                    return;
	                }
	                var path, edge = new drawing.Group();
	                setTransform(edge, transform);
	                group.append(edge);
	                sanitizeRadius(rl);
	                sanitizeRadius(rr);
	                path = new drawing.Path({
	                    fill: { color: color },
	                    stroke: null
	                });
	                edge.append(path);
	                path.moveTo(rl.x ? Math.max(rl.x, Wleft) : 0, 0).lineTo(len - (rr.x ? Math.max(rr.x, Wright) : 0), 0).lineTo(len - Math.max(rr.x, Wright), Wtop).lineTo(Math.max(rl.x, Wleft), Wtop).close();
	                if (rl.x) {
	                    drawRoundCorner(Wleft, rl, [
	                        -1,
	                        0,
	                        0,
	                        1,
	                        rl.x,
	                        0
	                    ]);
	                }
	                if (rr.x) {
	                    drawRoundCorner(Wright, rr, [
	                        1,
	                        0,
	                        0,
	                        1,
	                        len - rr.x,
	                        0
	                    ]);
	                }
	                function drawRoundCorner(Wright, r, transform) {
	                    var angle = Math.PI / 2 * Wright / (Wright + Wtop);
	                    var ri = {
	                        x: r.x - Wright,
	                        y: r.y - Wtop
	                    };
	                    var path = new drawing.Path({
	                        fill: { color: color },
	                        stroke: null
	                    }).moveTo(0, 0);
	                    setTransform(path, transform);
	                    addArcToPath(path, 0, r.y, {
	                        startAngle: -90,
	                        endAngle: -radiansToDegrees(angle),
	                        radiusX: r.x,
	                        radiusY: r.y
	                    });
	                    if (ri.x > 0 && ri.y > 0) {
	                        path.lineTo(ri.x * Math.cos(angle), r.y - ri.y * Math.sin(angle));
	                        addArcToPath(path, 0, r.y, {
	                            startAngle: -radiansToDegrees(angle),
	                            endAngle: -90,
	                            radiusX: ri.x,
	                            radiusY: ri.y,
	                            anticlockwise: true
	                        });
	                    } else if (ri.x > 0) {
	                        path.lineTo(ri.x, Wtop).lineTo(0, Wtop);
	                    } else {
	                        path.lineTo(ri.x, Wtop).lineTo(ri.x, 0);
	                    }
	                    edge.append(path.close());
	                }
	            }
	            function drawBackground(box) {
	                var background = new drawing.Group();
	                setClipping(background, roundBox(box, rTL0, rTR0, rBR0, rBL0));
	                group.append(background);
	                if (element.tagName == 'A' && element.href && !/^#?$/.test($(element).attr('href'))) {
	                    if (!nodeInfo._avoidLinks || !$(element).is(nodeInfo._avoidLinks)) {
	                        background._pdfLink = {
	                            url: element.href,
	                            top: box.top,
	                            right: box.right,
	                            bottom: box.bottom,
	                            left: box.left
	                        };
	                    }
	                }
	                if (backgroundColor) {
	                    var path = new drawing.Path({
	                        fill: { color: backgroundColor.toCssRgba() },
	                        stroke: null
	                    });
	                    path.moveTo(box.left, box.top).lineTo(box.right, box.top).lineTo(box.right, box.bottom).lineTo(box.left, box.bottom).close();
	                    background.append(path);
	                }
	                for (var i = backgroundImage.length; --i >= 0;) {
	                    drawOneBackground(background, box, backgroundImage[i], backgroundRepeat[i % backgroundRepeat.length], backgroundPosition[i % backgroundPosition.length], backgroundOrigin[i % backgroundOrigin.length], backgroundSize[i % backgroundSize.length]);
	                }
	            }
	            function drawOneBackground(group, box, background, backgroundRepeat, backgroundPosition, backgroundOrigin, backgroundSize) {
	                if (!background || background == 'none') {
	                    return;
	                }
	                if (background.type == 'url') {
	                    if (/^url\(\"data:image\/svg/i.test(background.url)) {
	                        return;
	                    }
	                    var img = IMAGE_CACHE[background.url];
	                    if (img && img.width > 0 && img.height > 0) {
	                        drawBackgroundImage(group, box, img.width, img.height, function (group, rect) {
	                            group.append(new drawing.Image(background.url, rect));
	                        });
	                    }
	                } else if (background.type == 'linear') {
	                    drawBackgroundImage(group, box, box.width, box.height, gradientRenderer(background));
	                } else {
	                    return;
	                }
	                function drawBackgroundImage(group, box, img_width, img_height, renderBG) {
	                    var aspect_ratio = img_width / img_height, f;
	                    var orgBox = box;
	                    if (backgroundOrigin == 'content-box') {
	                        orgBox = innerBox(orgBox, 'border-*-width', element);
	                        orgBox = innerBox(orgBox, 'padding-*', element);
	                    } else if (backgroundOrigin == 'padding-box') {
	                        orgBox = innerBox(orgBox, 'border-*-width', element);
	                    }
	                    if (!/^\s*auto(\s+auto)?\s*$/.test(backgroundSize)) {
	                        if (backgroundSize == 'contain') {
	                            f = Math.min(orgBox.width / img_width, orgBox.height / img_height);
	                            img_width *= f;
	                            img_height *= f;
	                        } else if (backgroundSize == 'cover') {
	                            f = Math.max(orgBox.width / img_width, orgBox.height / img_height);
	                            img_width *= f;
	                            img_height *= f;
	                        } else {
	                            var size = backgroundSize.split(/\s+/g);
	                            if (/%$/.test(size[0])) {
	                                img_width = orgBox.width * parseFloat(size[0]) / 100;
	                            } else {
	                                img_width = parseFloat(size[0]);
	                            }
	                            if (size.length == 1 || size[1] == 'auto') {
	                                img_height = img_width / aspect_ratio;
	                            } else if (/%$/.test(size[1])) {
	                                img_height = orgBox.height * parseFloat(size[1]) / 100;
	                            } else {
	                                img_height = parseFloat(size[1]);
	                            }
	                        }
	                    }
	                    var pos = (backgroundPosition + '').split(/\s+/);
	                    if (pos.length == 1) {
	                        pos[1] = '50%';
	                    }
	                    if (/%$/.test(pos[0])) {
	                        pos[0] = parseFloat(pos[0]) / 100 * (orgBox.width - img_width);
	                    } else {
	                        pos[0] = parseFloat(pos[0]);
	                    }
	                    if (/%$/.test(pos[1])) {
	                        pos[1] = parseFloat(pos[1]) / 100 * (orgBox.height - img_height);
	                    } else {
	                        pos[1] = parseFloat(pos[1]);
	                    }
	                    var rect = new geo.Rect([
	                        orgBox.left + pos[0],
	                        orgBox.top + pos[1]
	                    ], [
	                        img_width,
	                        img_height
	                    ]);
	                    function rewX() {
	                        while (rect.origin.x > box.left) {
	                            rect.origin.x -= img_width;
	                        }
	                    }
	                    function rewY() {
	                        while (rect.origin.y > box.top) {
	                            rect.origin.y -= img_height;
	                        }
	                    }
	                    function repeatX() {
	                        while (rect.origin.x < box.right) {
	                            renderBG(group, rect.clone());
	                            rect.origin.x += img_width;
	                        }
	                    }
	                    if (backgroundRepeat == 'no-repeat') {
	                        renderBG(group, rect);
	                    } else if (backgroundRepeat == 'repeat-x') {
	                        rewX();
	                        repeatX();
	                    } else if (backgroundRepeat == 'repeat-y') {
	                        rewY();
	                        while (rect.origin.y < box.bottom) {
	                            renderBG(group, rect.clone());
	                            rect.origin.y += img_height;
	                        }
	                    } else if (backgroundRepeat == 'repeat') {
	                        rewX();
	                        rewY();
	                        var origin = rect.origin.clone();
	                        while (rect.origin.y < box.bottom) {
	                            rect.origin.x = origin.x;
	                            repeatX();
	                            rect.origin.y += img_height;
	                        }
	                    }
	                }
	            }
	            function drawBullet() {
	                var listStyleType = getPropertyValue(style, 'list-style-type');
	                if (listStyleType == 'none') {
	                    return;
	                }
	                var listStylePosition = getPropertyValue(style, 'list-style-position');
	                function _drawBullet(f) {
	                    saveStyle(element, function () {
	                        element.style.position = 'relative';
	                        var bullet = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);
	                        bullet.style.position = 'absolute';
	                        bullet.style.boxSizing = 'border-box';
	                        if (listStylePosition == 'outside') {
	                            bullet.style.width = '6em';
	                            bullet.style.left = '-6.8em';
	                            bullet.style.textAlign = 'right';
	                        } else {
	                            bullet.style.left = '0px';
	                        }
	                        f(bullet);
	                        element.insertBefore(bullet, element.firstChild);
	                        renderElement(bullet, group);
	                        element.removeChild(bullet);
	                    });
	                }
	                function elementIndex(f) {
	                    var a = element.parentNode.children;
	                    var k = element.getAttribute('kendo-split-index');
	                    if (k != null) {
	                        return f(k | 0, a.length);
	                    }
	                    for (var i = 0; i < a.length; ++i) {
	                        if (a[i] === element) {
	                            return f(i, a.length);
	                        }
	                    }
	                }
	                switch (listStyleType) {
	                case 'circle':
	                case 'disc':
	                case 'square':
	                    _drawBullet(function (bullet) {
	                        bullet.style.fontSize = '60%';
	                        bullet.style.lineHeight = '200%';
	                        bullet.style.paddingRight = '0.5em';
	                        bullet.style.fontFamily = 'DejaVu Serif';
	                        bullet.innerHTML = {
	                            'disc': '\u25CF',
	                            'circle': '\u25EF',
	                            'square': '\u25A0'
	                        }[listStyleType];
	                    });
	                    break;
	                case 'decimal':
	                case 'decimal-leading-zero':
	                    _drawBullet(function (bullet) {
	                        elementIndex(function (idx) {
	                            ++idx;
	                            if (listStyleType == 'decimal-leading-zero' && (idx + '').length < 2) {
	                                idx = '0' + idx;
	                            }
	                            bullet.innerHTML = idx + '.';
	                        });
	                    });
	                    break;
	                case 'lower-roman':
	                case 'upper-roman':
	                    _drawBullet(function (bullet) {
	                        elementIndex(function (idx) {
	                            idx = romanNumeral(idx + 1);
	                            if (listStyleType == 'upper-roman') {
	                                idx = idx.toUpperCase();
	                            }
	                            bullet.innerHTML = idx + '.';
	                        });
	                    });
	                    break;
	                case 'lower-latin':
	                case 'lower-alpha':
	                case 'upper-latin':
	                case 'upper-alpha':
	                    _drawBullet(function (bullet) {
	                        elementIndex(function (idx) {
	                            idx = alphaNumeral(idx);
	                            if (/^upper/i.test(listStyleType)) {
	                                idx = idx.toUpperCase();
	                            }
	                            bullet.innerHTML = idx + '.';
	                        });
	                    });
	                    break;
	                }
	            }
	            function drawOneBox(box, isFirst, isLast) {
	                if (box.width === 0 || box.height === 0) {
	                    return;
	                }
	                drawBackground(box);
	                var shouldDrawLeft = left.width > 0 && (isFirst && dir == 'ltr' || isLast && dir == 'rtl');
	                var shouldDrawRight = right.width > 0 && (isLast && dir == 'ltr' || isFirst && dir == 'rtl');
	                if (top.width === 0 && left.width === 0 && right.width === 0 && bottom.width === 0) {
	                    return;
	                }
	                if (true) {
	                    if (top.color == right.color && top.color == bottom.color && top.color == left.color) {
	                        if (top.width == right.width && top.width == bottom.width && top.width == left.width) {
	                            if (shouldDrawLeft && shouldDrawRight) {
	                                box = innerBox(box, top.width / 2);
	                                var path = elementRoundBox(element, box, top.width / 2);
	                                path.options.stroke = {
	                                    color: top.color,
	                                    width: top.width
	                                };
	                                group.append(path);
	                                return;
	                            }
	                        }
	                    }
	                    if (rTL0.x === 0 && rTR0.x === 0 && rBR0.x === 0 && rBL0.x === 0) {
	                        if (top.width < 2 && left.width < 2 && right.width < 2 && bottom.width < 2) {
	                            if (top.width > 0) {
	                                group.append(new drawing.Path({
	                                    stroke: {
	                                        width: top.width,
	                                        color: top.color
	                                    }
	                                }).moveTo(box.left, box.top + top.width / 2).lineTo(box.right, box.top + top.width / 2));
	                            }
	                            if (bottom.width > 0) {
	                                group.append(new drawing.Path({
	                                    stroke: {
	                                        width: bottom.width,
	                                        color: bottom.color
	                                    }
	                                }).moveTo(box.left, box.bottom - bottom.width / 2).lineTo(box.right, box.bottom - bottom.width / 2));
	                            }
	                            if (shouldDrawLeft) {
	                                group.append(new drawing.Path({
	                                    stroke: {
	                                        width: left.width,
	                                        color: left.color
	                                    }
	                                }).moveTo(box.left + left.width / 2, box.top).lineTo(box.left + left.width / 2, box.bottom));
	                            }
	                            if (shouldDrawRight) {
	                                group.append(new drawing.Path({
	                                    stroke: {
	                                        width: right.width,
	                                        color: right.color
	                                    }
	                                }).moveTo(box.right - right.width / 2, box.top).lineTo(box.right - right.width / 2, box.bottom));
	                            }
	                            return;
	                        }
	                    }
	                }
	                var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);
	                var rTL = tmp.tl;
	                var rTR = tmp.tr;
	                var rBR = tmp.br;
	                var rBL = tmp.bl;
	                drawEdge(top.color, box.width, top.width, left.width, right.width, rTL, rTR, [
	                    1,
	                    0,
	                    0,
	                    1,
	                    box.left,
	                    box.top
	                ]);
	                drawEdge(bottom.color, box.width, bottom.width, right.width, left.width, rBR, rBL, [
	                    -1,
	                    0,
	                    0,
	                    -1,
	                    box.right,
	                    box.bottom
	                ]);
	                function inv(p) {
	                    return {
	                        x: p.y,
	                        y: p.x
	                    };
	                }
	                drawEdge(left.color, box.height, left.width, bottom.width, top.width, inv(rBL), inv(rTL), [
	                    0,
	                    -1,
	                    1,
	                    0,
	                    box.left,
	                    box.bottom
	                ]);
	                drawEdge(right.color, box.height, right.width, top.width, bottom.width, inv(rTR), inv(rBR), [
	                    0,
	                    1,
	                    -1,
	                    0,
	                    box.right,
	                    box.top
	                ]);
	            }
	        }
	        function gradientRenderer(gradient) {
	            return function (group, rect) {
	                var width = rect.width(), height = rect.height();
	                switch (gradient.type) {
	                case 'linear':
	                    var angle = gradient.angle != null ? gradient.angle : Math.PI;
	                    switch (gradient.to) {
	                    case 'top':
	                        angle = 0;
	                        break;
	                    case 'left':
	                        angle = -Math.PI / 2;
	                        break;
	                    case 'bottom':
	                        angle = Math.PI;
	                        break;
	                    case 'right':
	                        angle = Math.PI / 2;
	                        break;
	                    case 'top left':
	                    case 'left top':
	                        angle = -Math.atan2(height, width);
	                        break;
	                    case 'top right':
	                    case 'right top':
	                        angle = Math.atan2(height, width);
	                        break;
	                    case 'bottom left':
	                    case 'left bottom':
	                        angle = Math.PI + Math.atan2(height, width);
	                        break;
	                    case 'bottom right':
	                    case 'right bottom':
	                        angle = Math.PI - Math.atan2(height, width);
	                        break;
	                    }
	                    if (gradient.reverse) {
	                        angle -= Math.PI;
	                    }
	                    angle %= 2 * Math.PI;
	                    if (angle < 0) {
	                        angle += 2 * Math.PI;
	                    }
	                    var pxlen = Math.abs(width * Math.sin(angle)) + Math.abs(height * Math.cos(angle));
	                    var scaledAngle = Math.atan(width * Math.tan(angle) / height);
	                    var sin = Math.sin(scaledAngle), cos = Math.cos(scaledAngle);
	                    var len = Math.abs(sin) + Math.abs(cos);
	                    var x = len / 2 * sin;
	                    var y = len / 2 * cos;
	                    if (angle > Math.PI / 2 && angle <= 3 * Math.PI / 2) {
	                        x = -x;
	                        y = -y;
	                    }
	                    var implicit = [], right = 0;
	                    var stops = gradient.stops.map(function (s, i) {
	                        var offset = s.percent;
	                        if (offset) {
	                            offset = parseFloat(offset) / 100;
	                        } else if (s.length) {
	                            offset = parseFloat(s.length) / pxlen;
	                        } else if (i === 0) {
	                            offset = 0;
	                        } else if (i == gradient.stops.length - 1) {
	                            offset = 1;
	                        }
	                        var stop = {
	                            color: s.color.toCssRgba(),
	                            offset: offset
	                        };
	                        if (offset != null) {
	                            right = offset;
	                            implicit.forEach(function (s, i) {
	                                var stop = s.stop;
	                                stop.offset = s.left + (right - s.left) * (i + 1) / (implicit.length + 1);
	                            });
	                            implicit = [];
	                        } else {
	                            implicit.push({
	                                left: right,
	                                stop: stop
	                            });
	                        }
	                        return stop;
	                    });
	                    var start = [
	                        0.5 - x,
	                        0.5 + y
	                    ];
	                    var end = [
	                        0.5 + x,
	                        0.5 - y
	                    ];
	                    group.append(drawing.Path.fromRect(rect).stroke(null).fill(new drawing.LinearGradient({
	                        start: start,
	                        end: end,
	                        stops: stops,
	                        userSpace: false
	                    })));
	                    break;
	                case 'radial':
	                    if (window.console && window.console.log) {
	                        window.console.log('Radial gradients are not yet supported in HTML renderer');
	                    }
	                    break;
	                }
	            };
	        }
	        function maybeRenderWidget(element, group) {
	            if (element.getAttribute(kendo.attr('role'))) {
	                var widget = kendo.widgetInstance($(element));
	                if (widget && (widget.exportDOMVisual || widget.exportVisual)) {
	                    var visual;
	                    if (widget.exportDOMVisual) {
	                        visual = widget.exportDOMVisual();
	                    } else {
	                        visual = widget.exportVisual();
	                    }
	                    if (!visual) {
	                        return false;
	                    }
	                    var wrap = new drawing.Group();
	                    wrap.children.push(visual);
	                    var bbox = element.getBoundingClientRect();
	                    wrap.transform(geo.transform().translate(bbox.left, bbox.top));
	                    group.append(wrap);
	                    return true;
	                }
	            }
	        }
	        function renderImage(element, url, group) {
	            var box = getContentBox(element);
	            var rect = new geo.Rect([
	                box.left,
	                box.top
	            ], [
	                box.width,
	                box.height
	            ]);
	            var image = new drawing.Image(url, rect);
	            setClipping(image, elementRoundBox(element, box, 'content'));
	            group.append(image);
	        }
	        function zIndexSort(a, b) {
	            var sa = getComputedStyle(a);
	            var sb = getComputedStyle(b);
	            var za = parseFloat(getPropertyValue(sa, 'z-index'));
	            var zb = parseFloat(getPropertyValue(sb, 'z-index'));
	            var pa = getPropertyValue(sa, 'position');
	            var pb = getPropertyValue(sb, 'position');
	            if (isNaN(za) && isNaN(zb)) {
	                if (/static|absolute/.test(pa) && /static|absolute/.test(pb)) {
	                    return 0;
	                }
	                if (pa == 'static') {
	                    return -1;
	                }
	                if (pb == 'static') {
	                    return 1;
	                }
	                return 0;
	            }
	            if (isNaN(za)) {
	                return zb === 0 ? 0 : zb > 0 ? -1 : 1;
	            }
	            if (isNaN(zb)) {
	                return za === 0 ? 0 : za > 0 ? 1 : -1;
	            }
	            return parseFloat(za) - parseFloat(zb);
	        }
	        function isFormField(element) {
	            return /^(?:textarea|select|input)$/i.test(element.tagName);
	        }
	        function getSelectedOption(element) {
	            if (element.selectedOptions && element.selectedOptions.length > 0) {
	                return element.selectedOptions[0];
	            }
	            return element.options[element.selectedIndex];
	        }
	        function renderCheckbox(element, group) {
	            var style = getComputedStyle(element);
	            var color = getPropertyValue(style, 'color');
	            var box = element.getBoundingClientRect();
	            if (element.type == 'checkbox') {
	                group.append(drawing.Path.fromRect(new geo.Rect([
	                    box.left + 1,
	                    box.top + 1
	                ], [
	                    box.width - 2,
	                    box.height - 2
	                ])).stroke(color, 1));
	                if (element.checked) {
	                    group.append(new drawing.Path().stroke(color, 1.2).moveTo(box.left + 0.22 * box.width, box.top + 0.55 * box.height).lineTo(box.left + 0.45 * box.width, box.top + 0.75 * box.height).lineTo(box.left + 0.78 * box.width, box.top + 0.22 * box.width));
	                }
	            } else {
	                group.append(new drawing.Circle(new geo.Circle([
	                    (box.left + box.right) / 2,
	                    (box.top + box.bottom) / 2
	                ], Math.min(box.width - 2, box.height - 2) / 2)).stroke(color, 1));
	                if (element.checked) {
	                    group.append(new drawing.Circle(new geo.Circle([
	                        (box.left + box.right) / 2,
	                        (box.top + box.bottom) / 2
	                    ], Math.min(box.width - 8, box.height - 8) / 2)).fill(color).stroke(null));
	                }
	            }
	        }
	        function renderFormField(element, group) {
	            var tag = element.tagName.toLowerCase();
	            if (tag == 'input' && (element.type == 'checkbox' || element.type == 'radio')) {
	                return renderCheckbox(element, group);
	            }
	            var p = element.parentNode;
	            var doc = element.ownerDocument;
	            var el = doc.createElement(KENDO_PSEUDO_ELEMENT);
	            var option;
	            el.style.cssText = getCssText(getComputedStyle(element));
	            if (tag == 'input') {
	                el.style.whiteSpace = 'pre';
	            }
	            if (tag == 'select' || tag == 'textarea') {
	                el.style.overflow = 'auto';
	            }
	            if (tag == 'select') {
	                if (element.multiple) {
	                    for (var i = 0; i < element.options.length; ++i) {
	                        option = doc.createElement(KENDO_PSEUDO_ELEMENT);
	                        option.style.cssText = getCssText(getComputedStyle(element.options[i]));
	                        option.style.display = 'block';
	                        option.textContent = element.options[i].textContent;
	                        el.appendChild(option);
	                    }
	                } else {
	                    option = getSelectedOption(element);
	                    if (option) {
	                        el.textContent = option.textContent;
	                    }
	                }
	            } else {
	                el.textContent = element.value;
	            }
	            p.insertBefore(el, element);
	            el.scrollLeft = element.scrollLeft;
	            el.scrollTop = element.scrollTop;
	            element.style.display = 'none';
	            renderContents(el, group);
	            element.style.display = '';
	            p.removeChild(el);
	        }
	        function renderContents(element, group) {
	            if (nodeInfo._stackingContext.element === element) {
	                nodeInfo._stackingContext.group = group;
	            }
	            switch (element.tagName.toLowerCase()) {
	            case 'img':
	                renderImage(element, element.src, group);
	                break;
	            case 'canvas':
	                try {
	                    renderImage(element, element.toDataURL('image/png'), group);
	                } catch (ex) {
	                }
	                break;
	            case 'textarea':
	            case 'input':
	            case 'select':
	                renderFormField(element, group);
	                break;
	            default:
	                var blocks = [], floats = [], inline = [], positioned = [];
	                for (var i = element.firstChild; i; i = i.nextSibling) {
	                    switch (i.nodeType) {
	                    case 3:
	                        if (/\S/.test(i.data)) {
	                            renderText(element, i, group);
	                        }
	                        break;
	                    case 1:
	                        var style = getComputedStyle(i);
	                        var display = getPropertyValue(style, 'display');
	                        var floating = getPropertyValue(style, 'float');
	                        var position = getPropertyValue(style, 'position');
	                        if (position != 'static') {
	                            positioned.push(i);
	                        } else if (display != 'inline') {
	                            if (floating != 'none') {
	                                floats.push(i);
	                            } else {
	                                blocks.push(i);
	                            }
	                        } else {
	                            inline.push(i);
	                        }
	                        break;
	                    }
	                }
	                mergeSort(blocks, zIndexSort).forEach(function (el) {
	                    renderElement(el, group);
	                });
	                mergeSort(floats, zIndexSort).forEach(function (el) {
	                    renderElement(el, group);
	                });
	                mergeSort(inline, zIndexSort).forEach(function (el) {
	                    renderElement(el, group);
	                });
	                mergeSort(positioned, zIndexSort).forEach(function (el) {
	                    renderElement(el, group);
	                });
	            }
	        }
	        function renderText(element, node, group) {
	            if (emptyClipbox()) {
	                return;
	            }
	            var style = getComputedStyle(element);
	            if (parseFloat(getPropertyValue(style, 'text-indent')) < -500) {
	                return;
	            }
	            var text = node.data;
	            var start = 0;
	            var end = text.search(/\S\s*$/) + 1;
	            if (!end) {
	                return;
	            }
	            var fontSize = getPropertyValue(style, 'font-size');
	            var lineHeight = getPropertyValue(style, 'line-height');
	            var font = [
	                getPropertyValue(style, 'font-style'),
	                getPropertyValue(style, 'font-variant'),
	                getPropertyValue(style, 'font-weight'),
	                fontSize,
	                getPropertyValue(style, 'font-family')
	            ].join(' ');
	            fontSize = parseFloat(fontSize);
	            lineHeight = parseFloat(lineHeight);
	            if (fontSize === 0) {
	                return;
	            }
	            var color = getPropertyValue(style, 'color');
	            var range = element.ownerDocument.createRange();
	            var align = getPropertyValue(style, 'text-align');
	            var isJustified = align == 'justify';
	            var whiteSpace = getPropertyValue(style, 'white-space');
	            var textOverflow, saveTextOverflow;
	            if (browser.msie) {
	                textOverflow = style.textOverflow;
	                if (textOverflow == 'ellipsis') {
	                    saveTextOverflow = element.style.textOverflow;
	                    element.style.textOverflow = 'clip';
	                }
	            }
	            var estimateLineLength = element.getBoundingClientRect().width / fontSize * 5;
	            if (estimateLineLength === 0) {
	                estimateLineLength = 500;
	            }
	            var prevLineBottom = null;
	            while (!doChunk()) {
	            }
	            if (browser.msie && textOverflow == 'ellipsis') {
	                element.style.textOverflow = saveTextOverflow;
	            }
	            return;
	            function actuallyGetRangeBoundingRect(range) {
	                if (browser.msie || browser.chrome) {
	                    var rectangles = range.getClientRects(), box = {
	                            top: +Infinity,
	                            right: -Infinity,
	                            bottom: -Infinity,
	                            left: +Infinity
	                        };
	                    for (var i = 0; i < rectangles.length; ++i) {
	                        var b = rectangles[i];
	                        if (b.width <= 1 || b.bottom === prevLineBottom) {
	                            continue;
	                        }
	                        box.left = Math.min(b.left, box.left);
	                        box.top = Math.min(b.top, box.top);
	                        box.right = Math.max(b.right, box.right);
	                        box.bottom = Math.max(b.bottom, box.bottom);
	                    }
	                    box.width = box.right - box.left;
	                    box.height = box.bottom - box.top;
	                    return box;
	                }
	                return range.getBoundingClientRect();
	            }
	            function doChunk() {
	                var origStart = start;
	                var box, pos = text.substr(start).search(/\S/);
	                start += pos;
	                if (pos < 0 || start >= end) {
	                    return true;
	                }
	                range.setStart(node, start);
	                range.setEnd(node, start + 1);
	                box = actuallyGetRangeBoundingRect(range);
	                var found = false;
	                if (isJustified) {
	                    pos = text.substr(start).search(/\s/);
	                    if (pos >= 0) {
	                        range.setEnd(node, start + pos);
	                        var r = actuallyGetRangeBoundingRect(range);
	                        if (r.bottom == box.bottom) {
	                            box = r;
	                            found = true;
	                            start += pos;
	                        }
	                    }
	                }
	                if (!found) {
	                    pos = function findEOL(min, eol, max) {
	                        range.setEnd(node, eol);
	                        var r = actuallyGetRangeBoundingRect(range);
	                        if (r.bottom != box.bottom && min < eol) {
	                            return findEOL(min, min + eol >> 1, eol);
	                        } else if (r.right != box.right) {
	                            box = r;
	                            if (eol < max) {
	                                return findEOL(eol, eol + max >> 1, max);
	                            } else {
	                                return eol;
	                            }
	                        } else {
	                            return eol;
	                        }
	                    }(start, Math.min(end, start + estimateLineLength), end);
	                    if (pos == start) {
	                        return true;
	                    }
	                    start = pos;
	                    pos = range.toString().search(/\s+$/);
	                    if (pos === 0) {
	                        return;
	                    }
	                    if (pos > 0) {
	                        range.setEnd(node, range.startOffset + pos);
	                        box = actuallyGetRangeBoundingRect(range);
	                    }
	                }
	                if (browser.msie) {
	                    box = range.getClientRects()[0];
	                }
	                var str = range.toString();
	                if (!/^(?:pre|pre-wrap)$/i.test(whiteSpace)) {
	                    str = str.replace(/\s+/g, ' ');
	                } else if (/\t/.test(str)) {
	                    var cc = 0;
	                    for (pos = origStart; pos < range.startOffset; ++pos) {
	                        var code = text.charCodeAt(pos);
	                        if (code == 9) {
	                            cc += 8 - cc % 8;
	                        } else if (code == 10 || code == 13) {
	                            cc = 0;
	                        } else {
	                            cc++;
	                        }
	                    }
	                    while ((pos = str.search('\t')) >= 0) {
	                        var indent = '        '.substr(0, 8 - (cc + pos) % 8);
	                        str = str.substr(0, pos) + indent + str.substr(pos + 1);
	                    }
	                }
	                if (!found) {
	                    prevLineBottom = box.bottom;
	                }
	                drawText(str, box);
	            }
	            function drawText(str, box) {
	                if (browser.msie && !isNaN(lineHeight)) {
	                    var size = kendo.util.measureText(str, { font: font });
	                    var top = (box.top + box.bottom - size.height) / 2;
	                    box = {
	                        top: top,
	                        right: box.right,
	                        bottom: top + size.height,
	                        left: box.left,
	                        height: size.height,
	                        width: box.right - box.left
	                    };
	                }
	                var text = new TextRect(str, new geo.Rect([
	                    box.left,
	                    box.top
	                ], [
	                    box.width,
	                    box.height
	                ]), {
	                    font: font,
	                    fill: { color: color }
	                });
	                group.append(text);
	                decorate(box);
	            }
	            function decorate(box) {
	                line(nodeInfo['underline'], box.bottom);
	                line(nodeInfo['line-through'], box.bottom - box.height / 2.7);
	                line(nodeInfo['overline'], box.top);
	                function line(color, ypos) {
	                    if (color) {
	                        var width = fontSize / 12;
	                        var path = new drawing.Path({
	                            stroke: {
	                                width: width,
	                                color: color
	                            }
	                        });
	                        ypos -= width;
	                        path.moveTo(box.left, ypos).lineTo(box.right, ypos);
	                        group.append(path);
	                    }
	                }
	            }
	        }
	        function groupInStackingContext(element, group, zIndex) {
	            var main;
	            if (zIndex != 'auto') {
	                main = nodeInfo._stackingContext.group;
	                zIndex = parseFloat(zIndex);
	            } else {
	                main = group;
	                zIndex = 0;
	            }
	            var a = main.children;
	            for (var i = 0; i < a.length; ++i) {
	                if (a[i]._dom_zIndex != null && a[i]._dom_zIndex > zIndex) {
	                    break;
	                }
	            }
	            var tmp = new drawing.Group();
	            main.insertAt(tmp, i);
	            tmp._dom_zIndex = zIndex;
	            if (main !== group) {
	                if (nodeInfo._clipbox) {
	                    var m = nodeInfo._matrix.invert();
	                    var r = nodeInfo._clipbox.transformCopy(m);
	                    setClipping(tmp, drawing.Path.fromRect(r));
	                }
	            }
	            return tmp;
	        }
	        function renderElement(element, container) {
	            var style = getComputedStyle(element);
	            var counterReset = getPropertyValue(style, 'counter-reset');
	            if (counterReset) {
	                doCounters(splitProperty(counterReset, /^\s+/), resetCounter, 0);
	            }
	            var counterIncrement = getPropertyValue(style, 'counter-increment');
	            if (counterIncrement) {
	                doCounters(splitProperty(counterIncrement, /^\s+/), incCounter, 1);
	            }
	            if (/^(style|script|link|meta|iframe|svg|col|colgroup)$/i.test(element.tagName)) {
	                return;
	            }
	            if (nodeInfo._clipbox == null) {
	                return;
	            }
	            var opacity = parseFloat(getPropertyValue(style, 'opacity'));
	            var visibility = getPropertyValue(style, 'visibility');
	            var display = getPropertyValue(style, 'display');
	            if (opacity === 0 || visibility == 'hidden' || display == 'none') {
	                return;
	            }
	            var tr = getTransform(style);
	            var group;
	            var zIndex = getPropertyValue(style, 'z-index');
	            if ((tr || opacity < 1) && zIndex == 'auto') {
	                zIndex = 0;
	            }
	            group = groupInStackingContext(element, container, zIndex);
	            if (opacity < 1) {
	                group.opacity(opacity * group.opacity());
	            }
	            pushNodeInfo(element, style, group);
	            if (!tr) {
	                _renderWithPseudoElements(element, group);
	            } else {
	                saveStyle(element, function () {
	                    pleaseSetPropertyValue(element.style, 'transform', 'none', 'important');
	                    pleaseSetPropertyValue(element.style, 'transition', 'none', 'important');
	                    if (getPropertyValue(style, 'position') == 'static') {
	                        pleaseSetPropertyValue(element.style, 'position', 'relative', 'important');
	                    }
	                    var bbox = element.getBoundingClientRect();
	                    var x = bbox.left + tr.origin[0];
	                    var y = bbox.top + tr.origin[1];
	                    var m = [
	                        1,
	                        0,
	                        0,
	                        1,
	                        -x,
	                        -y
	                    ];
	                    m = mmul(m, tr.matrix);
	                    m = mmul(m, [
	                        1,
	                        0,
	                        0,
	                        1,
	                        x,
	                        y
	                    ]);
	                    m = setTransform(group, m);
	                    nodeInfo._matrix = nodeInfo._matrix.multiplyCopy(m);
	                    _renderWithPseudoElements(element, group);
	                });
	            }
	            popNodeInfo();
	        }
	        function mmul(a, b) {
	            var a1 = a[0], b1 = a[1], c1 = a[2], d1 = a[3], e1 = a[4], f1 = a[5];
	            var a2 = b[0], b2 = b[1], c2 = b[2], d2 = b[3], e2 = b[4], f2 = b[5];
	            return [
	                a1 * a2 + b1 * c2,
	                a1 * b2 + b1 * d2,
	                c1 * a2 + d1 * c2,
	                c1 * b2 + d1 * d2,
	                e1 * a2 + f1 * c2 + e2,
	                e1 * b2 + f1 * d2 + f2
	            ];
	        }
	    }(window.kendo.jQuery, parseFloat, Math));
	}, __webpack_require__(200)));
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __WEBPACK_LOCAL_MODULE_4__,
	        __WEBPACK_LOCAL_MODULE_5__
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_LOCAL_MODULE_14__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__));
	}(function () {
	    (function ($) {
	        var noop = $.noop, kendo = window.kendo, Class = kendo.Class, util = kendo.util, animationFrame = kendo.animationFrame, deepExtend = kendo.deepExtend;
	        var Animation = Class.extend({
	            init: function (element, options) {
	                var anim = this;
	                anim.options = deepExtend({}, anim.options, options);
	                anim.element = element;
	            },
	            options: {
	                duration: 500,
	                easing: 'swing'
	            },
	            setup: noop,
	            step: noop,
	            play: function () {
	                var anim = this, options = anim.options, easing = $.easing[options.easing], duration = options.duration, delay = options.delay || 0, start = util.now() + delay, finish = start + duration;
	                if (duration === 0) {
	                    anim.step(1);
	                    anim.abort();
	                } else {
	                    setTimeout(function () {
	                        var loop = function () {
	                            if (anim._stopped) {
	                                return;
	                            }
	                            var wallTime = util.now();
	                            var time = util.limitValue(wallTime - start, 0, duration);
	                            var pos = time / duration;
	                            var easingPos = easing(pos, time, 0, 1, duration);
	                            anim.step(easingPos);
	                            if (wallTime < finish) {
	                                animationFrame(loop);
	                            } else {
	                                anim.abort();
	                            }
	                        };
	                        loop();
	                    }, delay);
	                }
	            },
	            abort: function () {
	                this._stopped = true;
	            },
	            destroy: function () {
	                this.abort();
	            }
	        });
	        var AnimationFactory = function () {
	            this._items = [];
	        };
	        AnimationFactory.prototype = {
	            register: function (name, type) {
	                this._items.push({
	                    name: name,
	                    type: type
	                });
	            },
	            create: function (element, options) {
	                var items = this._items;
	                var match;
	                if (options && options.type) {
	                    var type = options.type.toLowerCase();
	                    for (var i = 0; i < items.length; i++) {
	                        if (items[i].name.toLowerCase() === type) {
	                            match = items[i];
	                            break;
	                        }
	                    }
	                }
	                if (match) {
	                    return new match.type(element, options);
	                }
	            }
	        };
	        AnimationFactory.current = new AnimationFactory();
	        Animation.create = function (type, element, options) {
	            return AnimationFactory.current.create(type, element, options);
	        };
	        deepExtend(kendo.drawing, {
	            Animation: Animation,
	            AnimationFactory: AnimationFactory
	        });
	    }(window.kendo.jQuery));
	}, __webpack_require__(200)));
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(236),
	        __WEBPACK_LOCAL_MODULE_0__,
	        __WEBPACK_LOCAL_MODULE_1__,
	        __WEBPACK_LOCAL_MODULE_2__,
	        __WEBPACK_LOCAL_MODULE_3__,
	        __WEBPACK_LOCAL_MODULE_4__,
	        __WEBPACK_LOCAL_MODULE_5__,
	        __WEBPACK_LOCAL_MODULE_6__,
	        __WEBPACK_LOCAL_MODULE_7__,
	        __WEBPACK_LOCAL_MODULE_8__,
	        __WEBPACK_LOCAL_MODULE_9__,
	        __WEBPACK_LOCAL_MODULE_10__,
	        __WEBPACK_LOCAL_MODULE_11__,
	        __WEBPACK_LOCAL_MODULE_12__,
	        __WEBPACK_LOCAL_MODULE_13__,
	        __WEBPACK_LOCAL_MODULE_14__
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'drawing',
	        name: 'Drawing API',
	        category: 'framework',
	        description: 'The Kendo UI low-level drawing API',
	        depends: [
	            'core',
	            'color',
	            'popup'
	        ]
	    };
	}, __webpack_require__(200)));

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(207)
	        // './vendor/kendo/kendo.multiselect' // required because of a test in kendo.binder.js
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    /* This function has too many statements. */
	    /* jshint -W071 */
	
	    (function ($, undefined) {
	
	        var kendo = window.kendo;
	        var data = kendo.data;
	        var DataSource = data.DataSource;
	        var ui = kendo.ui;
	        var Widget = ui.Widget;
	        var assert = window.assert;
	        var logger = new window.Logger('kidoju.widgets.dropzone');
	        var BOOLEAN = 'boolean';
	        var STRING = 'string';
	        var NUMBER = 'number';
	        var UNDEFINED = 'undefined';
	        var CHANGE = 'change';
	        var NS = '.kendoDropZone';
	        var MOUSEDOWN = 'mousedown' + NS + ' ' + 'touchstart' + NS;
	        var MOUSEMOVE = 'mousemove' + NS + ' ' + 'touchmove' + NS;
	        var MOUSEUP = 'mouseup' + NS + ' ' + 'touchend' + NS;
	        var TOP = 'top';
	        var LEFT = 'left';
	        var WIDGET_CLASS = 'kj-dropzone'; // 'k-widget kj-dropzone';
	        // TODO var DRAGGABLE_CLASS = 'kj-draggable';
	        var ATTRIBUTE_SELECTOR = '[{0}="{1}"]';
	        var STATE = 'state';
	        var ID = 'id';
	        var VALUE = 'dropValue';
	        var CONTENT_SELECTOR = '[' + kendo.attr(ID) +  ']';
	
	
	        /*********************************************************************************
	         * Helpers
	         *********************************************************************************/
	
	        var util = {
	
	            /**
	             * Get the mouse (or touch) position
	             * @param e
	             * @param stage
	             * @returns {{x: *, y: *}}
	             */
	            getMousePosition: function (e, stage) {
	                assert.instanceof($.Event, e, kendo.format(assert.messages.instanceof.default, 'e', 'jQuery.Event'));
	                assert.instanceof($, stage, kendo.format(assert.messages.instanceof.default, 'stage', 'jQuery'));
	                // See http://www.jacklmoore.com/notes/mouse-position/
	                // See http://www.jqwidgets.com/community/topic/dragend-event-properties-clientx-and-clienty-are-undefined-on-ios/
	                // See http://www.devinrolsen.com/basic-jquery-touchmove-event-setup/
	                // ATTENTION: e.originalEvent.changedTouches instanceof TouchList, not Array
	                var originalEvent = e.originalEvent;
	                var clientX = originalEvent && originalEvent.changedTouches ? originalEvent.changedTouches[0].clientX : e.clientX;
	                var clientY = originalEvent && originalEvent.changedTouches ? originalEvent.changedTouches[0].clientY : e.clientY;
	                // IMPORTANT: Position is relative to the stage and e.offsetX / e.offsetY do not work in Firefox
	                // var stage = $(e.target).closest('.kj-stage').find(kendo.roleSelector('stage'));
	                var ownerDocument = $(stage.get(0).ownerDocument);
	                var stageOffset = stage.offset();
	                var mouse = {
	                    x: clientX - stageOffset.left + ownerDocument.scrollLeft(),
	                    y: clientY - stageOffset.top + ownerDocument.scrollTop()
	                };
	                return mouse;
	            },
	
	            /**
	             * Get the position of the center of an element
	             * @param element
	             * @param stage
	             * @param scale
	             */
	            getElementCenter: function (element, stage, scale) {
	                assert.instanceof($, element, kendo.format(assert.messages.instanceof.default, 'element', 'jQuery'));
	                assert.instanceof($, stage, kendo.format(assert.messages.instanceof.default, 'stage', 'jQuery'));
	                assert.type(NUMBER, scale, kendo.format(assert.messages.type.default, 'scale', NUMBER));
	                // We need getBoundingClientRect to especially account for rotation
	                var rect = element[0].getBoundingClientRect();
	                var ownerDocument = $(stage.get(0).ownerDocument);
	                var stageOffset = stage.offset();
	                return {
	                    left: (rect.left - stageOffset.left + rect.width / 2  + ownerDocument.scrollLeft()) / scale,
	                    top: (rect.top - stageOffset.top + rect.height / 2 + ownerDocument.scrollTop()) / scale
	                };
	            },
	
	            /**
	             * Get the scale of an element's CSS transformation
	             * Note: the same function is used in kidoju.widgets.stage
	             * @param element
	             * @returns {Number|number}
	             */
	            getTransformScale: function (element) {
	                assert.instanceof($, element, kendo.format(assert.messages.instanceof.default, 'element', 'jQuery'));
	                // element.css('transform') returns a matrix, so we have to read the style attribute
	                var match = (element.attr('style') || '').match(/scale\([\s]*([0-9\.]+)[\s]*\)/);
	                return $.isArray(match) && match.length > 1 ? parseFloat(match[1]) || 1 : 1;
	            },
	
	            /**
	             * Get the rotation angle (in degrees) of an element's CSS transformation
	             * @param element
	             * @returns {Number|number}
	             */
	            getTransformRotation: function (element) {
	                // $(element).css('transform') returns a matrix, so we have to read the style attribute
	                var match = ($(element).attr('style') || '').match(/rotate\([\s]*([0-9\.]+)[deg\s]*\)/);
	                return $.isArray(match) && match.length > 1 ? parseFloat(match[1]) || 0 : 0;
	            },
	
	            /**
	             * Snapping consists in rounding the value to the closest multiple of snapValue
	             * @param value
	             * @param snapValue
	             * @returns {*}
	             */
	            snap: function (value, snapValue) {
	                if (snapValue) {
	                    return value % snapValue < snapValue / 2 ? value - value % snapValue : value + snapValue - value % snapValue;
	                } else {
	                    return value;
	                }
	            }
	
	        };
	
	        /*********************************************************************************
	         * Widget
	         *********************************************************************************/
	
	        /**
	         * DropZone
	         * @class DropZone Widget (kendoDropZone)
	         */
	        var DropZone = Widget.extend({
	
	            /**
	             * Initializes the widget
	             * @param element
	             * @param options
	             */
	            init: function (element, options) {
	                var that = this;
	                options = options || {};
	                Widget.fn.init.call(that, element, options);
	                logger.debug('widget initialized');
	                that._dataSource();
	                that._layout();
	                that.enable(that.options.enable);
	                kendo.notify(that);
	            },
	
	            /**
	             * Widget options
	             * @property options
	             */
	            options: {
	                name: 'DropZone',
	                autoBind: true,
	                dataSource: [],
	                value: [],
	                scaler: 'div.kj-stage', // that.wrapper in kidoju.widgets.stage
	                container: 'div.kj-stage>div[data-role="stage"]', // that.stage in kidoju.widgets.stage
	                draggable: 'div.kj-element:has([data-draggable="true"])', // a stageElement in kidoju.widgets.stage
	                enable: true
	            },
	
	            /**
	             * Widget events
	             * @property events
	             */
	            events: [
	                CHANGE
	            ],
	
	            /**
	             * Value for MVVM binding (cannot be set)
	             */
	            value: function (value) {
	                if ($.type(value) === UNDEFINED) {
	                    var that = this;
	                    var container = that.container;
	                    assert.instanceof($, container, kendo.format(assert.messages.instanceof.default, 'this.container', 'jQuery'));
	                    assert.hasLength(container, kendo.format(assert.messages.hasLength.default, 'this.container'));
	                    var ret = [];
	                    if ($.isArray(that._ids)) {
	                        $.each(that._ids, function (index, id) {
	                            var val = container.find(kendo.format(ATTRIBUTE_SELECTOR, kendo.attr(ID), id)).attr(kendo.attr(kendo.toHyphens(VALUE)));
	                            ret.push(val);
	                        });
	                    }
	                    return ret;
	                }
	            },
	
	            /**
	             * Builds the widget layout
	             * @private
	             */
	            _layout: function () {
	                var that = this;
	                var options = that.options;
	                var element = that.element;
	                that.wrapper = element;
	                element.addClass(WIDGET_CLASS);
	                that.container = element.closest(options.container);
	                that.scaler = element.closest(options.scaler);
	            },
	
	            /**
	             * Enable/disable the widget
	             * Initialize mouse events
	             * @param enable
	             * @private
	             */
	            enable: function (enable) {
	                var that = this;
	                assert.type(BOOLEAN, enable, kendo.format(assert.messages.type.default, 'enable', BOOLEAN));
	                that._enabled = enable;
	                // Yield some time for all drop zones to get enabled/disabled befor we init event handlers
	                setTimeout(function () {
	                    $.proxy(that._initDragEventHandlers, that)();
	                }, 100);
	            },
	
	            /**
	             * Initialize drag event handlers
	             * @private
	             */
	            _initDragEventHandlers: function () {
	                var that = this;
	                var options = that.options;
	                var container = that.container;
	                var dropZoneCollection = container.find(kendo.roleSelector('dropzone'));
	                //
	                // Event handlers should remain active if there is at least one active dropzone
	                var enable = that._enabled;
	                $.each(dropZoneCollection, function (index, otherDropZone) {
	                    var otherDropZoneWidget = $(otherDropZone).data('kendoDropZone');
	                    if (otherDropZoneWidget instanceof kendo.ui.DropZone && otherDropZoneWidget !== that) {
	                        enable = enable || otherDropZoneWidget._enabled;
	                    }
	                });
	                // find stageElements containing images or labels with attribute [data-draggable=true]
	                container.children(options.draggable)
	                    .css({ cursor: 'default' }); // or ''?
	                $(document).off(NS);
	                if (enable) {
	                    container.children(options.draggable)
	                        .css({ cursor: 'move' });
	                    $(document)
	                        .on(MOUSEDOWN, $.proxy(that._onMouseDown, that))
	                        .on(MOUSEMOVE, $.proxy(that._onMouseMove, that))
	                        .on(MOUSEUP, $.proxy(that._onMouseUp, that));
	                }
	            },
	
	            /**
	             * Mouse down event handler
	             * @param e
	             * @private
	             */
	            _onMouseDown: function (e) {
	                assert.instanceof($.Event, e, kendo.format(assert.messages.instanceof.default, 'e', 'jQuery.Event'));
	                var that = this;
	                var container = that.container;
	                assert.instanceof($, container, kendo.format(assert.messages.instanceof.default, 'this.container', 'jQuery'));
	                assert.hasLength(container, kendo.format(assert.messages.hasLength.default, 'this.container'));
	                var stageElement = $(e.target).closest(this.options.draggable);
	                if (stageElement instanceof $ && stageElement.length) {
	                    e.preventDefault(); // prevent text selection;
	                    var scaler = that.scaler;
	                    assert.instanceof($, scaler, kendo.format(assert.messages.instanceof.default, 'this.scaler', 'jQuery'));
	                    assert.hasLength(scaler, kendo.format(assert.messages.hasLength.default, 'this.scaler'));
	                    var mouse = util.getMousePosition(e, container);
	                    var id = stageElement.children(CONTENT_SELECTOR).attr(kendo.attr(ID));
	                    assert.type(STRING, id, kendo.format(assert.messages.type.default, 'id', STRING));
	                    var rotation = util.getTransformRotation(stageElement);
	                    var scale = util.getTransformScale(scaler);
	                    var offset = container.offset();
	                    container.data(STATE, {
	                        top: parseFloat(stageElement.css(TOP)) || 0, // stageElement.position().top does not work when scaled
	                        left: parseFloat(stageElement.css(LEFT)) || 0, // stageElement.position().left does not work when scaled
	                        height: stageElement.height(),
	                        width: stageElement.width(),
	                        rotation: rotation,
	                        scale: scale,
	                        snapGrid: 0, // TODO
	                        snapAngle: 0, // TODO
	                        mouseX: mouse.x,
	                        mouseY: mouse.y,
	                        // Note: contrary to kidoju.widgets.stage in design mode where new components have no id until they are saved, thus requiring the use of uid,
	                        // kidoju.widgets.dropZone is only enabled in play mode, so we can use id throughout considering also that we store the position of draggables
	                        // identified by their ids in database.
	                        id: id,
	                        boundaries: { // TODO review boundaries when element is rotated
	                            left: {
	                                min: 0,
	                                max: container.width() - stageElement.width()
	                            },
	                            top: {
	                                min: 0,
	                                max: container.height() - stageElement.height()
	                            }
	                        }
	                    });
	                } else {
	                    container.removeData(STATE);
	                }
	            },
	
	            /**
	             * Mouse move event handler
	             * @param e
	             * @private
	             */
	            _onMouseMove: function (e) {
	                assert.instanceof($.Event, e, kendo.format(assert.messages.instanceof.default, 'e', 'jQuery.Event'));
	                var that = this;
	                var container = that.container;
	                assert.instanceof($, container, kendo.format(assert.messages.instanceof.default, 'this.container', 'jQuery'));
	                assert.hasLength(container, kendo.format(assert.messages.hasLength.default, 'this.container'));
	                var startState = container.data(STATE);
	                if ($.isPlainObject(startState)) {
	                    // e.preventDefault(); // prevent text selection;
	                    var mouse = util.getMousePosition(e, container);
	                    var boundaries = startState.boundaries;
	                    var left = util.snap(startState.left + (mouse.x - startState.mouseX) / startState.scale, startState.snapGrid);
	                    var top = util.snap(startState.top + (mouse.y - startState.mouseY) / startState.scale, startState.snapGrid);
	                    left = Math.max(boundaries.left.min, Math.min(left, boundaries.left.max));
	                    top = Math.max(boundaries.top.min, Math.min(top, boundaries.top.max));
	                    // Set the data source and let the refresh method position the element
	                    that._setDataItem(startState.id, left, top);
	                }
	            },
	
	            /**
	             * Mouse up event handler
	             * @param e
	             * @private
	             */
	            _onMouseUp: function (e) {
	                assert.instanceof($.Event, e, kendo.format(assert.messages.instanceof.default, 'e', 'jQuery.Event'));
	                var that = this;
	                var container = that.container;
	                assert.instanceof($, container, kendo.format(assert.messages.instanceof.default, 'this.container', 'jQuery'));
	                assert.hasLength(container, kendo.format(assert.messages.hasLength.default, 'this.container'));
	                var startState = container.data(STATE);
	                if ($.isPlainObject(startState)) {
	                    // e.preventDefault(); // prevent text selection;
	                    // Update position (same as _onMouseMove)
	                    var mouse = util.getMousePosition(e, container);
	                    var scale = startState.scale;
	                    var boundaries = startState.boundaries;
	                    var left = util.snap(startState.left + (mouse.x - startState.mouseX) / startState.scale, startState.snapGrid);
	                    var top = util.snap(startState.top + (mouse.y - startState.mouseY) / startState.scale, startState.snapGrid);
	                    // Set the data source and let the refresh method position the element
	                    that._setDataItem(startState.id, left, top);
	
	                    // Check drop zone hits
	                    var stageElement = container.find(kendo.format(ATTRIBUTE_SELECTOR, kendo.attr(ID), startState.id)).closest(that.options.draggable);
	                    assert.hasLength(stageElement, kendo.format(assert.messages.hasLength.default, 'stageElement'));
	                    var center = util.getElementCenter(stageElement, container, scale);
	                    var id = startState.id;
	                    var dropZoneCollection = container.find(kendo.roleSelector('dropzone'));
	                    $.each(dropZoneCollection, function (index, htmlElement) {
	                        var anyDropZone = $(htmlElement);
	                        var anyDropZoneWidget = anyDropZone.data('kendoDropZone');
	                        assert.instanceof(DropZone, anyDropZoneWidget, kendo.format(assert.messages.instanceof.default, 'anyDropZoneWidget', 'kendo.ui.DropZone'));
	                        var parent = anyDropZone.parent(); // The parent .kj-element
	                        // TODO: in order for the implementation to be more flexible, we should search for the closest absolutely positioned parent
	                        // TODO: also consider rotation
	                        var position = parent.position();
	                        var rect = {
	                            left: {
	                                min: position.left / scale,
	                                max: position.left / scale + parent.width()
	                            },
	                            top: {
	                                min: position.top / scale,
	                                max: position.top / scale + parent.height()
	                            }
	                        };
	                        var _ids;
	                        if (center.left >= rect.left.min && center.left <= rect.left.max &&
	                            center.top >= rect.top.min && center.top <= rect.top.max) {
	                            _ids = anyDropZoneWidget._ids = anyDropZoneWidget._ids || [];
	                            if (_ids.indexOf(id) === -1) {
	                                _ids.push(id);
	                                logger.info({ message: 'id added', method: '_onMouseUp', data: { id: id } });
	                                anyDropZoneWidget.trigger(CHANGE);
	                            }
	                        } else {
	                            // Remove the value
	                            _ids = anyDropZoneWidget._ids = anyDropZoneWidget._ids || [];
	                            var pos = _ids.indexOf(id);
	                            if (pos >= 0) {
	                                _ids.splice(pos, 1);
	                                logger.info({ message: 'id removed', method: '_onMouseUp', data: { id: id } });
	                                anyDropZoneWidget.trigger(CHANGE);
	                            }
	                        }
	                    });
	                }
	                container.removeData(STATE);
	            },
	
	            /**
	             * set (add/update) data item in data source
	             * @param id
	             * @param left
	             * @param top
	             * @private
	             */
	            _setDataItem: function (id, left, top) {
	                assert.type(STRING, id, kendo.format(assert.messages.type.default, 'id', STRING));
	                assert.type(NUMBER, left, kendo.format(assert.messages.type.default, 'left', NUMBER));
	                assert.type(NUMBER, top, kendo.format(assert.messages.type.default, 'top', NUMBER));
	                var dataSource = this.dataSource;
	                assert.instanceof(DataSource, dataSource, kendo.format(assert.messages.instanceof.default, 'this.dataSource', 'kendo.data.DataSource'));
	                var dataItem = dataSource.get(id);
	                if (dataItem) {
	                    dataItem.set(LEFT, left);
	                    dataItem.set(TOP, top);
	                } else {
	                    dataSource.add({
	                        id: id,
	                        left: left,
	                        top: top
	                    });
	                }
	            },
	
	            /**
	             * _dataSource function to bind refresh to the change event
	             * @private
	             */
	            _dataSource: function () {
	                var that = this;
	
	                // returns the datasource OR creates one if using array or configuration
	                that.dataSource = DataSource.create(that.options.dataSource);
	
	                // bind to the change event to refresh the widget
	                if (that._refreshHandler) {
	                    that.dataSource.unbind(CHANGE, that._refreshHandler);
	                }
	                that._refreshHandler = $.proxy(that.refresh, that);
	                that.dataSource.bind(CHANGE, that._refreshHandler);
	
	                // trigger a read on the dataSource if one hasn't happened yet
	                if (that.options.autoBind) {
	                    that.dataSource.fetch();
	                }
	            },
	
	            /**
	             * sets the dataSource for source binding
	             * @param dataSource
	             */
	            setDataSource: function (dataSource) {
	                var that = this;
	                // set the internal datasource equal to the one passed in by MVVM
	                that.options.dataSource = dataSource;
	                // rebuild the datasource if necessary, or just reassign
	                that._dataSource();
	            },
	
	            /**
	             * Refresh the display
	             */
	            refresh: function (e) {
	                var that = this;
	                var container = that.container;
	                var items = that.dataSource.data();
	                if ($.isPlainObject(e) && $.isArray(e.items)) {
	                    items = e.items;
	                }
	                $.each(items, function (index, item) {
	                    var stageElement = container.find(kendo.format(ATTRIBUTE_SELECTOR, kendo.attr(ID), item.id)).closest(that.options.draggable);
	                    stageElement.css({
	                        left: item.left,
	                        top: item.top
	                    });
	                });
	            },
	
	            /**
	             * Destroys the widget including all DOM modifications
	             * @method destroy
	             */
	            destroy: function () {
	                var that = this;
	                var element = that.element;
	                that.enable(false);
	                Widget.fn.destroy.call(that);
	                // unbind and destroy kendo
	                kendo.unbind(element);
	                kendo.destroy(element);
	                // unbind all other events
	                that.element.find('*').off();
	                // remove descendants
	                that.element.empty();
	                // remove element classes
	                that.element.removeClass(WIDGET_CLASS);
	            }
	
	        });
	
	        kendo.ui.plugin(DropZone);
	
	    }(window.jQuery));
	
	    /* jshint +W071 */
	
	    return window.kendo;
	
	}, __webpack_require__(200));


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(207),
	        __webpack_require__(240),
	        __webpack_require__(241)
	        // './vendor/kendo/kendo.multiselect' // required because of a test in kendo.binder.js
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function (a, b, c, markdownit, highlight) {
	
	    'use strict';
	
	    // Load MathJax 2.6 dynamically - see https://docs.mathjax.org/en/v2.6-latest/advanced/dynamic.html
	    // SSee configuration options - see http://mathjax.readthedocs.org/en/latest/configuration.html
	    // And combined configuration options - see http://mathjax.readthedocs.org/en/latest/config-files.html
	    (function () {
	        var TYPE = 'text/x-mathjax-config';
	        var head = document.getElementsByTagName('head')[0];
	        var scripts = head.getElementsByTagName('script');
	        var found = false;
	        for (var i = 0; i < scripts.length; i++) {
	            if (scripts[i].type === TYPE) {
	                found = true;
	                break;
	            }
	        }
	        if (!found) {
	            var script = document.createElement('script');
	            script.type = TYPE;
	            // TODO OPTIMIZE without MathML input
	            script[(window.opera ? 'innerHTML' : 'text')] =
	                'MathJax.Hub.Config({\n' +
	                '  showMathMenu: false,\n' + // Hide contextual menu
	                '  asciimath2jax: { delimiters: [["#","#"], ["`","`"]] }\n' +
	                '});';
	            head.appendChild(script);
	            script = document.createElement('script');
	            script.type = 'text/javascript';
	            // script.src  = 'https://cdn.mathjax.org/mathjax/2.6-latest/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
	            script.src = 'https://cdn.mathjax.org/mathjax/2.6-latest/MathJax.js?config=TeX-MML-AM_HTMLorMML';
	            script.crossorigin = 'anonymous';
	            head.appendChild(script);
	        }
	    })();
	
	    (function ($, undefined) {
	
	        var kendo = window.kendo;
	        var Widget = kendo.ui.Widget;
	        var MarkdownIt = window.markdownit || markdownit;
	        var hljs = window.hljs || highlight;
	        var assert = window.assert;
	        var logger = new window.Logger('kidoju.widgets.markdown');
	        var STRING = 'string';
	        var NULL = 'null';
	        var UNDEFINED = 'undefined';
	        var EMPTY = '';
	        // var CHANGE = 'change';
	        // var NS = '.kendoMarkdown';
	        var WIDGET_CLASS = 'kj-markdown'; // 'k-widget kj-markdown';
	        var RX_YML = /^---\n([\s\S]*)\n---/;
	        var RX_KEYVAL = /([^:\n]+):([^\n]+)/g;
	        var KEY_BLACKLIST = /[-\s]/g;
	        var SCRIPT_SELECTOR = 'script[type="text/plain"]';
	        var SCRIPT_TAG = '<script type="text/plain"></script>';
	        var WRAP_TAG = '<wrap></wrap>';
	
	        /*********************************************************************************
	         * Helpers
	         * See https://github.com/Memba/Memba-Blog/blob/master/webapp/lib/markdown.js#L60
	         *********************************************************************************/
	
	        /**
	         * Return the yml metadata in value
	         * @param content
	         */
	        function head(content) {
	            var yml = {};
	            var ymlMatches = content.match(RX_YML);
	            if ($.isArray(ymlMatches) && ymlMatches.length > 1) {
	                var keyvalMatches = ymlMatches[1].match(RX_KEYVAL);
	                if ($.isArray(keyvalMatches) && keyvalMatches.length) {
	                    for (var i = 0; i < keyvalMatches.length; i++) {
	                        var keyval = keyvalMatches[i];
	                        var pos = keyval.indexOf(':');
	                        var key = keyval.substr(0, pos).trim().replace(KEY_BLACKLIST, '_');
	                        var val = keyval.substr(pos + 1).trim();
	                        yml[key] = val;
	                    }
	                }
	            }
	            return yml;
	        }
	
	        /**
	         * Returns the markdown content in value
	         * @param content
	         */
	        function body(content) {
	            return content.replace(RX_YML, EMPTY).trim();
	        }
	
	        /*********************************************************************************
	         * Widget
	         *********************************************************************************/
	
	        /**
	         * Markdown
	         * @class Markdown Widget (kendoMarkdown)
	         */
	        var Markdown = Widget.extend({
	
	            /**
	             * Initializes the widget
	             * @param element
	             * @param options
	             */
	            init: function (element, options) {
	                var that = this;
	                options = options || {};
	                Widget.fn.init.call(that, element, options);
	                logger.debug('widget initialized');
	                that._initMarkdownIt();
	                that._layout();
	                // kendo.notify(that);
	            },
	
	            /**
	             * Widget options
	             * @property options
	             */
	            options: {
	                name: 'Markdown',
	                url: null,
	                value: null
	            },
	
	            /**
	             * Widget events
	             * @property events
	             */
	            /*
	            events: [
	                CHANGE
	            ],
	            */
	
	            /**
	             * Value for MVVM binding
	             * Returns either a JS function as a string or a library formula name prefixed as a Javascript comment
	             * @param value
	             */
	            value: function (value) {
	                var that = this;
	                if ($.type(value) === STRING || $.type(value) === NULL) {
	                    if (that._value !== value) {
	                        that._value = value;
	                        // that.trigger(CHANGE, { value: that._value });
	                        that.refresh();
	                    }
	                } else if ($.type(value) === UNDEFINED) {
	                    if ($.type(that._value) === STRING || $.type(that._value) === NULL) {
	                        return that._value;
	                    } else {
	                        return undefined;
	                    }
	                } else {
	                    throw new TypeError('`value` is expected to be a string if not undefined');
	                }
	            },
	
	            /**
	             * Initialize markdown-it
	             * @private
	             */
	            _initMarkdownIt: function () {
	                var that = this;
	                that.md = new MarkdownIt({
	                    html: false,
	                    linkify: true,
	                    typographer: true,
	                    // See https://github.com/markdown-it/markdown-it#syntax-highlighting
	                    highlight: function (code, lang) {
	                        if (lang && hljs.getLanguage(lang)) {
	                            try {
	                                return '<pre class="hljs"><code>' +
	                                    hljs.highlight(lang, code, true).value +
	                                    '</code></pre>';
	                            } catch (ex) {}
	                        }
	                        return '<pre class="hljs"><code>' + that.md.utils.escapeHtml(code) + '</code></pre>';
	                    }
	                });
	            },
	
	            /**
	             * Builds the widget layout
	             * @private
	             */
	            _layout: function () {
	                var that = this;
	                var options = that.options;
	                that.wrapper = that.element;
	                that.element.addClass(WIDGET_CLASS);
	                if ($.type(options.url) === STRING) {
	                    that.url(options.url);
	                } else if ($.type(options.value) === STRING) {
	                    that.value(options.value);
	                } else {
	                    that.inline();
	                }
	            },
	
	            /**
	             * Reads the markdown text in an inline script
	             * @method _inline
	             * @private
	             */
	            inline: function () {
	                var that = this;
	                var element = that.element;
	                var inline = element.find(SCRIPT_SELECTOR);
	                if (inline.length) {
	                    that.value(inline.text());
	                }
	            },
	
	            /**
	             * Reads the markdown text from a url
	             * @param url
	             */
	            url: function (url) {
	                var that = this;
	                if ($.type(url) === NULL) {
	                    return;
	                } else if ($.type(url) === STRING) {
	                    $.get(url)
	                        .done(function (data) {
	                            that.value(data);
	                        })
	                        .fail(function () {
	                            that.value(null);
	                        });
	                } else {
	                    throw new TypeError('`url` is expected to be a string');
	                }
	            },
	
	            /**
	             * Returns yml metadata
	             */
	            metadata: function () {
	                return head((this.value() || '').trim());
	            },
	
	            /**
	             * Html displayed
	             * @method html
	             * @returns {*}
	             */
	            html: function () {
	                var markdown = body((this.value() || '').trim());
	                return this.md.render(markdown);
	            },
	
	            /**
	             * Refresh the display (especially after changing the value)
	             */
	            refresh: function () {
	                var that = this;
	                var element = that.element;
	                var inline = element.find(SCRIPT_SELECTOR);
	                var script = EMPTY;
	                if (inline.length) {
	                    script = $(SCRIPT_TAG).text(inline.text()).wrapAll(WRAP_TAG).parent().html();
	                }
	                element.html(script + that.html());
	                // If MathJax is not yet loaded it will parse the page anyway
	                var MathJax = window.MathJax;
	                if (MathJax) {
	                    // See http://mathjax.readthedocs.org/en/latest/advanced/typeset.html
	                    MathJax.Hub.Queue(['Typeset', MathJax.Hub, element[0]]);
	                }
	            },
	
	            /**
	             * Clears the widget
	             * @method _clear
	             * @private
	             */
	            _clear: function () {
	                var that = this;
	                // unbind kendo
	                // kendo.unbind($(that.element));
	                // unbind all other events
	                $(that.element).find('*').off();
	                $(that.element).off();
	                // remove descendants
	                $(that.element).empty();
	                // remove element classes
	                // $(that.element).removeClass(WIDGET_CLASS);
	            },
	
	            /**
	             * Destroys the widget including all DOM modifications
	             * @method destroy
	             */
	            destroy: function () {
	                var that = this;
	                Widget.fn.destroy.call(that);
	                that._clear();
	                kendo.destroy(that.element);
	            }
	
	        });
	
	        kendo.ui.plugin(Markdown);
	
	    }(window.jQuery));
	
	    return window.kendo;
	
	}, __webpack_require__(200));


/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;/* WEBPACK VAR INJECTION */(function(global) {/*! markdown-it 8.0.0 https://github.com//markdown-it/markdown-it @license MIT */(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.markdownit = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
	// HTML5 entities map: { name -> utf16string }
	//
	'use strict';
	
	/*eslint quotes:0*/
	module.exports = require('entities/maps/entities.json');
	
	},{"entities/maps/entities.json":52}],2:[function(require,module,exports){
	// List of valid html blocks names, accorting to commonmark spec
	// http://jgm.github.io/CommonMark/spec.html#html-blocks
	
	'use strict';
	
	
	module.exports = [
	  'address',
	  'article',
	  'aside',
	  'base',
	  'basefont',
	  'blockquote',
	  'body',
	  'caption',
	  'center',
	  'col',
	  'colgroup',
	  'dd',
	  'details',
	  'dialog',
	  'dir',
	  'div',
	  'dl',
	  'dt',
	  'fieldset',
	  'figcaption',
	  'figure',
	  'footer',
	  'form',
	  'frame',
	  'frameset',
	  'h1',
	  'head',
	  'header',
	  'hr',
	  'html',
	  'iframe',
	  'legend',
	  'li',
	  'link',
	  'main',
	  'menu',
	  'menuitem',
	  'meta',
	  'nav',
	  'noframes',
	  'ol',
	  'optgroup',
	  'option',
	  'p',
	  'param',
	  'pre',
	  'section',
	  'source',
	  'title',
	  'summary',
	  'table',
	  'tbody',
	  'td',
	  'tfoot',
	  'th',
	  'thead',
	  'title',
	  'tr',
	  'track',
	  'ul'
	];
	
	},{}],3:[function(require,module,exports){
	// Regexps to match html elements
	
	'use strict';
	
	var attr_name     = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
	
	var unquoted      = '[^"\'=<>`\\x00-\\x20]+';
	var single_quoted = "'[^']*'";
	var double_quoted = '"[^"]*"';
	
	var attr_value  = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';
	
	var attribute   = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';
	
	var open_tag    = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';
	
	var close_tag   = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
	var comment     = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
	var processing  = '<[?].*?[?]>';
	var declaration = '<![A-Z]+\\s+[^>]*>';
	var cdata       = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';
	
	var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment +
	                        '|' + processing + '|' + declaration + '|' + cdata + ')');
	var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');
	
	module.exports.HTML_TAG_RE = HTML_TAG_RE;
	module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;
	
	},{}],4:[function(require,module,exports){
	// Utilities
	//
	'use strict';
	
	
	function _class(obj) { return Object.prototype.toString.call(obj); }
	
	function isString(obj) { return _class(obj) === '[object String]'; }
	
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	
	function has(object, key) {
	  return _hasOwnProperty.call(object, key);
	}
	
	// Merge objects
	//
	function assign(obj /*from1, from2, from3, ...*/) {
	  var sources = Array.prototype.slice.call(arguments, 1);
	
	  sources.forEach(function (source) {
	    if (!source) { return; }
	
	    if (typeof source !== 'object') {
	      throw new TypeError(source + 'must be object');
	    }
	
	    Object.keys(source).forEach(function (key) {
	      obj[key] = source[key];
	    });
	  });
	
	  return obj;
	}
	
	// Remove element from array and put another array at those position.
	// Useful for some operations with tokens
	function arrayReplaceAt(src, pos, newElements) {
	  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
	}
	
	////////////////////////////////////////////////////////////////////////////////
	
	function isValidEntityCode(c) {
	  /*eslint no-bitwise:0*/
	  // broken sequence
	  if (c >= 0xD800 && c <= 0xDFFF) { return false; }
	  // never used
	  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }
	  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }
	  // control codes
	  if (c >= 0x00 && c <= 0x08) { return false; }
	  if (c === 0x0B) { return false; }
	  if (c >= 0x0E && c <= 0x1F) { return false; }
	  if (c >= 0x7F && c <= 0x9F) { return false; }
	  // out of range
	  if (c > 0x10FFFF) { return false; }
	  return true;
	}
	
	function fromCodePoint(c) {
	  /*eslint no-bitwise:0*/
	  if (c > 0xffff) {
	    c -= 0x10000;
	    var surrogate1 = 0xd800 + (c >> 10),
	        surrogate2 = 0xdc00 + (c & 0x3ff);
	
	    return String.fromCharCode(surrogate1, surrogate2);
	  }
	  return String.fromCharCode(c);
	}
	
	
	var UNESCAPE_MD_RE  = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
	var ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi;
	var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');
	
	var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
	
	var entities = require('./entities');
	
	function replaceEntityPattern(match, name) {
	  var code = 0;
	
	  if (has(entities, name)) {
	    return entities[name];
	  }
	
	  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
	    code = name[1].toLowerCase() === 'x' ?
	      parseInt(name.slice(2), 16)
	    :
	      parseInt(name.slice(1), 10);
	    if (isValidEntityCode(code)) {
	      return fromCodePoint(code);
	    }
	  }
	
	  return match;
	}
	
	/*function replaceEntities(str) {
	  if (str.indexOf('&') < 0) { return str; }
	
	  return str.replace(ENTITY_RE, replaceEntityPattern);
	}*/
	
	function unescapeMd(str) {
	  if (str.indexOf('\\') < 0) { return str; }
	  return str.replace(UNESCAPE_MD_RE, '$1');
	}
	
	function unescapeAll(str) {
	  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) { return str; }
	
	  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
	    if (escaped) { return escaped; }
	    return replaceEntityPattern(match, entity);
	  });
	}
	
	////////////////////////////////////////////////////////////////////////////////
	
	var HTML_ESCAPE_TEST_RE = /[&<>"]/;
	var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
	var HTML_REPLACEMENTS = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;'
	};
	
	function replaceUnsafeChar(ch) {
	  return HTML_REPLACEMENTS[ch];
	}
	
	function escapeHtml(str) {
	  if (HTML_ESCAPE_TEST_RE.test(str)) {
	    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
	  }
	  return str;
	}
	
	////////////////////////////////////////////////////////////////////////////////
	
	var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
	
	function escapeRE(str) {
	  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
	}
	
	////////////////////////////////////////////////////////////////////////////////
	
	function isSpace(code) {
	  switch (code) {
	    case 0x09:
	    case 0x20:
	      return true;
	  }
	  return false;
	}
	
	// Zs (unicode class) || [\t\f\v\r\n]
	function isWhiteSpace(code) {
	  if (code >= 0x2000 && code <= 0x200A) { return true; }
	  switch (code) {
	    case 0x09: // \t
	    case 0x0A: // \n
	    case 0x0B: // \v
	    case 0x0C: // \f
	    case 0x0D: // \r
	    case 0x20:
	    case 0xA0:
	    case 0x1680:
	    case 0x202F:
	    case 0x205F:
	    case 0x3000:
	      return true;
	  }
	  return false;
	}
	
	////////////////////////////////////////////////////////////////////////////////
	
	/*eslint-disable max-len*/
	var UNICODE_PUNCT_RE = require('uc.micro/categories/P/regex');
	
	// Currently without astral characters support.
	function isPunctChar(ch) {
	  return UNICODE_PUNCT_RE.test(ch);
	}
	
	
	// Markdown ASCII punctuation characters.
	//
	// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
	// http://spec.commonmark.org/0.15/#ascii-punctuation-character
	//
	// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
	//
	function isMdAsciiPunct(ch) {
	  switch (ch) {
	    case 0x21/* ! */:
	    case 0x22/* " */:
	    case 0x23/* # */:
	    case 0x24/* $ */:
	    case 0x25/* % */:
	    case 0x26/* & */:
	    case 0x27/* ' */:
	    case 0x28/* ( */:
	    case 0x29/* ) */:
	    case 0x2A/* * */:
	    case 0x2B/* + */:
	    case 0x2C/* , */:
	    case 0x2D/* - */:
	    case 0x2E/* . */:
	    case 0x2F/* / */:
	    case 0x3A/* : */:
	    case 0x3B/* ; */:
	    case 0x3C/* < */:
	    case 0x3D/* = */:
	    case 0x3E/* > */:
	    case 0x3F/* ? */:
	    case 0x40/* @ */:
	    case 0x5B/* [ */:
	    case 0x5C/* \ */:
	    case 0x5D/* ] */:
	    case 0x5E/* ^ */:
	    case 0x5F/* _ */:
	    case 0x60/* ` */:
	    case 0x7B/* { */:
	    case 0x7C/* | */:
	    case 0x7D/* } */:
	    case 0x7E/* ~ */:
	      return true;
	    default:
	      return false;
	  }
	}
	
	// Hepler to unify [reference labels].
	//
	function normalizeReference(str) {
	  // use .toUpperCase() instead of .toLowerCase()
	  // here to avoid a conflict with Object.prototype
	  // members (most notably, `__proto__`)
	  return str.trim().replace(/\s+/g, ' ').toUpperCase();
	}
	
	////////////////////////////////////////////////////////////////////////////////
	
	// Re-export libraries commonly used in both markdown-it and its plugins,
	// so plugins won't have to depend on them explicitly, which reduces their
	// bundled size (e.g. a browser build).
	//
	exports.lib                 = {};
	exports.lib.mdurl           = require('mdurl');
	exports.lib.ucmicro         = require('uc.micro');
	
	exports.assign              = assign;
	exports.isString            = isString;
	exports.has                 = has;
	exports.unescapeMd          = unescapeMd;
	exports.unescapeAll         = unescapeAll;
	exports.isValidEntityCode   = isValidEntityCode;
	exports.fromCodePoint       = fromCodePoint;
	// exports.replaceEntities     = replaceEntities;
	exports.escapeHtml          = escapeHtml;
	exports.arrayReplaceAt      = arrayReplaceAt;
	exports.isSpace             = isSpace;
	exports.isWhiteSpace        = isWhiteSpace;
	exports.isMdAsciiPunct      = isMdAsciiPunct;
	exports.isPunctChar         = isPunctChar;
	exports.escapeRE            = escapeRE;
	exports.normalizeReference  = normalizeReference;
	
	},{"./entities":1,"mdurl":58,"uc.micro":65,"uc.micro/categories/P/regex":63}],5:[function(require,module,exports){
	// Just a shortcut for bulk export
	'use strict';
	
	
	exports.parseLinkLabel       = require('./parse_link_label');
	exports.parseLinkDestination = require('./parse_link_destination');
	exports.parseLinkTitle       = require('./parse_link_title');
	
	},{"./parse_link_destination":6,"./parse_link_label":7,"./parse_link_title":8}],6:[function(require,module,exports){
	// Parse link destination
	//
	'use strict';
	
	
	var isSpace     = require('../common/utils').isSpace;
	var unescapeAll = require('../common/utils').unescapeAll;
	
	
	module.exports = function parseLinkDestination(str, pos, max) {
	  var code, level,
	      lines = 0,
	      start = pos,
	      result = {
	        ok: false,
	        pos: 0,
	        lines: 0,
	        str: ''
	      };
	
	  if (str.charCodeAt(pos) === 0x3C /* < */) {
	    pos++;
	    while (pos < max) {
	      code = str.charCodeAt(pos);
	      if (code === 0x0A /* \n */ || isSpace(code)) { return result; }
	      if (code === 0x3E /* > */) {
	        result.pos = pos + 1;
	        result.str = unescapeAll(str.slice(start + 1, pos));
	        result.ok = true;
	        return result;
	      }
	      if (code === 0x5C /* \ */ && pos + 1 < max) {
	        pos += 2;
	        continue;
	      }
	
	      pos++;
	    }
	
	    // no closing '>'
	    return result;
	  }
	
	  // this should be ... } else { ... branch
	
	  level = 0;
	  while (pos < max) {
	    code = str.charCodeAt(pos);
	
	    if (code === 0x20) { break; }
	
	    // ascii control characters
	    if (code < 0x20 || code === 0x7F) { break; }
	
	    if (code === 0x5C /* \ */ && pos + 1 < max) {
	      pos += 2;
	      continue;
	    }
	
	    if (code === 0x28 /* ( */) {
	      level++;
	      if (level > 1) { break; }
	    }
	
	    if (code === 0x29 /* ) */) {
	      level--;
	      if (level < 0) { break; }
	    }
	
	    pos++;
	  }
	
	  if (start === pos) { return result; }
	
	  result.str = unescapeAll(str.slice(start, pos));
	  result.lines = lines;
	  result.pos = pos;
	  result.ok = true;
	  return result;
	};
	
	},{"../common/utils":4}],7:[function(require,module,exports){
	// Parse link label
	//
	// this function assumes that first character ("[") already matches;
	// returns the end of the label
	//
	'use strict';
	
	module.exports = function parseLinkLabel(state, start, disableNested) {
	  var level, found, marker, prevPos,
	      labelEnd = -1,
	      max = state.posMax,
	      oldPos = state.pos;
	
	  state.pos = start + 1;
	  level = 1;
	
	  while (state.pos < max) {
	    marker = state.src.charCodeAt(state.pos);
	    if (marker === 0x5D /* ] */) {
	      level--;
	      if (level === 0) {
	        found = true;
	        break;
	      }
	    }
	
	    prevPos = state.pos;
	    state.md.inline.skipToken(state);
	    if (marker === 0x5B /* [ */) {
	      if (prevPos === state.pos - 1) {
	        // increase level if we find text `[`, which is not a part of any token
	        level++;
	      } else if (disableNested) {
	        state.pos = oldPos;
	        return -1;
	      }
	    }
	  }
	
	  if (found) {
	    labelEnd = state.pos;
	  }
	
	  // restore old state
	  state.pos = oldPos;
	
	  return labelEnd;
	};
	
	},{}],8:[function(require,module,exports){
	// Parse link title
	//
	'use strict';
	
	
	var unescapeAll = require('../common/utils').unescapeAll;
	
	
	module.exports = function parseLinkTitle(str, pos, max) {
	  var code,
	      marker,
	      lines = 0,
	      start = pos,
	      result = {
	        ok: false,
	        pos: 0,
	        lines: 0,
	        str: ''
	      };
	
	  if (pos >= max) { return result; }
	
	  marker = str.charCodeAt(pos);
	
	  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return result; }
	
	  pos++;
	
	  // if opening marker is "(", switch it to closing marker ")"
	  if (marker === 0x28) { marker = 0x29; }
	
	  while (pos < max) {
	    code = str.charCodeAt(pos);
	    if (code === marker) {
	      result.pos = pos + 1;
	      result.lines = lines;
	      result.str = unescapeAll(str.slice(start + 1, pos));
	      result.ok = true;
	      return result;
	    } else if (code === 0x0A) {
	      lines++;
	    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
	      pos++;
	      if (str.charCodeAt(pos) === 0x0A) {
	        lines++;
	      }
	    }
	
	    pos++;
	  }
	
	  return result;
	};
	
	},{"../common/utils":4}],9:[function(require,module,exports){
	// Main parser class
	
	'use strict';
	
	
	var utils        = require('./common/utils');
	var helpers      = require('./helpers');
	var Renderer     = require('./renderer');
	var ParserCore   = require('./parser_core');
	var ParserBlock  = require('./parser_block');
	var ParserInline = require('./parser_inline');
	var LinkifyIt    = require('linkify-it');
	var mdurl        = require('mdurl');
	var punycode     = require('punycode');
	
	
	var config = {
	  'default': require('./presets/default'),
	  zero: require('./presets/zero'),
	  commonmark: require('./presets/commonmark')
	};
	
	////////////////////////////////////////////////////////////////////////////////
	//
	// This validator can prohibit more than really needed to prevent XSS. It's a
	// tradeoff to keep code simple and to be secure by default.
	//
	// If you need different setup - override validator method as you wish. Or
	// replace it with dummy function and use external sanitizer.
	//
	
	var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
	var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
	
	function validateLink(url) {
	  // url should be normalized at this point, and existing entities are decoded
	  var str = url.trim().toLowerCase();
	
	  return BAD_PROTO_RE.test(str) ? (GOOD_DATA_RE.test(str) ? true : false) : true;
	}
	
	////////////////////////////////////////////////////////////////////////////////
	
	
	var RECODE_HOSTNAME_FOR = [ 'http:', 'https:', 'mailto:' ];
	
	function normalizeLink(url) {
	  var parsed = mdurl.parse(url, true);
	
	  if (parsed.hostname) {
	    // Encode hostnames in urls like:
	    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
	    //
	    // We don't encode unknown schemas, because it's likely that we encode
	    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
	    //
	    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
	      try {
	        parsed.hostname = punycode.toASCII(parsed.hostname);
	      } catch (er) { /**/ }
	    }
	  }
	
	  return mdurl.encode(mdurl.format(parsed));
	}
	
	function normalizeLinkText(url) {
	  var parsed = mdurl.parse(url, true);
	
	  if (parsed.hostname) {
	    // Encode hostnames in urls like:
	    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
	    //
	    // We don't encode unknown schemas, because it's likely that we encode
	    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
	    //
	    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
	      try {
	        parsed.hostname = punycode.toUnicode(parsed.hostname);
	      } catch (er) { /**/ }
	    }
	  }
	
	  return mdurl.decode(mdurl.format(parsed));
	}
	
	
	/**
	 * class MarkdownIt
	 *
	 * Main parser/renderer class.
	 *
	 * ##### Usage
	 *
	 * ```javascript
	 * // node.js, "classic" way:
	 * var MarkdownIt = require('markdown-it'),
	 *     md = new MarkdownIt();
	 * var result = md.render('# markdown-it rulezz!');
	 *
	 * // node.js, the same, but with sugar:
	 * var md = require('markdown-it')();
	 * var result = md.render('# markdown-it rulezz!');
	 *
	 * // browser without AMD, added to "window" on script load
	 * // Note, there are no dash.
	 * var md = window.markdownit();
	 * var result = md.render('# markdown-it rulezz!');
	 * ```
	 *
	 * Single line rendering, without paragraph wrap:
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 * var result = md.renderInline('__markdown-it__ rulezz!');
	 * ```
	 **/
	
	/**
	 * new MarkdownIt([presetName, options])
	 * - presetName (String): optional, `commonmark` / `zero`
	 * - options (Object)
	 *
	 * Creates parser instanse with given config. Can be called without `new`.
	 *
	 * ##### presetName
	 *
	 * MarkdownIt provides named presets as a convenience to quickly
	 * enable/disable active syntax rules and options for common use cases.
	 *
	 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
	 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
	 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
	 *   similar to GFM, used when no preset name given. Enables all available rules,
	 *   but still without html, typographer & autolinker.
	 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
	 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
	 *   For example, when you need only `bold` and `italic` markup and nothing else.
	 *
	 * ##### options:
	 *
	 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
	 *   That's not safe! You may need external sanitizer to protect output from XSS.
	 *   It's better to extend features via plugins, instead of enabling HTML.
	 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
	 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
	 *   world you will need HTML output.
	 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
	 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
	 *   Can be useful for external highlighters.
	 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
	 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
	 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
	 *   quotes beautification (smartquotes).
	 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
	 *   pairs, when typographer enabled and smartquotes on. For example, you can
	 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
	 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
	 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
	 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
	 *   return empty string if the source was not changed and should be escaped
	 *   externaly. If result starts with <pre... internal wrapper is skipped.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * // commonmark mode
	 * var md = require('markdown-it')('commonmark');
	 *
	 * // default mode
	 * var md = require('markdown-it')();
	 *
	 * // enable everything
	 * var md = require('markdown-it')({
	 *   html: true,
	 *   linkify: true,
	 *   typographer: true
	 * });
	 * ```
	 *
	 * ##### Syntax highlighting
	 *
	 * ```js
	 * var hljs = require('highlight.js') // https://highlightjs.org/
	 *
	 * var md = require('markdown-it')({
	 *   highlight: function (str, lang) {
	 *     if (lang && hljs.getLanguage(lang)) {
	 *       try {
	 *         return hljs.highlight(lang, str, true).value;
	 *       } catch (__) {}
	 *     }
	 *
	 *     return ''; // use external default escaping
	 *   }
	 * });
	 * ```
	 *
	 * Or with full wrapper override (if you need assign class to `<pre>`):
	 *
	 * ```javascript
	 * var hljs = require('highlight.js') // https://highlightjs.org/
	 *
	 * // Actual default values
	 * var md = require('markdown-it')({
	 *   highlight: function (str, lang) {
	 *     if (lang && hljs.getLanguage(lang)) {
	 *       try {
	 *         return '<pre class="hljs"><code>' +
	 *                hljs.highlight(lang, str, true).value +
	 *                '</code></pre>';
	 *       } catch (__) {}
	 *     }
	 *
	 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
	 *   }
	 * });
	 * ```
	 *
	 **/
	function MarkdownIt(presetName, options) {
	  if (!(this instanceof MarkdownIt)) {
	    return new MarkdownIt(presetName, options);
	  }
	
	  if (!options) {
	    if (!utils.isString(presetName)) {
	      options = presetName || {};
	      presetName = 'default';
	    }
	  }
	
	  /**
	   * MarkdownIt#inline -> ParserInline
	   *
	   * Instance of [[ParserInline]]. You may need it to add new rules when
	   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
	   * [[MarkdownIt.enable]].
	   **/
	  this.inline = new ParserInline();
	
	  /**
	   * MarkdownIt#block -> ParserBlock
	   *
	   * Instance of [[ParserBlock]]. You may need it to add new rules when
	   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
	   * [[MarkdownIt.enable]].
	   **/
	  this.block = new ParserBlock();
	
	  /**
	   * MarkdownIt#core -> Core
	   *
	   * Instance of [[Core]] chain executor. You may need it to add new rules when
	   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
	   * [[MarkdownIt.enable]].
	   **/
	  this.core = new ParserCore();
	
	  /**
	   * MarkdownIt#renderer -> Renderer
	   *
	   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
	   * rules for new token types, generated by plugins.
	   *
	   * ##### Example
	   *
	   * ```javascript
	   * var md = require('markdown-it')();
	   *
	   * function myToken(tokens, idx, options, env, self) {
	   *   //...
	   *   return result;
	   * };
	   *
	   * md.renderer.rules['my_token'] = myToken
	   * ```
	   *
	   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
	   **/
	  this.renderer = new Renderer();
	
	  /**
	   * MarkdownIt#linkify -> LinkifyIt
	   *
	   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
	   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
	   * rule.
	   **/
	  this.linkify = new LinkifyIt();
	
	  /**
	   * MarkdownIt#validateLink(url) -> Boolean
	   *
	   * Link validation function. CommonMark allows too much in links. By default
	   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
	   * except some embedded image types.
	   *
	   * You can change this behaviour:
	   *
	   * ```javascript
	   * var md = require('markdown-it')();
	   * // enable everything
	   * md.validateLink = function () { return true; }
	   * ```
	   **/
	  this.validateLink = validateLink;
	
	  /**
	   * MarkdownIt#normalizeLink(url) -> String
	   *
	   * Function used to encode link url to a machine-readable format,
	   * which includes url-encoding, punycode, etc.
	   **/
	  this.normalizeLink = normalizeLink;
	
	  /**
	   * MarkdownIt#normalizeLinkText(url) -> String
	   *
	   * Function used to decode link url to a human-readable format`
	   **/
	  this.normalizeLinkText = normalizeLinkText;
	
	
	  // Expose utils & helpers for easy acces from plugins
	
	  /**
	   * MarkdownIt#utils -> utils
	   *
	   * Assorted utility functions, useful to write plugins. See details
	   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
	   **/
	  this.utils = utils;
	
	  /**
	   * MarkdownIt#helpers -> helpers
	   *
	   * Link components parser functions, useful to write plugins. See details
	   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
	   **/
	  this.helpers = helpers;
	
	
	  this.options = {};
	  this.configure(presetName);
	
	  if (options) { this.set(options); }
	}
	
	
	/** chainable
	 * MarkdownIt.set(options)
	 *
	 * Set parser options (in the same format as in constructor). Probably, you
	 * will never need it, but you can change options after constructor call.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')()
	 *             .set({ html: true, breaks: true })
	 *             .set({ typographer, true });
	 * ```
	 *
	 * __Note:__ To achieve the best possible performance, don't modify a
	 * `markdown-it` instance options on the fly. If you need multiple configurations
	 * it's best to create multiple instances and initialize each with separate
	 * config.
	 **/
	MarkdownIt.prototype.set = function (options) {
	  utils.assign(this.options, options);
	  return this;
	};
	
	
	/** chainable, internal
	 * MarkdownIt.configure(presets)
	 *
	 * Batch load of all options and compenent settings. This is internal method,
	 * and you probably will not need it. But if you with - see available presets
	 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
	 *
	 * We strongly recommend to use presets instead of direct config loads. That
	 * will give better compatibility with next versions.
	 **/
	MarkdownIt.prototype.configure = function (presets) {
	  var self = this, presetName;
	
	  if (utils.isString(presets)) {
	    presetName = presets;
	    presets = config[presetName];
	    if (!presets) { throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name'); }
	  }
	
	  if (!presets) { throw new Error('Wrong `markdown-it` preset, can\'t be empty'); }
	
	  if (presets.options) { self.set(presets.options); }
	
	  if (presets.components) {
	    Object.keys(presets.components).forEach(function (name) {
	      if (presets.components[name].rules) {
	        self[name].ruler.enableOnly(presets.components[name].rules);
	      }
	      if (presets.components[name].rules2) {
	        self[name].ruler2.enableOnly(presets.components[name].rules2);
	      }
	    });
	  }
	  return this;
	};
	
	
	/** chainable
	 * MarkdownIt.enable(list, ignoreInvalid)
	 * - list (String|Array): rule name or list of rule names to enable
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * Enable list or rules. It will automatically find appropriate components,
	 * containing rules with given names. If rule not found, and `ignoreInvalid`
	 * not set - throws exception.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')()
	 *             .enable(['sub', 'sup'])
	 *             .disable('smartquotes');
	 * ```
	 **/
	MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
	  var result = [];
	
	  if (!Array.isArray(list)) { list = [ list ]; }
	
	  [ 'core', 'block', 'inline' ].forEach(function (chain) {
	    result = result.concat(this[chain].ruler.enable(list, true));
	  }, this);
	
	  result = result.concat(this.inline.ruler2.enable(list, true));
	
	  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });
	
	  if (missed.length && !ignoreInvalid) {
	    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
	  }
	
	  return this;
	};
	
	
	/** chainable
	 * MarkdownIt.disable(list, ignoreInvalid)
	 * - list (String|Array): rule name or list of rule names to disable.
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * The same as [[MarkdownIt.enable]], but turn specified rules off.
	 **/
	MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
	  var result = [];
	
	  if (!Array.isArray(list)) { list = [ list ]; }
	
	  [ 'core', 'block', 'inline' ].forEach(function (chain) {
	    result = result.concat(this[chain].ruler.disable(list, true));
	  }, this);
	
	  result = result.concat(this.inline.ruler2.disable(list, true));
	
	  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });
	
	  if (missed.length && !ignoreInvalid) {
	    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
	  }
	  return this;
	};
	
	
	/** chainable
	 * MarkdownIt.use(plugin, params)
	 *
	 * Load specified plugin with given params into current parser instance.
	 * It's just a sugar to call `plugin(md, params)` with curring.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var iterator = require('markdown-it-for-inline');
	 * var md = require('markdown-it')()
	 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
	 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
	 *             });
	 * ```
	 **/
	MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
	  var args = [ this ].concat(Array.prototype.slice.call(arguments, 1));
	  plugin.apply(plugin, args);
	  return this;
	};
	
	
	/** internal
	 * MarkdownIt.parse(src, env) -> Array
	 * - src (String): source string
	 * - env (Object): environment sandbox
	 *
	 * Parse input string and returns list of block tokens (special token type
	 * "inline" will contain list of inline tokens). You should not call this
	 * method directly, until you write custom renderer (for example, to produce
	 * AST).
	 *
	 * `env` is used to pass data between "distributed" rules and return additional
	 * metadata like reference info, needed for the renderer. It also can be used to
	 * inject data in specific cases. Usually, you will be ok to pass `{}`,
	 * and then pass updated object to renderer.
	 **/
	MarkdownIt.prototype.parse = function (src, env) {
	  var state = new this.core.State(src, this, env);
	
	  this.core.process(state);
	
	  return state.tokens;
	};
	
	
	/**
	 * MarkdownIt.render(src [, env]) -> String
	 * - src (String): source string
	 * - env (Object): environment sandbox
	 *
	 * Render markdown string into html. It does all magic for you :).
	 *
	 * `env` can be used to inject additional metadata (`{}` by default).
	 * But you will not need it with high probability. See also comment
	 * in [[MarkdownIt.parse]].
	 **/
	MarkdownIt.prototype.render = function (src, env) {
	  env = env || {};
	
	  return this.renderer.render(this.parse(src, env), this.options, env);
	};
	
	
	/** internal
	 * MarkdownIt.parseInline(src, env) -> Array
	 * - src (String): source string
	 * - env (Object): environment sandbox
	 *
	 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
	 * block tokens list with the single `inline` element, containing parsed inline
	 * tokens in `children` property. Also updates `env` object.
	 **/
	MarkdownIt.prototype.parseInline = function (src, env) {
	  var state = new this.core.State(src, this, env);
	
	  state.inlineMode = true;
	  this.core.process(state);
	
	  return state.tokens;
	};
	
	
	/**
	 * MarkdownIt.renderInline(src [, env]) -> String
	 * - src (String): source string
	 * - env (Object): environment sandbox
	 *
	 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
	 * will NOT be wrapped into `<p>` tags.
	 **/
	MarkdownIt.prototype.renderInline = function (src, env) {
	  env = env || {};
	
	  return this.renderer.render(this.parseInline(src, env), this.options, env);
	};
	
	
	module.exports = MarkdownIt;
	
	},{"./common/utils":4,"./helpers":5,"./parser_block":10,"./parser_core":11,"./parser_inline":12,"./presets/commonmark":13,"./presets/default":14,"./presets/zero":15,"./renderer":16,"linkify-it":53,"mdurl":58,"punycode":60}],10:[function(require,module,exports){
	/** internal
	 * class ParserBlock
	 *
	 * Block-level tokenizer.
	 **/
	'use strict';
	
	
	var Ruler           = require('./ruler');
	
	
	var _rules = [
	  // First 2 params - rule name & source. Secondary array - list of rules,
	  // which can be terminated by this one.
	  [ 'table',      require('./rules_block/table'),      [ 'paragraph', 'reference' ] ],
	  [ 'code',       require('./rules_block/code') ],
	  [ 'fence',      require('./rules_block/fence'),      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
	  [ 'blockquote', require('./rules_block/blockquote'), [ 'paragraph', 'reference', 'list' ] ],
	  [ 'hr',         require('./rules_block/hr'),         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
	  [ 'list',       require('./rules_block/list'),       [ 'paragraph', 'reference', 'blockquote' ] ],
	  [ 'reference',  require('./rules_block/reference') ],
	  [ 'heading',    require('./rules_block/heading'),    [ 'paragraph', 'reference', 'blockquote' ] ],
	  [ 'lheading',   require('./rules_block/lheading') ],
	  [ 'html_block', require('./rules_block/html_block'), [ 'paragraph', 'reference', 'blockquote' ] ],
	  [ 'paragraph',  require('./rules_block/paragraph') ]
	];
	
	
	/**
	 * new ParserBlock()
	 **/
	function ParserBlock() {
	  /**
	   * ParserBlock#ruler -> Ruler
	   *
	   * [[Ruler]] instance. Keep configuration of block rules.
	   **/
	  this.ruler = new Ruler();
	
	  for (var i = 0; i < _rules.length; i++) {
	    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
	  }
	}
	
	
	// Generate tokens for input range
	//
	ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
	  var ok, i,
	      rules = this.ruler.getRules(''),
	      len = rules.length,
	      line = startLine,
	      hasEmptyLines = false,
	      maxNesting = state.md.options.maxNesting;
	
	  while (line < endLine) {
	    state.line = line = state.skipEmptyLines(line);
	    if (line >= endLine) { break; }
	
	    // Termination condition for nested calls.
	    // Nested calls currently used for blockquotes & lists
	    if (state.sCount[line] < state.blkIndent) { break; }
	
	    // If nesting level exceeded - skip tail to the end. That's not ordinary
	    // situation and we should not care about content.
	    if (state.level >= maxNesting) {
	      state.line = endLine;
	      break;
	    }
	
	    // Try all possible rules.
	    // On success, rule should:
	    //
	    // - update `state.line`
	    // - update `state.tokens`
	    // - return true
	
	    for (i = 0; i < len; i++) {
	      ok = rules[i](state, line, endLine, false);
	      if (ok) { break; }
	    }
	
	    // set state.tight iff we had an empty line before current tag
	    // i.e. latest empty line should not count
	    state.tight = !hasEmptyLines;
	
	    // paragraph might "eat" one newline after it in nested lists
	    if (state.isEmpty(state.line - 1)) {
	      hasEmptyLines = true;
	    }
	
	    line = state.line;
	
	    if (line < endLine && state.isEmpty(line)) {
	      hasEmptyLines = true;
	      line++;
	      state.line = line;
	    }
	  }
	};
	
	
	/**
	 * ParserBlock.parse(str, md, env, outTokens)
	 *
	 * Process input string and push block tokens into `outTokens`
	 **/
	ParserBlock.prototype.parse = function (src, md, env, outTokens) {
	  var state;
	
	  if (!src) { return; }
	
	  state = new this.State(src, md, env, outTokens);
	
	  this.tokenize(state, state.line, state.lineMax);
	};
	
	
	ParserBlock.prototype.State = require('./rules_block/state_block');
	
	
	module.exports = ParserBlock;
	
	},{"./ruler":17,"./rules_block/blockquote":18,"./rules_block/code":19,"./rules_block/fence":20,"./rules_block/heading":21,"./rules_block/hr":22,"./rules_block/html_block":23,"./rules_block/lheading":24,"./rules_block/list":25,"./rules_block/paragraph":26,"./rules_block/reference":27,"./rules_block/state_block":28,"./rules_block/table":29}],11:[function(require,module,exports){
	/** internal
	 * class Core
	 *
	 * Top-level rules executor. Glues block/inline parsers and does intermediate
	 * transformations.
	 **/
	'use strict';
	
	
	var Ruler  = require('./ruler');
	
	
	var _rules = [
	  [ 'normalize',      require('./rules_core/normalize')      ],
	  [ 'block',          require('./rules_core/block')          ],
	  [ 'inline',         require('./rules_core/inline')         ],
	  [ 'linkify',        require('./rules_core/linkify')        ],
	  [ 'replacements',   require('./rules_core/replacements')   ],
	  [ 'smartquotes',    require('./rules_core/smartquotes')    ]
	];
	
	
	/**
	 * new Core()
	 **/
	function Core() {
	  /**
	   * Core#ruler -> Ruler
	   *
	   * [[Ruler]] instance. Keep configuration of core rules.
	   **/
	  this.ruler = new Ruler();
	
	  for (var i = 0; i < _rules.length; i++) {
	    this.ruler.push(_rules[i][0], _rules[i][1]);
	  }
	}
	
	
	/**
	 * Core.process(state)
	 *
	 * Executes core chain rules.
	 **/
	Core.prototype.process = function (state) {
	  var i, l, rules;
	
	  rules = this.ruler.getRules('');
	
	  for (i = 0, l = rules.length; i < l; i++) {
	    rules[i](state);
	  }
	};
	
	Core.prototype.State = require('./rules_core/state_core');
	
	
	module.exports = Core;
	
	},{"./ruler":17,"./rules_core/block":30,"./rules_core/inline":31,"./rules_core/linkify":32,"./rules_core/normalize":33,"./rules_core/replacements":34,"./rules_core/smartquotes":35,"./rules_core/state_core":36}],12:[function(require,module,exports){
	/** internal
	 * class ParserInline
	 *
	 * Tokenizes paragraph content.
	 **/
	'use strict';
	
	
	var Ruler           = require('./ruler');
	
	
	////////////////////////////////////////////////////////////////////////////////
	// Parser rules
	
	var _rules = [
	  [ 'text',            require('./rules_inline/text') ],
	  [ 'newline',         require('./rules_inline/newline') ],
	  [ 'escape',          require('./rules_inline/escape') ],
	  [ 'backticks',       require('./rules_inline/backticks') ],
	  [ 'strikethrough',   require('./rules_inline/strikethrough').tokenize ],
	  [ 'emphasis',        require('./rules_inline/emphasis').tokenize ],
	  [ 'link',            require('./rules_inline/link') ],
	  [ 'image',           require('./rules_inline/image') ],
	  [ 'autolink',        require('./rules_inline/autolink') ],
	  [ 'html_inline',     require('./rules_inline/html_inline') ],
	  [ 'entity',          require('./rules_inline/entity') ]
	];
	
	var _rules2 = [
	  [ 'balance_pairs',   require('./rules_inline/balance_pairs') ],
	  [ 'strikethrough',   require('./rules_inline/strikethrough').postProcess ],
	  [ 'emphasis',        require('./rules_inline/emphasis').postProcess ],
	  [ 'text_collapse',   require('./rules_inline/text_collapse') ]
	];
	
	
	/**
	 * new ParserInline()
	 **/
	function ParserInline() {
	  var i;
	
	  /**
	   * ParserInline#ruler -> Ruler
	   *
	   * [[Ruler]] instance. Keep configuration of inline rules.
	   **/
	  this.ruler = new Ruler();
	
	  for (i = 0; i < _rules.length; i++) {
	    this.ruler.push(_rules[i][0], _rules[i][1]);
	  }
	
	  /**
	   * ParserInline#ruler2 -> Ruler
	   *
	   * [[Ruler]] instance. Second ruler used for post-processing
	   * (e.g. in emphasis-like rules).
	   **/
	  this.ruler2 = new Ruler();
	
	  for (i = 0; i < _rules2.length; i++) {
	    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
	  }
	}
	
	
	// Skip single token by running all rules in validation mode;
	// returns `true` if any rule reported success
	//
	ParserInline.prototype.skipToken = function (state) {
	  var ok, i, pos = state.pos,
	      rules = this.ruler.getRules(''),
	      len = rules.length,
	      maxNesting = state.md.options.maxNesting,
	      cache = state.cache;
	
	
	  if (typeof cache[pos] !== 'undefined') {
	    state.pos = cache[pos];
	    return;
	  }
	
	  if (state.level < maxNesting) {
	    for (i = 0; i < len; i++) {
	      // Increment state.level and decrement it later to limit recursion.
	      // It's harmless to do here, because no tokens are created. But ideally,
	      // we'd need a separate private state variable for this purpose.
	      //
	      state.level++;
	      ok = rules[i](state, true);
	      state.level--;
	
	      if (ok) { break; }
	    }
	  } else {
	    // Too much nesting, just skip until the end of the paragraph.
	    //
	    // NOTE: this will cause links to behave incorrectly in the following case,
	    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
	    //
	    //       [[[[[[[[[[[[[[[[[[[[[foo]()
	    //
	    // TODO: remove this workaround when CM standard will allow nested links
	    //       (we can replace it by preventing links from being parsed in
	    //       validation mode)
	    //
	    state.pos = state.posMax;
	  }
	
	  if (!ok) { state.pos++; }
	  cache[pos] = state.pos;
	};
	
	
	// Generate tokens for input range
	//
	ParserInline.prototype.tokenize = function (state) {
	  var ok, i,
	      rules = this.ruler.getRules(''),
	      len = rules.length,
	      end = state.posMax,
	      maxNesting = state.md.options.maxNesting;
	
	  while (state.pos < end) {
	    // Try all possible rules.
	    // On success, rule should:
	    //
	    // - update `state.pos`
	    // - update `state.tokens`
	    // - return true
	
	    if (state.level < maxNesting) {
	      for (i = 0; i < len; i++) {
	        ok = rules[i](state, false);
	        if (ok) { break; }
	      }
	    }
	
	    if (ok) {
	      if (state.pos >= end) { break; }
	      continue;
	    }
	
	    state.pending += state.src[state.pos++];
	  }
	
	  if (state.pending) {
	    state.pushPending();
	  }
	};
	
	
	/**
	 * ParserInline.parse(str, md, env, outTokens)
	 *
	 * Process input string and push inline tokens into `outTokens`
	 **/
	ParserInline.prototype.parse = function (str, md, env, outTokens) {
	  var i, rules, len;
	  var state = new this.State(str, md, env, outTokens);
	
	  this.tokenize(state);
	
	  rules = this.ruler2.getRules('');
	  len = rules.length;
	
	  for (i = 0; i < len; i++) {
	    rules[i](state);
	  }
	};
	
	
	ParserInline.prototype.State = require('./rules_inline/state_inline');
	
	
	module.exports = ParserInline;
	
	},{"./ruler":17,"./rules_inline/autolink":37,"./rules_inline/backticks":38,"./rules_inline/balance_pairs":39,"./rules_inline/emphasis":40,"./rules_inline/entity":41,"./rules_inline/escape":42,"./rules_inline/html_inline":43,"./rules_inline/image":44,"./rules_inline/link":45,"./rules_inline/newline":46,"./rules_inline/state_inline":47,"./rules_inline/strikethrough":48,"./rules_inline/text":49,"./rules_inline/text_collapse":50}],13:[function(require,module,exports){
	// Commonmark default options
	
	'use strict';
	
	
	module.exports = {
	  options: {
	    html:         true,         // Enable HTML tags in source
	    xhtmlOut:     true,         // Use '/' to close single tags (<br />)
	    breaks:       false,        // Convert '\n' in paragraphs into <br>
	    langPrefix:   'language-',  // CSS language prefix for fenced blocks
	    linkify:      false,        // autoconvert URL-like texts to links
	
	    // Enable some language-neutral replacements + quotes beautification
	    typographer:  false,
	
	    // Double + single quotes replacement pairs, when typographer enabled,
	    // and smartquotes on. Could be either a String or an Array.
	    //
	    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
	    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
	    quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */
	
	    // Highlighter function. Should return escaped HTML,
	    // or '' if the source string is not changed and should be escaped externaly.
	    // If result starts with <pre... internal wrapper is skipped.
	    //
	    // function (/*str, lang*/) { return ''; }
	    //
	    highlight: null,
	
	    maxNesting:   20            // Internal protection, recursion limit
	  },
	
	  components: {
	
	    core: {
	      rules: [
	        'normalize',
	        'block',
	        'inline'
	      ]
	    },
	
	    block: {
	      rules: [
	        'blockquote',
	        'code',
	        'fence',
	        'heading',
	        'hr',
	        'html_block',
	        'lheading',
	        'list',
	        'reference',
	        'paragraph'
	      ]
	    },
	
	    inline: {
	      rules: [
	        'autolink',
	        'backticks',
	        'emphasis',
	        'entity',
	        'escape',
	        'html_inline',
	        'image',
	        'link',
	        'newline',
	        'text'
	      ],
	      rules2: [
	        'balance_pairs',
	        'emphasis',
	        'text_collapse'
	      ]
	    }
	  }
	};
	
	},{}],14:[function(require,module,exports){
	// markdown-it default options
	
	'use strict';
	
	
	module.exports = {
	  options: {
	    html:         false,        // Enable HTML tags in source
	    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
	    breaks:       false,        // Convert '\n' in paragraphs into <br>
	    langPrefix:   'language-',  // CSS language prefix for fenced blocks
	    linkify:      false,        // autoconvert URL-like texts to links
	
	    // Enable some language-neutral replacements + quotes beautification
	    typographer:  false,
	
	    // Double + single quotes replacement pairs, when typographer enabled,
	    // and smartquotes on. Could be either a String or an Array.
	    //
	    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
	    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
	    quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */
	
	    // Highlighter function. Should return escaped HTML,
	    // or '' if the source string is not changed and should be escaped externaly.
	    // If result starts with <pre... internal wrapper is skipped.
	    //
	    // function (/*str, lang*/) { return ''; }
	    //
	    highlight: null,
	
	    maxNesting:   100            // Internal protection, recursion limit
	  },
	
	  components: {
	
	    core: {},
	    block: {},
	    inline: {}
	  }
	};
	
	},{}],15:[function(require,module,exports){
	// "Zero" preset, with nothing enabled. Useful for manual configuring of simple
	// modes. For example, to parse bold/italic only.
	
	'use strict';
	
	
	module.exports = {
	  options: {
	    html:         false,        // Enable HTML tags in source
	    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
	    breaks:       false,        // Convert '\n' in paragraphs into <br>
	    langPrefix:   'language-',  // CSS language prefix for fenced blocks
	    linkify:      false,        // autoconvert URL-like texts to links
	
	    // Enable some language-neutral replacements + quotes beautification
	    typographer:  false,
	
	    // Double + single quotes replacement pairs, when typographer enabled,
	    // and smartquotes on. Could be either a String or an Array.
	    //
	    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
	    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
	    quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */
	
	    // Highlighter function. Should return escaped HTML,
	    // or '' if the source string is not changed and should be escaped externaly.
	    // If result starts with <pre... internal wrapper is skipped.
	    //
	    // function (/*str, lang*/) { return ''; }
	    //
	    highlight: null,
	
	    maxNesting:   20            // Internal protection, recursion limit
	  },
	
	  components: {
	
	    core: {
	      rules: [
	        'normalize',
	        'block',
	        'inline'
	      ]
	    },
	
	    block: {
	      rules: [
	        'paragraph'
	      ]
	    },
	
	    inline: {
	      rules: [
	        'text'
	      ],
	      rules2: [
	        'balance_pairs',
	        'text_collapse'
	      ]
	    }
	  }
	};
	
	},{}],16:[function(require,module,exports){
	/**
	 * class Renderer
	 *
	 * Generates HTML from parsed token stream. Each instance has independent
	 * copy of rules. Those can be rewritten with ease. Also, you can add new
	 * rules if you create plugin and adds new token types.
	 **/
	'use strict';
	
	
	var assign          = require('./common/utils').assign;
	var unescapeAll     = require('./common/utils').unescapeAll;
	var escapeHtml      = require('./common/utils').escapeHtml;
	
	
	////////////////////////////////////////////////////////////////////////////////
	
	var default_rules = {};
	
	
	default_rules.code_inline = function (tokens, idx, options, env, slf) {
	  var token = tokens[idx];
	
	  return  '<code' + slf.renderAttrs(token) + '>' +
	          escapeHtml(tokens[idx].content) +
	          '</code>';
	};
	
	
	default_rules.code_block = function (tokens, idx, options, env, slf) {
	  var token = tokens[idx];
	
	  return  '<pre' + slf.renderAttrs(token) + '><code>' +
	          escapeHtml(tokens[idx].content) +
	          '</code></pre>\n';
	};
	
	
	default_rules.fence = function (tokens, idx, options, env, slf) {
	  var token = tokens[idx],
	      info = token.info ? unescapeAll(token.info).trim() : '',
	      langName = '',
	      highlighted, i, tmpAttrs, tmpToken;
	
	  if (info) {
	    langName = info.split(/\s+/g)[0];
	  }
	
	  if (options.highlight) {
	    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
	  } else {
	    highlighted = escapeHtml(token.content);
	  }
	
	  if (highlighted.indexOf('<pre') === 0) {
	    return highlighted + '\n';
	  }
	
	  // If language exists, inject class gently, without mudofying original token.
	  // May be, one day we will add .clone() for token and simplify this part, but
	  // now we prefer to keep things local.
	  if (info) {
	    i        = token.attrIndex('class');
	    tmpAttrs = token.attrs ? token.attrs.slice() : [];
	
	    if (i < 0) {
	      tmpAttrs.push([ 'class', options.langPrefix + langName ]);
	    } else {
	      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
	    }
	
	    // Fake token just to render attributes
	    tmpToken = {
	      attrs: tmpAttrs
	    };
	
	    return  '<pre><code' + slf.renderAttrs(tmpToken) + '>'
	          + highlighted
	          + '</code></pre>\n';
	  }
	
	
	  return  '<pre><code' + slf.renderAttrs(token) + '>'
	        + highlighted
	        + '</code></pre>\n';
	};
	
	
	default_rules.image = function (tokens, idx, options, env, slf) {
	  var token = tokens[idx];
	
	  // "alt" attr MUST be set, even if empty. Because it's mandatory and
	  // should be placed on proper position for tests.
	  //
	  // Replace content with actual value
	
	  token.attrs[token.attrIndex('alt')][1] =
	    slf.renderInlineAsText(token.children, options, env);
	
	  return slf.renderToken(tokens, idx, options);
	};
	
	
	default_rules.hardbreak = function (tokens, idx, options /*, env */) {
	  return options.xhtmlOut ? '<br />\n' : '<br>\n';
	};
	default_rules.softbreak = function (tokens, idx, options /*, env */) {
	  return options.breaks ? (options.xhtmlOut ? '<br />\n' : '<br>\n') : '\n';
	};
	
	
	default_rules.text = function (tokens, idx /*, options, env */) {
	  return escapeHtml(tokens[idx].content);
	};
	
	
	default_rules.html_block = function (tokens, idx /*, options, env */) {
	  return tokens[idx].content;
	};
	default_rules.html_inline = function (tokens, idx /*, options, env */) {
	  return tokens[idx].content;
	};
	
	
	/**
	 * new Renderer()
	 *
	 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
	 **/
	function Renderer() {
	
	  /**
	   * Renderer#rules -> Object
	   *
	   * Contains render rules for tokens. Can be updated and extended.
	   *
	   * ##### Example
	   *
	   * ```javascript
	   * var md = require('markdown-it')();
	   *
	   * md.renderer.rules.strong_open  = function () { return '<b>'; };
	   * md.renderer.rules.strong_close = function () { return '</b>'; };
	   *
	   * var result = md.renderInline(...);
	   * ```
	   *
	   * Each rule is called as independed static function with fixed signature:
	   *
	   * ```javascript
	   * function my_token_render(tokens, idx, options, env, renderer) {
	   *   // ...
	   *   return renderedHTML;
	   * }
	   * ```
	   *
	   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
	   * for more details and examples.
	   **/
	  this.rules = assign({}, default_rules);
	}
	
	
	/**
	 * Renderer.renderAttrs(token) -> String
	 *
	 * Render token attributes to string.
	 **/
	Renderer.prototype.renderAttrs = function renderAttrs(token) {
	  var i, l, result;
	
	  if (!token.attrs) { return ''; }
	
	  result = '';
	
	  for (i = 0, l = token.attrs.length; i < l; i++) {
	    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
	  }
	
	  return result;
	};
	
	
	/**
	 * Renderer.renderToken(tokens, idx, options) -> String
	 * - tokens (Array): list of tokens
	 * - idx (Numbed): token index to render
	 * - options (Object): params of parser instance
	 *
	 * Default token renderer. Can be overriden by custom function
	 * in [[Renderer#rules]].
	 **/
	Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
	  var nextToken,
	      result = '',
	      needLf = false,
	      token = tokens[idx];
	
	  // Tight list paragraphs
	  if (token.hidden) {
	    return '';
	  }
	
	  // Insert a newline between hidden paragraph and subsequent opening
	  // block-level tag.
	  //
	  // For example, here we should insert a newline before blockquote:
	  //  - a
	  //    >
	  //
	  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
	    result += '\n';
	  }
	
	  // Add token name, e.g. `<img`
	  result += (token.nesting === -1 ? '</' : '<') + token.tag;
	
	  // Encode attributes, e.g. `<img src="foo"`
	  result += this.renderAttrs(token);
	
	  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
	  if (token.nesting === 0 && options.xhtmlOut) {
	    result += ' /';
	  }
	
	  // Check if we need to add a newline after this tag
	  if (token.block) {
	    needLf = true;
	
	    if (token.nesting === 1) {
	      if (idx + 1 < tokens.length) {
	        nextToken = tokens[idx + 1];
	
	        if (nextToken.type === 'inline' || nextToken.hidden) {
	          // Block-level tag containing an inline tag.
	          //
	          needLf = false;
	
	        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
	          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
	          //
	          needLf = false;
	        }
	      }
	    }
	  }
	
	  result += needLf ? '>\n' : '>';
	
	  return result;
	};
	
	
	/**
	 * Renderer.renderInline(tokens, options, env) -> String
	 * - tokens (Array): list on block tokens to renter
	 * - options (Object): params of parser instance
	 * - env (Object): additional data from parsed input (references, for example)
	 *
	 * The same as [[Renderer.render]], but for single token of `inline` type.
	 **/
	Renderer.prototype.renderInline = function (tokens, options, env) {
	  var type,
	      result = '',
	      rules = this.rules;
	
	  for (var i = 0, len = tokens.length; i < len; i++) {
	    type = tokens[i].type;
	
	    if (typeof rules[type] !== 'undefined') {
	      result += rules[type](tokens, i, options, env, this);
	    } else {
	      result += this.renderToken(tokens, i, options);
	    }
	  }
	
	  return result;
	};
	
	
	/** internal
	 * Renderer.renderInlineAsText(tokens, options, env) -> String
	 * - tokens (Array): list on block tokens to renter
	 * - options (Object): params of parser instance
	 * - env (Object): additional data from parsed input (references, for example)
	 *
	 * Special kludge for image `alt` attributes to conform CommonMark spec.
	 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
	 * instead of simple escaping.
	 **/
	Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
	  var result = '';
	
	  for (var i = 0, len = tokens.length; i < len; i++) {
	    if (tokens[i].type === 'text') {
	      result += tokens[i].content;
	    } else if (tokens[i].type === 'image') {
	      result += this.renderInlineAsText(tokens[i].children, options, env);
	    }
	  }
	
	  return result;
	};
	
	
	/**
	 * Renderer.render(tokens, options, env) -> String
	 * - tokens (Array): list on block tokens to renter
	 * - options (Object): params of parser instance
	 * - env (Object): additional data from parsed input (references, for example)
	 *
	 * Takes token stream and generates HTML. Probably, you will never need to call
	 * this method directly.
	 **/
	Renderer.prototype.render = function (tokens, options, env) {
	  var i, len, type,
	      result = '',
	      rules = this.rules;
	
	  for (i = 0, len = tokens.length; i < len; i++) {
	    type = tokens[i].type;
	
	    if (type === 'inline') {
	      result += this.renderInline(tokens[i].children, options, env);
	    } else if (typeof rules[type] !== 'undefined') {
	      result += rules[tokens[i].type](tokens, i, options, env, this);
	    } else {
	      result += this.renderToken(tokens, i, options, env);
	    }
	  }
	
	  return result;
	};
	
	module.exports = Renderer;
	
	},{"./common/utils":4}],17:[function(require,module,exports){
	/**
	 * class Ruler
	 *
	 * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
	 * [[MarkdownIt#inline]] to manage sequences of functions (rules):
	 *
	 * - keep rules in defined order
	 * - assign the name to each rule
	 * - enable/disable rules
	 * - add/replace rules
	 * - allow assign rules to additional named chains (in the same)
	 * - cacheing lists of active rules
	 *
	 * You will not need use this class directly until write plugins. For simple
	 * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
	 * [[MarkdownIt.use]].
	 **/
	'use strict';
	
	
	/**
	 * new Ruler()
	 **/
	function Ruler() {
	  // List of added rules. Each element is:
	  //
	  // {
	  //   name: XXX,
	  //   enabled: Boolean,
	  //   fn: Function(),
	  //   alt: [ name2, name3 ]
	  // }
	  //
	  this.__rules__ = [];
	
	  // Cached rule chains.
	  //
	  // First level - chain name, '' for default.
	  // Second level - diginal anchor for fast filtering by charcodes.
	  //
	  this.__cache__ = null;
	}
	
	////////////////////////////////////////////////////////////////////////////////
	// Helper methods, should not be used directly
	
	
	// Find rule index by name
	//
	Ruler.prototype.__find__ = function (name) {
	  for (var i = 0; i < this.__rules__.length; i++) {
	    if (this.__rules__[i].name === name) {
	      return i;
	    }
	  }
	  return -1;
	};
	
	
	// Build rules lookup cache
	//
	Ruler.prototype.__compile__ = function () {
	  var self = this;
	  var chains = [ '' ];
	
	  // collect unique names
	  self.__rules__.forEach(function (rule) {
	    if (!rule.enabled) { return; }
	
	    rule.alt.forEach(function (altName) {
	      if (chains.indexOf(altName) < 0) {
	        chains.push(altName);
	      }
	    });
	  });
	
	  self.__cache__ = {};
	
	  chains.forEach(function (chain) {
	    self.__cache__[chain] = [];
	    self.__rules__.forEach(function (rule) {
	      if (!rule.enabled) { return; }
	
	      if (chain && rule.alt.indexOf(chain) < 0) { return; }
	
	      self.__cache__[chain].push(rule.fn);
	    });
	  });
	};
	
	
	/**
	 * Ruler.at(name, fn [, options])
	 * - name (String): rule name to replace.
	 * - fn (Function): new rule function.
	 * - options (Object): new rule options (not mandatory).
	 *
	 * Replace rule by name with new function & options. Throws error if name not
	 * found.
	 *
	 * ##### Options:
	 *
	 * - __alt__ - array with names of "alternate" chains.
	 *
	 * ##### Example
	 *
	 * Replace existing typorgapher replacement rule with new one:
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 *
	 * md.core.ruler.at('replacements', function replace(state) {
	 *   //...
	 * });
	 * ```
	 **/
	Ruler.prototype.at = function (name, fn, options) {
	  var index = this.__find__(name);
	  var opt = options || {};
	
	  if (index === -1) { throw new Error('Parser rule not found: ' + name); }
	
	  this.__rules__[index].fn = fn;
	  this.__rules__[index].alt = opt.alt || [];
	  this.__cache__ = null;
	};
	
	
	/**
	 * Ruler.before(beforeName, ruleName, fn [, options])
	 * - beforeName (String): new rule will be added before this one.
	 * - ruleName (String): name of added rule.
	 * - fn (Function): rule function.
	 * - options (Object): rule options (not mandatory).
	 *
	 * Add new rule to chain before one with given name. See also
	 * [[Ruler.after]], [[Ruler.push]].
	 *
	 * ##### Options:
	 *
	 * - __alt__ - array with names of "alternate" chains.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 *
	 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
	 *   //...
	 * });
	 * ```
	 **/
	Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
	  var index = this.__find__(beforeName);
	  var opt = options || {};
	
	  if (index === -1) { throw new Error('Parser rule not found: ' + beforeName); }
	
	  this.__rules__.splice(index, 0, {
	    name: ruleName,
	    enabled: true,
	    fn: fn,
	    alt: opt.alt || []
	  });
	
	  this.__cache__ = null;
	};
	
	
	/**
	 * Ruler.after(afterName, ruleName, fn [, options])
	 * - afterName (String): new rule will be added after this one.
	 * - ruleName (String): name of added rule.
	 * - fn (Function): rule function.
	 * - options (Object): rule options (not mandatory).
	 *
	 * Add new rule to chain after one with given name. See also
	 * [[Ruler.before]], [[Ruler.push]].
	 *
	 * ##### Options:
	 *
	 * - __alt__ - array with names of "alternate" chains.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 *
	 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
	 *   //...
	 * });
	 * ```
	 **/
	Ruler.prototype.after = function (afterName, ruleName, fn, options) {
	  var index = this.__find__(afterName);
	  var opt = options || {};
	
	  if (index === -1) { throw new Error('Parser rule not found: ' + afterName); }
	
	  this.__rules__.splice(index + 1, 0, {
	    name: ruleName,
	    enabled: true,
	    fn: fn,
	    alt: opt.alt || []
	  });
	
	  this.__cache__ = null;
	};
	
	/**
	 * Ruler.push(ruleName, fn [, options])
	 * - ruleName (String): name of added rule.
	 * - fn (Function): rule function.
	 * - options (Object): rule options (not mandatory).
	 *
	 * Push new rule to the end of chain. See also
	 * [[Ruler.before]], [[Ruler.after]].
	 *
	 * ##### Options:
	 *
	 * - __alt__ - array with names of "alternate" chains.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 *
	 * md.core.ruler.push('my_rule', function replace(state) {
	 *   //...
	 * });
	 * ```
	 **/
	Ruler.prototype.push = function (ruleName, fn, options) {
	  var opt = options || {};
	
	  this.__rules__.push({
	    name: ruleName,
	    enabled: true,
	    fn: fn,
	    alt: opt.alt || []
	  });
	
	  this.__cache__ = null;
	};
	
	
	/**
	 * Ruler.enable(list [, ignoreInvalid]) -> Array
	 * - list (String|Array): list of rule names to enable.
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * Enable rules with given names. If any rule name not found - throw Error.
	 * Errors can be disabled by second param.
	 *
	 * Returns list of found rule names (if no exception happened).
	 *
	 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
	 **/
	Ruler.prototype.enable = function (list, ignoreInvalid) {
	  if (!Array.isArray(list)) { list = [ list ]; }
	
	  var result = [];
	
	  // Search by name and enable
	  list.forEach(function (name) {
	    var idx = this.__find__(name);
	
	    if (idx < 0) {
	      if (ignoreInvalid) { return; }
	      throw new Error('Rules manager: invalid rule name ' + name);
	    }
	    this.__rules__[idx].enabled = true;
	    result.push(name);
	  }, this);
	
	  this.__cache__ = null;
	  return result;
	};
	
	
	/**
	 * Ruler.enableOnly(list [, ignoreInvalid])
	 * - list (String|Array): list of rule names to enable (whitelist).
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * Enable rules with given names, and disable everything else. If any rule name
	 * not found - throw Error. Errors can be disabled by second param.
	 *
	 * See also [[Ruler.disable]], [[Ruler.enable]].
	 **/
	Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
	  if (!Array.isArray(list)) { list = [ list ]; }
	
	  this.__rules__.forEach(function (rule) { rule.enabled = false; });
	
	  this.enable(list, ignoreInvalid);
	};
	
	
	/**
	 * Ruler.disable(list [, ignoreInvalid]) -> Array
	 * - list (String|Array): list of rule names to disable.
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * Disable rules with given names. If any rule name not found - throw Error.
	 * Errors can be disabled by second param.
	 *
	 * Returns list of found rule names (if no exception happened).
	 *
	 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
	 **/
	Ruler.prototype.disable = function (list, ignoreInvalid) {
	  if (!Array.isArray(list)) { list = [ list ]; }
	
	  var result = [];
	
	  // Search by name and disable
	  list.forEach(function (name) {
	    var idx = this.__find__(name);
	
	    if (idx < 0) {
	      if (ignoreInvalid) { return; }
	      throw new Error('Rules manager: invalid rule name ' + name);
	    }
	    this.__rules__[idx].enabled = false;
	    result.push(name);
	  }, this);
	
	  this.__cache__ = null;
	  return result;
	};
	
	
	/**
	 * Ruler.getRules(chainName) -> Array
	 *
	 * Return array of active functions (rules) for given chain name. It analyzes
	 * rules configuration, compiles caches if not exists and returns result.
	 *
	 * Default chain name is `''` (empty string). It can't be skipped. That's
	 * done intentionally, to keep signature monomorphic for high speed.
	 **/
	Ruler.prototype.getRules = function (chainName) {
	  if (this.__cache__ === null) {
	    this.__compile__();
	  }
	
	  // Chain can be empty, if rules disabled. But we still have to return Array.
	  return this.__cache__[chainName] || [];
	};
	
	module.exports = Ruler;
	
	},{}],18:[function(require,module,exports){
	// Block quotes
	
	'use strict';
	
	var isSpace = require('../common/utils').isSpace;
	
	
	module.exports = function blockquote(state, startLine, endLine, silent) {
	  var adjustTab,
	      ch,
	      i,
	      initial,
	      l,
	      lastLineEmpty,
	      lines,
	      nextLine,
	      offset,
	      oldBMarks,
	      oldBSCount,
	      oldIndent,
	      oldParentType,
	      oldSCount,
	      oldTShift,
	      spaceAfterMarker,
	      terminate,
	      terminatorRules,
	      token,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine];
	
	  // check the block quote marker
	  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }
	
	  // we know that it's going to be a valid blockquote,
	  // so no point trying to find the end of it in silent mode
	  if (silent) { return true; }
	
	  oldIndent = state.blkIndent;
	  state.blkIndent = 0;
	
	  // skip spaces after ">" and re-calculate offset
	  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);
	
	  // skip one optional space after '>'
	  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
	    // ' >   test '
	    //     ^ -- position start of line here:
	    pos++;
	    initial++;
	    offset++;
	    adjustTab = false;
	    spaceAfterMarker = true;
	  } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
	    spaceAfterMarker = true;
	
	    if ((state.bsCount[startLine] + offset) % 4 === 3) {
	      // '  >\t  test '
	      //       ^ -- position start of line here (tab has width===1)
	      pos++;
	      initial++;
	      offset++;
	      adjustTab = false;
	    } else {
	      // ' >\t  test '
	      //    ^ -- position start of line here + shift bsCount slightly
	      //         to make extra space appear
	      adjustTab = true;
	    }
	  } else {
	    spaceAfterMarker = false;
	  }
	
	  oldBMarks = [ state.bMarks[startLine] ];
	  state.bMarks[startLine] = pos;
	
	  while (pos < max) {
	    ch = state.src.charCodeAt(pos);
	
	    if (isSpace(ch)) {
	      if (ch === 0x09) {
	        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
	      } else {
	        offset++;
	      }
	    } else {
	      break;
	    }
	
	    pos++;
	  }
	
	  oldBSCount = [ state.bsCount[startLine] ];
	  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
	
	  lastLineEmpty = pos >= max;
	
	  oldSCount = [ state.sCount[startLine] ];
	  state.sCount[startLine] = offset - initial;
	
	  oldTShift = [ state.tShift[startLine] ];
	  state.tShift[startLine] = pos - state.bMarks[startLine];
	
	  terminatorRules = state.md.block.ruler.getRules('blockquote');
	
	  oldParentType = state.parentType;
	  state.parentType = 'blockquote';
	
	  // Search the end of the block
	  //
	  // Block ends with either:
	  //  1. an empty line outside:
	  //     ```
	  //     > test
	  //
	  //     ```
	  //  2. an empty line inside:
	  //     ```
	  //     >
	  //     test
	  //     ```
	  //  3. another tag
	  //     ```
	  //     > test
	  //      - - -
	  //     ```
	  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
	    if (state.sCount[nextLine] < oldIndent) { break; }
	
	    pos = state.bMarks[nextLine] + state.tShift[nextLine];
	    max = state.eMarks[nextLine];
	
	    if (pos >= max) {
	      // Case 1: line is not inside the blockquote, and this line is empty.
	      break;
	    }
	
	    if (state.src.charCodeAt(pos++) === 0x3E/* > */) {
	      // This line is inside the blockquote.
	
	      // skip spaces after ">" and re-calculate offset
	      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);
	
	      // skip one optional space after '>'
	      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
	        // ' >   test '
	        //     ^ -- position start of line here:
	        pos++;
	        initial++;
	        offset++;
	        adjustTab = false;
	        spaceAfterMarker = true;
	      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
	        spaceAfterMarker = true;
	
	        if ((state.bsCount[nextLine] + offset) % 4 === 3) {
	          // '  >\t  test '
	          //       ^ -- position start of line here (tab has width===1)
	          pos++;
	          initial++;
	          offset++;
	          adjustTab = false;
	        } else {
	          // ' >\t  test '
	          //    ^ -- position start of line here + shift bsCount slightly
	          //         to make extra space appear
	          adjustTab = true;
	        }
	      } else {
	        spaceAfterMarker = false;
	      }
	
	      oldBMarks.push(state.bMarks[nextLine]);
	      state.bMarks[nextLine] = pos;
	
	      while (pos < max) {
	        ch = state.src.charCodeAt(pos);
	
	        if (isSpace(ch)) {
	          if (ch === 0x09) {
	            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
	          } else {
	            offset++;
	          }
	        } else {
	          break;
	        }
	
	        pos++;
	      }
	
	      lastLineEmpty = pos >= max;
	
	      oldBSCount.push(state.bsCount[nextLine]);
	      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
	
	      oldSCount.push(state.sCount[nextLine]);
	      state.sCount[nextLine] = offset - initial;
	
	      oldTShift.push(state.tShift[nextLine]);
	      state.tShift[nextLine] = pos - state.bMarks[nextLine];
	      continue;
	    }
	
	    // Case 2: line is not inside the blockquote, and the last line was empty.
	    if (lastLineEmpty) { break; }
	
	    // Case 3: another tag found.
	    terminate = false;
	    for (i = 0, l = terminatorRules.length; i < l; i++) {
	      if (terminatorRules[i](state, nextLine, endLine, true)) {
	        terminate = true;
	        break;
	      }
	    }
	    if (terminate) { break; }
	
	    oldBMarks.push(state.bMarks[nextLine]);
	    oldBSCount.push(state.bsCount[nextLine]);
	    oldTShift.push(state.tShift[nextLine]);
	    oldSCount.push(state.sCount[nextLine]);
	
	    // A negative indentation means that this is a paragraph continuation
	    //
	    state.sCount[nextLine] = -1;
	  }
	
	  token        = state.push('blockquote_open', 'blockquote', 1);
	  token.markup = '>';
	  token.map    = lines = [ startLine, 0 ];
	
	  state.md.block.tokenize(state, startLine, nextLine);
	
	  token        = state.push('blockquote_close', 'blockquote', -1);
	  token.markup = '>';
	
	  state.parentType = oldParentType;
	  lines[1] = state.line;
	
	  // Restore original tShift; this might not be necessary since the parser
	  // has already been here, but just to make sure we can do that.
	  for (i = 0; i < oldTShift.length; i++) {
	    state.bMarks[i + startLine] = oldBMarks[i];
	    state.tShift[i + startLine] = oldTShift[i];
	    state.sCount[i + startLine] = oldSCount[i];
	    state.bsCount[i + startLine] = oldBSCount[i];
	  }
	  state.blkIndent = oldIndent;
	
	  return true;
	};
	
	},{"../common/utils":4}],19:[function(require,module,exports){
	// Code block (4 spaces padded)
	
	'use strict';
	
	
	module.exports = function code(state, startLine, endLine/*, silent*/) {
	  var nextLine, last, token;
	
	  if (state.sCount[startLine] - state.blkIndent < 4) { return false; }
	
	  last = nextLine = startLine + 1;
	
	  while (nextLine < endLine) {
	    if (state.isEmpty(nextLine)) {
	      nextLine++;
	      continue;
	    }
	
	    if (state.sCount[nextLine] - state.blkIndent >= 4) {
	      nextLine++;
	      last = nextLine;
	      continue;
	    }
	    break;
	  }
	
	  state.line = last;
	
	  token         = state.push('code_block', 'code', 0);
	  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
	  token.map     = [ startLine, state.line ];
	
	  return true;
	};
	
	},{}],20:[function(require,module,exports){
	// fences (``` lang, ~~~ lang)
	
	'use strict';
	
	
	module.exports = function fence(state, startLine, endLine, silent) {
	  var marker, len, params, nextLine, mem, token, markup,
	      haveEndMarker = false,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine];
	
	  if (pos + 3 > max) { return false; }
	
	  marker = state.src.charCodeAt(pos);
	
	  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {
	    return false;
	  }
	
	  // scan marker length
	  mem = pos;
	  pos = state.skipChars(pos, marker);
	
	  len = pos - mem;
	
	  if (len < 3) { return false; }
	
	  markup = state.src.slice(mem, pos);
	  params = state.src.slice(pos, max);
	
	  if (params.indexOf('`') >= 0) { return false; }
	
	  // Since start is found, we can report success here in validation mode
	  if (silent) { return true; }
	
	  // search end of block
	  nextLine = startLine;
	
	  for (;;) {
	    nextLine++;
	    if (nextLine >= endLine) {
	      // unclosed block should be autoclosed by end of document.
	      // also block seems to be autoclosed by end of parent
	      break;
	    }
	
	    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
	    max = state.eMarks[nextLine];
	
	    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
	      // non-empty line with negative indent should stop the list:
	      // - ```
	      //  test
	      break;
	    }
	
	    if (state.src.charCodeAt(pos) !== marker) { continue; }
	
	    if (state.sCount[nextLine] - state.blkIndent >= 4) {
	      // closing fence should be indented less than 4 spaces
	      continue;
	    }
	
	    pos = state.skipChars(pos, marker);
	
	    // closing code fence must be at least as long as the opening one
	    if (pos - mem < len) { continue; }
	
	    // make sure tail has spaces only
	    pos = state.skipSpaces(pos);
	
	    if (pos < max) { continue; }
	
	    haveEndMarker = true;
	    // found!
	    break;
	  }
	
	  // If a fence has heading spaces, they should be removed from its inner block
	  len = state.sCount[startLine];
	
	  state.line = nextLine + (haveEndMarker ? 1 : 0);
	
	  token         = state.push('fence', 'code', 0);
	  token.info    = params;
	  token.content = state.getLines(startLine + 1, nextLine, len, true);
	  token.markup  = markup;
	  token.map     = [ startLine, state.line ];
	
	  return true;
	};
	
	},{}],21:[function(require,module,exports){
	// heading (#, ##, ...)
	
	'use strict';
	
	var isSpace = require('../common/utils').isSpace;
	
	
	module.exports = function heading(state, startLine, endLine, silent) {
	  var ch, level, tmp, token,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine];
	
	  ch  = state.src.charCodeAt(pos);
	
	  if (ch !== 0x23/* # */ || pos >= max) { return false; }
	
	  // count heading level
	  level = 1;
	  ch = state.src.charCodeAt(++pos);
	  while (ch === 0x23/* # */ && pos < max && level <= 6) {
	    level++;
	    ch = state.src.charCodeAt(++pos);
	  }
	
	  if (level > 6 || (pos < max && !isSpace(ch))) { return false; }
	
	  if (silent) { return true; }
	
	  // Let's cut tails like '    ###  ' from the end of string
	
	  max = state.skipSpacesBack(max, pos);
	  tmp = state.skipCharsBack(max, 0x23, pos); // #
	  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
	    max = tmp;
	  }
	
	  state.line = startLine + 1;
	
	  token        = state.push('heading_open', 'h' + String(level), 1);
	  token.markup = '########'.slice(0, level);
	  token.map    = [ startLine, state.line ];
	
	  token          = state.push('inline', '', 0);
	  token.content  = state.src.slice(pos, max).trim();
	  token.map      = [ startLine, state.line ];
	  token.children = [];
	
	  token        = state.push('heading_close', 'h' + String(level), -1);
	  token.markup = '########'.slice(0, level);
	
	  return true;
	};
	
	},{"../common/utils":4}],22:[function(require,module,exports){
	// Horizontal rule
	
	'use strict';
	
	var isSpace = require('../common/utils').isSpace;
	
	
	module.exports = function hr(state, startLine, endLine, silent) {
	  var marker, cnt, ch, token,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine];
	
	  marker = state.src.charCodeAt(pos++);
	
	  // Check hr marker
	  if (marker !== 0x2A/* * */ &&
	      marker !== 0x2D/* - */ &&
	      marker !== 0x5F/* _ */) {
	    return false;
	  }
	
	  // markers can be mixed with spaces, but there should be at least 3 of them
	
	  cnt = 1;
	  while (pos < max) {
	    ch = state.src.charCodeAt(pos++);
	    if (ch !== marker && !isSpace(ch)) { return false; }
	    if (ch === marker) { cnt++; }
	  }
	
	  if (cnt < 3) { return false; }
	
	  if (silent) { return true; }
	
	  state.line = startLine + 1;
	
	  token        = state.push('hr', 'hr', 0);
	  token.map    = [ startLine, state.line ];
	  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
	
	  return true;
	};
	
	},{"../common/utils":4}],23:[function(require,module,exports){
	// HTML block
	
	'use strict';
	
	
	var block_names = require('../common/html_blocks');
	var HTML_OPEN_CLOSE_TAG_RE = require('../common/html_re').HTML_OPEN_CLOSE_TAG_RE;
	
	// An array of opening and corresponding closing sequences for html tags,
	// last argument defines whether it can terminate a paragraph or not
	//
	var HTML_SEQUENCES = [
	  [ /^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true ],
	  [ /^<!--/,        /-->/,   true ],
	  [ /^<\?/,         /\?>/,   true ],
	  [ /^<![A-Z]/,     />/,     true ],
	  [ /^<!\[CDATA\[/, /\]\]>/, true ],
	  [ new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true ],
	  [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'),  /^$/, false ]
	];
	
	
	module.exports = function html_block(state, startLine, endLine, silent) {
	  var i, nextLine, token, lineText,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine];
	
	  if (!state.md.options.html) { return false; }
	
	  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }
	
	  lineText = state.src.slice(pos, max);
	
	  for (i = 0; i < HTML_SEQUENCES.length; i++) {
	    if (HTML_SEQUENCES[i][0].test(lineText)) { break; }
	  }
	
	  if (i === HTML_SEQUENCES.length) { return false; }
	
	  if (silent) {
	    // true if this sequence can be a terminator, false otherwise
	    return HTML_SEQUENCES[i][2];
	  }
	
	  nextLine = startLine + 1;
	
	  // If we are here - we detected HTML block.
	  // Let's roll down till block end.
	  if (!HTML_SEQUENCES[i][1].test(lineText)) {
	    for (; nextLine < endLine; nextLine++) {
	      if (state.sCount[nextLine] < state.blkIndent) { break; }
	
	      pos = state.bMarks[nextLine] + state.tShift[nextLine];
	      max = state.eMarks[nextLine];
	      lineText = state.src.slice(pos, max);
	
	      if (HTML_SEQUENCES[i][1].test(lineText)) {
	        if (lineText.length !== 0) { nextLine++; }
	        break;
	      }
	    }
	  }
	
	  state.line = nextLine;
	
	  token         = state.push('html_block', '', 0);
	  token.map     = [ startLine, nextLine ];
	  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
	
	  return true;
	};
	
	},{"../common/html_blocks":2,"../common/html_re":3}],24:[function(require,module,exports){
	// lheading (---, ===)
	
	'use strict';
	
	
	module.exports = function lheading(state, startLine, endLine/*, silent*/) {
	  var content, terminate, i, l, token, pos, max, level, marker,
	      nextLine = startLine + 1, oldParentType,
	      terminatorRules = state.md.block.ruler.getRules('paragraph');
	
	  oldParentType = state.parentType;
	  state.parentType = 'paragraph'; // use paragraph to match terminatorRules
	
	  // jump line-by-line until empty one or EOF
	  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
	    // this would be a code block normally, but after paragraph
	    // it's considered a lazy continuation regardless of what's there
	    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }
	
	    //
	    // Check for underline in setext header
	    //
	    if (state.sCount[nextLine] >= state.blkIndent) {
	      pos = state.bMarks[nextLine] + state.tShift[nextLine];
	      max = state.eMarks[nextLine];
	
	      if (pos < max) {
	        marker = state.src.charCodeAt(pos);
	
	        if (marker === 0x2D/* - */ || marker === 0x3D/* = */) {
	          pos = state.skipChars(pos, marker);
	          pos = state.skipSpaces(pos);
	
	          if (pos >= max) {
	            level = (marker === 0x3D/* = */ ? 1 : 2);
	            break;
	          }
	        }
	      }
	    }
	
	    // quirk for blockquotes, this line should already be checked by that rule
	    if (state.sCount[nextLine] < 0) { continue; }
	
	    // Some tags can terminate paragraph without empty line.
	    terminate = false;
	    for (i = 0, l = terminatorRules.length; i < l; i++) {
	      if (terminatorRules[i](state, nextLine, endLine, true)) {
	        terminate = true;
	        break;
	      }
	    }
	    if (terminate) { break; }
	  }
	
	  if (!level) {
	    // Didn't find valid underline
	    return false;
	  }
	
	  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
	
	  state.line = nextLine + 1;
	
	  token          = state.push('heading_open', 'h' + String(level), 1);
	  token.markup   = String.fromCharCode(marker);
	  token.map      = [ startLine, state.line ];
	
	  token          = state.push('inline', '', 0);
	  token.content  = content;
	  token.map      = [ startLine, state.line - 1 ];
	  token.children = [];
	
	  token          = state.push('heading_close', 'h' + String(level), -1);
	  token.markup   = String.fromCharCode(marker);
	
	  state.parentType = oldParentType;
	
	  return true;
	};
	
	},{}],25:[function(require,module,exports){
	// Lists
	
	'use strict';
	
	var isSpace = require('../common/utils').isSpace;
	
	
	// Search `[-+*][\n ]`, returns next pos arter marker on success
	// or -1 on fail.
	function skipBulletListMarker(state, startLine) {
	  var marker, pos, max, ch;
	
	  pos = state.bMarks[startLine] + state.tShift[startLine];
	  max = state.eMarks[startLine];
	
	  marker = state.src.charCodeAt(pos++);
	  // Check bullet
	  if (marker !== 0x2A/* * */ &&
	      marker !== 0x2D/* - */ &&
	      marker !== 0x2B/* + */) {
	    return -1;
	  }
	
	  if (pos < max) {
	    ch = state.src.charCodeAt(pos);
	
	    if (!isSpace(ch)) {
	      // " -test " - is not a list item
	      return -1;
	    }
	  }
	
	  return pos;
	}
	
	// Search `\d+[.)][\n ]`, returns next pos arter marker on success
	// or -1 on fail.
	function skipOrderedListMarker(state, startLine) {
	  var ch,
	      start = state.bMarks[startLine] + state.tShift[startLine],
	      pos = start,
	      max = state.eMarks[startLine];
	
	  // List marker should have at least 2 chars (digit + dot)
	  if (pos + 1 >= max) { return -1; }
	
	  ch = state.src.charCodeAt(pos++);
	
	  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }
	
	  for (;;) {
	    // EOL -> fail
	    if (pos >= max) { return -1; }
	
	    ch = state.src.charCodeAt(pos++);
	
	    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {
	
	      // List marker should have no more than 9 digits
	      // (prevents integer overflow in browsers)
	      if (pos - start >= 10) { return -1; }
	
	      continue;
	    }
	
	    // found valid marker
	    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {
	      break;
	    }
	
	    return -1;
	  }
	
	
	  if (pos < max) {
	    ch = state.src.charCodeAt(pos);
	
	    if (!isSpace(ch)) {
	      // " 1.test " - is not a list item
	      return -1;
	    }
	  }
	  return pos;
	}
	
	function markTightParagraphs(state, idx) {
	  var i, l,
	      level = state.level + 2;
	
	  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
	    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
	      state.tokens[i + 2].hidden = true;
	      state.tokens[i].hidden = true;
	      i += 2;
	    }
	  }
	}
	
	
	module.exports = function list(state, startLine, endLine, silent) {
	  var ch,
	      contentStart,
	      i,
	      indent,
	      indentAfterMarker,
	      initial,
	      isOrdered,
	      itemLines,
	      l,
	      listLines,
	      listTokIdx,
	      markerCharCode,
	      markerValue,
	      max,
	      nextLine,
	      offset,
	      oldIndent,
	      oldLIndent,
	      oldParentType,
	      oldTShift,
	      oldTight,
	      pos,
	      posAfterMarker,
	      prevEmptyEnd,
	      start,
	      terminate,
	      terminatorRules,
	      token,
	      isTerminatingParagraph = false,
	      tight = true;
	
	  // limit conditions when list can interrupt
	  // a paragraph (validation mode only)
	  if (silent && state.parentType === 'paragraph') {
	    // Next list item should still terminate previous list item;
	    //
	    // This code can fail if plugins use blkIndent as well as lists,
	    // but I hope the spec gets fixed long before that happens.
	    //
	    if (state.tShift[startLine] >= state.blkIndent) {
	      isTerminatingParagraph = true;
	    }
	  }
	
	  // Detect list type and position after marker
	  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
	    isOrdered = true;
	    start = state.bMarks[startLine] + state.tShift[startLine];
	    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));
	
	    // If we're starting a new ordered list right after
	    // a paragraph, it should start with 1.
	    if (isTerminatingParagraph && markerValue !== 1) return false;
	
	  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
	    isOrdered = false;
	
	  } else {
	    return false;
	  }
	
	  // If we're starting a new unordered list right after
	  // a paragraph, first line should not be empty.
	  if (isTerminatingParagraph) {
	    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
	  }
	
	  // We should terminate list on style change. Remember first one to compare.
	  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
	
	  // For validation mode we can terminate immediately
	  if (silent) { return true; }
	
	  // Start list
	  listTokIdx = state.tokens.length;
	
	  if (isOrdered) {
	    token       = state.push('ordered_list_open', 'ol', 1);
	    if (markerValue !== 1) {
	      token.attrs = [ [ 'start', markerValue ] ];
	    }
	
	  } else {
	    token       = state.push('bullet_list_open', 'ul', 1);
	  }
	
	  token.map    = listLines = [ startLine, 0 ];
	  token.markup = String.fromCharCode(markerCharCode);
	
	  //
	  // Iterate list items
	  //
	
	  nextLine = startLine;
	  prevEmptyEnd = false;
	  terminatorRules = state.md.block.ruler.getRules('list');
	
	  oldParentType = state.parentType;
	  state.parentType = 'list';
	
	  while (nextLine < endLine) {
	    pos = posAfterMarker;
	    max = state.eMarks[nextLine];
	
	    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
	
	    while (pos < max) {
	      ch = state.src.charCodeAt(pos);
	
	      if (isSpace(ch)) {
	        if (ch === 0x09) {
	          offset += 4 - (offset + state.bsCount[nextLine]) % 4;
	        } else {
	          offset++;
	        }
	      } else {
	        break;
	      }
	
	      pos++;
	    }
	
	    contentStart = pos;
	
	    if (contentStart >= max) {
	      // trimming space in "-    \n  3" case, indent is 1 here
	      indentAfterMarker = 1;
	    } else {
	      indentAfterMarker = offset - initial;
	    }
	
	    // If we have more than 4 spaces, the indent is 1
	    // (the rest is just indented code block)
	    if (indentAfterMarker > 4) { indentAfterMarker = 1; }
	
	    // "  -  test"
	    //  ^^^^^ - calculating total length of this thing
	    indent = initial + indentAfterMarker;
	
	    // Run subparser & write tokens
	    token        = state.push('list_item_open', 'li', 1);
	    token.markup = String.fromCharCode(markerCharCode);
	    token.map    = itemLines = [ startLine, 0 ];
	
	    oldIndent = state.blkIndent;
	    oldTight = state.tight;
	    oldTShift = state.tShift[startLine];
	    oldLIndent = state.sCount[startLine];
	    state.blkIndent = indent;
	    state.tight = true;
	    state.tShift[startLine] = contentStart - state.bMarks[startLine];
	    state.sCount[startLine] = offset;
	
	    if (contentStart >= max && state.isEmpty(startLine + 1)) {
	      // workaround for this case
	      // (list item is empty, list terminates before "foo"):
	      // ~~~~~~~~
	      //   -
	      //
	      //     foo
	      // ~~~~~~~~
	      state.line = Math.min(state.line + 2, endLine);
	    } else {
	      state.md.block.tokenize(state, startLine, endLine, true);
	    }
	
	    // If any of list item is tight, mark list as tight
	    if (!state.tight || prevEmptyEnd) {
	      tight = false;
	    }
	    // Item become loose if finish with empty line,
	    // but we should filter last element, because it means list finish
	    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);
	
	    state.blkIndent = oldIndent;
	    state.tShift[startLine] = oldTShift;
	    state.sCount[startLine] = oldLIndent;
	    state.tight = oldTight;
	
	    token        = state.push('list_item_close', 'li', -1);
	    token.markup = String.fromCharCode(markerCharCode);
	
	    nextLine = startLine = state.line;
	    itemLines[1] = nextLine;
	    contentStart = state.bMarks[startLine];
	
	    if (nextLine >= endLine) { break; }
	
	    //
	    // Try to check if list is terminated or continued.
	    //
	    if (state.sCount[nextLine] < state.blkIndent) { break; }
	
	    // fail if terminating block found
	    terminate = false;
	    for (i = 0, l = terminatorRules.length; i < l; i++) {
	      if (terminatorRules[i](state, nextLine, endLine, true)) {
	        terminate = true;
	        break;
	      }
	    }
	    if (terminate) { break; }
	
	    // fail if list has another type
	    if (isOrdered) {
	      posAfterMarker = skipOrderedListMarker(state, nextLine);
	      if (posAfterMarker < 0) { break; }
	    } else {
	      posAfterMarker = skipBulletListMarker(state, nextLine);
	      if (posAfterMarker < 0) { break; }
	    }
	
	    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }
	  }
	
	  // Finilize list
	  if (isOrdered) {
	    token = state.push('ordered_list_close', 'ol', -1);
	  } else {
	    token = state.push('bullet_list_close', 'ul', -1);
	  }
	  token.markup = String.fromCharCode(markerCharCode);
	
	  listLines[1] = nextLine;
	  state.line = nextLine;
	
	  state.parentType = oldParentType;
	
	  // mark paragraphs tight if needed
	  if (tight) {
	    markTightParagraphs(state, listTokIdx);
	  }
	
	  return true;
	};
	
	},{"../common/utils":4}],26:[function(require,module,exports){
	// Paragraph
	
	'use strict';
	
	
	module.exports = function paragraph(state, startLine/*, endLine*/) {
	  var content, terminate, i, l, token, oldParentType,
	      nextLine = startLine + 1,
	      terminatorRules = state.md.block.ruler.getRules('paragraph'),
	      endLine = state.lineMax;
	
	  oldParentType = state.parentType;
	  state.parentType = 'paragraph';
	
	  // jump line-by-line until empty one or EOF
	  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
	    // this would be a code block normally, but after paragraph
	    // it's considered a lazy continuation regardless of what's there
	    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }
	
	    // quirk for blockquotes, this line should already be checked by that rule
	    if (state.sCount[nextLine] < 0) { continue; }
	
	    // Some tags can terminate paragraph without empty line.
	    terminate = false;
	    for (i = 0, l = terminatorRules.length; i < l; i++) {
	      if (terminatorRules[i](state, nextLine, endLine, true)) {
	        terminate = true;
	        break;
	      }
	    }
	    if (terminate) { break; }
	  }
	
	  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
	
	  state.line = nextLine;
	
	  token          = state.push('paragraph_open', 'p', 1);
	  token.map      = [ startLine, state.line ];
	
	  token          = state.push('inline', '', 0);
	  token.content  = content;
	  token.map      = [ startLine, state.line ];
	  token.children = [];
	
	  token          = state.push('paragraph_close', 'p', -1);
	
	  state.parentType = oldParentType;
	
	  return true;
	};
	
	},{}],27:[function(require,module,exports){
	'use strict';
	
	
	var parseLinkDestination = require('../helpers/parse_link_destination');
	var parseLinkTitle       = require('../helpers/parse_link_title');
	var normalizeReference   = require('../common/utils').normalizeReference;
	var isSpace              = require('../common/utils').isSpace;
	
	
	module.exports = function reference(state, startLine, _endLine, silent) {
	  var ch,
	      destEndPos,
	      destEndLineNo,
	      endLine,
	      href,
	      i,
	      l,
	      label,
	      labelEnd,
	      oldParentType,
	      res,
	      start,
	      str,
	      terminate,
	      terminatorRules,
	      title,
	      lines = 0,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine],
	      nextLine = startLine + 1;
	
	  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }
	
	  // Simple check to quickly interrupt scan on [link](url) at the start of line.
	  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
	  while (++pos < max) {
	    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&
	        state.src.charCodeAt(pos - 1) !== 0x5C/* \ */) {
	      if (pos + 1 === max) { return false; }
	      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }
	      break;
	    }
	  }
	
	  endLine = state.lineMax;
	
	  // jump line-by-line until empty one or EOF
	  terminatorRules = state.md.block.ruler.getRules('reference');
	
	  oldParentType = state.parentType;
	  state.parentType = 'reference';
	
	  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
	    // this would be a code block normally, but after paragraph
	    // it's considered a lazy continuation regardless of what's there
	    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }
	
	    // quirk for blockquotes, this line should already be checked by that rule
	    if (state.sCount[nextLine] < 0) { continue; }
	
	    // Some tags can terminate paragraph without empty line.
	    terminate = false;
	    for (i = 0, l = terminatorRules.length; i < l; i++) {
	      if (terminatorRules[i](state, nextLine, endLine, true)) {
	        terminate = true;
	        break;
	      }
	    }
	    if (terminate) { break; }
	  }
	
	  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
	  max = str.length;
	
	  for (pos = 1; pos < max; pos++) {
	    ch = str.charCodeAt(pos);
	    if (ch === 0x5B /* [ */) {
	      return false;
	    } else if (ch === 0x5D /* ] */) {
	      labelEnd = pos;
	      break;
	    } else if (ch === 0x0A /* \n */) {
	      lines++;
	    } else if (ch === 0x5C /* \ */) {
	      pos++;
	      if (pos < max && str.charCodeAt(pos) === 0x0A) {
	        lines++;
	      }
	    }
	  }
	
	  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }
	
	  // [label]:   destination   'title'
	  //         ^^^ skip optional whitespace here
	  for (pos = labelEnd + 2; pos < max; pos++) {
	    ch = str.charCodeAt(pos);
	    if (ch === 0x0A) {
	      lines++;
	    } else if (isSpace(ch)) {
	      /*eslint no-empty:0*/
	    } else {
	      break;
	    }
	  }
	
	  // [label]:   destination   'title'
	  //            ^^^^^^^^^^^ parse this
	  res = parseLinkDestination(str, pos, max);
	  if (!res.ok) { return false; }
	
	  href = state.md.normalizeLink(res.str);
	  if (!state.md.validateLink(href)) { return false; }
	
	  pos = res.pos;
	  lines += res.lines;
	
	  // save cursor state, we could require to rollback later
	  destEndPos = pos;
	  destEndLineNo = lines;
	
	  // [label]:   destination   'title'
	  //                       ^^^ skipping those spaces
	  start = pos;
	  for (; pos < max; pos++) {
	    ch = str.charCodeAt(pos);
	    if (ch === 0x0A) {
	      lines++;
	    } else if (isSpace(ch)) {
	      /*eslint no-empty:0*/
	    } else {
	      break;
	    }
	  }
	
	  // [label]:   destination   'title'
	  //                          ^^^^^^^ parse this
	  res = parseLinkTitle(str, pos, max);
	  if (pos < max && start !== pos && res.ok) {
	    title = res.str;
	    pos = res.pos;
	    lines += res.lines;
	  } else {
	    title = '';
	    pos = destEndPos;
	    lines = destEndLineNo;
	  }
	
	  // skip trailing spaces until the rest of the line
	  while (pos < max) {
	    ch = str.charCodeAt(pos);
	    if (!isSpace(ch)) { break; }
	    pos++;
	  }
	
	  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
	    if (title) {
	      // garbage at the end of the line after title,
	      // but it could still be a valid reference if we roll back
	      title = '';
	      pos = destEndPos;
	      lines = destEndLineNo;
	      while (pos < max) {
	        ch = str.charCodeAt(pos);
	        if (!isSpace(ch)) { break; }
	        pos++;
	      }
	    }
	  }
	
	  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
	    // garbage at the end of the line
	    return false;
	  }
	
	  label = normalizeReference(str.slice(1, labelEnd));
	  if (!label) {
	    // CommonMark 0.20 disallows empty labels
	    return false;
	  }
	
	  // Reference can not terminate anything. This check is for safety only.
	  /*istanbul ignore if*/
	  if (silent) { return true; }
	
	  if (typeof state.env.references === 'undefined') {
	    state.env.references = {};
	  }
	  if (typeof state.env.references[label] === 'undefined') {
	    state.env.references[label] = { title: title, href: href };
	  }
	
	  state.parentType = oldParentType;
	
	  state.line = startLine + lines + 1;
	  return true;
	};
	
	},{"../common/utils":4,"../helpers/parse_link_destination":6,"../helpers/parse_link_title":8}],28:[function(require,module,exports){
	// Parser state class
	
	'use strict';
	
	var Token = require('../token');
	var isSpace = require('../common/utils').isSpace;
	
	
	function StateBlock(src, md, env, tokens) {
	  var ch, s, start, pos, len, indent, offset, indent_found;
	
	  this.src = src;
	
	  // link to parser instance
	  this.md     = md;
	
	  this.env = env;
	
	  //
	  // Internal state vartiables
	  //
	
	  this.tokens = tokens;
	
	  this.bMarks = [];  // line begin offsets for fast jumps
	  this.eMarks = [];  // line end offsets for fast jumps
	  this.tShift = [];  // offsets of the first non-space characters (tabs not expanded)
	  this.sCount = [];  // indents for each line (tabs expanded)
	
	  // An amount of virtual spaces (tabs expanded) between beginning
	  // of each line (bMarks) and real beginning of that line.
	  //
	  // It exists only as a hack because blockquotes override bMarks
	  // losing information in the process.
	  //
	  // It's used only when expanding tabs, you can think about it as
	  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
	  // means first tab should be expanded to 4-21%4 === 3 spaces.
	  //
	  this.bsCount = [];
	
	  // block parser variables
	  this.blkIndent  = 0; // required block content indent
	                       // (for example, if we are in list)
	  this.line       = 0; // line index in src
	  this.lineMax    = 0; // lines count
	  this.tight      = false;  // loose/tight mode for lists
	  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)
	
	  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
	  // used in lists to determine if they interrupt a paragraph
	  this.parentType = 'root';
	
	  this.level = 0;
	
	  // renderer
	  this.result = '';
	
	  // Create caches
	  // Generate markers.
	  s = this.src;
	  indent_found = false;
	
	  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
	    ch = s.charCodeAt(pos);
	
	    if (!indent_found) {
	      if (isSpace(ch)) {
	        indent++;
	
	        if (ch === 0x09) {
	          offset += 4 - offset % 4;
	        } else {
	          offset++;
	        }
	        continue;
	      } else {
	        indent_found = true;
	      }
	    }
	
	    if (ch === 0x0A || pos === len - 1) {
	      if (ch !== 0x0A) { pos++; }
	      this.bMarks.push(start);
	      this.eMarks.push(pos);
	      this.tShift.push(indent);
	      this.sCount.push(offset);
	      this.bsCount.push(0);
	
	      indent_found = false;
	      indent = 0;
	      offset = 0;
	      start = pos + 1;
	    }
	  }
	
	  // Push fake entry to simplify cache bounds checks
	  this.bMarks.push(s.length);
	  this.eMarks.push(s.length);
	  this.tShift.push(0);
	  this.sCount.push(0);
	  this.bsCount.push(0);
	
	  this.lineMax = this.bMarks.length - 1; // don't count last fake line
	}
	
	// Push new token to "stream".
	//
	StateBlock.prototype.push = function (type, tag, nesting) {
	  var token = new Token(type, tag, nesting);
	  token.block = true;
	
	  if (nesting < 0) { this.level--; }
	  token.level = this.level;
	  if (nesting > 0) { this.level++; }
	
	  this.tokens.push(token);
	  return token;
	};
	
	StateBlock.prototype.isEmpty = function isEmpty(line) {
	  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
	};
	
	StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
	  for (var max = this.lineMax; from < max; from++) {
	    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
	      break;
	    }
	  }
	  return from;
	};
	
	// Skip spaces from given position.
	StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
	  var ch;
	
	  for (var max = this.src.length; pos < max; pos++) {
	    ch = this.src.charCodeAt(pos);
	    if (!isSpace(ch)) { break; }
	  }
	  return pos;
	};
	
	// Skip spaces from given position in reverse.
	StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
	  if (pos <= min) { return pos; }
	
	  while (pos > min) {
	    if (!isSpace(this.src.charCodeAt(--pos))) { return pos + 1; }
	  }
	  return pos;
	};
	
	// Skip char codes from given position
	StateBlock.prototype.skipChars = function skipChars(pos, code) {
	  for (var max = this.src.length; pos < max; pos++) {
	    if (this.src.charCodeAt(pos) !== code) { break; }
	  }
	  return pos;
	};
	
	// Skip char codes reverse from given position - 1
	StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
	  if (pos <= min) { return pos; }
	
	  while (pos > min) {
	    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }
	  }
	  return pos;
	};
	
	// cut lines range from source.
	StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
	  var i, lineIndent, ch, first, last, queue, lineStart,
	      line = begin;
	
	  if (begin >= end) {
	    return '';
	  }
	
	  queue = new Array(end - begin);
	
	  for (i = 0; line < end; line++, i++) {
	    lineIndent = 0;
	    lineStart = first = this.bMarks[line];
	
	    if (line + 1 < end || keepLastLF) {
	      // No need for bounds check because we have fake entry on tail.
	      last = this.eMarks[line] + 1;
	    } else {
	      last = this.eMarks[line];
	    }
	
	    while (first < last && lineIndent < indent) {
	      ch = this.src.charCodeAt(first);
	
	      if (isSpace(ch)) {
	        if (ch === 0x09) {
	          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
	        } else {
	          lineIndent++;
	        }
	      } else if (first - lineStart < this.tShift[line]) {
	        // patched tShift masked characters to look like spaces (blockquotes, list markers)
	        lineIndent++;
	      } else {
	        break;
	      }
	
	      first++;
	    }
	
	    if (lineIndent > indent) {
	      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
	      // with indent=2 becomes '  \tfoobar'
	      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
	    } else {
	      queue[i] = this.src.slice(first, last);
	    }
	  }
	
	  return queue.join('');
	};
	
	// re-export Token class to use in block rules
	StateBlock.prototype.Token = Token;
	
	
	module.exports = StateBlock;
	
	},{"../common/utils":4,"../token":51}],29:[function(require,module,exports){
	// GFM table, non-standard
	
	'use strict';
	
	
	function getLine(state, line) {
	  var pos = state.bMarks[line] + state.blkIndent,
	      max = state.eMarks[line];
	
	  return state.src.substr(pos, max - pos);
	}
	
	function escapedSplit(str) {
	  var result = [],
	      pos = 0,
	      max = str.length,
	      ch,
	      escapes = 0,
	      lastPos = 0,
	      backTicked = false,
	      lastBackTick = 0;
	
	  ch  = str.charCodeAt(pos);
	
	  while (pos < max) {
	    if (ch === 0x60/* ` */ && (escapes % 2 === 0)) {
	      backTicked = !backTicked;
	      lastBackTick = pos;
	    } else if (ch === 0x7c/* | */ && (escapes % 2 === 0) && !backTicked) {
	      result.push(str.substring(lastPos, pos));
	      lastPos = pos + 1;
	    } else if (ch === 0x5c/* \ */) {
	      escapes++;
	    } else {
	      escapes = 0;
	    }
	
	    pos++;
	
	    // If there was an un-closed backtick, go back to just after
	    // the last backtick, but as if it was a normal character
	    if (pos === max && backTicked) {
	      backTicked = false;
	      pos = lastBackTick + 1;
	    }
	
	    ch = str.charCodeAt(pos);
	  }
	
	  result.push(str.substring(lastPos));
	
	  return result;
	}
	
	
	module.exports = function table(state, startLine, endLine, silent) {
	  var ch, lineText, pos, i, nextLine, columns, columnCount, token,
	      aligns, t, tableLines, tbodyLines;
	
	  // should have at least three lines
	  if (startLine + 2 > endLine) { return false; }
	
	  nextLine = startLine + 1;
	
	  if (state.sCount[nextLine] < state.blkIndent) { return false; }
	
	  // first character of the second line should be '|' or '-'
	
	  pos = state.bMarks[nextLine] + state.tShift[nextLine];
	  if (pos >= state.eMarks[nextLine]) { return false; }
	
	  ch = state.src.charCodeAt(pos);
	  if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */) { return false; }
	
	  lineText = getLine(state, startLine + 1);
	  if (!/^[-:| ]+$/.test(lineText)) { return false; }
	
	  columns = lineText.split('|');
	  aligns = [];
	  for (i = 0; i < columns.length; i++) {
	    t = columns[i].trim();
	    if (!t) {
	      // allow empty columns before and after table, but not in between columns;
	      // e.g. allow ` |---| `, disallow ` ---||--- `
	      if (i === 0 || i === columns.length - 1) {
	        continue;
	      } else {
	        return false;
	      }
	    }
	
	    if (!/^:?-+:?$/.test(t)) { return false; }
	    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {
	      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');
	    } else if (t.charCodeAt(0) === 0x3A/* : */) {
	      aligns.push('left');
	    } else {
	      aligns.push('');
	    }
	  }
	
	  lineText = getLine(state, startLine).trim();
	  if (lineText.indexOf('|') === -1) { return false; }
	  columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));
	
	  // header row will define an amount of columns in the entire table,
	  // and align row shouldn't be smaller than that (the rest of the rows can)
	  columnCount = columns.length;
	  if (columnCount > aligns.length) { return false; }
	
	  if (silent) { return true; }
	
	  token     = state.push('table_open', 'table', 1);
	  token.map = tableLines = [ startLine, 0 ];
	
	  token     = state.push('thead_open', 'thead', 1);
	  token.map = [ startLine, startLine + 1 ];
	
	  token     = state.push('tr_open', 'tr', 1);
	  token.map = [ startLine, startLine + 1 ];
	
	  for (i = 0; i < columns.length; i++) {
	    token          = state.push('th_open', 'th', 1);
	    token.map      = [ startLine, startLine + 1 ];
	    if (aligns[i]) {
	      token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];
	    }
	
	    token          = state.push('inline', '', 0);
	    token.content  = columns[i].trim();
	    token.map      = [ startLine, startLine + 1 ];
	    token.children = [];
	
	    token          = state.push('th_close', 'th', -1);
	  }
	
	  token     = state.push('tr_close', 'tr', -1);
	  token     = state.push('thead_close', 'thead', -1);
	
	  token     = state.push('tbody_open', 'tbody', 1);
	  token.map = tbodyLines = [ startLine + 2, 0 ];
	
	  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
	    if (state.sCount[nextLine] < state.blkIndent) { break; }
	
	    lineText = getLine(state, nextLine);
	    if (lineText.indexOf('|') === -1) { break; }
	
	    // keep spaces at beginning of line to indicate an empty first cell, but
	    // strip trailing whitespace
	    columns = escapedSplit(lineText.replace(/^\||\|\s*$/g, ''));
	
	    token = state.push('tr_open', 'tr', 1);
	    for (i = 0; i < columnCount; i++) {
	      token          = state.push('td_open', 'td', 1);
	      if (aligns[i]) {
	        token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];
	      }
	
	      token          = state.push('inline', '', 0);
	      token.content  = columns[i] ? columns[i].trim() : '';
	      token.children = [];
	
	      token          = state.push('td_close', 'td', -1);
	    }
	    token = state.push('tr_close', 'tr', -1);
	  }
	  token = state.push('tbody_close', 'tbody', -1);
	  token = state.push('table_close', 'table', -1);
	
	  tableLines[1] = tbodyLines[1] = nextLine;
	  state.line = nextLine;
	  return true;
	};
	
	},{}],30:[function(require,module,exports){
	'use strict';
	
	
	module.exports = function block(state) {
	  var token;
	
	  if (state.inlineMode) {
	    token          = new state.Token('inline', '', 0);
	    token.content  = state.src;
	    token.map      = [ 0, 1 ];
	    token.children = [];
	    state.tokens.push(token);
	  } else {
	    state.md.block.parse(state.src, state.md, state.env, state.tokens);
	  }
	};
	
	},{}],31:[function(require,module,exports){
	'use strict';
	
	module.exports = function inline(state) {
	  var tokens = state.tokens, tok, i, l;
	
	  // Parse inlines
	  for (i = 0, l = tokens.length; i < l; i++) {
	    tok = tokens[i];
	    if (tok.type === 'inline') {
	      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
	    }
	  }
	};
	
	},{}],32:[function(require,module,exports){
	// Replace link-like texts with link nodes.
	//
	// Currently restricted by `md.validateLink()` to http/https/ftp
	//
	'use strict';
	
	
	var arrayReplaceAt = require('../common/utils').arrayReplaceAt;
	
	
	function isLinkOpen(str) {
	  return /^<a[>\s]/i.test(str);
	}
	function isLinkClose(str) {
	  return /^<\/a\s*>/i.test(str);
	}
	
	
	module.exports = function linkify(state) {
	  var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,
	      level, htmlLinkLevel, url, fullUrl, urlText,
	      blockTokens = state.tokens,
	      links;
	
	  if (!state.md.options.linkify) { return; }
	
	  for (j = 0, l = blockTokens.length; j < l; j++) {
	    if (blockTokens[j].type !== 'inline' ||
	        !state.md.linkify.pretest(blockTokens[j].content)) {
	      continue;
	    }
	
	    tokens = blockTokens[j].children;
	
	    htmlLinkLevel = 0;
	
	    // We scan from the end, to keep position when new tags added.
	    // Use reversed logic in links start/end match
	    for (i = tokens.length - 1; i >= 0; i--) {
	      currentToken = tokens[i];
	
	      // Skip content of markdown links
	      if (currentToken.type === 'link_close') {
	        i--;
	        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
	          i--;
	        }
	        continue;
	      }
	
	      // Skip content of html tag links
	      if (currentToken.type === 'html_inline') {
	        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
	          htmlLinkLevel--;
	        }
	        if (isLinkClose(currentToken.content)) {
	          htmlLinkLevel++;
	        }
	      }
	      if (htmlLinkLevel > 0) { continue; }
	
	      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {
	
	        text = currentToken.content;
	        links = state.md.linkify.match(text);
	
	        // Now split string to nodes
	        nodes = [];
	        level = currentToken.level;
	        lastPos = 0;
	
	        for (ln = 0; ln < links.length; ln++) {
	
	          url = links[ln].url;
	          fullUrl = state.md.normalizeLink(url);
	          if (!state.md.validateLink(fullUrl)) { continue; }
	
	          urlText = links[ln].text;
	
	          // Linkifier might send raw hostnames like "example.com", where url
	          // starts with domain name. So we prepend http:// in those cases,
	          // and remove it afterwards.
	          //
	          if (!links[ln].schema) {
	            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
	          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
	            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
	          } else {
	            urlText = state.md.normalizeLinkText(urlText);
	          }
	
	          pos = links[ln].index;
	
	          if (pos > lastPos) {
	            token         = new state.Token('text', '', 0);
	            token.content = text.slice(lastPos, pos);
	            token.level   = level;
	            nodes.push(token);
	          }
	
	          token         = new state.Token('link_open', 'a', 1);
	          token.attrs   = [ [ 'href', fullUrl ] ];
	          token.level   = level++;
	          token.markup  = 'linkify';
	          token.info    = 'auto';
	          nodes.push(token);
	
	          token         = new state.Token('text', '', 0);
	          token.content = urlText;
	          token.level   = level;
	          nodes.push(token);
	
	          token         = new state.Token('link_close', 'a', -1);
	          token.level   = --level;
	          token.markup  = 'linkify';
	          token.info    = 'auto';
	          nodes.push(token);
	
	          lastPos = links[ln].lastIndex;
	        }
	        if (lastPos < text.length) {
	          token         = new state.Token('text', '', 0);
	          token.content = text.slice(lastPos);
	          token.level   = level;
	          nodes.push(token);
	        }
	
	        // replace current node
	        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
	      }
	    }
	  }
	};
	
	},{"../common/utils":4}],33:[function(require,module,exports){
	// Normalize input string
	
	'use strict';
	
	
	var NEWLINES_RE  = /\r[\n\u0085]?|[\u2424\u2028\u0085]/g;
	var NULL_RE      = /\u0000/g;
	
	
	module.exports = function inline(state) {
	  var str;
	
	  // Normalize newlines
	  str = state.src.replace(NEWLINES_RE, '\n');
	
	  // Replace NULL characters
	  str = str.replace(NULL_RE, '\uFFFD');
	
	  state.src = str;
	};
	
	},{}],34:[function(require,module,exports){
	// Simple typographyc replacements
	//
	// (c) (C) → ©
	// (tm) (TM) → ™
	// (r) (R) → ®
	// +- → ±
	// (p) (P) -> §
	// ... → … (also ?.... → ?.., !.... → !..)
	// ???????? → ???, !!!!! → !!!, `,,` → `,`
	// -- → &ndash;, --- → &mdash;
	//
	'use strict';
	
	// TODO:
	// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
	// - miltiplication 2 x 4 -> 2 × 4
	
	var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
	
	// Workaround for phantomjs - need regex without /g flag,
	// or root check will fail every second time
	var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
	
	var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
	var SCOPED_ABBR = {
	  c: '©',
	  r: '®',
	  p: '§',
	  tm: '™'
	};
	
	function replaceFn(match, name) {
	  return SCOPED_ABBR[name.toLowerCase()];
	}
	
	function replace_scoped(inlineTokens) {
	  var i, token, inside_autolink = 0;
	
	  for (i = inlineTokens.length - 1; i >= 0; i--) {
	    token = inlineTokens[i];
	
	    if (token.type === 'text' && !inside_autolink) {
	      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
	    }
	
	    if (token.type === 'link_open' && token.info === 'auto') {
	      inside_autolink--;
	    }
	
	    if (token.type === 'link_close' && token.info === 'auto') {
	      inside_autolink++;
	    }
	  }
	}
	
	function replace_rare(inlineTokens) {
	  var i, token, inside_autolink = 0;
	
	  for (i = inlineTokens.length - 1; i >= 0; i--) {
	    token = inlineTokens[i];
	
	    if (token.type === 'text' && !inside_autolink) {
	      if (RARE_RE.test(token.content)) {
	        token.content = token.content
	                    .replace(/\+-/g, '±')
	                    // .., ..., ....... -> …
	                    // but ?..... & !..... -> ?.. & !..
	                    .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..')
	                    .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
	                    // em-dash
	                    .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
	                    // en-dash
	                    .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2')
	                    .replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
	      }
	    }
	
	    if (token.type === 'link_open' && token.info === 'auto') {
	      inside_autolink--;
	    }
	
	    if (token.type === 'link_close' && token.info === 'auto') {
	      inside_autolink++;
	    }
	  }
	}
	
	
	module.exports = function replace(state) {
	  var blkIdx;
	
	  if (!state.md.options.typographer) { return; }
	
	  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
	
	    if (state.tokens[blkIdx].type !== 'inline') { continue; }
	
	    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
	      replace_scoped(state.tokens[blkIdx].children);
	    }
	
	    if (RARE_RE.test(state.tokens[blkIdx].content)) {
	      replace_rare(state.tokens[blkIdx].children);
	    }
	
	  }
	};
	
	},{}],35:[function(require,module,exports){
	// Convert straight quotation marks to typographic ones
	//
	'use strict';
	
	
	var isWhiteSpace   = require('../common/utils').isWhiteSpace;
	var isPunctChar    = require('../common/utils').isPunctChar;
	var isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;
	
	var QUOTE_TEST_RE = /['"]/;
	var QUOTE_RE = /['"]/g;
	var APOSTROPHE = '\u2019'; /* ’ */
	
	
	function replaceAt(str, index, ch) {
	  return str.substr(0, index) + ch + str.substr(index + 1);
	}
	
	function process_inlines(tokens, state) {
	  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,
	      isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,
	      canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
	
	  stack = [];
	
	  for (i = 0; i < tokens.length; i++) {
	    token = tokens[i];
	
	    thisLevel = tokens[i].level;
	
	    for (j = stack.length - 1; j >= 0; j--) {
	      if (stack[j].level <= thisLevel) { break; }
	    }
	    stack.length = j + 1;
	
	    if (token.type !== 'text') { continue; }
	
	    text = token.content;
	    pos = 0;
	    max = text.length;
	
	    /*eslint no-labels:0,block-scoped-var:0*/
	    OUTER:
	    while (pos < max) {
	      QUOTE_RE.lastIndex = pos;
	      t = QUOTE_RE.exec(text);
	      if (!t) { break; }
	
	      canOpen = canClose = true;
	      pos = t.index + 1;
	      isSingle = (t[0] === "'");
	
	      // Find previous character,
	      // default to space if it's the beginning of the line
	      //
	      lastChar = 0x20;
	
	      if (t.index - 1 >= 0) {
	        lastChar = text.charCodeAt(t.index - 1);
	      } else {
	        for (j = i - 1; j >= 0; j--) {
	          if (tokens[j].type !== 'text') { continue; }
	
	          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
	          break;
	        }
	      }
	
	      // Find next character,
	      // default to space if it's the end of the line
	      //
	      nextChar = 0x20;
	
	      if (pos < max) {
	        nextChar = text.charCodeAt(pos);
	      } else {
	        for (j = i + 1; j < tokens.length; j++) {
	          if (tokens[j].type !== 'text') { continue; }
	
	          nextChar = tokens[j].content.charCodeAt(0);
	          break;
	        }
	      }
	
	      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
	      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
	
	      isLastWhiteSpace = isWhiteSpace(lastChar);
	      isNextWhiteSpace = isWhiteSpace(nextChar);
	
	      if (isNextWhiteSpace) {
	        canOpen = false;
	      } else if (isNextPunctChar) {
	        if (!(isLastWhiteSpace || isLastPunctChar)) {
	          canOpen = false;
	        }
	      }
	
	      if (isLastWhiteSpace) {
	        canClose = false;
	      } else if (isLastPunctChar) {
	        if (!(isNextWhiteSpace || isNextPunctChar)) {
	          canClose = false;
	        }
	      }
	
	      if (nextChar === 0x22 /* " */ && t[0] === '"') {
	        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
	          // special case: 1"" - count first quote as an inch
	          canClose = canOpen = false;
	        }
	      }
	
	      if (canOpen && canClose) {
	        // treat this as the middle of the word
	        canOpen = false;
	        canClose = isNextPunctChar;
	      }
	
	      if (!canOpen && !canClose) {
	        // middle of word
	        if (isSingle) {
	          token.content = replaceAt(token.content, t.index, APOSTROPHE);
	        }
	        continue;
	      }
	
	      if (canClose) {
	        // this could be a closing quote, rewind the stack to get a match
	        for (j = stack.length - 1; j >= 0; j--) {
	          item = stack[j];
	          if (stack[j].level < thisLevel) { break; }
	          if (item.single === isSingle && stack[j].level === thisLevel) {
	            item = stack[j];
	
	            if (isSingle) {
	              openQuote = state.md.options.quotes[2];
	              closeQuote = state.md.options.quotes[3];
	            } else {
	              openQuote = state.md.options.quotes[0];
	              closeQuote = state.md.options.quotes[1];
	            }
	
	            // replace token.content *before* tokens[item.token].content,
	            // because, if they are pointing at the same token, replaceAt
	            // could mess up indices when quote length != 1
	            token.content = replaceAt(token.content, t.index, closeQuote);
	            tokens[item.token].content = replaceAt(
	              tokens[item.token].content, item.pos, openQuote);
	
	            pos += closeQuote.length - 1;
	            if (item.token === i) { pos += openQuote.length - 1; }
	
	            text = token.content;
	            max = text.length;
	
	            stack.length = j;
	            continue OUTER;
	          }
	        }
	      }
	
	      if (canOpen) {
	        stack.push({
	          token: i,
	          pos: t.index,
	          single: isSingle,
	          level: thisLevel
	        });
	      } else if (canClose && isSingle) {
	        token.content = replaceAt(token.content, t.index, APOSTROPHE);
	      }
	    }
	  }
	}
	
	
	module.exports = function smartquotes(state) {
	  /*eslint max-depth:0*/
	  var blkIdx;
	
	  if (!state.md.options.typographer) { return; }
	
	  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
	
	    if (state.tokens[blkIdx].type !== 'inline' ||
	        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
	      continue;
	    }
	
	    process_inlines(state.tokens[blkIdx].children, state);
	  }
	};
	
	},{"../common/utils":4}],36:[function(require,module,exports){
	// Core state object
	//
	'use strict';
	
	var Token = require('../token');
	
	
	function StateCore(src, md, env) {
	  this.src = src;
	  this.env = env;
	  this.tokens = [];
	  this.inlineMode = false;
	  this.md = md; // link to parser instance
	}
	
	// re-export Token class to use in core rules
	StateCore.prototype.Token = Token;
	
	
	module.exports = StateCore;
	
	},{"../token":51}],37:[function(require,module,exports){
	// Process autolinks '<protocol:...>'
	
	'use strict';
	
	
	/*eslint max-len:0*/
	var EMAIL_RE    = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
	var AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;
	
	
	module.exports = function autolink(state, silent) {
	  var tail, linkMatch, emailMatch, url, fullUrl, token,
	      pos = state.pos;
	
	  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }
	
	  tail = state.src.slice(pos);
	
	  if (tail.indexOf('>') < 0) { return false; }
	
	  if (AUTOLINK_RE.test(tail)) {
	    linkMatch = tail.match(AUTOLINK_RE);
	
	    url = linkMatch[0].slice(1, -1);
	    fullUrl = state.md.normalizeLink(url);
	    if (!state.md.validateLink(fullUrl)) { return false; }
	
	    if (!silent) {
	      token         = state.push('link_open', 'a', 1);
	      token.attrs   = [ [ 'href', fullUrl ] ];
	      token.markup  = 'autolink';
	      token.info    = 'auto';
	
	      token         = state.push('text', '', 0);
	      token.content = state.md.normalizeLinkText(url);
	
	      token         = state.push('link_close', 'a', -1);
	      token.markup  = 'autolink';
	      token.info    = 'auto';
	    }
	
	    state.pos += linkMatch[0].length;
	    return true;
	  }
	
	  if (EMAIL_RE.test(tail)) {
	    emailMatch = tail.match(EMAIL_RE);
	
	    url = emailMatch[0].slice(1, -1);
	    fullUrl = state.md.normalizeLink('mailto:' + url);
	    if (!state.md.validateLink(fullUrl)) { return false; }
	
	    if (!silent) {
	      token         = state.push('link_open', 'a', 1);
	      token.attrs   = [ [ 'href', fullUrl ] ];
	      token.markup  = 'autolink';
	      token.info    = 'auto';
	
	      token         = state.push('text', '', 0);
	      token.content = state.md.normalizeLinkText(url);
	
	      token         = state.push('link_close', 'a', -1);
	      token.markup  = 'autolink';
	      token.info    = 'auto';
	    }
	
	    state.pos += emailMatch[0].length;
	    return true;
	  }
	
	  return false;
	};
	
	},{}],38:[function(require,module,exports){
	// Parse backticks
	
	'use strict';
	
	module.exports = function backtick(state, silent) {
	  var start, max, marker, matchStart, matchEnd, token,
	      pos = state.pos,
	      ch = state.src.charCodeAt(pos);
	
	  if (ch !== 0x60/* ` */) { return false; }
	
	  start = pos;
	  pos++;
	  max = state.posMax;
	
	  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }
	
	  marker = state.src.slice(start, pos);
	
	  matchStart = matchEnd = pos;
	
	  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
	    matchEnd = matchStart + 1;
	
	    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }
	
	    if (matchEnd - matchStart === marker.length) {
	      if (!silent) {
	        token         = state.push('code_inline', 'code', 0);
	        token.markup  = marker;
	        token.content = state.src.slice(pos, matchStart)
	                                 .replace(/[ \n]+/g, ' ')
	                                 .trim();
	      }
	      state.pos = matchEnd;
	      return true;
	    }
	  }
	
	  if (!silent) { state.pending += marker; }
	  state.pos += marker.length;
	  return true;
	};
	
	},{}],39:[function(require,module,exports){
	// For each opening emphasis-like marker find a matching closing one
	//
	'use strict';
	
	
	module.exports = function link_pairs(state) {
	  var i, j, lastDelim, currDelim,
	      delimiters = state.delimiters,
	      max = state.delimiters.length;
	
	  for (i = 0; i < max; i++) {
	    lastDelim = delimiters[i];
	
	    if (!lastDelim.close) { continue; }
	
	    j = i - lastDelim.jump - 1;
	
	    while (j >= 0) {
	      currDelim = delimiters[j];
	
	      if (currDelim.open &&
	          currDelim.marker === lastDelim.marker &&
	          currDelim.end < 0 &&
	          currDelim.level === lastDelim.level) {
	
	        // typeofs are for backward compatibility with plugins
	        var odd_match = (currDelim.close || lastDelim.open) &&
	                        typeof currDelim.length !== 'undefined' &&
	                        typeof lastDelim.length !== 'undefined' &&
	                        (currDelim.length + lastDelim.length) % 3 === 0;
	
	        if (!odd_match) {
	          lastDelim.jump = i - j;
	          lastDelim.open = false;
	          currDelim.end  = i;
	          currDelim.jump = 0;
	          break;
	        }
	      }
	
	      j -= currDelim.jump + 1;
	    }
	  }
	};
	
	},{}],40:[function(require,module,exports){
	// Process *this* and _that_
	//
	'use strict';
	
	
	// Insert each marker as a separate text token, and add it to delimiter list
	//
	module.exports.tokenize = function emphasis(state, silent) {
	  var i, scanned, token,
	      start = state.pos,
	      marker = state.src.charCodeAt(start);
	
	  if (silent) { return false; }
	
	  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false; }
	
	  scanned = state.scanDelims(state.pos, marker === 0x2A);
	
	  for (i = 0; i < scanned.length; i++) {
	    token         = state.push('text', '', 0);
	    token.content = String.fromCharCode(marker);
	
	    state.delimiters.push({
	      // Char code of the starting marker (number).
	      //
	      marker: marker,
	
	      // Total length of these series of delimiters.
	      //
	      length: scanned.length,
	
	      // An amount of characters before this one that's equivalent to
	      // current one. In plain English: if this delimiter does not open
	      // an emphasis, neither do previous `jump` characters.
	      //
	      // Used to skip sequences like "*****" in one step, for 1st asterisk
	      // value will be 0, for 2nd it's 1 and so on.
	      //
	      jump:   i,
	
	      // A position of the token this delimiter corresponds to.
	      //
	      token:  state.tokens.length - 1,
	
	      // Token level.
	      //
	      level:  state.level,
	
	      // If this delimiter is matched as a valid opener, `end` will be
	      // equal to its position, otherwise it's `-1`.
	      //
	      end:    -1,
	
	      // Boolean flags that determine if this delimiter could open or close
	      // an emphasis.
	      //
	      open:   scanned.can_open,
	      close:  scanned.can_close
	    });
	  }
	
	  state.pos += scanned.length;
	
	  return true;
	};
	
	
	// Walk through delimiter list and replace text tokens with tags
	//
	module.exports.postProcess = function emphasis(state) {
	  var i,
	      startDelim,
	      endDelim,
	      token,
	      ch,
	      isStrong,
	      delimiters = state.delimiters,
	      max = state.delimiters.length;
	
	  for (i = 0; i < max; i++) {
	    startDelim = delimiters[i];
	
	    if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {
	      continue;
	    }
	
	    // Process only opening markers
	    if (startDelim.end === -1) {
	      continue;
	    }
	
	    endDelim = delimiters[startDelim.end];
	
	    // If the next delimiter has the same marker and is adjacent to this one,
	    // merge those into one strong delimiter.
	    //
	    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
	    //
	    isStrong = i + 1 < max &&
	               delimiters[i + 1].end === startDelim.end - 1 &&
	               delimiters[i + 1].token === startDelim.token + 1 &&
	               delimiters[startDelim.end - 1].token === endDelim.token - 1 &&
	               delimiters[i + 1].marker === startDelim.marker;
	
	    ch = String.fromCharCode(startDelim.marker);
	
	    token         = state.tokens[startDelim.token];
	    token.type    = isStrong ? 'strong_open' : 'em_open';
	    token.tag     = isStrong ? 'strong' : 'em';
	    token.nesting = 1;
	    token.markup  = isStrong ? ch + ch : ch;
	    token.content = '';
	
	    token         = state.tokens[endDelim.token];
	    token.type    = isStrong ? 'strong_close' : 'em_close';
	    token.tag     = isStrong ? 'strong' : 'em';
	    token.nesting = -1;
	    token.markup  = isStrong ? ch + ch : ch;
	    token.content = '';
	
	    if (isStrong) {
	      state.tokens[delimiters[i + 1].token].content = '';
	      state.tokens[delimiters[startDelim.end - 1].token].content = '';
	      i++;
	    }
	  }
	};
	
	},{}],41:[function(require,module,exports){
	// Process html entity - &#123;, &#xAF;, &quot;, ...
	
	'use strict';
	
	var entities          = require('../common/entities');
	var has               = require('../common/utils').has;
	var isValidEntityCode = require('../common/utils').isValidEntityCode;
	var fromCodePoint     = require('../common/utils').fromCodePoint;
	
	
	var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
	var NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;
	
	
	module.exports = function entity(state, silent) {
	  var ch, code, match, pos = state.pos, max = state.posMax;
	
	  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }
	
	  if (pos + 1 < max) {
	    ch = state.src.charCodeAt(pos + 1);
	
	    if (ch === 0x23 /* # */) {
	      match = state.src.slice(pos).match(DIGITAL_RE);
	      if (match) {
	        if (!silent) {
	          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
	          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
	        }
	        state.pos += match[0].length;
	        return true;
	      }
	    } else {
	      match = state.src.slice(pos).match(NAMED_RE);
	      if (match) {
	        if (has(entities, match[1])) {
	          if (!silent) { state.pending += entities[match[1]]; }
	          state.pos += match[0].length;
	          return true;
	        }
	      }
	    }
	  }
	
	  if (!silent) { state.pending += '&'; }
	  state.pos++;
	  return true;
	};
	
	},{"../common/entities":1,"../common/utils":4}],42:[function(require,module,exports){
	// Proceess escaped chars and hardbreaks
	
	'use strict';
	
	var isSpace = require('../common/utils').isSpace;
	
	var ESCAPED = [];
	
	for (var i = 0; i < 256; i++) { ESCAPED.push(0); }
	
	'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'
	  .split('').forEach(function (ch) { ESCAPED[ch.charCodeAt(0)] = 1; });
	
	
	module.exports = function escape(state, silent) {
	  var ch, pos = state.pos, max = state.posMax;
	
	  if (state.src.charCodeAt(pos) !== 0x5C/* \ */) { return false; }
	
	  pos++;
	
	  if (pos < max) {
	    ch = state.src.charCodeAt(pos);
	
	    if (ch < 256 && ESCAPED[ch] !== 0) {
	      if (!silent) { state.pending += state.src[pos]; }
	      state.pos += 2;
	      return true;
	    }
	
	    if (ch === 0x0A) {
	      if (!silent) {
	        state.push('hardbreak', 'br', 0);
	      }
	
	      pos++;
	      // skip leading whitespaces from next line
	      while (pos < max) {
	        ch = state.src.charCodeAt(pos);
	        if (!isSpace(ch)) { break; }
	        pos++;
	      }
	
	      state.pos = pos;
	      return true;
	    }
	  }
	
	  if (!silent) { state.pending += '\\'; }
	  state.pos++;
	  return true;
	};
	
	},{"../common/utils":4}],43:[function(require,module,exports){
	// Process html tags
	
	'use strict';
	
	
	var HTML_TAG_RE = require('../common/html_re').HTML_TAG_RE;
	
	
	function isLetter(ch) {
	  /*eslint no-bitwise:0*/
	  var lc = ch | 0x20; // to lower case
	  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);
	}
	
	
	module.exports = function html_inline(state, silent) {
	  var ch, match, max, token,
	      pos = state.pos;
	
	  if (!state.md.options.html) { return false; }
	
	  // Check start
	  max = state.posMax;
	  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||
	      pos + 2 >= max) {
	    return false;
	  }
	
	  // Quick fail on second char
	  ch = state.src.charCodeAt(pos + 1);
	  if (ch !== 0x21/* ! */ &&
	      ch !== 0x3F/* ? */ &&
	      ch !== 0x2F/* / */ &&
	      !isLetter(ch)) {
	    return false;
	  }
	
	  match = state.src.slice(pos).match(HTML_TAG_RE);
	  if (!match) { return false; }
	
	  if (!silent) {
	    token         = state.push('html_inline', '', 0);
	    token.content = state.src.slice(pos, pos + match[0].length);
	  }
	  state.pos += match[0].length;
	  return true;
	};
	
	},{"../common/html_re":3}],44:[function(require,module,exports){
	// Process ![image](<src> "title")
	
	'use strict';
	
	var parseLinkLabel       = require('../helpers/parse_link_label');
	var parseLinkDestination = require('../helpers/parse_link_destination');
	var parseLinkTitle       = require('../helpers/parse_link_title');
	var normalizeReference   = require('../common/utils').normalizeReference;
	var isSpace              = require('../common/utils').isSpace;
	
	
	module.exports = function image(state, silent) {
	  var attrs,
	      code,
	      content,
	      label,
	      labelEnd,
	      labelStart,
	      pos,
	      ref,
	      res,
	      title,
	      token,
	      tokens,
	      start,
	      href = '',
	      oldPos = state.pos,
	      max = state.posMax;
	
	  if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false; }
	  if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false; }
	
	  labelStart = state.pos + 2;
	  labelEnd = parseLinkLabel(state, state.pos + 1, false);
	
	  // parser failed to find ']', so it's not a valid link
	  if (labelEnd < 0) { return false; }
	
	  pos = labelEnd + 1;
	  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
	    //
	    // Inline link
	    //
	
	    // [link](  <href>  "title"  )
	    //        ^^ skipping these spaces
	    pos++;
	    for (; pos < max; pos++) {
	      code = state.src.charCodeAt(pos);
	      if (!isSpace(code) && code !== 0x0A) { break; }
	    }
	    if (pos >= max) { return false; }
	
	    // [link](  <href>  "title"  )
	    //          ^^^^^^ parsing link destination
	    start = pos;
	    res = parseLinkDestination(state.src, pos, state.posMax);
	    if (res.ok) {
	      href = state.md.normalizeLink(res.str);
	      if (state.md.validateLink(href)) {
	        pos = res.pos;
	      } else {
	        href = '';
	      }
	    }
	
	    // [link](  <href>  "title"  )
	    //                ^^ skipping these spaces
	    start = pos;
	    for (; pos < max; pos++) {
	      code = state.src.charCodeAt(pos);
	      if (!isSpace(code) && code !== 0x0A) { break; }
	    }
	
	    // [link](  <href>  "title"  )
	    //                  ^^^^^^^ parsing link title
	    res = parseLinkTitle(state.src, pos, state.posMax);
	    if (pos < max && start !== pos && res.ok) {
	      title = res.str;
	      pos = res.pos;
	
	      // [link](  <href>  "title"  )
	      //                         ^^ skipping these spaces
	      for (; pos < max; pos++) {
	        code = state.src.charCodeAt(pos);
	        if (!isSpace(code) && code !== 0x0A) { break; }
	      }
	    } else {
	      title = '';
	    }
	
	    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
	      state.pos = oldPos;
	      return false;
	    }
	    pos++;
	  } else {
	    //
	    // Link reference
	    //
	    if (typeof state.env.references === 'undefined') { return false; }
	
	    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
	      start = pos + 1;
	      pos = parseLinkLabel(state, pos);
	      if (pos >= 0) {
	        label = state.src.slice(start, pos++);
	      } else {
	        pos = labelEnd + 1;
	      }
	    } else {
	      pos = labelEnd + 1;
	    }
	
	    // covers label === '' and label === undefined
	    // (collapsed reference link and shortcut reference link respectively)
	    if (!label) { label = state.src.slice(labelStart, labelEnd); }
	
	    ref = state.env.references[normalizeReference(label)];
	    if (!ref) {
	      state.pos = oldPos;
	      return false;
	    }
	    href = ref.href;
	    title = ref.title;
	  }
	
	  //
	  // We found the end of the link, and know for a fact it's a valid link;
	  // so all that's left to do is to call tokenizer.
	  //
	  if (!silent) {
	    content = state.src.slice(labelStart, labelEnd);
	
	    state.md.inline.parse(
	      content,
	      state.md,
	      state.env,
	      tokens = []
	    );
	
	    token          = state.push('image', 'img', 0);
	    token.attrs    = attrs = [ [ 'src', href ], [ 'alt', '' ] ];
	    token.children = tokens;
	    token.content  = content;
	
	    if (title) {
	      attrs.push([ 'title', title ]);
	    }
	  }
	
	  state.pos = pos;
	  state.posMax = max;
	  return true;
	};
	
	},{"../common/utils":4,"../helpers/parse_link_destination":6,"../helpers/parse_link_label":7,"../helpers/parse_link_title":8}],45:[function(require,module,exports){
	// Process [link](<to> "stuff")
	
	'use strict';
	
	var parseLinkLabel       = require('../helpers/parse_link_label');
	var parseLinkDestination = require('../helpers/parse_link_destination');
	var parseLinkTitle       = require('../helpers/parse_link_title');
	var normalizeReference   = require('../common/utils').normalizeReference;
	var isSpace              = require('../common/utils').isSpace;
	
	
	module.exports = function link(state, silent) {
	  var attrs,
	      code,
	      label,
	      labelEnd,
	      labelStart,
	      pos,
	      res,
	      ref,
	      title,
	      token,
	      href = '',
	      oldPos = state.pos,
	      max = state.posMax,
	      start = state.pos;
	
	  if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false; }
	
	  labelStart = state.pos + 1;
	  labelEnd = parseLinkLabel(state, state.pos, true);
	
	  // parser failed to find ']', so it's not a valid link
	  if (labelEnd < 0) { return false; }
	
	  pos = labelEnd + 1;
	  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
	    //
	    // Inline link
	    //
	
	    // [link](  <href>  "title"  )
	    //        ^^ skipping these spaces
	    pos++;
	    for (; pos < max; pos++) {
	      code = state.src.charCodeAt(pos);
	      if (!isSpace(code) && code !== 0x0A) { break; }
	    }
	    if (pos >= max) { return false; }
	
	    // [link](  <href>  "title"  )
	    //          ^^^^^^ parsing link destination
	    start = pos;
	    res = parseLinkDestination(state.src, pos, state.posMax);
	    if (res.ok) {
	      href = state.md.normalizeLink(res.str);
	      if (state.md.validateLink(href)) {
	        pos = res.pos;
	      } else {
	        href = '';
	      }
	    }
	
	    // [link](  <href>  "title"  )
	    //                ^^ skipping these spaces
	    start = pos;
	    for (; pos < max; pos++) {
	      code = state.src.charCodeAt(pos);
	      if (!isSpace(code) && code !== 0x0A) { break; }
	    }
	
	    // [link](  <href>  "title"  )
	    //                  ^^^^^^^ parsing link title
	    res = parseLinkTitle(state.src, pos, state.posMax);
	    if (pos < max && start !== pos && res.ok) {
	      title = res.str;
	      pos = res.pos;
	
	      // [link](  <href>  "title"  )
	      //                         ^^ skipping these spaces
	      for (; pos < max; pos++) {
	        code = state.src.charCodeAt(pos);
	        if (!isSpace(code) && code !== 0x0A) { break; }
	      }
	    } else {
	      title = '';
	    }
	
	    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
	      state.pos = oldPos;
	      return false;
	    }
	    pos++;
	  } else {
	    //
	    // Link reference
	    //
	    if (typeof state.env.references === 'undefined') { return false; }
	
	    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
	      start = pos + 1;
	      pos = parseLinkLabel(state, pos);
	      if (pos >= 0) {
	        label = state.src.slice(start, pos++);
	      } else {
	        pos = labelEnd + 1;
	      }
	    } else {
	      pos = labelEnd + 1;
	    }
	
	    // covers label === '' and label === undefined
	    // (collapsed reference link and shortcut reference link respectively)
	    if (!label) { label = state.src.slice(labelStart, labelEnd); }
	
	    ref = state.env.references[normalizeReference(label)];
	    if (!ref) {
	      state.pos = oldPos;
	      return false;
	    }
	    href = ref.href;
	    title = ref.title;
	  }
	
	  //
	  // We found the end of the link, and know for a fact it's a valid link;
	  // so all that's left to do is to call tokenizer.
	  //
	  if (!silent) {
	    state.pos = labelStart;
	    state.posMax = labelEnd;
	
	    token        = state.push('link_open', 'a', 1);
	    token.attrs  = attrs = [ [ 'href', href ] ];
	    if (title) {
	      attrs.push([ 'title', title ]);
	    }
	
	    state.md.inline.tokenize(state);
	
	    token        = state.push('link_close', 'a', -1);
	  }
	
	  state.pos = pos;
	  state.posMax = max;
	  return true;
	};
	
	},{"../common/utils":4,"../helpers/parse_link_destination":6,"../helpers/parse_link_label":7,"../helpers/parse_link_title":8}],46:[function(require,module,exports){
	// Proceess '\n'
	
	'use strict';
	
	module.exports = function newline(state, silent) {
	  var pmax, max, pos = state.pos;
	
	  if (state.src.charCodeAt(pos) !== 0x0A/* \n */) { return false; }
	
	  pmax = state.pending.length - 1;
	  max = state.posMax;
	
	  // '  \n' -> hardbreak
	  // Lookup in pending chars is bad practice! Don't copy to other rules!
	  // Pending string is stored in concat mode, indexed lookups will cause
	  // convertion to flat mode.
	  if (!silent) {
	    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
	      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
	        state.pending = state.pending.replace(/ +$/, '');
	        state.push('hardbreak', 'br', 0);
	      } else {
	        state.pending = state.pending.slice(0, -1);
	        state.push('softbreak', 'br', 0);
	      }
	
	    } else {
	      state.push('softbreak', 'br', 0);
	    }
	  }
	
	  pos++;
	
	  // skip heading spaces for next line
	  while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }
	
	  state.pos = pos;
	  return true;
	};
	
	},{}],47:[function(require,module,exports){
	// Inline parser state
	
	'use strict';
	
	
	var Token          = require('../token');
	var isWhiteSpace   = require('../common/utils').isWhiteSpace;
	var isPunctChar    = require('../common/utils').isPunctChar;
	var isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;
	
	
	function StateInline(src, md, env, outTokens) {
	  this.src = src;
	  this.env = env;
	  this.md = md;
	  this.tokens = outTokens;
	
	  this.pos = 0;
	  this.posMax = this.src.length;
	  this.level = 0;
	  this.pending = '';
	  this.pendingLevel = 0;
	
	  this.cache = {};        // Stores { start: end } pairs. Useful for backtrack
	                          // optimization of pairs parse (emphasis, strikes).
	
	  this.delimiters = [];   // Emphasis-like delimiters
	}
	
	
	// Flush pending text
	//
	StateInline.prototype.pushPending = function () {
	  var token = new Token('text', '', 0);
	  token.content = this.pending;
	  token.level = this.pendingLevel;
	  this.tokens.push(token);
	  this.pending = '';
	  return token;
	};
	
	
	// Push new token to "stream".
	// If pending text exists - flush it as text token
	//
	StateInline.prototype.push = function (type, tag, nesting) {
	  if (this.pending) {
	    this.pushPending();
	  }
	
	  var token = new Token(type, tag, nesting);
	
	  if (nesting < 0) { this.level--; }
	  token.level = this.level;
	  if (nesting > 0) { this.level++; }
	
	  this.pendingLevel = this.level;
	  this.tokens.push(token);
	  return token;
	};
	
	
	// Scan a sequence of emphasis-like markers, and determine whether
	// it can start an emphasis sequence or end an emphasis sequence.
	//
	//  - start - position to scan from (it should point at a valid marker);
	//  - canSplitWord - determine if these markers can be found inside a word
	//
	StateInline.prototype.scanDelims = function (start, canSplitWord) {
	  var pos = start, lastChar, nextChar, count, can_open, can_close,
	      isLastWhiteSpace, isLastPunctChar,
	      isNextWhiteSpace, isNextPunctChar,
	      left_flanking = true,
	      right_flanking = true,
	      max = this.posMax,
	      marker = this.src.charCodeAt(start);
	
	  // treat beginning of the line as a whitespace
	  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;
	
	  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++; }
	
	  count = pos - start;
	
	  // treat end of the line as a whitespace
	  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;
	
	  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
	  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
	
	  isLastWhiteSpace = isWhiteSpace(lastChar);
	  isNextWhiteSpace = isWhiteSpace(nextChar);
	
	  if (isNextWhiteSpace) {
	    left_flanking = false;
	  } else if (isNextPunctChar) {
	    if (!(isLastWhiteSpace || isLastPunctChar)) {
	      left_flanking = false;
	    }
	  }
	
	  if (isLastWhiteSpace) {
	    right_flanking = false;
	  } else if (isLastPunctChar) {
	    if (!(isNextWhiteSpace || isNextPunctChar)) {
	      right_flanking = false;
	    }
	  }
	
	  if (!canSplitWord) {
	    can_open  = left_flanking  && (!right_flanking || isLastPunctChar);
	    can_close = right_flanking && (!left_flanking  || isNextPunctChar);
	  } else {
	    can_open  = left_flanking;
	    can_close = right_flanking;
	  }
	
	  return {
	    can_open:  can_open,
	    can_close: can_close,
	    length:    count
	  };
	};
	
	
	// re-export Token class to use in block rules
	StateInline.prototype.Token = Token;
	
	
	module.exports = StateInline;
	
	},{"../common/utils":4,"../token":51}],48:[function(require,module,exports){
	// ~~strike through~~
	//
	'use strict';
	
	
	// Insert each marker as a separate text token, and add it to delimiter list
	//
	module.exports.tokenize = function strikethrough(state, silent) {
	  var i, scanned, token, len, ch,
	      start = state.pos,
	      marker = state.src.charCodeAt(start);
	
	  if (silent) { return false; }
	
	  if (marker !== 0x7E/* ~ */) { return false; }
	
	  scanned = state.scanDelims(state.pos, true);
	  len = scanned.length;
	  ch = String.fromCharCode(marker);
	
	  if (len < 2) { return false; }
	
	  if (len % 2) {
	    token         = state.push('text', '', 0);
	    token.content = ch;
	    len--;
	  }
	
	  for (i = 0; i < len; i += 2) {
	    token         = state.push('text', '', 0);
	    token.content = ch + ch;
	
	    state.delimiters.push({
	      marker: marker,
	      jump:   i,
	      token:  state.tokens.length - 1,
	      level:  state.level,
	      end:    -1,
	      open:   scanned.can_open,
	      close:  scanned.can_close
	    });
	  }
	
	  state.pos += scanned.length;
	
	  return true;
	};
	
	
	// Walk through delimiter list and replace text tokens with tags
	//
	module.exports.postProcess = function strikethrough(state) {
	  var i, j,
	      startDelim,
	      endDelim,
	      token,
	      loneMarkers = [],
	      delimiters = state.delimiters,
	      max = state.delimiters.length;
	
	  for (i = 0; i < max; i++) {
	    startDelim = delimiters[i];
	
	    if (startDelim.marker !== 0x7E/* ~ */) {
	      continue;
	    }
	
	    if (startDelim.end === -1) {
	      continue;
	    }
	
	    endDelim = delimiters[startDelim.end];
	
	    token         = state.tokens[startDelim.token];
	    token.type    = 's_open';
	    token.tag     = 's';
	    token.nesting = 1;
	    token.markup  = '~~';
	    token.content = '';
	
	    token         = state.tokens[endDelim.token];
	    token.type    = 's_close';
	    token.tag     = 's';
	    token.nesting = -1;
	    token.markup  = '~~';
	    token.content = '';
	
	    if (state.tokens[endDelim.token - 1].type === 'text' &&
	        state.tokens[endDelim.token - 1].content === '~') {
	
	      loneMarkers.push(endDelim.token - 1);
	    }
	  }
	
	  // If a marker sequence has an odd number of characters, it's splitted
	  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
	  // start of the sequence.
	  //
	  // So, we have to move all those markers after subsequent s_close tags.
	  //
	  while (loneMarkers.length) {
	    i = loneMarkers.pop();
	    j = i + 1;
	
	    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
	      j++;
	    }
	
	    j--;
	
	    if (i !== j) {
	      token = state.tokens[j];
	      state.tokens[j] = state.tokens[i];
	      state.tokens[i] = token;
	    }
	  }
	};
	
	},{}],49:[function(require,module,exports){
	// Skip text characters for text token, place those to pending buffer
	// and increment current pos
	
	'use strict';
	
	
	// Rule to skip pure text
	// '{}$%@~+=:' reserved for extentions
	
	// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
	
	// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
	// http://spec.commonmark.org/0.15/#ascii-punctuation-character
	function isTerminatorChar(ch) {
	  switch (ch) {
	    case 0x0A/* \n */:
	    case 0x21/* ! */:
	    case 0x23/* # */:
	    case 0x24/* $ */:
	    case 0x25/* % */:
	    case 0x26/* & */:
	    case 0x2A/* * */:
	    case 0x2B/* + */:
	    case 0x2D/* - */:
	    case 0x3A/* : */:
	    case 0x3C/* < */:
	    case 0x3D/* = */:
	    case 0x3E/* > */:
	    case 0x40/* @ */:
	    case 0x5B/* [ */:
	    case 0x5C/* \ */:
	    case 0x5D/* ] */:
	    case 0x5E/* ^ */:
	    case 0x5F/* _ */:
	    case 0x60/* ` */:
	    case 0x7B/* { */:
	    case 0x7D/* } */:
	    case 0x7E/* ~ */:
	      return true;
	    default:
	      return false;
	  }
	}
	
	module.exports = function text(state, silent) {
	  var pos = state.pos;
	
	  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
	    pos++;
	  }
	
	  if (pos === state.pos) { return false; }
	
	  if (!silent) { state.pending += state.src.slice(state.pos, pos); }
	
	  state.pos = pos;
	
	  return true;
	};
	
	// Alternative implementation, for memory.
	//
	// It costs 10% of performance, but allows extend terminators list, if place it
	// to `ParcerInline` property. Probably, will switch to it sometime, such
	// flexibility required.
	
	/*
	var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;
	
	module.exports = function text(state, silent) {
	  var pos = state.pos,
	      idx = state.src.slice(pos).search(TERMINATOR_RE);
	
	  // first char is terminator -> empty text
	  if (idx === 0) { return false; }
	
	  // no terminator -> text till end of string
	  if (idx < 0) {
	    if (!silent) { state.pending += state.src.slice(pos); }
	    state.pos = state.src.length;
	    return true;
	  }
	
	  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }
	
	  state.pos += idx;
	
	  return true;
	};*/
	
	},{}],50:[function(require,module,exports){
	// Merge adjacent text nodes into one, and re-calculate all token levels
	//
	'use strict';
	
	
	module.exports = function text_collapse(state) {
	  var curr, last,
	      level = 0,
	      tokens = state.tokens,
	      max = state.tokens.length;
	
	  for (curr = last = 0; curr < max; curr++) {
	    // re-calculate levels
	    level += tokens[curr].nesting;
	    tokens[curr].level = level;
	
	    if (tokens[curr].type === 'text' &&
	        curr + 1 < max &&
	        tokens[curr + 1].type === 'text') {
	
	      // collapse two adjacent text nodes
	      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
	    } else {
	      if (curr !== last) { tokens[last] = tokens[curr]; }
	
	      last++;
	    }
	  }
	
	  if (curr !== last) {
	    tokens.length = last;
	  }
	};
	
	},{}],51:[function(require,module,exports){
	// Token class
	
	'use strict';
	
	
	/**
	 * class Token
	 **/
	
	/**
	 * new Token(type, tag, nesting)
	 *
	 * Create new token and fill passed properties.
	 **/
	function Token(type, tag, nesting) {
	  /**
	   * Token#type -> String
	   *
	   * Type of the token (string, e.g. "paragraph_open")
	   **/
	  this.type     = type;
	
	  /**
	   * Token#tag -> String
	   *
	   * html tag name, e.g. "p"
	   **/
	  this.tag      = tag;
	
	  /**
	   * Token#attrs -> Array
	   *
	   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
	   **/
	  this.attrs    = null;
	
	  /**
	   * Token#map -> Array
	   *
	   * Source map info. Format: `[ line_begin, line_end ]`
	   **/
	  this.map      = null;
	
	  /**
	   * Token#nesting -> Number
	   *
	   * Level change (number in {-1, 0, 1} set), where:
	   *
	   * -  `1` means the tag is opening
	   * -  `0` means the tag is self-closing
	   * - `-1` means the tag is closing
	   **/
	  this.nesting  = nesting;
	
	  /**
	   * Token#level -> Number
	   *
	   * nesting level, the same as `state.level`
	   **/
	  this.level    = 0;
	
	  /**
	   * Token#children -> Array
	   *
	   * An array of child nodes (inline and img tokens)
	   **/
	  this.children = null;
	
	  /**
	   * Token#content -> String
	   *
	   * In a case of self-closing tag (code, html, fence, etc.),
	   * it has contents of this tag.
	   **/
	  this.content  = '';
	
	  /**
	   * Token#markup -> String
	   *
	   * '*' or '_' for emphasis, fence string for fence, etc.
	   **/
	  this.markup   = '';
	
	  /**
	   * Token#info -> String
	   *
	   * fence infostring
	   **/
	  this.info     = '';
	
	  /**
	   * Token#meta -> Object
	   *
	   * A place for plugins to store an arbitrary data
	   **/
	  this.meta     = null;
	
	  /**
	   * Token#block -> Boolean
	   *
	   * True for block-level tokens, false for inline tokens.
	   * Used in renderer to calculate line breaks
	   **/
	  this.block    = false;
	
	  /**
	   * Token#hidden -> Boolean
	   *
	   * If it's true, ignore this element when rendering. Used for tight lists
	   * to hide paragraphs.
	   **/
	  this.hidden   = false;
	}
	
	
	/**
	 * Token.attrIndex(name) -> Number
	 *
	 * Search attribute index by name.
	 **/
	Token.prototype.attrIndex = function attrIndex(name) {
	  var attrs, i, len;
	
	  if (!this.attrs) { return -1; }
	
	  attrs = this.attrs;
	
	  for (i = 0, len = attrs.length; i < len; i++) {
	    if (attrs[i][0] === name) { return i; }
	  }
	  return -1;
	};
	
	
	/**
	 * Token.attrPush(attrData)
	 *
	 * Add `[ name, value ]` attribute to list. Init attrs if necessary
	 **/
	Token.prototype.attrPush = function attrPush(attrData) {
	  if (this.attrs) {
	    this.attrs.push(attrData);
	  } else {
	    this.attrs = [ attrData ];
	  }
	};
	
	
	/**
	 * Token.attrSet(name, value)
	 *
	 * Set `name` attribute to `value`. Override old value if exists.
	 **/
	Token.prototype.attrSet = function attrSet(name, value) {
	  var idx = this.attrIndex(name),
	      attrData = [ name, value ];
	
	  if (idx < 0) {
	    this.attrPush(attrData);
	  } else {
	    this.attrs[idx] = attrData;
	  }
	};
	
	
	/**
	 * Token.attrGet(name)
	 *
	 * Get the value of attribute `name`, or null if it does not exist.
	 **/
	Token.prototype.attrGet = function attrGet(name) {
	  var idx = this.attrIndex(name), value = null;
	  if (idx >= 0) {
	    value = this.attrs[idx][1];
	  }
	  return value;
	};
	
	
	/**
	 * Token.attrJoin(name, value)
	 *
	 * Join value to existing attribute via space. Or create new attribute if not
	 * exists. Useful to operate with token classes.
	 **/
	Token.prototype.attrJoin = function attrJoin(name, value) {
	  var idx = this.attrIndex(name);
	
	  if (idx < 0) {
	    this.attrPush([ name, value ]);
	  } else {
	    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
	  }
	};
	
	
	module.exports = Token;
	
	},{}],52:[function(require,module,exports){
	module.exports={"Aacute":"\u00C1","aacute":"\u00E1","Abreve":"\u0102","abreve":"\u0103","ac":"\u223E","acd":"\u223F","acE":"\u223E\u0333","Acirc":"\u00C2","acirc":"\u00E2","acute":"\u00B4","Acy":"\u0410","acy":"\u0430","AElig":"\u00C6","aelig":"\u00E6","af":"\u2061","Afr":"\uD835\uDD04","afr":"\uD835\uDD1E","Agrave":"\u00C0","agrave":"\u00E0","alefsym":"\u2135","aleph":"\u2135","Alpha":"\u0391","alpha":"\u03B1","Amacr":"\u0100","amacr":"\u0101","amalg":"\u2A3F","amp":"&","AMP":"&","andand":"\u2A55","And":"\u2A53","and":"\u2227","andd":"\u2A5C","andslope":"\u2A58","andv":"\u2A5A","ang":"\u2220","ange":"\u29A4","angle":"\u2220","angmsdaa":"\u29A8","angmsdab":"\u29A9","angmsdac":"\u29AA","angmsdad":"\u29AB","angmsdae":"\u29AC","angmsdaf":"\u29AD","angmsdag":"\u29AE","angmsdah":"\u29AF","angmsd":"\u2221","angrt":"\u221F","angrtvb":"\u22BE","angrtvbd":"\u299D","angsph":"\u2222","angst":"\u00C5","angzarr":"\u237C","Aogon":"\u0104","aogon":"\u0105","Aopf":"\uD835\uDD38","aopf":"\uD835\uDD52","apacir":"\u2A6F","ap":"\u2248","apE":"\u2A70","ape":"\u224A","apid":"\u224B","apos":"'","ApplyFunction":"\u2061","approx":"\u2248","approxeq":"\u224A","Aring":"\u00C5","aring":"\u00E5","Ascr":"\uD835\uDC9C","ascr":"\uD835\uDCB6","Assign":"\u2254","ast":"*","asymp":"\u2248","asympeq":"\u224D","Atilde":"\u00C3","atilde":"\u00E3","Auml":"\u00C4","auml":"\u00E4","awconint":"\u2233","awint":"\u2A11","backcong":"\u224C","backepsilon":"\u03F6","backprime":"\u2035","backsim":"\u223D","backsimeq":"\u22CD","Backslash":"\u2216","Barv":"\u2AE7","barvee":"\u22BD","barwed":"\u2305","Barwed":"\u2306","barwedge":"\u2305","bbrk":"\u23B5","bbrktbrk":"\u23B6","bcong":"\u224C","Bcy":"\u0411","bcy":"\u0431","bdquo":"\u201E","becaus":"\u2235","because":"\u2235","Because":"\u2235","bemptyv":"\u29B0","bepsi":"\u03F6","bernou":"\u212C","Bernoullis":"\u212C","Beta":"\u0392","beta":"\u03B2","beth":"\u2136","between":"\u226C","Bfr":"\uD835\uDD05","bfr":"\uD835\uDD1F","bigcap":"\u22C2","bigcirc":"\u25EF","bigcup":"\u22C3","bigodot":"\u2A00","bigoplus":"\u2A01","bigotimes":"\u2A02","bigsqcup":"\u2A06","bigstar":"\u2605","bigtriangledown":"\u25BD","bigtriangleup":"\u25B3","biguplus":"\u2A04","bigvee":"\u22C1","bigwedge":"\u22C0","bkarow":"\u290D","blacklozenge":"\u29EB","blacksquare":"\u25AA","blacktriangle":"\u25B4","blacktriangledown":"\u25BE","blacktriangleleft":"\u25C2","blacktriangleright":"\u25B8","blank":"\u2423","blk12":"\u2592","blk14":"\u2591","blk34":"\u2593","block":"\u2588","bne":"=\u20E5","bnequiv":"\u2261\u20E5","bNot":"\u2AED","bnot":"\u2310","Bopf":"\uD835\uDD39","bopf":"\uD835\uDD53","bot":"\u22A5","bottom":"\u22A5","bowtie":"\u22C8","boxbox":"\u29C9","boxdl":"\u2510","boxdL":"\u2555","boxDl":"\u2556","boxDL":"\u2557","boxdr":"\u250C","boxdR":"\u2552","boxDr":"\u2553","boxDR":"\u2554","boxh":"\u2500","boxH":"\u2550","boxhd":"\u252C","boxHd":"\u2564","boxhD":"\u2565","boxHD":"\u2566","boxhu":"\u2534","boxHu":"\u2567","boxhU":"\u2568","boxHU":"\u2569","boxminus":"\u229F","boxplus":"\u229E","boxtimes":"\u22A0","boxul":"\u2518","boxuL":"\u255B","boxUl":"\u255C","boxUL":"\u255D","boxur":"\u2514","boxuR":"\u2558","boxUr":"\u2559","boxUR":"\u255A","boxv":"\u2502","boxV":"\u2551","boxvh":"\u253C","boxvH":"\u256A","boxVh":"\u256B","boxVH":"\u256C","boxvl":"\u2524","boxvL":"\u2561","boxVl":"\u2562","boxVL":"\u2563","boxvr":"\u251C","boxvR":"\u255E","boxVr":"\u255F","boxVR":"\u2560","bprime":"\u2035","breve":"\u02D8","Breve":"\u02D8","brvbar":"\u00A6","bscr":"\uD835\uDCB7","Bscr":"\u212C","bsemi":"\u204F","bsim":"\u223D","bsime":"\u22CD","bsolb":"\u29C5","bsol":"\\","bsolhsub":"\u27C8","bull":"\u2022","bullet":"\u2022","bump":"\u224E","bumpE":"\u2AAE","bumpe":"\u224F","Bumpeq":"\u224E","bumpeq":"\u224F","Cacute":"\u0106","cacute":"\u0107","capand":"\u2A44","capbrcup":"\u2A49","capcap":"\u2A4B","cap":"\u2229","Cap":"\u22D2","capcup":"\u2A47","capdot":"\u2A40","CapitalDifferentialD":"\u2145","caps":"\u2229\uFE00","caret":"\u2041","caron":"\u02C7","Cayleys":"\u212D","ccaps":"\u2A4D","Ccaron":"\u010C","ccaron":"\u010D","Ccedil":"\u00C7","ccedil":"\u00E7","Ccirc":"\u0108","ccirc":"\u0109","Cconint":"\u2230","ccups":"\u2A4C","ccupssm":"\u2A50","Cdot":"\u010A","cdot":"\u010B","cedil":"\u00B8","Cedilla":"\u00B8","cemptyv":"\u29B2","cent":"\u00A2","centerdot":"\u00B7","CenterDot":"\u00B7","cfr":"\uD835\uDD20","Cfr":"\u212D","CHcy":"\u0427","chcy":"\u0447","check":"\u2713","checkmark":"\u2713","Chi":"\u03A7","chi":"\u03C7","circ":"\u02C6","circeq":"\u2257","circlearrowleft":"\u21BA","circlearrowright":"\u21BB","circledast":"\u229B","circledcirc":"\u229A","circleddash":"\u229D","CircleDot":"\u2299","circledR":"\u00AE","circledS":"\u24C8","CircleMinus":"\u2296","CirclePlus":"\u2295","CircleTimes":"\u2297","cir":"\u25CB","cirE":"\u29C3","cire":"\u2257","cirfnint":"\u2A10","cirmid":"\u2AEF","cirscir":"\u29C2","ClockwiseContourIntegral":"\u2232","CloseCurlyDoubleQuote":"\u201D","CloseCurlyQuote":"\u2019","clubs":"\u2663","clubsuit":"\u2663","colon":":","Colon":"\u2237","Colone":"\u2A74","colone":"\u2254","coloneq":"\u2254","comma":",","commat":"@","comp":"\u2201","compfn":"\u2218","complement":"\u2201","complexes":"\u2102","cong":"\u2245","congdot":"\u2A6D","Congruent":"\u2261","conint":"\u222E","Conint":"\u222F","ContourIntegral":"\u222E","copf":"\uD835\uDD54","Copf":"\u2102","coprod":"\u2210","Coproduct":"\u2210","copy":"\u00A9","COPY":"\u00A9","copysr":"\u2117","CounterClockwiseContourIntegral":"\u2233","crarr":"\u21B5","cross":"\u2717","Cross":"\u2A2F","Cscr":"\uD835\uDC9E","cscr":"\uD835\uDCB8","csub":"\u2ACF","csube":"\u2AD1","csup":"\u2AD0","csupe":"\u2AD2","ctdot":"\u22EF","cudarrl":"\u2938","cudarrr":"\u2935","cuepr":"\u22DE","cuesc":"\u22DF","cularr":"\u21B6","cularrp":"\u293D","cupbrcap":"\u2A48","cupcap":"\u2A46","CupCap":"\u224D","cup":"\u222A","Cup":"\u22D3","cupcup":"\u2A4A","cupdot":"\u228D","cupor":"\u2A45","cups":"\u222A\uFE00","curarr":"\u21B7","curarrm":"\u293C","curlyeqprec":"\u22DE","curlyeqsucc":"\u22DF","curlyvee":"\u22CE","curlywedge":"\u22CF","curren":"\u00A4","curvearrowleft":"\u21B6","curvearrowright":"\u21B7","cuvee":"\u22CE","cuwed":"\u22CF","cwconint":"\u2232","cwint":"\u2231","cylcty":"\u232D","dagger":"\u2020","Dagger":"\u2021","daleth":"\u2138","darr":"\u2193","Darr":"\u21A1","dArr":"\u21D3","dash":"\u2010","Dashv":"\u2AE4","dashv":"\u22A3","dbkarow":"\u290F","dblac":"\u02DD","Dcaron":"\u010E","dcaron":"\u010F","Dcy":"\u0414","dcy":"\u0434","ddagger":"\u2021","ddarr":"\u21CA","DD":"\u2145","dd":"\u2146","DDotrahd":"\u2911","ddotseq":"\u2A77","deg":"\u00B0","Del":"\u2207","Delta":"\u0394","delta":"\u03B4","demptyv":"\u29B1","dfisht":"\u297F","Dfr":"\uD835\uDD07","dfr":"\uD835\uDD21","dHar":"\u2965","dharl":"\u21C3","dharr":"\u21C2","DiacriticalAcute":"\u00B4","DiacriticalDot":"\u02D9","DiacriticalDoubleAcute":"\u02DD","DiacriticalGrave":"`","DiacriticalTilde":"\u02DC","diam":"\u22C4","diamond":"\u22C4","Diamond":"\u22C4","diamondsuit":"\u2666","diams":"\u2666","die":"\u00A8","DifferentialD":"\u2146","digamma":"\u03DD","disin":"\u22F2","div":"\u00F7","divide":"\u00F7","divideontimes":"\u22C7","divonx":"\u22C7","DJcy":"\u0402","djcy":"\u0452","dlcorn":"\u231E","dlcrop":"\u230D","dollar":"$","Dopf":"\uD835\uDD3B","dopf":"\uD835\uDD55","Dot":"\u00A8","dot":"\u02D9","DotDot":"\u20DC","doteq":"\u2250","doteqdot":"\u2251","DotEqual":"\u2250","dotminus":"\u2238","dotplus":"\u2214","dotsquare":"\u22A1","doublebarwedge":"\u2306","DoubleContourIntegral":"\u222F","DoubleDot":"\u00A8","DoubleDownArrow":"\u21D3","DoubleLeftArrow":"\u21D0","DoubleLeftRightArrow":"\u21D4","DoubleLeftTee":"\u2AE4","DoubleLongLeftArrow":"\u27F8","DoubleLongLeftRightArrow":"\u27FA","DoubleLongRightArrow":"\u27F9","DoubleRightArrow":"\u21D2","DoubleRightTee":"\u22A8","DoubleUpArrow":"\u21D1","DoubleUpDownArrow":"\u21D5","DoubleVerticalBar":"\u2225","DownArrowBar":"\u2913","downarrow":"\u2193","DownArrow":"\u2193","Downarrow":"\u21D3","DownArrowUpArrow":"\u21F5","DownBreve":"\u0311","downdownarrows":"\u21CA","downharpoonleft":"\u21C3","downharpoonright":"\u21C2","DownLeftRightVector":"\u2950","DownLeftTeeVector":"\u295E","DownLeftVectorBar":"\u2956","DownLeftVector":"\u21BD","DownRightTeeVector":"\u295F","DownRightVectorBar":"\u2957","DownRightVector":"\u21C1","DownTeeArrow":"\u21A7","DownTee":"\u22A4","drbkarow":"\u2910","drcorn":"\u231F","drcrop":"\u230C","Dscr":"\uD835\uDC9F","dscr":"\uD835\uDCB9","DScy":"\u0405","dscy":"\u0455","dsol":"\u29F6","Dstrok":"\u0110","dstrok":"\u0111","dtdot":"\u22F1","dtri":"\u25BF","dtrif":"\u25BE","duarr":"\u21F5","duhar":"\u296F","dwangle":"\u29A6","DZcy":"\u040F","dzcy":"\u045F","dzigrarr":"\u27FF","Eacute":"\u00C9","eacute":"\u00E9","easter":"\u2A6E","Ecaron":"\u011A","ecaron":"\u011B","Ecirc":"\u00CA","ecirc":"\u00EA","ecir":"\u2256","ecolon":"\u2255","Ecy":"\u042D","ecy":"\u044D","eDDot":"\u2A77","Edot":"\u0116","edot":"\u0117","eDot":"\u2251","ee":"\u2147","efDot":"\u2252","Efr":"\uD835\uDD08","efr":"\uD835\uDD22","eg":"\u2A9A","Egrave":"\u00C8","egrave":"\u00E8","egs":"\u2A96","egsdot":"\u2A98","el":"\u2A99","Element":"\u2208","elinters":"\u23E7","ell":"\u2113","els":"\u2A95","elsdot":"\u2A97","Emacr":"\u0112","emacr":"\u0113","empty":"\u2205","emptyset":"\u2205","EmptySmallSquare":"\u25FB","emptyv":"\u2205","EmptyVerySmallSquare":"\u25AB","emsp13":"\u2004","emsp14":"\u2005","emsp":"\u2003","ENG":"\u014A","eng":"\u014B","ensp":"\u2002","Eogon":"\u0118","eogon":"\u0119","Eopf":"\uD835\uDD3C","eopf":"\uD835\uDD56","epar":"\u22D5","eparsl":"\u29E3","eplus":"\u2A71","epsi":"\u03B5","Epsilon":"\u0395","epsilon":"\u03B5","epsiv":"\u03F5","eqcirc":"\u2256","eqcolon":"\u2255","eqsim":"\u2242","eqslantgtr":"\u2A96","eqslantless":"\u2A95","Equal":"\u2A75","equals":"=","EqualTilde":"\u2242","equest":"\u225F","Equilibrium":"\u21CC","equiv":"\u2261","equivDD":"\u2A78","eqvparsl":"\u29E5","erarr":"\u2971","erDot":"\u2253","escr":"\u212F","Escr":"\u2130","esdot":"\u2250","Esim":"\u2A73","esim":"\u2242","Eta":"\u0397","eta":"\u03B7","ETH":"\u00D0","eth":"\u00F0","Euml":"\u00CB","euml":"\u00EB","euro":"\u20AC","excl":"!","exist":"\u2203","Exists":"\u2203","expectation":"\u2130","exponentiale":"\u2147","ExponentialE":"\u2147","fallingdotseq":"\u2252","Fcy":"\u0424","fcy":"\u0444","female":"\u2640","ffilig":"\uFB03","fflig":"\uFB00","ffllig":"\uFB04","Ffr":"\uD835\uDD09","ffr":"\uD835\uDD23","filig":"\uFB01","FilledSmallSquare":"\u25FC","FilledVerySmallSquare":"\u25AA","fjlig":"fj","flat":"\u266D","fllig":"\uFB02","fltns":"\u25B1","fnof":"\u0192","Fopf":"\uD835\uDD3D","fopf":"\uD835\uDD57","forall":"\u2200","ForAll":"\u2200","fork":"\u22D4","forkv":"\u2AD9","Fouriertrf":"\u2131","fpartint":"\u2A0D","frac12":"\u00BD","frac13":"\u2153","frac14":"\u00BC","frac15":"\u2155","frac16":"\u2159","frac18":"\u215B","frac23":"\u2154","frac25":"\u2156","frac34":"\u00BE","frac35":"\u2157","frac38":"\u215C","frac45":"\u2158","frac56":"\u215A","frac58":"\u215D","frac78":"\u215E","frasl":"\u2044","frown":"\u2322","fscr":"\uD835\uDCBB","Fscr":"\u2131","gacute":"\u01F5","Gamma":"\u0393","gamma":"\u03B3","Gammad":"\u03DC","gammad":"\u03DD","gap":"\u2A86","Gbreve":"\u011E","gbreve":"\u011F","Gcedil":"\u0122","Gcirc":"\u011C","gcirc":"\u011D","Gcy":"\u0413","gcy":"\u0433","Gdot":"\u0120","gdot":"\u0121","ge":"\u2265","gE":"\u2267","gEl":"\u2A8C","gel":"\u22DB","geq":"\u2265","geqq":"\u2267","geqslant":"\u2A7E","gescc":"\u2AA9","ges":"\u2A7E","gesdot":"\u2A80","gesdoto":"\u2A82","gesdotol":"\u2A84","gesl":"\u22DB\uFE00","gesles":"\u2A94","Gfr":"\uD835\uDD0A","gfr":"\uD835\uDD24","gg":"\u226B","Gg":"\u22D9","ggg":"\u22D9","gimel":"\u2137","GJcy":"\u0403","gjcy":"\u0453","gla":"\u2AA5","gl":"\u2277","glE":"\u2A92","glj":"\u2AA4","gnap":"\u2A8A","gnapprox":"\u2A8A","gne":"\u2A88","gnE":"\u2269","gneq":"\u2A88","gneqq":"\u2269","gnsim":"\u22E7","Gopf":"\uD835\uDD3E","gopf":"\uD835\uDD58","grave":"`","GreaterEqual":"\u2265","GreaterEqualLess":"\u22DB","GreaterFullEqual":"\u2267","GreaterGreater":"\u2AA2","GreaterLess":"\u2277","GreaterSlantEqual":"\u2A7E","GreaterTilde":"\u2273","Gscr":"\uD835\uDCA2","gscr":"\u210A","gsim":"\u2273","gsime":"\u2A8E","gsiml":"\u2A90","gtcc":"\u2AA7","gtcir":"\u2A7A","gt":">","GT":">","Gt":"\u226B","gtdot":"\u22D7","gtlPar":"\u2995","gtquest":"\u2A7C","gtrapprox":"\u2A86","gtrarr":"\u2978","gtrdot":"\u22D7","gtreqless":"\u22DB","gtreqqless":"\u2A8C","gtrless":"\u2277","gtrsim":"\u2273","gvertneqq":"\u2269\uFE00","gvnE":"\u2269\uFE00","Hacek":"\u02C7","hairsp":"\u200A","half":"\u00BD","hamilt":"\u210B","HARDcy":"\u042A","hardcy":"\u044A","harrcir":"\u2948","harr":"\u2194","hArr":"\u21D4","harrw":"\u21AD","Hat":"^","hbar":"\u210F","Hcirc":"\u0124","hcirc":"\u0125","hearts":"\u2665","heartsuit":"\u2665","hellip":"\u2026","hercon":"\u22B9","hfr":"\uD835\uDD25","Hfr":"\u210C","HilbertSpace":"\u210B","hksearow":"\u2925","hkswarow":"\u2926","hoarr":"\u21FF","homtht":"\u223B","hookleftarrow":"\u21A9","hookrightarrow":"\u21AA","hopf":"\uD835\uDD59","Hopf":"\u210D","horbar":"\u2015","HorizontalLine":"\u2500","hscr":"\uD835\uDCBD","Hscr":"\u210B","hslash":"\u210F","Hstrok":"\u0126","hstrok":"\u0127","HumpDownHump":"\u224E","HumpEqual":"\u224F","hybull":"\u2043","hyphen":"\u2010","Iacute":"\u00CD","iacute":"\u00ED","ic":"\u2063","Icirc":"\u00CE","icirc":"\u00EE","Icy":"\u0418","icy":"\u0438","Idot":"\u0130","IEcy":"\u0415","iecy":"\u0435","iexcl":"\u00A1","iff":"\u21D4","ifr":"\uD835\uDD26","Ifr":"\u2111","Igrave":"\u00CC","igrave":"\u00EC","ii":"\u2148","iiiint":"\u2A0C","iiint":"\u222D","iinfin":"\u29DC","iiota":"\u2129","IJlig":"\u0132","ijlig":"\u0133","Imacr":"\u012A","imacr":"\u012B","image":"\u2111","ImaginaryI":"\u2148","imagline":"\u2110","imagpart":"\u2111","imath":"\u0131","Im":"\u2111","imof":"\u22B7","imped":"\u01B5","Implies":"\u21D2","incare":"\u2105","in":"\u2208","infin":"\u221E","infintie":"\u29DD","inodot":"\u0131","intcal":"\u22BA","int":"\u222B","Int":"\u222C","integers":"\u2124","Integral":"\u222B","intercal":"\u22BA","Intersection":"\u22C2","intlarhk":"\u2A17","intprod":"\u2A3C","InvisibleComma":"\u2063","InvisibleTimes":"\u2062","IOcy":"\u0401","iocy":"\u0451","Iogon":"\u012E","iogon":"\u012F","Iopf":"\uD835\uDD40","iopf":"\uD835\uDD5A","Iota":"\u0399","iota":"\u03B9","iprod":"\u2A3C","iquest":"\u00BF","iscr":"\uD835\uDCBE","Iscr":"\u2110","isin":"\u2208","isindot":"\u22F5","isinE":"\u22F9","isins":"\u22F4","isinsv":"\u22F3","isinv":"\u2208","it":"\u2062","Itilde":"\u0128","itilde":"\u0129","Iukcy":"\u0406","iukcy":"\u0456","Iuml":"\u00CF","iuml":"\u00EF","Jcirc":"\u0134","jcirc":"\u0135","Jcy":"\u0419","jcy":"\u0439","Jfr":"\uD835\uDD0D","jfr":"\uD835\uDD27","jmath":"\u0237","Jopf":"\uD835\uDD41","jopf":"\uD835\uDD5B","Jscr":"\uD835\uDCA5","jscr":"\uD835\uDCBF","Jsercy":"\u0408","jsercy":"\u0458","Jukcy":"\u0404","jukcy":"\u0454","Kappa":"\u039A","kappa":"\u03BA","kappav":"\u03F0","Kcedil":"\u0136","kcedil":"\u0137","Kcy":"\u041A","kcy":"\u043A","Kfr":"\uD835\uDD0E","kfr":"\uD835\uDD28","kgreen":"\u0138","KHcy":"\u0425","khcy":"\u0445","KJcy":"\u040C","kjcy":"\u045C","Kopf":"\uD835\uDD42","kopf":"\uD835\uDD5C","Kscr":"\uD835\uDCA6","kscr":"\uD835\uDCC0","lAarr":"\u21DA","Lacute":"\u0139","lacute":"\u013A","laemptyv":"\u29B4","lagran":"\u2112","Lambda":"\u039B","lambda":"\u03BB","lang":"\u27E8","Lang":"\u27EA","langd":"\u2991","langle":"\u27E8","lap":"\u2A85","Laplacetrf":"\u2112","laquo":"\u00AB","larrb":"\u21E4","larrbfs":"\u291F","larr":"\u2190","Larr":"\u219E","lArr":"\u21D0","larrfs":"\u291D","larrhk":"\u21A9","larrlp":"\u21AB","larrpl":"\u2939","larrsim":"\u2973","larrtl":"\u21A2","latail":"\u2919","lAtail":"\u291B","lat":"\u2AAB","late":"\u2AAD","lates":"\u2AAD\uFE00","lbarr":"\u290C","lBarr":"\u290E","lbbrk":"\u2772","lbrace":"{","lbrack":"[","lbrke":"\u298B","lbrksld":"\u298F","lbrkslu":"\u298D","Lcaron":"\u013D","lcaron":"\u013E","Lcedil":"\u013B","lcedil":"\u013C","lceil":"\u2308","lcub":"{","Lcy":"\u041B","lcy":"\u043B","ldca":"\u2936","ldquo":"\u201C","ldquor":"\u201E","ldrdhar":"\u2967","ldrushar":"\u294B","ldsh":"\u21B2","le":"\u2264","lE":"\u2266","LeftAngleBracket":"\u27E8","LeftArrowBar":"\u21E4","leftarrow":"\u2190","LeftArrow":"\u2190","Leftarrow":"\u21D0","LeftArrowRightArrow":"\u21C6","leftarrowtail":"\u21A2","LeftCeiling":"\u2308","LeftDoubleBracket":"\u27E6","LeftDownTeeVector":"\u2961","LeftDownVectorBar":"\u2959","LeftDownVector":"\u21C3","LeftFloor":"\u230A","leftharpoondown":"\u21BD","leftharpoonup":"\u21BC","leftleftarrows":"\u21C7","leftrightarrow":"\u2194","LeftRightArrow":"\u2194","Leftrightarrow":"\u21D4","leftrightarrows":"\u21C6","leftrightharpoons":"\u21CB","leftrightsquigarrow":"\u21AD","LeftRightVector":"\u294E","LeftTeeArrow":"\u21A4","LeftTee":"\u22A3","LeftTeeVector":"\u295A","leftthreetimes":"\u22CB","LeftTriangleBar":"\u29CF","LeftTriangle":"\u22B2","LeftTriangleEqual":"\u22B4","LeftUpDownVector":"\u2951","LeftUpTeeVector":"\u2960","LeftUpVectorBar":"\u2958","LeftUpVector":"\u21BF","LeftVectorBar":"\u2952","LeftVector":"\u21BC","lEg":"\u2A8B","leg":"\u22DA","leq":"\u2264","leqq":"\u2266","leqslant":"\u2A7D","lescc":"\u2AA8","les":"\u2A7D","lesdot":"\u2A7F","lesdoto":"\u2A81","lesdotor":"\u2A83","lesg":"\u22DA\uFE00","lesges":"\u2A93","lessapprox":"\u2A85","lessdot":"\u22D6","lesseqgtr":"\u22DA","lesseqqgtr":"\u2A8B","LessEqualGreater":"\u22DA","LessFullEqual":"\u2266","LessGreater":"\u2276","lessgtr":"\u2276","LessLess":"\u2AA1","lesssim":"\u2272","LessSlantEqual":"\u2A7D","LessTilde":"\u2272","lfisht":"\u297C","lfloor":"\u230A","Lfr":"\uD835\uDD0F","lfr":"\uD835\uDD29","lg":"\u2276","lgE":"\u2A91","lHar":"\u2962","lhard":"\u21BD","lharu":"\u21BC","lharul":"\u296A","lhblk":"\u2584","LJcy":"\u0409","ljcy":"\u0459","llarr":"\u21C7","ll":"\u226A","Ll":"\u22D8","llcorner":"\u231E","Lleftarrow":"\u21DA","llhard":"\u296B","lltri":"\u25FA","Lmidot":"\u013F","lmidot":"\u0140","lmoustache":"\u23B0","lmoust":"\u23B0","lnap":"\u2A89","lnapprox":"\u2A89","lne":"\u2A87","lnE":"\u2268","lneq":"\u2A87","lneqq":"\u2268","lnsim":"\u22E6","loang":"\u27EC","loarr":"\u21FD","lobrk":"\u27E6","longleftarrow":"\u27F5","LongLeftArrow":"\u27F5","Longleftarrow":"\u27F8","longleftrightarrow":"\u27F7","LongLeftRightArrow":"\u27F7","Longleftrightarrow":"\u27FA","longmapsto":"\u27FC","longrightarrow":"\u27F6","LongRightArrow":"\u27F6","Longrightarrow":"\u27F9","looparrowleft":"\u21AB","looparrowright":"\u21AC","lopar":"\u2985","Lopf":"\uD835\uDD43","lopf":"\uD835\uDD5D","loplus":"\u2A2D","lotimes":"\u2A34","lowast":"\u2217","lowbar":"_","LowerLeftArrow":"\u2199","LowerRightArrow":"\u2198","loz":"\u25CA","lozenge":"\u25CA","lozf":"\u29EB","lpar":"(","lparlt":"\u2993","lrarr":"\u21C6","lrcorner":"\u231F","lrhar":"\u21CB","lrhard":"\u296D","lrm":"\u200E","lrtri":"\u22BF","lsaquo":"\u2039","lscr":"\uD835\uDCC1","Lscr":"\u2112","lsh":"\u21B0","Lsh":"\u21B0","lsim":"\u2272","lsime":"\u2A8D","lsimg":"\u2A8F","lsqb":"[","lsquo":"\u2018","lsquor":"\u201A","Lstrok":"\u0141","lstrok":"\u0142","ltcc":"\u2AA6","ltcir":"\u2A79","lt":"<","LT":"<","Lt":"\u226A","ltdot":"\u22D6","lthree":"\u22CB","ltimes":"\u22C9","ltlarr":"\u2976","ltquest":"\u2A7B","ltri":"\u25C3","ltrie":"\u22B4","ltrif":"\u25C2","ltrPar":"\u2996","lurdshar":"\u294A","luruhar":"\u2966","lvertneqq":"\u2268\uFE00","lvnE":"\u2268\uFE00","macr":"\u00AF","male":"\u2642","malt":"\u2720","maltese":"\u2720","Map":"\u2905","map":"\u21A6","mapsto":"\u21A6","mapstodown":"\u21A7","mapstoleft":"\u21A4","mapstoup":"\u21A5","marker":"\u25AE","mcomma":"\u2A29","Mcy":"\u041C","mcy":"\u043C","mdash":"\u2014","mDDot":"\u223A","measuredangle":"\u2221","MediumSpace":"\u205F","Mellintrf":"\u2133","Mfr":"\uD835\uDD10","mfr":"\uD835\uDD2A","mho":"\u2127","micro":"\u00B5","midast":"*","midcir":"\u2AF0","mid":"\u2223","middot":"\u00B7","minusb":"\u229F","minus":"\u2212","minusd":"\u2238","minusdu":"\u2A2A","MinusPlus":"\u2213","mlcp":"\u2ADB","mldr":"\u2026","mnplus":"\u2213","models":"\u22A7","Mopf":"\uD835\uDD44","mopf":"\uD835\uDD5E","mp":"\u2213","mscr":"\uD835\uDCC2","Mscr":"\u2133","mstpos":"\u223E","Mu":"\u039C","mu":"\u03BC","multimap":"\u22B8","mumap":"\u22B8","nabla":"\u2207","Nacute":"\u0143","nacute":"\u0144","nang":"\u2220\u20D2","nap":"\u2249","napE":"\u2A70\u0338","napid":"\u224B\u0338","napos":"\u0149","napprox":"\u2249","natural":"\u266E","naturals":"\u2115","natur":"\u266E","nbsp":"\u00A0","nbump":"\u224E\u0338","nbumpe":"\u224F\u0338","ncap":"\u2A43","Ncaron":"\u0147","ncaron":"\u0148","Ncedil":"\u0145","ncedil":"\u0146","ncong":"\u2247","ncongdot":"\u2A6D\u0338","ncup":"\u2A42","Ncy":"\u041D","ncy":"\u043D","ndash":"\u2013","nearhk":"\u2924","nearr":"\u2197","neArr":"\u21D7","nearrow":"\u2197","ne":"\u2260","nedot":"\u2250\u0338","NegativeMediumSpace":"\u200B","NegativeThickSpace":"\u200B","NegativeThinSpace":"\u200B","NegativeVeryThinSpace":"\u200B","nequiv":"\u2262","nesear":"\u2928","nesim":"\u2242\u0338","NestedGreaterGreater":"\u226B","NestedLessLess":"\u226A","NewLine":"\n","nexist":"\u2204","nexists":"\u2204","Nfr":"\uD835\uDD11","nfr":"\uD835\uDD2B","ngE":"\u2267\u0338","nge":"\u2271","ngeq":"\u2271","ngeqq":"\u2267\u0338","ngeqslant":"\u2A7E\u0338","nges":"\u2A7E\u0338","nGg":"\u22D9\u0338","ngsim":"\u2275","nGt":"\u226B\u20D2","ngt":"\u226F","ngtr":"\u226F","nGtv":"\u226B\u0338","nharr":"\u21AE","nhArr":"\u21CE","nhpar":"\u2AF2","ni":"\u220B","nis":"\u22FC","nisd":"\u22FA","niv":"\u220B","NJcy":"\u040A","njcy":"\u045A","nlarr":"\u219A","nlArr":"\u21CD","nldr":"\u2025","nlE":"\u2266\u0338","nle":"\u2270","nleftarrow":"\u219A","nLeftarrow":"\u21CD","nleftrightarrow":"\u21AE","nLeftrightarrow":"\u21CE","nleq":"\u2270","nleqq":"\u2266\u0338","nleqslant":"\u2A7D\u0338","nles":"\u2A7D\u0338","nless":"\u226E","nLl":"\u22D8\u0338","nlsim":"\u2274","nLt":"\u226A\u20D2","nlt":"\u226E","nltri":"\u22EA","nltrie":"\u22EC","nLtv":"\u226A\u0338","nmid":"\u2224","NoBreak":"\u2060","NonBreakingSpace":"\u00A0","nopf":"\uD835\uDD5F","Nopf":"\u2115","Not":"\u2AEC","not":"\u00AC","NotCongruent":"\u2262","NotCupCap":"\u226D","NotDoubleVerticalBar":"\u2226","NotElement":"\u2209","NotEqual":"\u2260","NotEqualTilde":"\u2242\u0338","NotExists":"\u2204","NotGreater":"\u226F","NotGreaterEqual":"\u2271","NotGreaterFullEqual":"\u2267\u0338","NotGreaterGreater":"\u226B\u0338","NotGreaterLess":"\u2279","NotGreaterSlantEqual":"\u2A7E\u0338","NotGreaterTilde":"\u2275","NotHumpDownHump":"\u224E\u0338","NotHumpEqual":"\u224F\u0338","notin":"\u2209","notindot":"\u22F5\u0338","notinE":"\u22F9\u0338","notinva":"\u2209","notinvb":"\u22F7","notinvc":"\u22F6","NotLeftTriangleBar":"\u29CF\u0338","NotLeftTriangle":"\u22EA","NotLeftTriangleEqual":"\u22EC","NotLess":"\u226E","NotLessEqual":"\u2270","NotLessGreater":"\u2278","NotLessLess":"\u226A\u0338","NotLessSlantEqual":"\u2A7D\u0338","NotLessTilde":"\u2274","NotNestedGreaterGreater":"\u2AA2\u0338","NotNestedLessLess":"\u2AA1\u0338","notni":"\u220C","notniva":"\u220C","notnivb":"\u22FE","notnivc":"\u22FD","NotPrecedes":"\u2280","NotPrecedesEqual":"\u2AAF\u0338","NotPrecedesSlantEqual":"\u22E0","NotReverseElement":"\u220C","NotRightTriangleBar":"\u29D0\u0338","NotRightTriangle":"\u22EB","NotRightTriangleEqual":"\u22ED","NotSquareSubset":"\u228F\u0338","NotSquareSubsetEqual":"\u22E2","NotSquareSuperset":"\u2290\u0338","NotSquareSupersetEqual":"\u22E3","NotSubset":"\u2282\u20D2","NotSubsetEqual":"\u2288","NotSucceeds":"\u2281","NotSucceedsEqual":"\u2AB0\u0338","NotSucceedsSlantEqual":"\u22E1","NotSucceedsTilde":"\u227F\u0338","NotSuperset":"\u2283\u20D2","NotSupersetEqual":"\u2289","NotTilde":"\u2241","NotTildeEqual":"\u2244","NotTildeFullEqual":"\u2247","NotTildeTilde":"\u2249","NotVerticalBar":"\u2224","nparallel":"\u2226","npar":"\u2226","nparsl":"\u2AFD\u20E5","npart":"\u2202\u0338","npolint":"\u2A14","npr":"\u2280","nprcue":"\u22E0","nprec":"\u2280","npreceq":"\u2AAF\u0338","npre":"\u2AAF\u0338","nrarrc":"\u2933\u0338","nrarr":"\u219B","nrArr":"\u21CF","nrarrw":"\u219D\u0338","nrightarrow":"\u219B","nRightarrow":"\u21CF","nrtri":"\u22EB","nrtrie":"\u22ED","nsc":"\u2281","nsccue":"\u22E1","nsce":"\u2AB0\u0338","Nscr":"\uD835\uDCA9","nscr":"\uD835\uDCC3","nshortmid":"\u2224","nshortparallel":"\u2226","nsim":"\u2241","nsime":"\u2244","nsimeq":"\u2244","nsmid":"\u2224","nspar":"\u2226","nsqsube":"\u22E2","nsqsupe":"\u22E3","nsub":"\u2284","nsubE":"\u2AC5\u0338","nsube":"\u2288","nsubset":"\u2282\u20D2","nsubseteq":"\u2288","nsubseteqq":"\u2AC5\u0338","nsucc":"\u2281","nsucceq":"\u2AB0\u0338","nsup":"\u2285","nsupE":"\u2AC6\u0338","nsupe":"\u2289","nsupset":"\u2283\u20D2","nsupseteq":"\u2289","nsupseteqq":"\u2AC6\u0338","ntgl":"\u2279","Ntilde":"\u00D1","ntilde":"\u00F1","ntlg":"\u2278","ntriangleleft":"\u22EA","ntrianglelefteq":"\u22EC","ntriangleright":"\u22EB","ntrianglerighteq":"\u22ED","Nu":"\u039D","nu":"\u03BD","num":"#","numero":"\u2116","numsp":"\u2007","nvap":"\u224D\u20D2","nvdash":"\u22AC","nvDash":"\u22AD","nVdash":"\u22AE","nVDash":"\u22AF","nvge":"\u2265\u20D2","nvgt":">\u20D2","nvHarr":"\u2904","nvinfin":"\u29DE","nvlArr":"\u2902","nvle":"\u2264\u20D2","nvlt":"<\u20D2","nvltrie":"\u22B4\u20D2","nvrArr":"\u2903","nvrtrie":"\u22B5\u20D2","nvsim":"\u223C\u20D2","nwarhk":"\u2923","nwarr":"\u2196","nwArr":"\u21D6","nwarrow":"\u2196","nwnear":"\u2927","Oacute":"\u00D3","oacute":"\u00F3","oast":"\u229B","Ocirc":"\u00D4","ocirc":"\u00F4","ocir":"\u229A","Ocy":"\u041E","ocy":"\u043E","odash":"\u229D","Odblac":"\u0150","odblac":"\u0151","odiv":"\u2A38","odot":"\u2299","odsold":"\u29BC","OElig":"\u0152","oelig":"\u0153","ofcir":"\u29BF","Ofr":"\uD835\uDD12","ofr":"\uD835\uDD2C","ogon":"\u02DB","Ograve":"\u00D2","ograve":"\u00F2","ogt":"\u29C1","ohbar":"\u29B5","ohm":"\u03A9","oint":"\u222E","olarr":"\u21BA","olcir":"\u29BE","olcross":"\u29BB","oline":"\u203E","olt":"\u29C0","Omacr":"\u014C","omacr":"\u014D","Omega":"\u03A9","omega":"\u03C9","Omicron":"\u039F","omicron":"\u03BF","omid":"\u29B6","ominus":"\u2296","Oopf":"\uD835\uDD46","oopf":"\uD835\uDD60","opar":"\u29B7","OpenCurlyDoubleQuote":"\u201C","OpenCurlyQuote":"\u2018","operp":"\u29B9","oplus":"\u2295","orarr":"\u21BB","Or":"\u2A54","or":"\u2228","ord":"\u2A5D","order":"\u2134","orderof":"\u2134","ordf":"\u00AA","ordm":"\u00BA","origof":"\u22B6","oror":"\u2A56","orslope":"\u2A57","orv":"\u2A5B","oS":"\u24C8","Oscr":"\uD835\uDCAA","oscr":"\u2134","Oslash":"\u00D8","oslash":"\u00F8","osol":"\u2298","Otilde":"\u00D5","otilde":"\u00F5","otimesas":"\u2A36","Otimes":"\u2A37","otimes":"\u2297","Ouml":"\u00D6","ouml":"\u00F6","ovbar":"\u233D","OverBar":"\u203E","OverBrace":"\u23DE","OverBracket":"\u23B4","OverParenthesis":"\u23DC","para":"\u00B6","parallel":"\u2225","par":"\u2225","parsim":"\u2AF3","parsl":"\u2AFD","part":"\u2202","PartialD":"\u2202","Pcy":"\u041F","pcy":"\u043F","percnt":"%","period":".","permil":"\u2030","perp":"\u22A5","pertenk":"\u2031","Pfr":"\uD835\uDD13","pfr":"\uD835\uDD2D","Phi":"\u03A6","phi":"\u03C6","phiv":"\u03D5","phmmat":"\u2133","phone":"\u260E","Pi":"\u03A0","pi":"\u03C0","pitchfork":"\u22D4","piv":"\u03D6","planck":"\u210F","planckh":"\u210E","plankv":"\u210F","plusacir":"\u2A23","plusb":"\u229E","pluscir":"\u2A22","plus":"+","plusdo":"\u2214","plusdu":"\u2A25","pluse":"\u2A72","PlusMinus":"\u00B1","plusmn":"\u00B1","plussim":"\u2A26","plustwo":"\u2A27","pm":"\u00B1","Poincareplane":"\u210C","pointint":"\u2A15","popf":"\uD835\uDD61","Popf":"\u2119","pound":"\u00A3","prap":"\u2AB7","Pr":"\u2ABB","pr":"\u227A","prcue":"\u227C","precapprox":"\u2AB7","prec":"\u227A","preccurlyeq":"\u227C","Precedes":"\u227A","PrecedesEqual":"\u2AAF","PrecedesSlantEqual":"\u227C","PrecedesTilde":"\u227E","preceq":"\u2AAF","precnapprox":"\u2AB9","precneqq":"\u2AB5","precnsim":"\u22E8","pre":"\u2AAF","prE":"\u2AB3","precsim":"\u227E","prime":"\u2032","Prime":"\u2033","primes":"\u2119","prnap":"\u2AB9","prnE":"\u2AB5","prnsim":"\u22E8","prod":"\u220F","Product":"\u220F","profalar":"\u232E","profline":"\u2312","profsurf":"\u2313","prop":"\u221D","Proportional":"\u221D","Proportion":"\u2237","propto":"\u221D","prsim":"\u227E","prurel":"\u22B0","Pscr":"\uD835\uDCAB","pscr":"\uD835\uDCC5","Psi":"\u03A8","psi":"\u03C8","puncsp":"\u2008","Qfr":"\uD835\uDD14","qfr":"\uD835\uDD2E","qint":"\u2A0C","qopf":"\uD835\uDD62","Qopf":"\u211A","qprime":"\u2057","Qscr":"\uD835\uDCAC","qscr":"\uD835\uDCC6","quaternions":"\u210D","quatint":"\u2A16","quest":"?","questeq":"\u225F","quot":"\"","QUOT":"\"","rAarr":"\u21DB","race":"\u223D\u0331","Racute":"\u0154","racute":"\u0155","radic":"\u221A","raemptyv":"\u29B3","rang":"\u27E9","Rang":"\u27EB","rangd":"\u2992","range":"\u29A5","rangle":"\u27E9","raquo":"\u00BB","rarrap":"\u2975","rarrb":"\u21E5","rarrbfs":"\u2920","rarrc":"\u2933","rarr":"\u2192","Rarr":"\u21A0","rArr":"\u21D2","rarrfs":"\u291E","rarrhk":"\u21AA","rarrlp":"\u21AC","rarrpl":"\u2945","rarrsim":"\u2974","Rarrtl":"\u2916","rarrtl":"\u21A3","rarrw":"\u219D","ratail":"\u291A","rAtail":"\u291C","ratio":"\u2236","rationals":"\u211A","rbarr":"\u290D","rBarr":"\u290F","RBarr":"\u2910","rbbrk":"\u2773","rbrace":"}","rbrack":"]","rbrke":"\u298C","rbrksld":"\u298E","rbrkslu":"\u2990","Rcaron":"\u0158","rcaron":"\u0159","Rcedil":"\u0156","rcedil":"\u0157","rceil":"\u2309","rcub":"}","Rcy":"\u0420","rcy":"\u0440","rdca":"\u2937","rdldhar":"\u2969","rdquo":"\u201D","rdquor":"\u201D","rdsh":"\u21B3","real":"\u211C","realine":"\u211B","realpart":"\u211C","reals":"\u211D","Re":"\u211C","rect":"\u25AD","reg":"\u00AE","REG":"\u00AE","ReverseElement":"\u220B","ReverseEquilibrium":"\u21CB","ReverseUpEquilibrium":"\u296F","rfisht":"\u297D","rfloor":"\u230B","rfr":"\uD835\uDD2F","Rfr":"\u211C","rHar":"\u2964","rhard":"\u21C1","rharu":"\u21C0","rharul":"\u296C","Rho":"\u03A1","rho":"\u03C1","rhov":"\u03F1","RightAngleBracket":"\u27E9","RightArrowBar":"\u21E5","rightarrow":"\u2192","RightArrow":"\u2192","Rightarrow":"\u21D2","RightArrowLeftArrow":"\u21C4","rightarrowtail":"\u21A3","RightCeiling":"\u2309","RightDoubleBracket":"\u27E7","RightDownTeeVector":"\u295D","RightDownVectorBar":"\u2955","RightDownVector":"\u21C2","RightFloor":"\u230B","rightharpoondown":"\u21C1","rightharpoonup":"\u21C0","rightleftarrows":"\u21C4","rightleftharpoons":"\u21CC","rightrightarrows":"\u21C9","rightsquigarrow":"\u219D","RightTeeArrow":"\u21A6","RightTee":"\u22A2","RightTeeVector":"\u295B","rightthreetimes":"\u22CC","RightTriangleBar":"\u29D0","RightTriangle":"\u22B3","RightTriangleEqual":"\u22B5","RightUpDownVector":"\u294F","RightUpTeeVector":"\u295C","RightUpVectorBar":"\u2954","RightUpVector":"\u21BE","RightVectorBar":"\u2953","RightVector":"\u21C0","ring":"\u02DA","risingdotseq":"\u2253","rlarr":"\u21C4","rlhar":"\u21CC","rlm":"\u200F","rmoustache":"\u23B1","rmoust":"\u23B1","rnmid":"\u2AEE","roang":"\u27ED","roarr":"\u21FE","robrk":"\u27E7","ropar":"\u2986","ropf":"\uD835\uDD63","Ropf":"\u211D","roplus":"\u2A2E","rotimes":"\u2A35","RoundImplies":"\u2970","rpar":")","rpargt":"\u2994","rppolint":"\u2A12","rrarr":"\u21C9","Rrightarrow":"\u21DB","rsaquo":"\u203A","rscr":"\uD835\uDCC7","Rscr":"\u211B","rsh":"\u21B1","Rsh":"\u21B1","rsqb":"]","rsquo":"\u2019","rsquor":"\u2019","rthree":"\u22CC","rtimes":"\u22CA","rtri":"\u25B9","rtrie":"\u22B5","rtrif":"\u25B8","rtriltri":"\u29CE","RuleDelayed":"\u29F4","ruluhar":"\u2968","rx":"\u211E","Sacute":"\u015A","sacute":"\u015B","sbquo":"\u201A","scap":"\u2AB8","Scaron":"\u0160","scaron":"\u0161","Sc":"\u2ABC","sc":"\u227B","sccue":"\u227D","sce":"\u2AB0","scE":"\u2AB4","Scedil":"\u015E","scedil":"\u015F","Scirc":"\u015C","scirc":"\u015D","scnap":"\u2ABA","scnE":"\u2AB6","scnsim":"\u22E9","scpolint":"\u2A13","scsim":"\u227F","Scy":"\u0421","scy":"\u0441","sdotb":"\u22A1","sdot":"\u22C5","sdote":"\u2A66","searhk":"\u2925","searr":"\u2198","seArr":"\u21D8","searrow":"\u2198","sect":"\u00A7","semi":";","seswar":"\u2929","setminus":"\u2216","setmn":"\u2216","sext":"\u2736","Sfr":"\uD835\uDD16","sfr":"\uD835\uDD30","sfrown":"\u2322","sharp":"\u266F","SHCHcy":"\u0429","shchcy":"\u0449","SHcy":"\u0428","shcy":"\u0448","ShortDownArrow":"\u2193","ShortLeftArrow":"\u2190","shortmid":"\u2223","shortparallel":"\u2225","ShortRightArrow":"\u2192","ShortUpArrow":"\u2191","shy":"\u00AD","Sigma":"\u03A3","sigma":"\u03C3","sigmaf":"\u03C2","sigmav":"\u03C2","sim":"\u223C","simdot":"\u2A6A","sime":"\u2243","simeq":"\u2243","simg":"\u2A9E","simgE":"\u2AA0","siml":"\u2A9D","simlE":"\u2A9F","simne":"\u2246","simplus":"\u2A24","simrarr":"\u2972","slarr":"\u2190","SmallCircle":"\u2218","smallsetminus":"\u2216","smashp":"\u2A33","smeparsl":"\u29E4","smid":"\u2223","smile":"\u2323","smt":"\u2AAA","smte":"\u2AAC","smtes":"\u2AAC\uFE00","SOFTcy":"\u042C","softcy":"\u044C","solbar":"\u233F","solb":"\u29C4","sol":"/","Sopf":"\uD835\uDD4A","sopf":"\uD835\uDD64","spades":"\u2660","spadesuit":"\u2660","spar":"\u2225","sqcap":"\u2293","sqcaps":"\u2293\uFE00","sqcup":"\u2294","sqcups":"\u2294\uFE00","Sqrt":"\u221A","sqsub":"\u228F","sqsube":"\u2291","sqsubset":"\u228F","sqsubseteq":"\u2291","sqsup":"\u2290","sqsupe":"\u2292","sqsupset":"\u2290","sqsupseteq":"\u2292","square":"\u25A1","Square":"\u25A1","SquareIntersection":"\u2293","SquareSubset":"\u228F","SquareSubsetEqual":"\u2291","SquareSuperset":"\u2290","SquareSupersetEqual":"\u2292","SquareUnion":"\u2294","squarf":"\u25AA","squ":"\u25A1","squf":"\u25AA","srarr":"\u2192","Sscr":"\uD835\uDCAE","sscr":"\uD835\uDCC8","ssetmn":"\u2216","ssmile":"\u2323","sstarf":"\u22C6","Star":"\u22C6","star":"\u2606","starf":"\u2605","straightepsilon":"\u03F5","straightphi":"\u03D5","strns":"\u00AF","sub":"\u2282","Sub":"\u22D0","subdot":"\u2ABD","subE":"\u2AC5","sube":"\u2286","subedot":"\u2AC3","submult":"\u2AC1","subnE":"\u2ACB","subne":"\u228A","subplus":"\u2ABF","subrarr":"\u2979","subset":"\u2282","Subset":"\u22D0","subseteq":"\u2286","subseteqq":"\u2AC5","SubsetEqual":"\u2286","subsetneq":"\u228A","subsetneqq":"\u2ACB","subsim":"\u2AC7","subsub":"\u2AD5","subsup":"\u2AD3","succapprox":"\u2AB8","succ":"\u227B","succcurlyeq":"\u227D","Succeeds":"\u227B","SucceedsEqual":"\u2AB0","SucceedsSlantEqual":"\u227D","SucceedsTilde":"\u227F","succeq":"\u2AB0","succnapprox":"\u2ABA","succneqq":"\u2AB6","succnsim":"\u22E9","succsim":"\u227F","SuchThat":"\u220B","sum":"\u2211","Sum":"\u2211","sung":"\u266A","sup1":"\u00B9","sup2":"\u00B2","sup3":"\u00B3","sup":"\u2283","Sup":"\u22D1","supdot":"\u2ABE","supdsub":"\u2AD8","supE":"\u2AC6","supe":"\u2287","supedot":"\u2AC4","Superset":"\u2283","SupersetEqual":"\u2287","suphsol":"\u27C9","suphsub":"\u2AD7","suplarr":"\u297B","supmult":"\u2AC2","supnE":"\u2ACC","supne":"\u228B","supplus":"\u2AC0","supset":"\u2283","Supset":"\u22D1","supseteq":"\u2287","supseteqq":"\u2AC6","supsetneq":"\u228B","supsetneqq":"\u2ACC","supsim":"\u2AC8","supsub":"\u2AD4","supsup":"\u2AD6","swarhk":"\u2926","swarr":"\u2199","swArr":"\u21D9","swarrow":"\u2199","swnwar":"\u292A","szlig":"\u00DF","Tab":"\t","target":"\u2316","Tau":"\u03A4","tau":"\u03C4","tbrk":"\u23B4","Tcaron":"\u0164","tcaron":"\u0165","Tcedil":"\u0162","tcedil":"\u0163","Tcy":"\u0422","tcy":"\u0442","tdot":"\u20DB","telrec":"\u2315","Tfr":"\uD835\uDD17","tfr":"\uD835\uDD31","there4":"\u2234","therefore":"\u2234","Therefore":"\u2234","Theta":"\u0398","theta":"\u03B8","thetasym":"\u03D1","thetav":"\u03D1","thickapprox":"\u2248","thicksim":"\u223C","ThickSpace":"\u205F\u200A","ThinSpace":"\u2009","thinsp":"\u2009","thkap":"\u2248","thksim":"\u223C","THORN":"\u00DE","thorn":"\u00FE","tilde":"\u02DC","Tilde":"\u223C","TildeEqual":"\u2243","TildeFullEqual":"\u2245","TildeTilde":"\u2248","timesbar":"\u2A31","timesb":"\u22A0","times":"\u00D7","timesd":"\u2A30","tint":"\u222D","toea":"\u2928","topbot":"\u2336","topcir":"\u2AF1","top":"\u22A4","Topf":"\uD835\uDD4B","topf":"\uD835\uDD65","topfork":"\u2ADA","tosa":"\u2929","tprime":"\u2034","trade":"\u2122","TRADE":"\u2122","triangle":"\u25B5","triangledown":"\u25BF","triangleleft":"\u25C3","trianglelefteq":"\u22B4","triangleq":"\u225C","triangleright":"\u25B9","trianglerighteq":"\u22B5","tridot":"\u25EC","trie":"\u225C","triminus":"\u2A3A","TripleDot":"\u20DB","triplus":"\u2A39","trisb":"\u29CD","tritime":"\u2A3B","trpezium":"\u23E2","Tscr":"\uD835\uDCAF","tscr":"\uD835\uDCC9","TScy":"\u0426","tscy":"\u0446","TSHcy":"\u040B","tshcy":"\u045B","Tstrok":"\u0166","tstrok":"\u0167","twixt":"\u226C","twoheadleftarrow":"\u219E","twoheadrightarrow":"\u21A0","Uacute":"\u00DA","uacute":"\u00FA","uarr":"\u2191","Uarr":"\u219F","uArr":"\u21D1","Uarrocir":"\u2949","Ubrcy":"\u040E","ubrcy":"\u045E","Ubreve":"\u016C","ubreve":"\u016D","Ucirc":"\u00DB","ucirc":"\u00FB","Ucy":"\u0423","ucy":"\u0443","udarr":"\u21C5","Udblac":"\u0170","udblac":"\u0171","udhar":"\u296E","ufisht":"\u297E","Ufr":"\uD835\uDD18","ufr":"\uD835\uDD32","Ugrave":"\u00D9","ugrave":"\u00F9","uHar":"\u2963","uharl":"\u21BF","uharr":"\u21BE","uhblk":"\u2580","ulcorn":"\u231C","ulcorner":"\u231C","ulcrop":"\u230F","ultri":"\u25F8","Umacr":"\u016A","umacr":"\u016B","uml":"\u00A8","UnderBar":"_","UnderBrace":"\u23DF","UnderBracket":"\u23B5","UnderParenthesis":"\u23DD","Union":"\u22C3","UnionPlus":"\u228E","Uogon":"\u0172","uogon":"\u0173","Uopf":"\uD835\uDD4C","uopf":"\uD835\uDD66","UpArrowBar":"\u2912","uparrow":"\u2191","UpArrow":"\u2191","Uparrow":"\u21D1","UpArrowDownArrow":"\u21C5","updownarrow":"\u2195","UpDownArrow":"\u2195","Updownarrow":"\u21D5","UpEquilibrium":"\u296E","upharpoonleft":"\u21BF","upharpoonright":"\u21BE","uplus":"\u228E","UpperLeftArrow":"\u2196","UpperRightArrow":"\u2197","upsi":"\u03C5","Upsi":"\u03D2","upsih":"\u03D2","Upsilon":"\u03A5","upsilon":"\u03C5","UpTeeArrow":"\u21A5","UpTee":"\u22A5","upuparrows":"\u21C8","urcorn":"\u231D","urcorner":"\u231D","urcrop":"\u230E","Uring":"\u016E","uring":"\u016F","urtri":"\u25F9","Uscr":"\uD835\uDCB0","uscr":"\uD835\uDCCA","utdot":"\u22F0","Utilde":"\u0168","utilde":"\u0169","utri":"\u25B5","utrif":"\u25B4","uuarr":"\u21C8","Uuml":"\u00DC","uuml":"\u00FC","uwangle":"\u29A7","vangrt":"\u299C","varepsilon":"\u03F5","varkappa":"\u03F0","varnothing":"\u2205","varphi":"\u03D5","varpi":"\u03D6","varpropto":"\u221D","varr":"\u2195","vArr":"\u21D5","varrho":"\u03F1","varsigma":"\u03C2","varsubsetneq":"\u228A\uFE00","varsubsetneqq":"\u2ACB\uFE00","varsupsetneq":"\u228B\uFE00","varsupsetneqq":"\u2ACC\uFE00","vartheta":"\u03D1","vartriangleleft":"\u22B2","vartriangleright":"\u22B3","vBar":"\u2AE8","Vbar":"\u2AEB","vBarv":"\u2AE9","Vcy":"\u0412","vcy":"\u0432","vdash":"\u22A2","vDash":"\u22A8","Vdash":"\u22A9","VDash":"\u22AB","Vdashl":"\u2AE6","veebar":"\u22BB","vee":"\u2228","Vee":"\u22C1","veeeq":"\u225A","vellip":"\u22EE","verbar":"|","Verbar":"\u2016","vert":"|","Vert":"\u2016","VerticalBar":"\u2223","VerticalLine":"|","VerticalSeparator":"\u2758","VerticalTilde":"\u2240","VeryThinSpace":"\u200A","Vfr":"\uD835\uDD19","vfr":"\uD835\uDD33","vltri":"\u22B2","vnsub":"\u2282\u20D2","vnsup":"\u2283\u20D2","Vopf":"\uD835\uDD4D","vopf":"\uD835\uDD67","vprop":"\u221D","vrtri":"\u22B3","Vscr":"\uD835\uDCB1","vscr":"\uD835\uDCCB","vsubnE":"\u2ACB\uFE00","vsubne":"\u228A\uFE00","vsupnE":"\u2ACC\uFE00","vsupne":"\u228B\uFE00","Vvdash":"\u22AA","vzigzag":"\u299A","Wcirc":"\u0174","wcirc":"\u0175","wedbar":"\u2A5F","wedge":"\u2227","Wedge":"\u22C0","wedgeq":"\u2259","weierp":"\u2118","Wfr":"\uD835\uDD1A","wfr":"\uD835\uDD34","Wopf":"\uD835\uDD4E","wopf":"\uD835\uDD68","wp":"\u2118","wr":"\u2240","wreath":"\u2240","Wscr":"\uD835\uDCB2","wscr":"\uD835\uDCCC","xcap":"\u22C2","xcirc":"\u25EF","xcup":"\u22C3","xdtri":"\u25BD","Xfr":"\uD835\uDD1B","xfr":"\uD835\uDD35","xharr":"\u27F7","xhArr":"\u27FA","Xi":"\u039E","xi":"\u03BE","xlarr":"\u27F5","xlArr":"\u27F8","xmap":"\u27FC","xnis":"\u22FB","xodot":"\u2A00","Xopf":"\uD835\uDD4F","xopf":"\uD835\uDD69","xoplus":"\u2A01","xotime":"\u2A02","xrarr":"\u27F6","xrArr":"\u27F9","Xscr":"\uD835\uDCB3","xscr":"\uD835\uDCCD","xsqcup":"\u2A06","xuplus":"\u2A04","xutri":"\u25B3","xvee":"\u22C1","xwedge":"\u22C0","Yacute":"\u00DD","yacute":"\u00FD","YAcy":"\u042F","yacy":"\u044F","Ycirc":"\u0176","ycirc":"\u0177","Ycy":"\u042B","ycy":"\u044B","yen":"\u00A5","Yfr":"\uD835\uDD1C","yfr":"\uD835\uDD36","YIcy":"\u0407","yicy":"\u0457","Yopf":"\uD835\uDD50","yopf":"\uD835\uDD6A","Yscr":"\uD835\uDCB4","yscr":"\uD835\uDCCE","YUcy":"\u042E","yucy":"\u044E","yuml":"\u00FF","Yuml":"\u0178","Zacute":"\u0179","zacute":"\u017A","Zcaron":"\u017D","zcaron":"\u017E","Zcy":"\u0417","zcy":"\u0437","Zdot":"\u017B","zdot":"\u017C","zeetrf":"\u2128","ZeroWidthSpace":"\u200B","Zeta":"\u0396","zeta":"\u03B6","zfr":"\uD835\uDD37","Zfr":"\u2128","ZHcy":"\u0416","zhcy":"\u0436","zigrarr":"\u21DD","zopf":"\uD835\uDD6B","Zopf":"\u2124","Zscr":"\uD835\uDCB5","zscr":"\uD835\uDCCF","zwj":"\u200D","zwnj":"\u200C"}
	},{}],53:[function(require,module,exports){
	'use strict';
	
	
	////////////////////////////////////////////////////////////////////////////////
	// Helpers
	
	// Merge objects
	//
	function assign(obj /*from1, from2, from3, ...*/) {
	  var sources = Array.prototype.slice.call(arguments, 1);
	
	  sources.forEach(function (source) {
	    if (!source) { return; }
	
	    Object.keys(source).forEach(function (key) {
	      obj[key] = source[key];
	    });
	  });
	
	  return obj;
	}
	
	function _class(obj) { return Object.prototype.toString.call(obj); }
	function isString(obj) { return _class(obj) === '[object String]'; }
	function isObject(obj) { return _class(obj) === '[object Object]'; }
	function isRegExp(obj) { return _class(obj) === '[object RegExp]'; }
	function isFunction(obj) { return _class(obj) === '[object Function]'; }
	
	
	function escapeRE(str) { return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&'); }
	
	////////////////////////////////////////////////////////////////////////////////
	
	
	var defaultOptions = {
	  fuzzyLink: true,
	  fuzzyEmail: true,
	  fuzzyIP: false
	};
	
	
	function isOptionsObj(obj) {
	  return Object.keys(obj || {}).reduce(function (acc, k) {
	    return acc || defaultOptions.hasOwnProperty(k);
	  }, false);
	}
	
	
	var defaultSchemas = {
	  'http:': {
	    validate: function (text, pos, self) {
	      var tail = text.slice(pos);
	
	      if (!self.re.http) {
	        // compile lazily, because "host"-containing variables can change on tlds update.
	        self.re.http =  new RegExp(
	          '^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'
	        );
	      }
	      if (self.re.http.test(tail)) {
	        return tail.match(self.re.http)[0].length;
	      }
	      return 0;
	    }
	  },
	  'https:':  'http:',
	  'ftp:':    'http:',
	  '//':      {
	    validate: function (text, pos, self) {
	      var tail = text.slice(pos);
	
	      if (!self.re.no_http) {
	      // compile lazily, because "host"-containing variables can change on tlds update.
	        self.re.no_http =  new RegExp(
	          '^' +
	          self.re.src_auth +
	          // Don't allow single-level domains, because of false positives like '//test'
	          // with code comments
	          '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' +
	          self.re.src_port +
	          self.re.src_host_terminator +
	          self.re.src_path,
	
	          'i'
	        );
	      }
	
	      if (self.re.no_http.test(tail)) {
	        // should not be `://` & `///`, that protects from errors in protocol name
	        if (pos >= 3 && text[pos - 3] === ':') { return 0; }
	        if (pos >= 3 && text[pos - 3] === '/') { return 0; }
	        return tail.match(self.re.no_http)[0].length;
	      }
	      return 0;
	    }
	  },
	  'mailto:': {
	    validate: function (text, pos, self) {
	      var tail = text.slice(pos);
	
	      if (!self.re.mailto) {
	        self.re.mailto =  new RegExp(
	          '^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i'
	        );
	      }
	      if (self.re.mailto.test(tail)) {
	        return tail.match(self.re.mailto)[0].length;
	      }
	      return 0;
	    }
	  }
	};
	
	/*eslint-disable max-len*/
	
	// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
	var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';
	
	// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
	var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');
	
	/*eslint-enable max-len*/
	
	////////////////////////////////////////////////////////////////////////////////
	
	function resetScanCache(self) {
	  self.__index__ = -1;
	  self.__text_cache__   = '';
	}
	
	function createValidator(re) {
	  return function (text, pos) {
	    var tail = text.slice(pos);
	
	    if (re.test(tail)) {
	      return tail.match(re)[0].length;
	    }
	    return 0;
	  };
	}
	
	function createNormalizer() {
	  return function (match, self) {
	    self.normalize(match);
	  };
	}
	
	// Schemas compiler. Build regexps.
	//
	function compile(self) {
	
	  // Load & clone RE patterns.
	  var re = self.re = require('./lib/re')(self.__opts__);
	
	  // Define dynamic patterns
	  var tlds = self.__tlds__.slice();
	
	  self.onCompile();
	
	  if (!self.__tlds_replaced__) {
	    tlds.push(tlds_2ch_src_re);
	  }
	  tlds.push(re.src_xn);
	
	  re.src_tlds = tlds.join('|');
	
	  function untpl(tpl) { return tpl.replace('%TLDS%', re.src_tlds); }
	
	  re.email_fuzzy      = RegExp(untpl(re.tpl_email_fuzzy), 'i');
	  re.link_fuzzy       = RegExp(untpl(re.tpl_link_fuzzy), 'i');
	  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
	  re.host_fuzzy_test  = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');
	
	  //
	  // Compile each schema
	  //
	
	  var aliases = [];
	
	  self.__compiled__ = {}; // Reset compiled data
	
	  function schemaError(name, val) {
	    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
	  }
	
	  Object.keys(self.__schemas__).forEach(function (name) {
	    var val = self.__schemas__[name];
	
	    // skip disabled methods
	    if (val === null) { return; }
	
	    var compiled = { validate: null, link: null };
	
	    self.__compiled__[name] = compiled;
	
	    if (isObject(val)) {
	      if (isRegExp(val.validate)) {
	        compiled.validate = createValidator(val.validate);
	      } else if (isFunction(val.validate)) {
	        compiled.validate = val.validate;
	      } else {
	        schemaError(name, val);
	      }
	
	      if (isFunction(val.normalize)) {
	        compiled.normalize = val.normalize;
	      } else if (!val.normalize) {
	        compiled.normalize = createNormalizer();
	      } else {
	        schemaError(name, val);
	      }
	
	      return;
	    }
	
	    if (isString(val)) {
	      aliases.push(name);
	      return;
	    }
	
	    schemaError(name, val);
	  });
	
	  //
	  // Compile postponed aliases
	  //
	
	  aliases.forEach(function (alias) {
	    if (!self.__compiled__[self.__schemas__[alias]]) {
	      // Silently fail on missed schemas to avoid errons on disable.
	      // schemaError(alias, self.__schemas__[alias]);
	      return;
	    }
	
	    self.__compiled__[alias].validate =
	      self.__compiled__[self.__schemas__[alias]].validate;
	    self.__compiled__[alias].normalize =
	      self.__compiled__[self.__schemas__[alias]].normalize;
	  });
	
	  //
	  // Fake record for guessed links
	  //
	  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };
	
	  //
	  // Build schema condition
	  //
	  var slist = Object.keys(self.__compiled__)
	                      .filter(function (name) {
	                        // Filter disabled & fake schemas
	                        return name.length > 0 && self.__compiled__[name];
	                      })
	                      .map(escapeRE)
	                      .join('|');
	  // (?!_) cause 1.5x slowdown
	  self.re.schema_test   = RegExp('(^|(?!_)(?:[><]|' + re.src_ZPCc + '))(' + slist + ')', 'i');
	  self.re.schema_search = RegExp('(^|(?!_)(?:[><]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');
	
	  self.re.pretest       = RegExp(
	                            '(' + self.re.schema_test.source + ')|' +
	                            '(' + self.re.host_fuzzy_test.source + ')|' +
	                            '@',
	                            'i');
	
	  //
	  // Cleanup
	  //
	
	  resetScanCache(self);
	}
	
	/**
	 * class Match
	 *
	 * Match result. Single element of array, returned by [[LinkifyIt#match]]
	 **/
	function Match(self, shift) {
	  var start = self.__index__,
	      end   = self.__last_index__,
	      text  = self.__text_cache__.slice(start, end);
	
	  /**
	   * Match#schema -> String
	   *
	   * Prefix (protocol) for matched string.
	   **/
	  this.schema    = self.__schema__.toLowerCase();
	  /**
	   * Match#index -> Number
	   *
	   * First position of matched string.
	   **/
	  this.index     = start + shift;
	  /**
	   * Match#lastIndex -> Number
	   *
	   * Next position after matched string.
	   **/
	  this.lastIndex = end + shift;
	  /**
	   * Match#raw -> String
	   *
	   * Matched string.
	   **/
	  this.raw       = text;
	  /**
	   * Match#text -> String
	   *
	   * Notmalized text of matched string.
	   **/
	  this.text      = text;
	  /**
	   * Match#url -> String
	   *
	   * Normalized url of matched string.
	   **/
	  this.url       = text;
	}
	
	function createMatch(self, shift) {
	  var match = new Match(self, shift);
	
	  self.__compiled__[match.schema].normalize(match, self);
	
	  return match;
	}
	
	
	/**
	 * class LinkifyIt
	 **/
	
	/**
	 * new LinkifyIt(schemas, options)
	 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
	 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
	 *
	 * Creates new linkifier instance with optional additional schemas.
	 * Can be called without `new` keyword for convenience.
	 *
	 * By default understands:
	 *
	 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
	 * - "fuzzy" links and emails (example.com, foo@bar.com).
	 *
	 * `schemas` is an object, where each key/value describes protocol/rule:
	 *
	 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
	 *   for example). `linkify-it` makes shure that prefix is not preceeded with
	 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
	 * - __value__ - rule to check tail after link prefix
	 *   - _String_ - just alias to existing rule
	 *   - _Object_
	 *     - _validate_ - validator function (should return matched length on success),
	 *       or `RegExp`.
	 *     - _normalize_ - optional function to normalize text & url of matched result
	 *       (for example, for @twitter mentions).
	 *
	 * `options`:
	 *
	 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
	 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
	 *   like version numbers. Default `false`.
	 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
	 *
	 **/
	function LinkifyIt(schemas, options) {
	  if (!(this instanceof LinkifyIt)) {
	    return new LinkifyIt(schemas, options);
	  }
	
	  if (!options) {
	    if (isOptionsObj(schemas)) {
	      options = schemas;
	      schemas = {};
	    }
	  }
	
	  this.__opts__           = assign({}, defaultOptions, options);
	
	  // Cache last tested result. Used to skip repeating steps on next `match` call.
	  this.__index__          = -1;
	  this.__last_index__     = -1; // Next scan position
	  this.__schema__         = '';
	  this.__text_cache__     = '';
	
	  this.__schemas__        = assign({}, defaultSchemas, schemas);
	  this.__compiled__       = {};
	
	  this.__tlds__           = tlds_default;
	  this.__tlds_replaced__  = false;
	
	  this.re = {};
	
	  compile(this);
	}
	
	
	/** chainable
	 * LinkifyIt#add(schema, definition)
	 * - schema (String): rule name (fixed pattern prefix)
	 * - definition (String|RegExp|Object): schema definition
	 *
	 * Add new rule definition. See constructor description for details.
	 **/
	LinkifyIt.prototype.add = function add(schema, definition) {
	  this.__schemas__[schema] = definition;
	  compile(this);
	  return this;
	};
	
	
	/** chainable
	 * LinkifyIt#set(options)
	 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
	 *
	 * Set recognition options for links without schema.
	 **/
	LinkifyIt.prototype.set = function set(options) {
	  this.__opts__ = assign(this.__opts__, options);
	  return this;
	};
	
	
	/**
	 * LinkifyIt#test(text) -> Boolean
	 *
	 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
	 **/
	LinkifyIt.prototype.test = function test(text) {
	  // Reset scan cache
	  this.__text_cache__ = text;
	  this.__index__      = -1;
	
	  if (!text.length) { return false; }
	
	  var m, ml, me, len, shift, next, re, tld_pos, at_pos;
	
	  // try to scan for link with schema - that's the most simple rule
	  if (this.re.schema_test.test(text)) {
	    re = this.re.schema_search;
	    re.lastIndex = 0;
	    while ((m = re.exec(text)) !== null) {
	      len = this.testSchemaAt(text, m[2], re.lastIndex);
	      if (len) {
	        this.__schema__     = m[2];
	        this.__index__      = m.index + m[1].length;
	        this.__last_index__ = m.index + m[0].length + len;
	        break;
	      }
	    }
	  }
	
	  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
	    // guess schemaless links
	    tld_pos = text.search(this.re.host_fuzzy_test);
	    if (tld_pos >= 0) {
	      // if tld is located after found link - no need to check fuzzy pattern
	      if (this.__index__ < 0 || tld_pos < this.__index__) {
	        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
	
	          shift = ml.index + ml[1].length;
	
	          if (this.__index__ < 0 || shift < this.__index__) {
	            this.__schema__     = '';
	            this.__index__      = shift;
	            this.__last_index__ = ml.index + ml[0].length;
	          }
	        }
	      }
	    }
	  }
	
	  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
	    // guess schemaless emails
	    at_pos = text.indexOf('@');
	    if (at_pos >= 0) {
	      // We can't skip this check, because this cases are possible:
	      // 192.168.1.1@gmail.com, my.in@example.com
	      if ((me = text.match(this.re.email_fuzzy)) !== null) {
	
	        shift = me.index + me[1].length;
	        next  = me.index + me[0].length;
	
	        if (this.__index__ < 0 || shift < this.__index__ ||
	            (shift === this.__index__ && next > this.__last_index__)) {
	          this.__schema__     = 'mailto:';
	          this.__index__      = shift;
	          this.__last_index__ = next;
	        }
	      }
	    }
	  }
	
	  return this.__index__ >= 0;
	};
	
	
	/**
	 * LinkifyIt#pretest(text) -> Boolean
	 *
	 * Very quick check, that can give false positives. Returns true if link MAY BE
	 * can exists. Can be used for speed optimization, when you need to check that
	 * link NOT exists.
	 **/
	LinkifyIt.prototype.pretest = function pretest(text) {
	  return this.re.pretest.test(text);
	};
	
	
	/**
	 * LinkifyIt#testSchemaAt(text, name, position) -> Number
	 * - text (String): text to scan
	 * - name (String): rule (schema) name
	 * - position (Number): text offset to check from
	 *
	 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
	 * at given position. Returns length of found pattern (0 on fail).
	 **/
	LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
	  // If not supported schema check requested - terminate
	  if (!this.__compiled__[schema.toLowerCase()]) {
	    return 0;
	  }
	  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
	};
	
	
	/**
	 * LinkifyIt#match(text) -> Array|null
	 *
	 * Returns array of found link descriptions or `null` on fail. We strongly
	 * recommend to use [[LinkifyIt#test]] first, for best speed.
	 *
	 * ##### Result match description
	 *
	 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
	 *   protocol-neutral  links.
	 * - __index__ - offset of matched text
	 * - __lastIndex__ - index of next char after mathch end
	 * - __raw__ - matched text
	 * - __text__ - normalized text
	 * - __url__ - link, generated from matched text
	 **/
	LinkifyIt.prototype.match = function match(text) {
	  var shift = 0, result = [];
	
	  // Try to take previous element from cache, if .test() called before
	  if (this.__index__ >= 0 && this.__text_cache__ === text) {
	    result.push(createMatch(this, shift));
	    shift = this.__last_index__;
	  }
	
	  // Cut head if cache was used
	  var tail = shift ? text.slice(shift) : text;
	
	  // Scan string until end reached
	  while (this.test(tail)) {
	    result.push(createMatch(this, shift));
	
	    tail = tail.slice(this.__last_index__);
	    shift += this.__last_index__;
	  }
	
	  if (result.length) {
	    return result;
	  }
	
	  return null;
	};
	
	
	/** chainable
	 * LinkifyIt#tlds(list [, keepOld]) -> this
	 * - list (Array): list of tlds
	 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
	 *
	 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
	 * to avoid false positives. By default this algorythm used:
	 *
	 * - hostname with any 2-letter root zones are ok.
	 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
	 *   are ok.
	 * - encoded (`xn--...`) root zones are ok.
	 *
	 * If list is replaced, then exact match for 2-chars root zones will be checked.
	 **/
	LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
	  list = Array.isArray(list) ? list : [ list ];
	
	  if (!keepOld) {
	    this.__tlds__ = list.slice();
	    this.__tlds_replaced__ = true;
	    compile(this);
	    return this;
	  }
	
	  this.__tlds__ = this.__tlds__.concat(list)
	                                  .sort()
	                                  .filter(function (el, idx, arr) {
	                                    return el !== arr[idx - 1];
	                                  })
	                                  .reverse();
	
	  compile(this);
	  return this;
	};
	
	/**
	 * LinkifyIt#normalize(match)
	 *
	 * Default normalizer (if schema does not define it's own).
	 **/
	LinkifyIt.prototype.normalize = function normalize(match) {
	
	  // Do minimal possible changes by default. Need to collect feedback prior
	  // to move forward https://github.com/markdown-it/linkify-it/issues/1
	
	  if (!match.schema) { match.url = 'http://' + match.url; }
	
	  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
	    match.url = 'mailto:' + match.url;
	  }
	};
	
	
	/**
	 * LinkifyIt#onCompile()
	 *
	 * Override to modify basic RegExp-s.
	 **/
	LinkifyIt.prototype.onCompile = function onCompile() {
	};
	
	
	module.exports = LinkifyIt;
	
	},{"./lib/re":54}],54:[function(require,module,exports){
	'use strict';
	
	
	module.exports = function (opts) {
	  var re = {};
	
	  // Use direct extract instead of `regenerate` to reduse browserified size
	  re.src_Any = require('uc.micro/properties/Any/regex').source;
	  re.src_Cc  = require('uc.micro/categories/Cc/regex').source;
	  re.src_Z   = require('uc.micro/categories/Z/regex').source;
	  re.src_P   = require('uc.micro/categories/P/regex').source;
	
	  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
	  re.src_ZPCc = [ re.src_Z, re.src_P, re.src_Cc ].join('|');
	
	  // \p{\Z\Cc} (white spaces + control)
	  re.src_ZCc = [ re.src_Z, re.src_Cc ].join('|');
	
	  // All possible word characters (everything without punctuation, spaces & controls)
	  // Defined via punctuation & spaces to save space
	  // Should be something like \p{\L\N\S\M} (\w but without `_`)
	  re.src_pseudo_letter       = '(?:(?!>|<|' + re.src_ZPCc + ')' + re.src_Any + ')';
	  // The same as abothe but without [0-9]
	  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';
	
	  ////////////////////////////////////////////////////////////////////////////////
	
	  re.src_ip4 =
	
	    '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';
	
	  // Prohibit [@/] in user/pass to avoid wrong domain fetch.
	  re.src_auth    = '(?:(?:(?!' + re.src_ZCc + '|[@/]).)+@)?';
	
	  re.src_port =
	
	    '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';
	
	  re.src_host_terminator =
	
	    '(?=$|>|<|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';
	
	  re.src_path =
	
	    '(?:' +
	      '[/?#]' +
	        '(?:' +
	          '(?!' + re.src_ZCc + '|[()[\\]{}.,"\'?!\\-<>]).|' +
	          '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' +
	          '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' +
	          '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' +
	          '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' +
	          "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" +
	          "\\'(?=" + re.src_pseudo_letter + '|[-]).|' +  // allow `I'm_king` if no pair found
	          '\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to
	                                     // - english
	                                     // - percent-encoded
	                                     // - parts of file path
	                                     // until more examples found.
	          '\\.(?!' + re.src_ZCc + '|[.]).|' +
	          (opts && opts['---'] ?
	            '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
	          :
	            '\\-+|'
	          ) +
	          '\\,(?!' + re.src_ZCc + ').|' +      // allow `,,,` in paths
	          '\\!(?!' + re.src_ZCc + '|[!]).|' +
	          '\\?(?!' + re.src_ZCc + '|[?]).' +
	        ')+' +
	      '|\\/' +
	    ')?';
	
	  re.src_email_name =
	
	    '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';
	
	  re.src_xn =
	
	    'xn--[a-z0-9\\-]{1,59}';
	
	  // More to read about domain names
	  // http://serverfault.com/questions/638260/
	
	  re.src_domain_root =
	
	    // Allow letters & digits (http://test1)
	    '(?:' +
	      re.src_xn +
	      '|' +
	      re.src_pseudo_letter + '{1,63}' +
	    ')';
	
	  re.src_domain =
	
	    '(?:' +
	      re.src_xn +
	      '|' +
	      '(?:' + re.src_pseudo_letter + ')' +
	      '|' +
	      // don't allow `--` in domain names, because:
	      // - that can conflict with markdown &mdash; / &ndash;
	      // - nobody use those anyway
	      '(?:' + re.src_pseudo_letter + '(?:-(?!-)|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' +
	    ')';
	
	  re.src_host =
	
	    '(?:' +
	    // Don't need IP check, because digits are already allowed in normal domain names
	    //   src_ip4 +
	    // '|' +
	      '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain_root + ')' +
	    ')';
	
	  re.tpl_host_fuzzy =
	
	    '(?:' +
	      re.src_ip4 +
	    '|' +
	      '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' +
	    ')';
	
	  re.tpl_host_no_ip_fuzzy =
	
	    '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';
	
	  re.src_host_strict =
	
	    re.src_host + re.src_host_terminator;
	
	  re.tpl_host_fuzzy_strict =
	
	    re.tpl_host_fuzzy + re.src_host_terminator;
	
	  re.src_host_port_strict =
	
	    re.src_host + re.src_port + re.src_host_terminator;
	
	  re.tpl_host_port_fuzzy_strict =
	
	    re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
	
	  re.tpl_host_port_no_ip_fuzzy_strict =
	
	    re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
	
	
	  ////////////////////////////////////////////////////////////////////////////////
	  // Main rules
	
	  // Rude test fuzzy links by host, for quick deny
	  re.tpl_host_fuzzy_test =
	
	    'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';
	
	  re.tpl_email_fuzzy =
	
	      '(^|<|>|\\(|' + re.src_ZCc + ')(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';
	
	  re.tpl_link_fuzzy =
	      // Fuzzy link can't be prepended with .:/\- and non punctuation.
	      // but can start with > (markdown blockquote)
	      '(^|(?![.:/\\-_@])(?:[$+<=>^`|]|' + re.src_ZPCc + '))' +
	      '((?![$+<=>^`|])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';
	
	  re.tpl_link_no_ip_fuzzy =
	      // Fuzzy link can't be prepended with .:/\- and non punctuation.
	      // but can start with > (markdown blockquote)
	      '(^|(?![.:/\\-_@])(?:[$+<=>^`|]|' + re.src_ZPCc + '))' +
	      '((?![$+<=>^`|])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';
	
	  return re;
	};
	
	},{"uc.micro/categories/Cc/regex":61,"uc.micro/categories/P/regex":63,"uc.micro/categories/Z/regex":64,"uc.micro/properties/Any/regex":66}],55:[function(require,module,exports){
	
	'use strict';
	
	
	/* eslint-disable no-bitwise */
	
	var decodeCache = {};
	
	function getDecodeCache(exclude) {
	  var i, ch, cache = decodeCache[exclude];
	  if (cache) { return cache; }
	
	  cache = decodeCache[exclude] = [];
	
	  for (i = 0; i < 128; i++) {
	    ch = String.fromCharCode(i);
	    cache.push(ch);
	  }
	
	  for (i = 0; i < exclude.length; i++) {
	    ch = exclude.charCodeAt(i);
	    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
	  }
	
	  return cache;
	}
	
	
	// Decode percent-encoded string.
	//
	function decode(string, exclude) {
	  var cache;
	
	  if (typeof exclude !== 'string') {
	    exclude = decode.defaultChars;
	  }
	
	  cache = getDecodeCache(exclude);
	
	  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
	    var i, l, b1, b2, b3, b4, chr,
	        result = '';
	
	    for (i = 0, l = seq.length; i < l; i += 3) {
	      b1 = parseInt(seq.slice(i + 1, i + 3), 16);
	
	      if (b1 < 0x80) {
	        result += cache[b1];
	        continue;
	      }
	
	      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {
	        // 110xxxxx 10xxxxxx
	        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
	
	        if ((b2 & 0xC0) === 0x80) {
	          chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);
	
	          if (chr < 0x80) {
	            result += '\ufffd\ufffd';
	          } else {
	            result += String.fromCharCode(chr);
	          }
	
	          i += 3;
	          continue;
	        }
	      }
	
	      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {
	        // 1110xxxx 10xxxxxx 10xxxxxx
	        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
	        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
	
	        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
	          chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);
	
	          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {
	            result += '\ufffd\ufffd\ufffd';
	          } else {
	            result += String.fromCharCode(chr);
	          }
	
	          i += 6;
	          continue;
	        }
	      }
	
	      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {
	        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
	        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
	        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
	        b4 = parseInt(seq.slice(i + 10, i + 12), 16);
	
	        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
	          chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);
	
	          if (chr < 0x10000 || chr > 0x10FFFF) {
	            result += '\ufffd\ufffd\ufffd\ufffd';
	          } else {
	            chr -= 0x10000;
	            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
	          }
	
	          i += 9;
	          continue;
	        }
	      }
	
	      result += '\ufffd';
	    }
	
	    return result;
	  });
	}
	
	
	decode.defaultChars   = ';/?:@&=+$,#';
	decode.componentChars = '';
	
	
	module.exports = decode;
	
	},{}],56:[function(require,module,exports){
	
	'use strict';
	
	
	var encodeCache = {};
	
	
	// Create a lookup array where anything but characters in `chars` string
	// and alphanumeric chars is percent-encoded.
	//
	function getEncodeCache(exclude) {
	  var i, ch, cache = encodeCache[exclude];
	  if (cache) { return cache; }
	
	  cache = encodeCache[exclude] = [];
	
	  for (i = 0; i < 128; i++) {
	    ch = String.fromCharCode(i);
	
	    if (/^[0-9a-z]$/i.test(ch)) {
	      // always allow unencoded alphanumeric characters
	      cache.push(ch);
	    } else {
	      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
	    }
	  }
	
	  for (i = 0; i < exclude.length; i++) {
	    cache[exclude.charCodeAt(i)] = exclude[i];
	  }
	
	  return cache;
	}
	
	
	// Encode unsafe characters with percent-encoding, skipping already
	// encoded sequences.
	//
	//  - string       - string to encode
	//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
	//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
	//
	function encode(string, exclude, keepEscaped) {
	  var i, l, code, nextCode, cache,
	      result = '';
	
	  if (typeof exclude !== 'string') {
	    // encode(string, keepEscaped)
	    keepEscaped  = exclude;
	    exclude = encode.defaultChars;
	  }
	
	  if (typeof keepEscaped === 'undefined') {
	    keepEscaped = true;
	  }
	
	  cache = getEncodeCache(exclude);
	
	  for (i = 0, l = string.length; i < l; i++) {
	    code = string.charCodeAt(i);
	
	    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
	      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
	        result += string.slice(i, i + 3);
	        i += 2;
	        continue;
	      }
	    }
	
	    if (code < 128) {
	      result += cache[code];
	      continue;
	    }
	
	    if (code >= 0xD800 && code <= 0xDFFF) {
	      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
	        nextCode = string.charCodeAt(i + 1);
	        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
	          result += encodeURIComponent(string[i] + string[i + 1]);
	          i++;
	          continue;
	        }
	      }
	      result += '%EF%BF%BD';
	      continue;
	    }
	
	    result += encodeURIComponent(string[i]);
	  }
	
	  return result;
	}
	
	encode.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
	encode.componentChars = "-_.!~*'()";
	
	
	module.exports = encode;
	
	},{}],57:[function(require,module,exports){
	
	'use strict';
	
	
	module.exports = function format(url) {
	  var result = '';
	
	  result += url.protocol || '';
	  result += url.slashes ? '//' : '';
	  result += url.auth ? url.auth + '@' : '';
	
	  if (url.hostname && url.hostname.indexOf(':') !== -1) {
	    // ipv6 address
	    result += '[' + url.hostname + ']';
	  } else {
	    result += url.hostname || '';
	  }
	
	  result += url.port ? ':' + url.port : '';
	  result += url.pathname || '';
	  result += url.search || '';
	  result += url.hash || '';
	
	  return result;
	};
	
	},{}],58:[function(require,module,exports){
	'use strict';
	
	
	module.exports.encode = require('./encode');
	module.exports.decode = require('./decode');
	module.exports.format = require('./format');
	module.exports.parse  = require('./parse');
	
	},{"./decode":55,"./encode":56,"./format":57,"./parse":59}],59:[function(require,module,exports){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	//
	// Changes from joyent/node:
	//
	// 1. No leading slash in paths,
	//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
	//
	// 2. Backslashes are not replaced with slashes,
	//    so `http:\\example.org\` is treated like a relative path
	//
	// 3. Trailing colon is treated like a part of the path,
	//    i.e. in `http://example.org:foo` pathname is `:foo`
	//
	// 4. Nothing is URL-encoded in the resulting object,
	//    (in joyent/node some chars in auth and paths are encoded)
	//
	// 5. `url.parse()` does not have `parseQueryString` argument
	//
	// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
	//    which can be constructed using other parts of the url.
	//
	
	
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.pathname = null;
	}
	
	// Reference: RFC 3986, RFC 1808, RFC 2396
	
	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,
	
	    // Special case for a simple path URL
	    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
	
	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = [ '<', '>', '"', '`', ' ', '\r', '\n', '\t' ],
	
	    // RFC 2396: characters not allowed for various reasons.
	    unwise = [ '{', '}', '|', '\\', '^', '`' ].concat(delims),
	
	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = [ '\'' ].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = [ '%', '/', '?', ';', '#' ].concat(autoEscape),
	    hostEndingChars = [ '/', '?', '#' ],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    /* eslint-disable no-script-url */
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    };
	    /* eslint-enable no-script-url */
	
	function urlParse(url, slashesDenoteHost) {
	  if (url && url instanceof Url) { return url; }
	
	  var u = new Url();
	  u.parse(url, slashesDenoteHost);
	  return u;
	}
	
	Url.prototype.parse = function(url, slashesDenoteHost) {
	  var i, l, lowerProto, hec, slashes,
	      rest = url;
	
	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();
	
	  if (!slashesDenoteHost && url.split('#').length === 1) {
	    // Try fast path regexp
	    var simplePath = simplePathPattern.exec(rest);
	    if (simplePath) {
	      this.pathname = simplePath[1];
	      if (simplePath[2]) {
	        this.search = simplePath[2];
	      }
	      return this;
	    }
	  }
	
	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    lowerProto = proto.toLowerCase();
	    this.protocol = proto;
	    rest = rest.substr(proto.length);
	  }
	
	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }
	
	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {
	
	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c
	
	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.
	
	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (i = 0; i < hostEndingChars.length; i++) {
	      hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
	        hostEnd = hec;
	      }
	    }
	
	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }
	
	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = auth;
	    }
	
	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (i = 0; i < nonHostChars.length; i++) {
	      hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
	        hostEnd = hec;
	      }
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1) {
	      hostEnd = rest.length;
	    }
	
	    if (rest[hostEnd - 1] === ':') { hostEnd--; }
	    var host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);
	
	    // pull out port.
	    this.parseHost(host);
	
	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';
	
	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';
	
	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) { continue; }
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }
	
	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    }
	
	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	    }
	  }
	
	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    rest = rest.slice(0, qm);
	  }
	  if (rest) { this.pathname = rest; }
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '';
	  }
	
	  return this;
	};
	
	Url.prototype.parseHost = function(host) {
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) { this.hostname = host; }
	};
	
	module.exports = urlParse;
	
	},{}],60:[function(require,module,exports){
	(function (global){
	/*! https://mths.be/punycode v1.4.1 by @mathias */
	;(function(root) {
	
		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}
	
		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,
	
		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
	
		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'
	
		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
	
		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
	
		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,
	
		/** Temporary variable */
		key;
	
		/*--------------------------------------------------------------------------*/
	
		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw new RangeError(errors[type]);
		}
	
		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
	
		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
	
		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}
	
		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}
	
		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}
	
		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * https://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}
	
		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;
	
			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.
	
			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
	
			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
	
			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.
	
			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
	
				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
	
					if (index >= inputLength) {
						error('invalid-input');
					}
	
					digit = basicToDigit(input.charCodeAt(index++));
	
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}
	
					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	
					if (digit < t) {
						break;
					}
	
					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}
	
					w *= baseMinusT;
	
				}
	
				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
	
				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}
	
				n += floor(i / out);
				i %= out;
	
				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
	
			}
	
			return ucs2encode(output);
		}
	
		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;
	
			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);
	
			// Cache the length
			inputLength = input.length;
	
			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;
	
			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}
	
			handledCPCount = basicLength = output.length;
	
			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.
	
			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}
	
			// Main encoding loop:
			while (handledCPCount < inputLength) {
	
				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}
	
				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}
	
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
	
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
	
					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}
	
					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}
	
						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
	
				++delta;
				++n;
	
			}
			return output.join('');
		}
	
		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}
	
		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}
	
		/*--------------------------------------------------------------------------*/
	
		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.4.1',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
	
		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			typeof define == 'function' &&
			typeof define.amd == 'object' &&
			define.amd
		) {
			define('punycode', function() {
				return punycode;
			});
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) {
				// in Node.js, io.js, or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else {
				// in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else {
			// in Rhino or a web browser
			root.punycode = punycode;
		}
	
	}(this));
	
	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{}],61:[function(require,module,exports){
	module.exports=/[\0-\x1F\x7F-\x9F]/
	},{}],62:[function(require,module,exports){
	module.exports=/[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/
	},{}],63:[function(require,module,exports){
	module.exports=/[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/
	},{}],64:[function(require,module,exports){
	module.exports=/[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/
	},{}],65:[function(require,module,exports){
	'use strict';
	
	exports.Any = require('./properties/Any/regex');
	exports.Cc  = require('./categories/Cc/regex');
	exports.Cf  = require('./categories/Cf/regex');
	exports.P   = require('./categories/P/regex');
	exports.Z   = require('./categories/Z/regex');
	
	},{"./categories/Cc/regex":61,"./categories/Cf/regex":62,"./categories/P/regex":63,"./categories/Z/regex":64,"./properties/Any/regex":66}],66:[function(require,module,exports){
	module.exports=/[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/
	},{}],67:[function(require,module,exports){
	'use strict';
	
	
	module.exports = require('./lib/');
	
	},{"./lib/":9}]},{},[67])(67)
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	/*! highlight.js v9.7.0 | BSD3 License | git.io/hljslicense */
	!function(e){var t="object"==typeof window&&window||"object"==typeof self&&self; true?e(exports):t&&(t.hljs=e({}),"function"==typeof define&&define.amd&&define([],function(){return t.hljs}))}(function(e){function t(e){return e.replace(/[&<>]/gm,function(e){return S[e]})}function r(e){return e.nodeName.toLowerCase()}function a(e,t){var r=e&&e.exec(t);return r&&0===r.index}function n(e){return C.test(e)}function i(e){var t,r,a,i,s=e.className+" ";if(s+=e.parentNode?e.parentNode.className:"",r=E.exec(s))return y(r[1])?r[1]:"no-highlight";for(s=s.split(/\s+/),t=0,a=s.length;a>t;t++)if(i=s[t],n(i)||y(i))return i}function s(e,t){var r,a={};for(r in e)a[r]=e[r];if(t)for(r in t)a[r]=t[r];return a}function c(e){var t=[];return function a(e,n){for(var i=e.firstChild;i;i=i.nextSibling)3===i.nodeType?n+=i.nodeValue.length:1===i.nodeType&&(t.push({event:"start",offset:n,node:i}),n=a(i,n),r(i).match(/br|hr|img|input/)||t.push({event:"stop",offset:n,node:i}));return n}(e,0),t}function o(e,a,n){function i(){return e.length&&a.length?e[0].offset!==a[0].offset?e[0].offset<a[0].offset?e:a:"start"===a[0].event?e:a:e.length?e:a}function s(e){function a(e){return" "+e.nodeName+'="'+t(e.value)+'"'}u+="<"+r(e)+w.map.call(e.attributes,a).join("")+">"}function c(e){u+="</"+r(e)+">"}function o(e){("start"===e.event?s:c)(e.node)}for(var l=0,u="",d=[];e.length||a.length;){var b=i();if(u+=t(n.substr(l,b[0].offset-l)),l=b[0].offset,b===e){d.reverse().forEach(c);do o(b.splice(0,1)[0]),b=i();while(b===e&&b.length&&b[0].offset===l);d.reverse().forEach(s)}else"start"===b[0].event?d.push(b[0].node):d.pop(),o(b.splice(0,1)[0])}return u+t(n.substr(l))}function l(e){function t(e){return e&&e.source||e}function r(r,a){return new RegExp(t(r),"m"+(e.cI?"i":"")+(a?"g":""))}function a(n,i){if(!n.compiled){if(n.compiled=!0,n.k=n.k||n.bK,n.k){var c={},o=function(t,r){e.cI&&(r=r.toLowerCase()),r.split(" ").forEach(function(e){var r=e.split("|");c[r[0]]=[t,r[1]?Number(r[1]):1]})};"string"==typeof n.k?o("keyword",n.k):N(n.k).forEach(function(e){o(e,n.k[e])}),n.k=c}n.lR=r(n.l||/\w+/,!0),i&&(n.bK&&(n.b="\\b("+n.bK.split(" ").join("|")+")\\b"),n.b||(n.b=/\B|\b/),n.bR=r(n.b),n.e||n.eW||(n.e=/\B|\b/),n.e&&(n.eR=r(n.e)),n.tE=t(n.e)||"",n.eW&&i.tE&&(n.tE+=(n.e?"|":"")+i.tE)),n.i&&(n.iR=r(n.i)),null==n.r&&(n.r=1),n.c||(n.c=[]);var l=[];n.c.forEach(function(e){e.v?e.v.forEach(function(t){l.push(s(e,t))}):l.push("self"===e?n:e)}),n.c=l,n.c.forEach(function(e){a(e,n)}),n.starts&&a(n.starts,i);var u=n.c.map(function(e){return e.bK?"\\.?("+e.b+")\\.?":e.b}).concat([n.tE,n.i]).map(t).filter(Boolean);n.t=u.length?r(u.join("|"),!0):{exec:function(){return null}}}}a(e)}function u(e,r,n,i){function s(e,t){var r,n;for(r=0,n=t.c.length;n>r;r++)if(a(t.c[r].bR,e))return t.c[r]}function c(e,t){if(a(e.eR,t)){for(;e.endsParent&&e.parent;)e=e.parent;return e}return e.eW?c(e.parent,t):void 0}function o(e,t){return!n&&a(t.iR,e)}function b(e,t){var r=v.cI?t[0].toLowerCase():t[0];return e.k.hasOwnProperty(r)&&e.k[r]}function p(e,t,r,a){var n=a?"":R.classPrefix,i='<span class="'+n,s=r?"":B;return i+=e+'">',i+t+s}function m(){var e,r,a,n;if(!N.k)return t(E);for(n="",r=0,N.lR.lastIndex=0,a=N.lR.exec(E);a;)n+=t(E.substr(r,a.index-r)),e=b(N,a),e?(M+=e[1],n+=p(e[0],t(a[0]))):n+=t(a[0]),r=N.lR.lastIndex,a=N.lR.exec(E);return n+t(E.substr(r))}function f(){var e="string"==typeof N.sL;if(e&&!k[N.sL])return t(E);var r=e?u(N.sL,E,!0,x[N.sL]):d(E,N.sL.length?N.sL:void 0);return N.r>0&&(M+=r.r),e&&(x[N.sL]=r.top),p(r.language,r.value,!1,!0)}function g(){C+=null!=N.sL?f():m(),E=""}function _(e){C+=e.cN?p(e.cN,"",!0):"",N=Object.create(e,{parent:{value:N}})}function h(e,t){if(E+=e,null==t)return g(),0;var r=s(t,N);if(r)return r.skip?E+=t:(r.eB&&(E+=t),g(),r.rB||r.eB||(E=t)),_(r,t),r.rB?0:t.length;var a=c(N,t);if(a){var n=N;n.skip?E+=t:(n.rE||n.eE||(E+=t),g(),n.eE&&(E=t));do N.cN&&(C+=B),N.skip||(M+=N.r),N=N.parent;while(N!==a.parent);return a.starts&&_(a.starts,""),n.rE?0:t.length}if(o(t,N))throw new Error('Illegal lexeme "'+t+'" for mode "'+(N.cN||"<unnamed>")+'"');return E+=t,t.length||1}var v=y(e);if(!v)throw new Error('Unknown language: "'+e+'"');l(v);var w,N=i||v,x={},C="";for(w=N;w!==v;w=w.parent)w.cN&&(C=p(w.cN,"",!0)+C);var E="",M=0;try{for(var S,L,A=0;;){if(N.t.lastIndex=A,S=N.t.exec(r),!S)break;L=h(r.substr(A,S.index-A),S[0]),A=S.index+L}for(h(r.substr(A)),w=N;w.parent;w=w.parent)w.cN&&(C+=B);return{r:M,value:C,language:e,top:N}}catch($){if($.message&&-1!==$.message.indexOf("Illegal"))return{r:0,value:t(r)};throw $}}function d(e,r){r=r||R.languages||N(k);var a={r:0,value:t(e)},n=a;return r.filter(y).forEach(function(t){var r=u(t,e,!1);r.language=t,r.r>n.r&&(n=r),r.r>a.r&&(n=a,a=r)}),n.language&&(a.second_best=n),a}function b(e){return R.tabReplace||R.useBR?e.replace(M,function(e,t){return R.useBR&&"\n"===e?"<br>":R.tabReplace?t.replace(/\t/g,R.tabReplace):void 0}):e}function p(e,t,r){var a=t?x[t]:r,n=[e.trim()];return e.match(/\bhljs\b/)||n.push("hljs"),-1===e.indexOf(a)&&n.push(a),n.join(" ").trim()}function m(e){var t,r,a,s,l,m=i(e);n(m)||(R.useBR?(t=document.createElementNS("http://www.w3.org/1999/xhtml","div"),t.innerHTML=e.innerHTML.replace(/\n/g,"").replace(/<br[ \/]*>/g,"\n")):t=e,l=t.textContent,a=m?u(m,l,!0):d(l),r=c(t),r.length&&(s=document.createElementNS("http://www.w3.org/1999/xhtml","div"),s.innerHTML=a.value,a.value=o(r,c(s),l)),a.value=b(a.value),e.innerHTML=a.value,e.className=p(e.className,m,a.language),e.result={language:a.language,re:a.r},a.second_best&&(e.second_best={language:a.second_best.language,re:a.second_best.r}))}function f(e){R=s(R,e)}function g(){if(!g.called){g.called=!0;var e=document.querySelectorAll("pre code");w.forEach.call(e,m)}}function _(){addEventListener("DOMContentLoaded",g,!1),addEventListener("load",g,!1)}function h(t,r){var a=k[t]=r(e);a.aliases&&a.aliases.forEach(function(e){x[e]=t})}function v(){return N(k)}function y(e){return e=(e||"").toLowerCase(),k[e]||k[x[e]]}var w=[],N=Object.keys,k={},x={},C=/^(no-?highlight|plain|text)$/i,E=/\blang(?:uage)?-([\w-]+)\b/i,M=/((^(<[^>]+>|\t|)+|(?:\n)))/gm,B="</span>",R={classPrefix:"hljs-",tabReplace:null,useBR:!1,languages:void 0},S={"&":"&amp;","<":"&lt;",">":"&gt;"};return e.highlight=u,e.highlightAuto=d,e.fixMarkup=b,e.highlightBlock=m,e.configure=f,e.initHighlighting=g,e.initHighlightingOnLoad=_,e.registerLanguage=h,e.listLanguages=v,e.getLanguage=y,e.inherit=s,e.IR="[a-zA-Z]\\w*",e.UIR="[a-zA-Z_]\\w*",e.NR="\\b\\d+(\\.\\d+)?",e.CNR="(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",e.BNR="\\b(0b[01]+)",e.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",e.BE={b:"\\\\[\\s\\S]",r:0},e.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[e.BE]},e.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[e.BE]},e.PWM={b:/\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|like)\b/},e.C=function(t,r,a){var n=e.inherit({cN:"comment",b:t,e:r,c:[]},a||{});return n.c.push(e.PWM),n.c.push({cN:"doctag",b:"(?:TODO|FIXME|NOTE|BUG|XXX):",r:0}),n},e.CLCM=e.C("//","$"),e.CBCM=e.C("/\\*","\\*/"),e.HCM=e.C("#","$"),e.NM={cN:"number",b:e.NR,r:0},e.CNM={cN:"number",b:e.CNR,r:0},e.BNM={cN:"number",b:e.BNR,r:0},e.CSSNM={cN:"number",b:e.NR+"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",r:0},e.RM={cN:"regexp",b:/\//,e:/\/[gimuy]*/,i:/\n/,c:[e.BE,{b:/\[/,e:/\]/,r:0,c:[e.BE]}]},e.TM={cN:"title",b:e.IR,r:0},e.UTM={cN:"title",b:e.UIR,r:0},e.METHOD_GUARD={b:"\\.\\s*"+e.UIR,r:0},e.registerLanguage("apache",function(e){var t={cN:"number",b:"[\\$%]\\d+"};return{aliases:["apacheconf"],cI:!0,c:[e.HCM,{cN:"section",b:"</?",e:">"},{cN:"attribute",b:/\w+/,r:0,k:{nomarkup:"order deny allow setenv rewriterule rewriteengine rewritecond documentroot sethandler errordocument loadmodule options header listen serverroot servername"},starts:{e:/$/,r:0,k:{literal:"on off all"},c:[{cN:"meta",b:"\\s\\[",e:"\\]$"},{cN:"variable",b:"[\\$%]\\{",e:"\\}",c:["self",t]},t,e.QSM]}}],i:/\S/}}),e.registerLanguage("bash",function(e){var t={cN:"variable",v:[{b:/\$[\w\d#@][\w\d_]*/},{b:/\$\{(.*?)}/}]},r={cN:"string",b:/"/,e:/"/,c:[e.BE,t,{cN:"variable",b:/\$\(/,e:/\)/,c:[e.BE]}]},a={cN:"string",b:/'/,e:/'/};return{aliases:["sh","zsh"],l:/-?[a-z\._]+/,k:{keyword:"if then else elif fi for while in do done case esac function",literal:"true false",built_in:"break cd continue eval exec exit export getopts hash pwd readonly return shift test times trap umask unset alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias set shopt autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate fc fg float functions getcap getln history integer jobs kill limit log noglob popd print pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof zpty zregexparse zsocket zstyle ztcp",_:"-ne -eq -lt -gt -f -d -e -s -l -a"},c:[{cN:"meta",b:/^#![^\n]+sh\s*$/,r:10},{cN:"function",b:/\w[\w\d_]*\s*\(\s*\)\s*\{/,rB:!0,c:[e.inherit(e.TM,{b:/\w[\w\d_]*/})],r:0},e.HCM,r,a,t]}}),e.registerLanguage("coffeescript",function(e){var t={keyword:"in if for while finally new do return else break catch instanceof throw try this switch continue typeof delete debugger super then unless until loop of by when and or is isnt not",literal:"true false null undefined yes no on off",built_in:"npm require console print module global window document"},r="[A-Za-z$_][0-9A-Za-z$_]*",a={cN:"subst",b:/#\{/,e:/}/,k:t},n=[e.BNM,e.inherit(e.CNM,{starts:{e:"(\\s*/)?",r:0}}),{cN:"string",v:[{b:/'''/,e:/'''/,c:[e.BE]},{b:/'/,e:/'/,c:[e.BE]},{b:/"""/,e:/"""/,c:[e.BE,a]},{b:/"/,e:/"/,c:[e.BE,a]}]},{cN:"regexp",v:[{b:"///",e:"///",c:[a,e.HCM]},{b:"//[gim]*",r:0},{b:/\/(?![ *])(\\\/|.)*?\/[gim]*(?=\W|$)/}]},{b:"@"+r},{b:"`",e:"`",eB:!0,eE:!0,sL:"javascript"}];a.c=n;var i=e.inherit(e.TM,{b:r}),s="(\\(.*\\))?\\s*\\B[-=]>",c={cN:"params",b:"\\([^\\(]",rB:!0,c:[{b:/\(/,e:/\)/,k:t,c:["self"].concat(n)}]};return{aliases:["coffee","cson","iced"],k:t,i:/\/\*/,c:n.concat([e.C("###","###"),e.HCM,{cN:"function",b:"^\\s*"+r+"\\s*=\\s*"+s,e:"[-=]>",rB:!0,c:[i,c]},{b:/[:\(,=]\s*/,r:0,c:[{cN:"function",b:s,e:"[-=]>",rB:!0,c:[c]}]},{cN:"class",bK:"class",e:"$",i:/[:="\[\]]/,c:[{bK:"extends",eW:!0,i:/[:="\[\]]/,c:[i]},i]},{b:r+":",e:":",rB:!0,rE:!0,r:0}])}}),e.registerLanguage("cpp",function(e){var t={cN:"keyword",b:"\\b[a-z\\d_]*_t\\b"},r={cN:"string",v:[{b:'(u8?|U)?L?"',e:'"',i:"\\n",c:[e.BE]},{b:'(u8?|U)?R"',e:'"',c:[e.BE]},{b:"'\\\\?.",e:"'",i:"."}]},a={cN:"number",v:[{b:"\\b(0b[01']+)"},{b:"\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)"},{b:"(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"}],r:0},n={cN:"meta",b:/#\s*[a-z]+\b/,e:/$/,k:{"meta-keyword":"if else elif endif define undef warning error line pragma ifdef ifndef include"},c:[{b:/\\\n/,r:0},e.inherit(r,{cN:"meta-string"}),{cN:"meta-string",b:"<",e:">",i:"\\n"},e.CLCM,e.CBCM]},i=e.IR+"\\s*\\(",s={keyword:"int float while private char catch import module export virtual operator sizeof dynamic_cast|10 typedef const_cast|10 const struct for static_cast|10 union namespace unsigned long volatile static protected bool template mutable if public friend do goto auto void enum else break extern using class asm case typeid short reinterpret_cast|10 default double register explicit signed typename try this switch continue inline delete alignof constexpr decltype noexcept static_assert thread_local restrict _Bool complex _Complex _Imaginary atomic_bool atomic_char atomic_schar atomic_uchar atomic_short atomic_ushort atomic_int atomic_uint atomic_long atomic_ulong atomic_llong atomic_ullong new throw return",built_in:"std string cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap array shared_ptr abort abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr",literal:"true false nullptr NULL"},c=[t,e.CLCM,e.CBCM,a,r];return{aliases:["c","cc","h","c++","h++","hpp"],k:s,i:"</",c:c.concat([n,{b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:s,c:["self",t]},{b:e.IR+"::",k:s},{v:[{b:/=/,e:/;/},{b:/\(/,e:/\)/},{bK:"new throw return else",e:/;/}],k:s,c:c.concat([{b:/\(/,e:/\)/,k:s,c:c.concat(["self"]),r:0}]),r:0},{cN:"function",b:"("+e.IR+"[\\*&\\s]+)+"+i,rB:!0,e:/[{;=]/,eE:!0,k:s,i:/[^\w\s\*&]/,c:[{b:i,rB:!0,c:[e.TM],r:0},{cN:"params",b:/\(/,e:/\)/,k:s,r:0,c:[e.CLCM,e.CBCM,r,a,t]},e.CLCM,e.CBCM,n]}]),exports:{preprocessor:n,strings:r,k:s}}}),e.registerLanguage("cs",function(e){var t={keyword:"abstract as base bool break byte case catch char checked const continue decimal default delegate do double else enum event explicit extern finally fixed float for foreach goto if implicit in int interface internal is lock long object operator out override params private protected public readonly ref sbyte sealed short sizeof stackalloc static string struct switch this try typeof uint ulong unchecked unsafe ushort using virtual void volatile while nameof add alias ascending async await by descending dynamic equals from get global group into join let on orderby partial remove select set value var where yield",literal:"null false true"},r={cN:"string",b:'@"',e:'"',c:[{b:'""'}]},a=e.inherit(r,{i:/\n/}),n={cN:"subst",b:"{",e:"}",k:t},i=e.inherit(n,{i:/\n/}),s={cN:"string",b:/\$"/,e:'"',i:/\n/,c:[{b:"{{"},{b:"}}"},e.BE,i]},c={cN:"string",b:/\$@"/,e:'"',c:[{b:"{{"},{b:"}}"},{b:'""'},n]},o=e.inherit(c,{i:/\n/,c:[{b:"{{"},{b:"}}"},{b:'""'},i]});n.c=[c,s,r,e.ASM,e.QSM,e.CNM,e.CBCM],i.c=[o,s,a,e.ASM,e.QSM,e.CNM,e.inherit(e.CBCM,{i:/\n/})];var l={v:[c,s,r,e.ASM,e.QSM]},u=e.IR+"(<"+e.IR+"(\\s*,\\s*"+e.IR+")*>)?(\\[\\])?";return{aliases:["csharp"],k:t,i:/::/,c:[e.C("///","$",{rB:!0,c:[{cN:"doctag",v:[{b:"///",r:0},{b:"<!--|-->"},{b:"</?",e:">"}]}]}),e.CLCM,e.CBCM,{cN:"meta",b:"#",e:"$",k:{"meta-keyword":"if else elif endif define undef warning error line region endregion pragma checksum"}},l,e.CNM,{bK:"class interface",e:/[{;=]/,i:/[^\s:]/,c:[e.TM,e.CLCM,e.CBCM]},{bK:"namespace",e:/[{;=]/,i:/[^\s:]/,c:[e.inherit(e.TM,{b:"[a-zA-Z](\\.?\\w)*"}),e.CLCM,e.CBCM]},{bK:"new return throw await",r:0},{cN:"function",b:"("+u+"\\s+)+"+e.IR+"\\s*\\(",rB:!0,e:/[{;=]/,eE:!0,k:t,c:[{b:e.IR+"\\s*\\(",rB:!0,c:[e.TM],r:0},{cN:"params",b:/\(/,e:/\)/,eB:!0,eE:!0,k:t,r:0,c:[l,e.CNM,e.CBCM]},e.CLCM,e.CBCM]}]}}),e.registerLanguage("css",function(e){var t="[a-zA-Z-][a-zA-Z0-9_-]*",r={b:/[A-Z\_\.\-]+\s*:/,rB:!0,e:";",eW:!0,c:[{cN:"attribute",b:/\S/,e:":",eE:!0,starts:{eW:!0,eE:!0,c:[{b:/[\w-]+\(/,rB:!0,c:[{cN:"built_in",b:/[\w-]+/},{b:/\(/,e:/\)/,c:[e.ASM,e.QSM]}]},e.CSSNM,e.QSM,e.ASM,e.CBCM,{cN:"number",b:"#[0-9A-Fa-f]+"},{cN:"meta",b:"!important"}]}}]};return{cI:!0,i:/[=\/|'\$]/,c:[e.CBCM,{cN:"selector-id",b:/#[A-Za-z0-9_-]+/},{cN:"selector-class",b:/\.[A-Za-z0-9_-]+/},{cN:"selector-attr",b:/\[/,e:/\]/,i:"$"},{cN:"selector-pseudo",b:/:(:)?[a-zA-Z0-9\_\-\+\(\)"'.]+/},{b:"@(font-face|page)",l:"[a-z-]+",k:"font-face page"},{b:"@",e:"[{;]",i:/:/,c:[{cN:"keyword",b:/\w+/},{b:/\s/,eW:!0,eE:!0,r:0,c:[e.ASM,e.QSM,e.CSSNM]}]},{cN:"selector-tag",b:t,r:0},{b:"{",e:"}",i:/\S/,c:[e.CBCM,r]}]}}),e.registerLanguage("diff",function(e){return{aliases:["patch"],c:[{cN:"meta",r:10,v:[{b:/^@@ +\-\d+,\d+ +\+\d+,\d+ +@@$/},{b:/^\*\*\* +\d+,\d+ +\*\*\*\*$/},{b:/^\-\-\- +\d+,\d+ +\-\-\-\-$/}]},{cN:"comment",v:[{b:/Index: /,e:/$/},{b:/={3,}/,e:/$/},{b:/^\-{3}/,e:/$/},{b:/^\*{3} /,e:/$/},{b:/^\+{3}/,e:/$/},{b:/\*{5}/,e:/\*{5}$/}]},{cN:"addition",b:"^\\+",e:"$"},{cN:"deletion",b:"^\\-",e:"$"},{cN:"addition",b:"^\\!",e:"$"}]}}),e.registerLanguage("http",function(e){var t="HTTP/[0-9\\.]+";return{aliases:["https"],i:"\\S",c:[{b:"^"+t,e:"$",c:[{cN:"number",b:"\\b\\d{3}\\b"}]},{b:"^[A-Z]+ (.*?) "+t+"$",rB:!0,e:"$",c:[{cN:"string",b:" ",e:" ",eB:!0,eE:!0},{b:t},{cN:"keyword",b:"[A-Z]+"}]},{cN:"attribute",b:"^\\w",e:": ",eE:!0,i:"\\n|\\s|=",starts:{e:"$",r:0}},{b:"\\n\\n",starts:{sL:[],eW:!0}}]}}),e.registerLanguage("ini",function(e){var t={cN:"string",c:[e.BE],v:[{b:"'''",e:"'''",r:10},{b:'"""',e:'"""',r:10},{b:'"',e:'"'},{b:"'",e:"'"}]};return{aliases:["toml"],cI:!0,i:/\S/,c:[e.C(";","$"),e.HCM,{cN:"section",b:/^\s*\[+/,e:/\]+/},{b:/^[a-z0-9\[\]_-]+\s*=\s*/,e:"$",rB:!0,c:[{cN:"attr",b:/[a-z0-9\[\]_-]+/},{b:/=/,eW:!0,r:0,c:[{cN:"literal",b:/\bon|off|true|false|yes|no\b/},{cN:"variable",v:[{b:/\$[\w\d"][\w\d_]*/},{b:/\$\{(.*?)}/}]},t,{cN:"number",b:/([\+\-]+)?[\d]+_[\d_]+/},e.NM]}]}]}}),e.registerLanguage("java",function(e){var t=e.UIR+"(<"+e.UIR+"(\\s*,\\s*"+e.UIR+")*>)?",r="false synchronized int abstract float private char boolean static null if const for true while long strictfp finally protected import native final void enum else break transient catch instanceof byte super volatile case assert short package default double public try this switch continue throws protected public private module requires exports",a="\\b(0[bB]([01]+[01_]+[01]+|[01]+)|0[xX]([a-fA-F0-9]+[a-fA-F0-9_]+[a-fA-F0-9]+|[a-fA-F0-9]+)|(([\\d]+[\\d_]+[\\d]+|[\\d]+)(\\.([\\d]+[\\d_]+[\\d]+|[\\d]+))?|\\.([\\d]+[\\d_]+[\\d]+|[\\d]+))([eE][-+]?\\d+)?)[lLfF]?",n={cN:"number",b:a,r:0};return{aliases:["jsp"],k:r,i:/<\/|#/,c:[e.C("/\\*\\*","\\*/",{r:0,c:[{b:/\w+@/,r:0},{cN:"doctag",b:"@[A-Za-z]+"}]}),e.CLCM,e.CBCM,e.ASM,e.QSM,{cN:"class",bK:"class interface",e:/[{;=]/,eE:!0,k:"class interface",i:/[:"\[\]]/,c:[{bK:"extends implements"},e.UTM]},{bK:"new throw return else",r:0},{cN:"function",b:"("+t+"\\s+)+"+e.UIR+"\\s*\\(",rB:!0,e:/[{;=]/,eE:!0,k:r,c:[{b:e.UIR+"\\s*\\(",rB:!0,r:0,c:[e.UTM]},{cN:"params",b:/\(/,e:/\)/,k:r,r:0,c:[e.ASM,e.QSM,e.CNM,e.CBCM]},e.CLCM,e.CBCM]},n,{cN:"meta",b:"@[A-Za-z]+"}]}}),e.registerLanguage("javascript",function(e){var t="[A-Za-z$_][0-9A-Za-z$_]*",r={keyword:"in of if for while finally var new function do return void else break catch instanceof with throw case default try this switch continue typeof delete let yield const export super debugger as async await static import from as",literal:"true false null undefined NaN Infinity",built_in:"eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError Number Math Date String RegExp Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require module console window document Symbol Set Map WeakSet WeakMap Proxy Reflect Promise"},a={cN:"number",v:[{b:"\\b(0[bB][01]+)"},{b:"\\b(0[oO][0-7]+)"},{b:e.CNR}],r:0},n={cN:"subst",b:"\\$\\{",e:"\\}",k:r,c:[]},i={cN:"string",b:"`",e:"`",c:[e.BE,n]};n.c=[e.ASM,e.QSM,i,a,e.RM];var s=n.c.concat([e.CBCM,e.CLCM]);return{aliases:["js","jsx"],k:r,c:[{cN:"meta",r:10,b:/^\s*['"]use (strict|asm)['"]/},{cN:"meta",b:/^#!/,e:/$/},e.ASM,e.QSM,i,e.CLCM,e.CBCM,a,{b:/[{,]\s*/,r:0,c:[{b:t+"\\s*:",rB:!0,r:0,c:[{cN:"attr",b:t,r:0}]}]},{b:"("+e.RSR+"|\\b(case|return|throw)\\b)\\s*",k:"return throw case",c:[e.CLCM,e.CBCM,e.RM,{cN:"function",b:"(\\(.*?\\)|"+t+")\\s*=>",rB:!0,e:"\\s*=>",c:[{cN:"params",v:[{b:t},{b:/\(\s*\)/},{b:/\(/,e:/\)/,eB:!0,eE:!0,k:r,c:s}]}]},{b:/</,e:/(\/\w+|\w+\/)>/,sL:"xml",c:[{b:/<\w+\s*\/>/,skip:!0},{b:/<\w+/,e:/(\/\w+|\w+\/)>/,skip:!0,c:[{b:/<\w+\s*\/>/,skip:!0},"self"]}]}],r:0},{cN:"function",bK:"function",e:/\{/,eE:!0,c:[e.inherit(e.TM,{b:t}),{cN:"params",b:/\(/,e:/\)/,eB:!0,eE:!0,c:s}],i:/\[|%/},{b:/\$[(.]/},e.METHOD_GUARD,{cN:"class",bK:"class",e:/[{;=]/,eE:!0,i:/[:"\[\]]/,c:[{bK:"extends"},e.UTM]},{bK:"constructor",e:/\{/,eE:!0}],i:/#(?!!)/}}),e.registerLanguage("json",function(e){var t={literal:"true false null"},r=[e.QSM,e.CNM],a={e:",",eW:!0,eE:!0,c:r,k:t},n={b:"{",e:"}",c:[{cN:"attr",b:/"/,e:/"/,c:[e.BE],i:"\\n"},e.inherit(a,{b:/:/})],i:"\\S"},i={b:"\\[",e:"\\]",c:[e.inherit(a)],i:"\\S"};return r.splice(r.length,0,n,i),{c:r,k:t,i:"\\S"}}),e.registerLanguage("makefile",function(e){var t={cN:"variable",b:/\$\(/,e:/\)/,c:[e.BE]};return{aliases:["mk","mak"],c:[e.HCM,{b:/^\w+\s*\W*=/,rB:!0,r:0,starts:{e:/\s*\W*=/,eE:!0,starts:{e:/$/,r:0,c:[t]}}},{cN:"section",b:/^[\w]+:\s*$/},{cN:"meta",b:/^\.PHONY:/,e:/$/,k:{"meta-keyword":".PHONY"},l:/[\.\w]+/},{b:/^\t+/,e:/$/,r:0,c:[e.QSM,t]}]}}),e.registerLanguage("xml",function(e){var t="[A-Za-z0-9\\._:-]+",r={eW:!0,i:/</,r:0,c:[{cN:"attr",b:t,r:0},{b:/=\s*/,r:0,c:[{cN:"string",endsParent:!0,v:[{b:/"/,e:/"/},{b:/'/,e:/'/},{b:/[^\s"'=<>`]+/}]}]}]};return{aliases:["html","xhtml","rss","atom","xjb","xsd","xsl","plist"],cI:!0,c:[{cN:"meta",b:"<!DOCTYPE",e:">",r:10,c:[{b:"\\[",e:"\\]"}]},e.C("<!--","-->",{r:10}),{b:"<\\!\\[CDATA\\[",e:"\\]\\]>",r:10},{b:/<\?(php)?/,e:/\?>/,sL:"php",c:[{b:"/\\*",e:"\\*/",skip:!0}]},{cN:"tag",b:"<style(?=\\s|>|$)",e:">",k:{name:"style"},c:[r],starts:{e:"</style>",rE:!0,sL:["css","xml"]}},{cN:"tag",b:"<script(?=\\s|>|$)",e:">",k:{name:"script"},c:[r],starts:{e:"</script>",rE:!0,sL:["actionscript","javascript","handlebars","xml"]}},{cN:"meta",v:[{b:/<\?xml/,e:/\?>/,r:10},{b:/<\?\w+/,e:/\?>/}]},{cN:"tag",b:"</?",e:"/?>",c:[{cN:"name",b:/[^\/><\s]+/,r:0},r]}]}}),e.registerLanguage("markdown",function(e){return{aliases:["md","mkdown","mkd"],c:[{cN:"section",v:[{b:"^#{1,6}",e:"$"},{b:"^.+?\\n[=-]{2,}$"}]},{b:"<",e:">",sL:"xml",r:0},{cN:"bullet",b:"^([*+-]|(\\d+\\.))\\s+"},{cN:"strong",b:"[*_]{2}.+?[*_]{2}"},{cN:"emphasis",v:[{b:"\\*.+?\\*"},{b:"_.+?_",r:0}]},{cN:"quote",b:"^>\\s+",e:"$"},{cN:"code",v:[{b:"^```w*s*$",e:"^```s*$"},{b:"`.+?`"},{b:"^( {4}|	)",e:"$",r:0}]},{b:"^[-\\*]{3,}",e:"$"},{b:"\\[.+?\\][\\(\\[].*?[\\)\\]]",rB:!0,c:[{cN:"string",b:"\\[",e:"\\]",eB:!0,rE:!0,r:0},{cN:"link",b:"\\]\\(",e:"\\)",eB:!0,eE:!0},{cN:"symbol",b:"\\]\\[",e:"\\]",eB:!0,eE:!0}],r:10},{b:/^\[[^\n]+\]:/,rB:!0,c:[{cN:"symbol",b:/\[/,e:/\]/,eB:!0,eE:!0},{cN:"link",b:/:\s*/,e:/$/,eB:!0}]}]}}),e.registerLanguage("nginx",function(e){var t={cN:"variable",v:[{b:/\$\d+/},{b:/\$\{/,e:/}/},{b:"[\\$\\@]"+e.UIR}]},r={eW:!0,l:"[a-z/_]+",k:{literal:"on off yes no true false none blocked debug info notice warn error crit select break last permanent redirect kqueue rtsig epoll poll /dev/poll"},r:0,i:"=>",c:[e.HCM,{cN:"string",c:[e.BE,t],v:[{b:/"/,e:/"/},{b:/'/,e:/'/}]},{b:"([a-z]+):/",e:"\\s",eW:!0,eE:!0,c:[t]},{cN:"regexp",c:[e.BE,t],v:[{b:"\\s\\^",e:"\\s|{|;",rE:!0},{b:"~\\*?\\s+",e:"\\s|{|;",rE:!0},{b:"\\*(\\.[a-z\\-]+)+"},{b:"([a-z\\-]+\\.)+\\*"}]},{cN:"number",b:"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}(:\\d{1,5})?\\b"},{cN:"number",b:"\\b\\d+[kKmMgGdshdwy]*\\b",r:0},t]};return{aliases:["nginxconf"],c:[e.HCM,{b:e.UIR+"\\s+{",rB:!0,e:"{",c:[{cN:"section",b:e.UIR}],r:0},{b:e.UIR+"\\s",e:";|{",rB:!0,c:[{cN:"attribute",b:e.UIR,starts:r}],r:0}],i:"[^\\s\\}]"}}),e.registerLanguage("objectivec",function(e){var t={cN:"built_in",b:"\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"},r={keyword:"int float while char export sizeof typedef const struct for union unsigned long volatile static bool mutable if do return goto void enum else break extern asm case short default double register explicit signed typename this switch continue wchar_t inline readonly assign readwrite self @synchronized id typeof nonatomic super unichar IBOutlet IBAction strong weak copy in out inout bycopy byref oneway __strong __weak __block __autoreleasing @private @protected @public @try @property @end @throw @catch @finally @autoreleasepool @synthesize @dynamic @selector @optional @required @encode @package @import @defs @compatibility_alias __bridge __bridge_transfer __bridge_retained __bridge_retain __covariant __contravariant __kindof _Nonnull _Nullable _Null_unspecified __FUNCTION__ __PRETTY_FUNCTION__ __attribute__ getter setter retain unsafe_unretained nonnull nullable null_unspecified null_resettable class instancetype NS_DESIGNATED_INITIALIZER NS_UNAVAILABLE NS_REQUIRES_SUPER NS_RETURNS_INNER_POINTER NS_INLINE NS_AVAILABLE NS_DEPRECATED NS_ENUM NS_OPTIONS NS_SWIFT_UNAVAILABLE NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_REFINED_FOR_SWIFT NS_SWIFT_NAME NS_SWIFT_NOTHROW NS_DURING NS_HANDLER NS_ENDHANDLER NS_VALUERETURN NS_VOIDRETURN",literal:"false true FALSE TRUE nil YES NO NULL",built_in:"BOOL dispatch_once_t dispatch_queue_t dispatch_sync dispatch_async dispatch_once"},a=/[a-zA-Z@][a-zA-Z0-9_]*/,n="@interface @class @protocol @implementation";return{aliases:["mm","objc","obj-c"],k:r,l:a,i:"</",c:[t,e.CLCM,e.CBCM,e.CNM,e.QSM,{cN:"string",v:[{b:'@"',e:'"',i:"\\n",c:[e.BE]},{b:"'",e:"[^\\\\]'",i:"[^\\\\][^']"}]},{cN:"meta",b:"#",e:"$",c:[{cN:"meta-string",v:[{b:'"',e:'"'},{b:"<",e:">"}]}]},{cN:"class",b:"("+n.split(" ").join("|")+")\\b",e:"({|$)",eE:!0,k:n,l:a,c:[e.UTM]},{b:"\\."+e.UIR,r:0}]}}),e.registerLanguage("perl",function(e){var t="getpwent getservent quotemeta msgrcv scalar kill dbmclose undef lc ma syswrite tr send umask sysopen shmwrite vec qx utime local oct semctl localtime readpipe do return format read sprintf dbmopen pop getpgrp not getpwnam rewinddir qqfileno qw endprotoent wait sethostent bless s|0 opendir continue each sleep endgrent shutdown dump chomp connect getsockname die socketpair close flock exists index shmgetsub for endpwent redo lstat msgctl setpgrp abs exit select print ref gethostbyaddr unshift fcntl syscall goto getnetbyaddr join gmtime symlink semget splice x|0 getpeername recv log setsockopt cos last reverse gethostbyname getgrnam study formline endhostent times chop length gethostent getnetent pack getprotoent getservbyname rand mkdir pos chmod y|0 substr endnetent printf next open msgsnd readdir use unlink getsockopt getpriority rindex wantarray hex system getservbyport endservent int chr untie rmdir prototype tell listen fork shmread ucfirst setprotoent else sysseek link getgrgid shmctl waitpid unpack getnetbyname reset chdir grep split require caller lcfirst until warn while values shift telldir getpwuid my getprotobynumber delete and sort uc defined srand accept package seekdir getprotobyname semop our rename seek if q|0 chroot sysread setpwent no crypt getc chown sqrt write setnetent setpriority foreach tie sin msgget map stat getlogin unless elsif truncate exec keys glob tied closedirioctl socket readlink eval xor readline binmode setservent eof ord bind alarm pipe atan2 getgrent exp time push setgrent gt lt or ne m|0 break given say state when",r={cN:"subst",b:"[$@]\\{",e:"\\}",k:t},a={b:"->{",e:"}"},n={v:[{b:/\$\d/},{b:/[\$%@](\^\w\b|#\w+(::\w+)*|{\w+}|\w+(::\w*)*)/},{b:/[\$%@][^\s\w{]/,r:0}]},i=[e.BE,r,n],s=[n,e.HCM,e.C("^\\=\\w","\\=cut",{eW:!0}),a,{cN:"string",c:i,v:[{b:"q[qwxr]?\\s*\\(",e:"\\)",r:5},{b:"q[qwxr]?\\s*\\[",e:"\\]",r:5},{b:"q[qwxr]?\\s*\\{",e:"\\}",r:5},{b:"q[qwxr]?\\s*\\|",e:"\\|",r:5},{b:"q[qwxr]?\\s*\\<",e:"\\>",r:5},{b:"qw\\s+q",e:"q",r:5},{b:"'",e:"'",c:[e.BE]},{b:'"',e:'"'},{b:"`",e:"`",c:[e.BE]},{b:"{\\w+}",c:[],r:0},{b:"-?\\w+\\s*\\=\\>",c:[],r:0}]},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{b:"(\\/\\/|"+e.RSR+"|\\b(split|return|print|reverse|grep)\\b)\\s*",k:"split return print reverse grep",r:0,c:[e.HCM,{cN:"regexp",b:"(s|tr|y)/(\\\\.|[^/])*/(\\\\.|[^/])*/[a-z]*",r:10},{cN:"regexp",b:"(m|qr)?/",e:"/[a-z]*",c:[e.BE],r:0}]},{cN:"function",bK:"sub",e:"(\\s*\\(.*?\\))?[;{]",eE:!0,r:5,c:[e.TM]},{b:"-\\w\\b",r:0},{b:"^__DATA__$",e:"^__END__$",sL:"mojolicious",c:[{b:"^@@.*",e:"$",cN:"comment"}]}];return r.c=s,a.c=s,{aliases:["pl","pm"],l:/[\w\.]+/,k:t,c:s}}),e.registerLanguage("php",function(e){var t={b:"\\$+[a-zA-Z_-ÿ][a-zA-Z0-9_-ÿ]*"},r={cN:"meta",b:/<\?(php)?|\?>/},a={cN:"string",c:[e.BE,r],v:[{b:'b"',e:'"'},{b:"b'",e:"'"},e.inherit(e.ASM,{i:null}),e.inherit(e.QSM,{i:null})]},n={v:[e.BNM,e.CNM]};return{aliases:["php3","php4","php5","php6"],cI:!0,k:"and include_once list abstract global private echo interface as static endswitch array null if endwhile or const for endforeach self var while isset public protected exit foreach throw elseif include __FILE__ empty require_once do xor return parent clone use __CLASS__ __LINE__ else break print eval new catch __METHOD__ case exception default die require __FUNCTION__ enddeclare final try switch continue endfor endif declare unset true false trait goto instanceof insteadof __DIR__ __NAMESPACE__ yield finally",c:[e.HCM,e.C("//","$",{c:[r]}),e.C("/\\*","\\*/",{c:[{cN:"doctag",b:"@[A-Za-z]+"}]}),e.C("__halt_compiler.+?;",!1,{eW:!0,k:"__halt_compiler",l:e.UIR}),{cN:"string",b:/<<<['"]?\w+['"]?$/,e:/^\w+;?$/,c:[e.BE,{cN:"subst",v:[{b:/\$\w+/},{b:/\{\$/,e:/\}/}]}]},r,{cN:"keyword",b:/\$this\b/},t,{b:/(::|->)+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/},{cN:"function",bK:"function",e:/[;{]/,eE:!0,i:"\\$|\\[|%",c:[e.UTM,{cN:"params",b:"\\(",e:"\\)",c:["self",t,e.CBCM,a,n]}]},{cN:"class",bK:"class interface",e:"{",eE:!0,i:/[:\(\$"]/,c:[{bK:"extends implements"},e.UTM]},{bK:"namespace",e:";",i:/[\.']/,c:[e.UTM]},{bK:"use",e:";",c:[e.UTM]},{b:"=>"},a,n]}}),e.registerLanguage("python",function(e){var t={cN:"meta",b:/^(>>>|\.\.\.) /},r={cN:"string",c:[e.BE],v:[{b:/(u|b)?r?'''/,e:/'''/,c:[t],r:10},{b:/(u|b)?r?"""/,e:/"""/,c:[t],r:10},{b:/(u|r|ur)'/,e:/'/,r:10},{b:/(u|r|ur)"/,e:/"/,r:10},{b:/(b|br)'/,e:/'/},{b:/(b|br)"/,e:/"/},e.ASM,e.QSM]},a={cN:"number",r:0,v:[{b:e.BNR+"[lLjJ]?"},{b:"\\b(0o[0-7]+)[lLjJ]?"},{b:e.CNR+"[lLjJ]?"}]},n={cN:"params",b:/\(/,e:/\)/,c:["self",t,a,r]};return{aliases:["py","gyp"],k:{keyword:"and elif is global as in if from raise for except finally print import pass return exec else break not with class assert yield try while continue del or def lambda async await nonlocal|10 None True False",built_in:"Ellipsis NotImplemented"},i:/(<\/|->|\?)/,c:[t,a,r,e.HCM,{v:[{cN:"function",bK:"def",r:10},{cN:"class",bK:"class"}],e:/:/,i:/[${=;\n,]/,c:[e.UTM,n,{b:/->/,eW:!0,k:"None"}]},{cN:"meta",b:/^[\t ]*@/,e:/$/},{b:/\b(print|exec)\(/}]}}),e.registerLanguage("ruby",function(e){var t="[a-zA-Z_]\\w*[!?=]?|[-+~]\\@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?",r={keyword:"and then defined module in return redo if BEGIN retry end for self when next until do begin unless END rescue else break undef not super class case require yield alias while ensure elsif or include attr_reader attr_writer attr_accessor",literal:"true false nil"},a={cN:"doctag",b:"@[A-Za-z]+"},n={b:"#<",e:">"},i=[e.C("#","$",{c:[a]}),e.C("^\\=begin","^\\=end",{c:[a],r:10}),e.C("^__END__","\\n$")],s={cN:"subst",b:"#\\{",e:"}",k:r},c={cN:"string",c:[e.BE,s],v:[{b:/'/,e:/'/},{b:/"/,e:/"/},{b:/`/,e:/`/},{b:"%[qQwWx]?\\(",e:"\\)"},{b:"%[qQwWx]?\\[",e:"\\]"},{b:"%[qQwWx]?{",e:"}"},{b:"%[qQwWx]?<",e:">"},{b:"%[qQwWx]?/",e:"/"},{b:"%[qQwWx]?%",e:"%"},{b:"%[qQwWx]?-",e:"-"},{b:"%[qQwWx]?\\|",e:"\\|"},{b:/\B\?(\\\d{1,3}|\\x[A-Fa-f0-9]{1,2}|\\u[A-Fa-f0-9]{4}|\\?\S)\b/},{b:/<<(-?)\w+$/,e:/^\s*\w+$/}]},o={cN:"params",b:"\\(",e:"\\)",endsParent:!0,k:r},l=[c,n,{cN:"class",bK:"class module",e:"$|;",i:/=/,c:[e.inherit(e.TM,{b:"[A-Za-z_]\\w*(::\\w+)*(\\?|\\!)?"}),{b:"<\\s*",c:[{b:"("+e.IR+"::)?"+e.IR}]}].concat(i)},{cN:"function",bK:"def",
	e:"$|;",c:[e.inherit(e.TM,{b:t}),o].concat(i)},{b:e.IR+"::"},{cN:"symbol",b:e.UIR+"(\\!|\\?)?:",r:0},{cN:"symbol",b:":(?!\\s)",c:[c,{b:t}],r:0},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{b:"(\\$\\W)|((\\$|\\@\\@?)(\\w+))"},{cN:"params",b:/\|/,e:/\|/,k:r},{b:"("+e.RSR+")\\s*",c:[n,{cN:"regexp",c:[e.BE,s],i:/\n/,v:[{b:"/",e:"/[a-z]*"},{b:"%r{",e:"}[a-z]*"},{b:"%r\\(",e:"\\)[a-z]*"},{b:"%r!",e:"![a-z]*"},{b:"%r\\[",e:"\\][a-z]*"}]}].concat(i),r:0}].concat(i);s.c=l,o.c=l;var u="[>?]>",d="[\\w#]+\\(\\w+\\):\\d+:\\d+>",b="(\\w+-)?\\d+\\.\\d+\\.\\d(p\\d+)?[^>]+>",p=[{b:/^\s*=>/,starts:{e:"$",c:l}},{cN:"meta",b:"^("+u+"|"+d+"|"+b+")",starts:{e:"$",c:l}}];return{aliases:["rb","gemspec","podspec","thor","irb"],k:r,i:/\/\*/,c:i.concat(p).concat(l)}}),e.registerLanguage("sql",function(e){var t=e.C("--","$");return{cI:!0,i:/[<>{}*#]/,c:[{bK:"begin end start commit rollback savepoint lock alter create drop rename call delete do handler insert load replace select truncate update set show pragma grant merge describe use explain help declare prepare execute deallocate release unlock purge reset change stop analyze cache flush optimize repair kill install uninstall checksum restore check backup revoke comment",e:/;/,eW:!0,l:/[\w\.]+/,k:{keyword:"abort abs absolute acc acce accep accept access accessed accessible account acos action activate add addtime admin administer advanced advise aes_decrypt aes_encrypt after agent aggregate ali alia alias allocate allow alter always analyze ancillary and any anydata anydataset anyschema anytype apply archive archived archivelog are as asc ascii asin assembly assertion associate asynchronous at atan atn2 attr attri attrib attribu attribut attribute attributes audit authenticated authentication authid authors auto autoallocate autodblink autoextend automatic availability avg backup badfile basicfile before begin beginning benchmark between bfile bfile_base big bigfile bin binary_double binary_float binlog bit_and bit_count bit_length bit_or bit_xor bitmap blob_base block blocksize body both bound buffer_cache buffer_pool build bulk by byte byteordermark bytes cache caching call calling cancel capacity cascade cascaded case cast catalog category ceil ceiling chain change changed char_base char_length character_length characters characterset charindex charset charsetform charsetid check checksum checksum_agg child choose chr chunk class cleanup clear client clob clob_base clone close cluster_id cluster_probability cluster_set clustering coalesce coercibility col collate collation collect colu colum column column_value columns columns_updated comment commit compact compatibility compiled complete composite_limit compound compress compute concat concat_ws concurrent confirm conn connec connect connect_by_iscycle connect_by_isleaf connect_by_root connect_time connection consider consistent constant constraint constraints constructor container content contents context contributors controlfile conv convert convert_tz corr corr_k corr_s corresponding corruption cos cost count count_big counted covar_pop covar_samp cpu_per_call cpu_per_session crc32 create creation critical cross cube cume_dist curdate current current_date current_time current_timestamp current_user cursor curtime customdatum cycle data database databases datafile datafiles datalength date_add date_cache date_format date_sub dateadd datediff datefromparts datename datepart datetime2fromparts day day_to_second dayname dayofmonth dayofweek dayofyear days db_role_change dbtimezone ddl deallocate declare decode decompose decrement decrypt deduplicate def defa defau defaul default defaults deferred defi defin define degrees delayed delegate delete delete_all delimited demand dense_rank depth dequeue des_decrypt des_encrypt des_key_file desc descr descri describ describe descriptor deterministic diagnostics difference dimension direct_load directory disable disable_all disallow disassociate discardfile disconnect diskgroup distinct distinctrow distribute distributed div do document domain dotnet double downgrade drop dumpfile duplicate duration each edition editionable editions element ellipsis else elsif elt empty enable enable_all enclosed encode encoding encrypt end end-exec endian enforced engine engines enqueue enterprise entityescaping eomonth error errors escaped evalname evaluate event eventdata events except exception exceptions exchange exclude excluding execu execut execute exempt exists exit exp expire explain export export_set extended extent external external_1 external_2 externally extract failed failed_login_attempts failover failure far fast feature_set feature_value fetch field fields file file_name_convert filesystem_like_logging final finish first first_value fixed flash_cache flashback floor flush following follows for forall force form forma format found found_rows freelist freelists freepools fresh from from_base64 from_days ftp full function general generated get get_format get_lock getdate getutcdate global global_name globally go goto grant grants greatest group group_concat group_id grouping grouping_id groups gtid_subtract guarantee guard handler hash hashkeys having hea head headi headin heading heap help hex hierarchy high high_priority hosts hour http id ident_current ident_incr ident_seed identified identity idle_time if ifnull ignore iif ilike ilm immediate import in include including increment index indexes indexing indextype indicator indices inet6_aton inet6_ntoa inet_aton inet_ntoa infile initial initialized initially initrans inmemory inner innodb input insert install instance instantiable instr interface interleaved intersect into invalidate invisible is is_free_lock is_ipv4 is_ipv4_compat is_not is_not_null is_used_lock isdate isnull isolation iterate java join json json_exists keep keep_duplicates key keys kill language large last last_day last_insert_id last_value lax lcase lead leading least leaves left len lenght length less level levels library like like2 like4 likec limit lines link list listagg little ln load load_file lob lobs local localtime localtimestamp locate locator lock locked log log10 log2 logfile logfiles logging logical logical_reads_per_call logoff logon logs long loop low low_priority lower lpad lrtrim ltrim main make_set makedate maketime managed management manual map mapping mask master master_pos_wait match matched materialized max maxextents maximize maxinstances maxlen maxlogfiles maxloghistory maxlogmembers maxsize maxtrans md5 measures median medium member memcompress memory merge microsecond mid migration min minextents minimum mining minus minute minvalue missing mod mode model modification modify module monitoring month months mount move movement multiset mutex name name_const names nan national native natural nav nchar nclob nested never new newline next nextval no no_write_to_binlog noarchivelog noaudit nobadfile nocheck nocompress nocopy nocycle nodelay nodiscardfile noentityescaping noguarantee nokeep nologfile nomapping nomaxvalue nominimize nominvalue nomonitoring none noneditionable nonschema noorder nopr nopro noprom nopromp noprompt norely noresetlogs noreverse normal norowdependencies noschemacheck noswitch not nothing notice notrim novalidate now nowait nth_value nullif nulls num numb numbe nvarchar nvarchar2 object ocicoll ocidate ocidatetime ociduration ociinterval ociloblocator ocinumber ociref ocirefcursor ocirowid ocistring ocitype oct octet_length of off offline offset oid oidindex old on online only opaque open operations operator optimal optimize option optionally or oracle oracle_date oradata ord ordaudio orddicom orddoc order ordimage ordinality ordvideo organization orlany orlvary out outer outfile outline output over overflow overriding package pad parallel parallel_enable parameters parent parse partial partition partitions pascal passing password password_grace_time password_lock_time password_reuse_max password_reuse_time password_verify_function patch path patindex pctincrease pctthreshold pctused pctversion percent percent_rank percentile_cont percentile_disc performance period period_add period_diff permanent physical pi pipe pipelined pivot pluggable plugin policy position post_transaction pow power pragma prebuilt precedes preceding precision prediction prediction_cost prediction_details prediction_probability prediction_set prepare present preserve prior priority private private_sga privileges procedural procedure procedure_analyze processlist profiles project prompt protection public publishingservername purge quarter query quick quiesce quota quotename radians raise rand range rank raw read reads readsize rebuild record records recover recovery recursive recycle redo reduced ref reference referenced references referencing refresh regexp_like register regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy reject rekey relational relative relaylog release release_lock relies_on relocate rely rem remainder rename repair repeat replace replicate replication required reset resetlogs resize resource respect restore restricted result result_cache resumable resume retention return returning returns reuse reverse revoke right rlike role roles rollback rolling rollup round row row_count rowdependencies rowid rownum rows rtrim rules safe salt sample save savepoint sb1 sb2 sb4 scan schema schemacheck scn scope scroll sdo_georaster sdo_topo_geometry search sec_to_time second section securefile security seed segment select self sequence sequential serializable server servererror session session_user sessions_per_user set sets settings sha sha1 sha2 share shared shared_pool short show shrink shutdown si_averagecolor si_colorhistogram si_featurelist si_positionalcolor si_stillimage si_texture siblings sid sign sin size size_t sizes skip slave sleep smalldatetimefromparts smallfile snapshot some soname sort soundex source space sparse spfile split sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_small_result sql_variant_property sqlcode sqldata sqlerror sqlname sqlstate sqrt square standalone standby start starting startup statement static statistics stats_binomial_test stats_crosstab stats_ks_test stats_mode stats_mw_test stats_one_way_anova stats_t_test_ stats_t_test_indep stats_t_test_one stats_t_test_paired stats_wsr_test status std stddev stddev_pop stddev_samp stdev stop storage store stored str str_to_date straight_join strcmp strict string struct stuff style subdate subpartition subpartitions substitutable substr substring subtime subtring_index subtype success sum suspend switch switchoffset switchover sync synchronous synonym sys sys_xmlagg sysasm sysaux sysdate sysdatetimeoffset sysdba sysoper system system_user sysutcdatetime table tables tablespace tan tdo template temporary terminated tertiary_weights test than then thread through tier ties time time_format time_zone timediff timefromparts timeout timestamp timestampadd timestampdiff timezone_abbr timezone_minute timezone_region to to_base64 to_date to_days to_seconds todatetimeoffset trace tracking transaction transactional translate translation treat trigger trigger_nestlevel triggers trim truncate try_cast try_convert try_parse type ub1 ub2 ub4 ucase unarchived unbounded uncompress under undo unhex unicode uniform uninstall union unique unix_timestamp unknown unlimited unlock unpivot unrecoverable unsafe unsigned until untrusted unusable unused update updated upgrade upped upper upsert url urowid usable usage use use_stored_outlines user user_data user_resources users using utc_date utc_timestamp uuid uuid_short validate validate_password_strength validation valist value values var var_samp varcharc vari varia variab variabl variable variables variance varp varraw varrawc varray verify version versions view virtual visible void wait wallet warning warnings week weekday weekofyear wellformed when whene whenev wheneve whenever where while whitespace with within without work wrapped xdb xml xmlagg xmlattributes xmlcast xmlcolattval xmlelement xmlexists xmlforest xmlindex xmlnamespaces xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltype xor year year_to_month years yearweek",literal:"true false null",built_in:"array bigint binary bit blob boolean char character date dec decimal float int int8 integer interval number numeric real record serial serial8 smallint text varchar varying void"},c:[{cN:"string",b:"'",e:"'",c:[e.BE,{b:"''"}]},{cN:"string",b:'"',e:'"',c:[e.BE,{b:'""'}]},{cN:"string",b:"`",e:"`",c:[e.BE]},e.CNM,e.CBCM,t]},e.CBCM,t]}}),e});

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(207),
	        __webpack_require__(209),
	        __webpack_require__(210)
	        // './vendor/kendo/kendo.multiselect' // required because of a test in kendo.binder.js
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    // Load MathJax 2.6 dynamically - see https://docs.mathjax.org/en/v2.6-latest/advanced/dynamic.html
	    // See configuration options - see http://mathjax.readthedocs.org/en/latest/configuration.html
	    // And combined configuration options - see http://mathjax.readthedocs.org/en/latest/config-files.html
	    (function () {
	        var TYPE = 'text/x-mathjax-config';
	        var head = document.getElementsByTagName('head')[0];
	        var scripts = head.getElementsByTagName('script');
	        var found = false;
	        for (var i = 0; i < scripts.length; i++) {
	            if (scripts[i].type === TYPE) {
	                found = true;
	                break;
	            }
	        }
	        if (!found) {
	            var script = document.createElement('script');
	            script.type = TYPE;
	            // TODO OPTIMIZE without MathML input
	            script[(window.opera ? 'innerHTML' : 'text')] =
	                'MathJax.Hub.Config({\n' +
	                '  showMathMenu: false,\n' + // Hide contextual menu
	                '  asciimath2jax: { delimiters: [["#","#"], ["`","`"]] }\n' +
	                '});';
	            head.appendChild(script);
	            script = document.createElement('script');
	            script.type = 'text/javascript';
	            // script.src  = 'https://cdn.mathjax.org/mathjax/2.6-latest/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
	            script.src = 'https://cdn.mathjax.org/mathjax/2.6-latest/MathJax.js?config=TeX-MML-AM_HTMLorMML';
	            script.crossorigin = 'anonymous';
	            head.appendChild(script);
	        }
	    })();
	
	    (function ($, undefined) {
	
	        var kendo = window.kendo;
	        var Widget = kendo.ui.Widget;
	        var assert = window.assert;
	        var logger = new window.Logger('kidoju.widgets.mathexpression');
	        var STRING = 'string';
	        var NULL = 'null';
	        var UNDEFINED = 'undefined';
	        var CHANGE = 'change';
	        // var NS = '.kendoDropZone';
	        var WIDGET_CLASS = 'kj-mathexpression'; // 'k-widget kj-mathexpression';
	
	        /*********************************************************************************
	         * Widget
	         *********************************************************************************/
	
	        /**
	         * MathExpression
	         * @class MathExpression Widget (kendoDropZone)
	         */
	        var MathExpression = Widget.extend({
	
	            /**
	             * Initializes the widget
	             * @param element
	             * @param options
	             */
	            init: function (element, options) {
	                var that = this;
	                options = options || {};
	                Widget.fn.init.call(that, element, options);
	                logger.debug('widget initialized');
	                that.bind(CHANGE, $.proxy(that.refresh, that));
	                that._layout();
	                that.value(that.options.value);
	                // see http://www.telerik.com/forums/kendo-notify()
	                kendo.notify(that);
	            },
	
	            /**
	             * Widget options
	             * @property options
	             */
	            options: {
	                name: 'MathExpression',
	                value: null
	            },
	
	            /**
	             * Widget events
	             * @property events
	             */
	            events: [
	                CHANGE
	            ],
	
	            /**
	             * Value for MVVM binding
	             * @param value
	             */
	            value: function (value) {
	                var that = this;
	                if ($.type(value) === STRING || $.type(value) === NULL) {
	                    if (that._value !== value) {
	                        that._value = value;
	                        that.trigger(CHANGE, { value: that._value });
	                    }
	                } else if ($.type(value) === UNDEFINED) {
	                    return that._value;
	                } else {
	                    throw new TypeError('`value` is expected to be a string if not undefined');
	                }
	            },
	
	            /**
	             * Builds the widget layout
	             * @private
	             */
	            _layout: function () {
	                var that = this;
	                that.wrapper = that.element;
	                that.element.addClass(WIDGET_CLASS);
	            },
	
	            /**
	             * Refresh the widget
	             */
	            refresh: function () {
	                var element = this.element;
	                element.text(this.value() || '');
	                // If MathJax is not yet loaded it will parse the page anyway
	                var MathJax = window.MathJax;
	                if (MathJax) {
	                    // See http://mathjax.readthedocs.org/en/latest/advanced/typeset.html
	                    MathJax.Hub.Queue(['Typeset', MathJax.Hub, element[0]]);
	                }
	                logger.debug('widget refreshed');
	            },
	
	            /**
	             * Clears the widget
	             * @method _clear
	             * @private
	             */
	            _clear: function () {
	                var that = this;
	                // unbind kendo
	                // kendo.unbind($(that.element));
	                // unbind all other events
	                $(that.element).find('*').off();
	                $(that.element).off();
	                // remove descendants
	                $(that.element).empty();
	                // remove element classes
	                // $(that.element).removeClass(WIDGET_CLASS);
	            },
	
	            /**
	             * Destroys the widget including all DOM modifications
	             * @method destroy
	             */
	            destroy: function () {
	                var that = this;
	                Widget.fn.destroy.call(that);
	                that._clear();
	                kendo.destroy(that.element);
	            }
	
	        });
	
	        kendo.ui.plugin(MathExpression);
	
	    }(window.jQuery));
	
	    return window.kendo;
	
	}, __webpack_require__(200));


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(207),
	        __webpack_require__(244)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    /* This function has too many statements */
	    /* jshint -W071 */
	
	    (function ($, undefined) {
	
	        var kendo = window.kendo;
	        var ui = kendo.ui;
	        var Widget = ui.Widget;
	        var Slider = ui.Slider;
	        var assert = window.assert;
	        var logger = new window.Logger('kidoju.widgets.mediaplayer');
	        var NS = '.kendoMediaPlayer';
	        var ARRAY = 'array';
	        var STRING = 'string';
	        var NUMBER = 'number';
	        var UNDEFINED = 'undefined';
	        var WIDGET_CLASS = 'kj-mediaplayer';
	        var TOOLBAR_CLASS = 'k-widget k-toolbar kj-mediaplayer-toolbar';
	        var BUTTON_CLASS = 'k-button kj-mediaplayer-button';
	        var COMMAND = 'command';
	        var BUTTON_SELECTOR = 'a.kj-mediaplayer-button[' + kendo.attr(COMMAND) + '="{0}"]';
	        var SEEKER_CLASS = 'kj-mediaplayer-seeker';
	        var SEEKER_SELECTOR = 'div.' + SEEKER_CLASS;
	        var TIME_CLASS = 'kj-mediaplayer-time';
	        var TIME_SELECTOR = 'span.' + TIME_CLASS;
	        var VOLUME_CLASS = 'kj-mediaplayer-volume';
	        var VOLUME_SELECTOR = 'div.' + VOLUME_CLASS;
	        var DISABLE = 'k-state-disabled';
	        var CLICK = 'click';
	        var LOADEDMETADATA = 'loadedmetadata';
	        var PLAY = 'play';
	        var TIMEUPDATE = 'timeupdate';
	        var VOLUMECHANGE = 'volumechange';
	        var PAUSE = 'pause';
	        var ENDED = 'ended';
	        var ENTEREVENTS = 'mouseenter' + NS + ' touchstart' + NS;
	        var LEAVEEVENTS = 'mouseleave' + NS + ' focusout' + NS;
	        var EVENTDURATION = 300;
	        var MODES = {
	            AUDIO: 'audio',
	            VIDEO: 'video'
	        };
	        var COMMANDS = {
	            PLAY: 'play',
	            MUTE: 'mute',
	            FULL: 'full' // full screen
	        };
	        var SVG = {
	            FULL: '<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" width="24px" height="24px" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="nonzero" clip-rule="evenodd" viewBox="0 0 10240 10240" xmlns:xlink="http://www.w3.org/1999/xlink">' +
	            '<path id="curve3" fill="#000000" d="M6530 5627c460,457 923,911 1381,1369l0 -971c0,-66 38,-123 99,-148 61,-25 128,-12 174,35l589 598c123,125 187,276 187,452l0 1678c0,176 -144,320 -320,320l-1678 0c-176,0 -329,-62 -452,-187l-588 -598c-47,-47 -60,-114 -35,-175 25,-61 82,-98 148,-99l971 0c-457,-457 -917,-913 -1376,-1368l900 -906z"/>' +
	            '<path id="curve2" fill="#000000" d="M4613 6530c-457,460 -911,923 -1369,1381l971 0c66,0 123,38 148,99 25,61 12,128 -35,174l-598 589c-125,123 -276,187 -452,187l-1678 0c-176,0 -320,-144 -320,-320l0 -1678c0,-176 62,-329 187,-452l598 -588c47,-47 114,-60 175,-35 61,25 98,82 99,148l0 971c457,-457 913,-917 1368,-1376l906 900z"/>' +
	            '<path id="curve1" fill="#000000" d="M5627 3710c457,-460 911,-923 1369,-1381l-971 0c-66,0 -123,-38 -148,-99 -25,-61 -12,-128 35,-174l598 -589c125,-123 276,-187 452,-187l1678 0c176,0 320,144 320,320l0 1678c0,176 -62,329 -187,452l-598 588c-47,47 -114,60 -175,35 -61,-25 -98,-82 -99,-148l0 -971c-457,457 -913,917 -1368,1376l-906 -900z"/>' +
	            '<path id="curve0" fill="#000000" d="M3710 4613c-460,-457 -923,-911 -1381,-1369l0 971c0,66 -38,123 -99,148 -61,25 -128,12 -174,-35l-589 -598c-123,-125 -187,-276 -187,-452l0 -1678c0,-176 144,-320 320,-320l1678 0c176,0 329,62 452,187l588 598c47,47 60,114 35,175 -25,61 -82,98 -148,99l-971 0c457,457 917,913 1376,1368l-900 906z"/>' +
	            '</svg>',
	            MUTE: '<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" width="24px" height="24px" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="nonzero" clip-rule="evenodd" viewBox="0 0 10240 10240" xmlns:xlink="http://www.w3.org/1999/xlink">' +
	            '<path id="curve3" fill="#000000" d="M6080 7660c1263,-157 2240,-1235 2240,-2540 0,-1305 -977,-2383 -2240,-2540l0 647c908,152 1600,942 1600,1893 0,951 -692,1741 -1600,1893l0 647z"/>' +
	            '<path id="curve2" fill="#000000" d="M6080 6360c552,-142 960,-644 960,-1240 0,-596 -408,-1098 -960,-1240l0 686c191,110 320,317 320,554 0,237 -129,444 -320,554l0 686z"/>' +
	            '<path id="curve1" fill="#000000" d="M960 3520l320 0 0 -320 1280 0 0 3840 -1280 0 0 -320 -320 0c-220,0 -320,-144 -320,-320l0 -2560c0,-176 100,-320 320,-320z"/>' +
	            '<path id="curve0" fill="#000000" d="M5440 640l0 0c176,0 320,144 320,320l0 8320c0,176 -144,320 -320,320l0 0c-176,0 -320,-144 -320,-320l-2240 -2240 0 -3840 2240 -2240c0,-176 144,-320 320,-320z"/>' +
	            '</svg>',
	            PAUSE: '<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" width="24px" height="24px" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="nonzero" clip-rule="evenodd" viewBox="0 0 10240 10240" xmlns:xlink="http://www.w3.org/1999/xlink">' +
	            '<path id="curve1" fill="#000000" d="M6400 1280l1280 0c353,0 640,288 640,640l0 6400c0,352 -288,640 -640,640l-1280 0c-352,0 -640,-288 -640,-640l0 -6400c0,-353 287,-640 640,-640z"/>' +
	            '<path id="curve0" fill="#000000" d="M2560 1280l1280 0c353,0 640,288 640,640l0 6400c0,352 -288,640 -640,640l-1280 0c-352,0 -640,-287 -640,-640l0 -6400c0,-353 287,-640 640,-640z"/>' +
	            '</svg>',
	            PLAY: '<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" width="24px" height="24px" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="nonzero" clip-rule="evenodd" viewBox="0 0 10240 10240" xmlns:xlink="http://www.w3.org/1999/xlink">' +
	            '<path id="curve0" fill="#000000" d="M2878 1364l5757 3209c207,115 325,314 325,547 0,233 -118,432 -325,547l-5757 3209c-204,113 -436,112 -639,-4 -203,-116 -319,-313 -319,-544l0 -6416c0,-231 116,-428 319,-544 203,-116 435,-117 639,-4z"/>' +
	            '</svg>',
	            SOUND: '<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" width="24px" height="24px" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="nonzero" clip-rule="evenodd" viewBox="0 0 10240 10240" xmlns:xlink="http://www.w3.org/1999/xlink">' +
	            '<path id="curve2" fill="#000000" d="M960 3520l320 0 0 -320 1280 0 0 3840 -1280 0 0 -320 -320 0c-220,0 -320,-144 -320,-320l0 -2560c0,-176 100,-320 320,-320z"/>' +
	            '<path id="curve1" fill="#000000" d="M5440 640c176,0 320,144 320,320l0 8320c0,176 -144,320 -320,320 -176,0 -320,-144 -320,-320l-2240 -2240 0 -3840 2240 -2240c0,-176 144,-320 320,-320z"/>' +
	            '<path id="curve0" fill="#000000" d="M8921 7266l-921 -921 -921 921c-125,125 -328,125 -453,0l-452 -452c-125,-125 -125,-328 0,-453l921 -921 -921 -921c-125,-125 -125,-328 0,-453l452 -452c125,-125 328,-125 453,0l921 921 921 -921c125,-125 328,-125 453,0l452 452c125,125 125,328 0,453l-921 921 921 921c125,125 125,328 0,453l-452 452c-125,125 -328,125 -453,0z"/>' +
	            '</svg>'
	        };
	        var SVG_MARGIN = '2px 0 0 -2px';
	        var PX = 'px';
	
	        /**
	         * Docs about media playing
	         * @see http://camendesign.com/code/video_for_everybody
	         * @see http://blog.falafel.com/new-kendo-ui-media-player-widget-mvvm/
	         * @see https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Using_HTML5_audio_and_video
	         */
	
	        /*********************************************************************************
	         * Helpers
	         *********************************************************************************/
	
	        /**
	         * Convert file extension to mime type
	         * @see http://hul.harvard.edu/ois/systems/wax/wax-public-help/mimetypes.htm
	         * @param url
	         * @returns {*}
	         */
	        function typeFormatter(url) {
	            assert.type(STRING, url, kendo.format(assert.messages.type.default, 'url', STRING));
	            var ext = url.split('.').pop();
	            switch (ext) {
	                case 'mp3':
	                    // @see http://tools.ietf.org/html/rfc3003
	                    // @see https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats#MP3
	                    return 'audio/mpeg';
	                case 'mp4':
	                    // @see http://www.rfc-editor.org/rfc/rfc4337.txt
	                    return 'video/mp4';
	                case 'ogg':
	                    return 'audio/ogg';
	                case 'ogv':
	                    return 'video/ogg';
	                case 'wav':
	                    return 'audio/wav';
	                case 'webm':
	                    return 'video/webm';
	                default:
	                    return 'application/octet-stream';
	            }
	        }
	
	        /**
	         * Format duration as MM:SS
	         * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/duration
	         * @param seconds
	         */
	        function toHMS(seconds) {
	            assert.type(NUMBER, seconds, kendo.format(assert.messages.type.default, 'seconds', NUMBER));
	            assert.ok(seconds >= 0 && seconds < 24 * 60 * 60, 'Cannot format negative numbers or days.');
	            var s = Math.round(seconds);
	            var m = Math.floor (s / 60);
	            var h = Math.floor (m / 60);
	            s = s % 60;
	            m = m % 60;
	            if (h === 0) {
	                return kendo.format('{0:00}:{1:00}', m, s);
	            } else {
	                return kendo.format('{0:00}:{1:00}:{2:00}', h, m, s);
	            }
	        }
	
	        /*********************************************************************************
	         * Widget
	         *********************************************************************************/
	
	        /**
	         * MediaPlayer widget
	         */
	        var MediaPlayer = Widget.extend({
	
	            // TODO: Check http://blog.falafel.com/new-kendo-ui-media-player-widget-mvvm/ and consider improvements
	
	            /**
	             * Constructor
	             * @param element
	             * @param options
	             */
	            init: function (element, options) {
	                var that = this;
	                Widget.fn.init.call(that, element, options);
	                logger.debug('widget initialized');
	                that._layout();
	            },
	
	            options: {
	                name: 'MediaPlayer',
	                mode: MODES.AUDIO,
	                autoPlay: false, // loop?
	                files: [],
	                enable: true,
	                toolbarHeight: 48,
	                messages: {
	                    play: 'Play/Pause',
	                    mute: 'Mute/Unmute',
	                    full: 'Full Screen',
	                    notSupported: 'Media not supported'
	                }
	            },
	
	            /*
	            events: [
	            ],
	            */
	
	            modes: {
	                audio: MODES.AUDIO,
	                video: MODES.VIDEO
	                // TODO: youtube, vimeo, dailymotion and others modes.
	            },
	
	            /**
	             * Layout the widget
	             * @private
	             */
	            _layout: function () {
	                var that = this;
	                that.wrapper = that.element;
	                that.element
	                    .addClass(WIDGET_CLASS)
	                    .css({ position: 'relative' });
	                that._media();
	                that._toolbar();
	                that.enable(that.options.enable);
	            },
	
	            /**
	             * Add HTML 5 audio/video tag
	             * @private
	             */
	            _media: function () {
	                var that = this;
	                // Create audio or video tag
	                if (that.options.mode === MODES.AUDIO) {
	                    that.media = $('<audio></audio>');
	                } else {
	                    that.media = $('<video></video>');
	                }
	                that.media
	                    .attr('preload', 'auto')
	                    .prop('autoplay', that.options.autoPlay)
	                    .css({ width: '100%' });
	                // .css({ height: '100%', width: '100%' });
	                // Add source files
	                var files = $.type(that.options.files) === STRING ? [that.options.files] : that.options.files;
	                assert.type(ARRAY, files, kendo.format(assert.messages.type.default, 'options.files', ARRAY));
	                $.each(files, function (index, url) {
	                    if ($.type(url) === STRING && url.length) {
	                        $('<source>')
	                            .attr({ src: url, type: typeFormatter(url) })
	                            .appendTo(that.media);
	                    }
	                });
	
	                // Initialize media element
	                // Note: These event handlers are required because the toolbar needs to be updated
	                // when commands are executed in full screen mode, e.g. a PAUSE in full screen should update the toolbar icon
	                that.media
	                    .append(that.options.messages.notSupported)
	                    .on(LOADEDMETADATA, $.proxy(that._onLoadedMetadata, that))
	                    .on(PLAY, $.proxy(that._onPlay, that))
	                    .on(TIMEUPDATE, $.proxy(that._onTimeUpdate, that))
	                    .on(PAUSE, $.proxy(that._onPause, that))
	                    .on(ENDED, $.proxy(that._onEnded, that))
	                    .on(VOLUMECHANGE, $.proxy(that._onVolumeChange, that));
	
	                // Append media element to widget
	                that.element.append(that.media);
	            },
	
	            /**
	             * Event handler called when media metadata is loaded
	             * @param e
	             * @private
	             */
	            _onLoadedMetadata: function (e) {
	                // This is where we initially set our toolbar values
	                assert.instanceof($.Event, e, kendo.format(assert.messages.instanceof.default, 'e', 'jQuery.Event'));
	                if (this.toolbar instanceof $ && this.seekerSlider instanceof Slider && this.volumeSlider instanceof Slider) {
	                    var mediaElement = e.target;
	                    assert.instanceof(window.HTMLMediaElement, mediaElement, kendo.format(assert.messages.instanceof.default, 'this.media.get(0)', 'window.HTMLMediaElement'));
	                    this._setSeekerSlider(mediaElement.duration);
	                    this.seekerSlider.value(0);
	                    this.toolbar.find(TIME_SELECTOR).text(toHMS(mediaElement.duration));
	                    this.volumeSlider.value(mediaElement.volume);
	                    // we now need to resize our toolbar properly
	                    this.resize();
	                }
	            },
	
	            /**
	             * Event handler triggered when media is played
	             * @param e
	             * @private
	             */
	            _onPlay: function (e) {
	                var mediaElement = this.media.get(0);
	                assert.instanceof(window.HTMLMediaElement, mediaElement, kendo.format(assert.messages.instanceof.default, 'this.media.get(0)', 'window.HTMLMediaElement'));
	                if (this.toolbar instanceof $) {
	                    var oldSVG = this.toolbar.find(kendo.format(BUTTON_SELECTOR, COMMANDS.PLAY)).children('svg');
	                    // Note: we need the actual HEIGHT and WIDTH attributes because the $.height and $.width methods update the STYLE attribute
	                    var newSVG = $(SVG.PAUSE)
	                        .attr({ height: oldSVG.attr('height'), width: oldSVG.attr('width') })
	                        .css({ margin: SVG_MARGIN });
	                    oldSVG.replaceWith(newSVG);
	                }
	            },
	
	            /**
	             * Event hander periodically triggered as playback progresses
	             * @param e
	             * @private
	             */
	            _onTimeUpdate: function (e) {
	                assert.instanceof($.Event, e, kendo.format(assert.messages.instanceof.default, 'e', 'jQuery.Event'));
	                if (this.toolbar instanceof $) {
	                    var mediaElement = e.target;
	                    assert.instanceof(window.HTMLMediaElement, mediaElement, kendo.format(assert.messages.instanceof.default, 'this.media.get(0)', 'window.HTMLMediaElement'));
	                    this.toolbar.find(TIME_SELECTOR).text(toHMS(mediaElement.duration - mediaElement.currentTime));
	                    this.seekerSlider.value(mediaElement.currentTime);
	                }
	            },
	
	            /**
	             * Event handler triggered when playback is paused
	             * @param e
	             * @private
	             */
	            _onPause: function (e) {
	                var mediaElement = this.media.get(0);
	                assert.instanceof(window.HTMLMediaElement, mediaElement, kendo.format(assert.messages.instanceof.default, 'this.media.get(0)', 'window.HTMLMediaElement'));
	                if (this.toolbar instanceof $) {
	                    var oldSVG = this.toolbar.find(kendo.format(BUTTON_SELECTOR, COMMANDS.PLAY)).children('svg');
	                    // Note: we need the actual HEIGHT and WIDTH attributes because the $.height and $.width methods update the STYLE attribute
	                    var newSVG = $(SVG.PLAY)
	                        .attr({ height: oldSVG.attr('height'), width: oldSVG.attr('width') })
	                        .css({ margin: SVG_MARGIN });
	                    oldSVG.replaceWith(newSVG);
	                }
	            },
	
	            /**
	             * Event handler triggered when playback ends
	             * @param e
	             * @private
	             */
	            _onEnded: function (e) {
	                assert.instanceof($.Event, e, kendo.format(assert.messages.instanceof.default, 'e', 'jQuery.Event'));
	                if (this.toolbar instanceof $ && this.seekerSlider instanceof Slider) {
	                    var mediaElement = e.target;
	                    assert.instanceof(window.HTMLMediaElement, mediaElement, kendo.format(assert.messages.instanceof.default, 'this.media.get(0)', 'window.HTMLMediaElement'));
	                    mediaElement.currentTime = 0;
	                    this.seekerSlider.value(mediaElement.currentTime);
	                    var oldSVG = this.toolbar.find(kendo.format(BUTTON_SELECTOR, COMMANDS.PLAY)).children('svg');
	                    // Note: we need the actual HEIGHT and WIDTH attributes because the $.height and $.width methods update the STYLE attribute
	                    var newSVG = $(SVG.PLAY)
	                        .attr({ height: oldSVG.attr('height'), width: oldSVG.attr('width') })
	                        .css({ margin: SVG_MARGIN });
	                    oldSVG.replaceWith(newSVG);
	                }
	            },
	
	            /**
	             * Event handler trigger when volume changes (including muting)
	             * @param e
	             * @private
	             */
	            _onVolumeChange: function (e) {
	                var mediaElement = this.media.get(0);
	                assert.instanceof(window.HTMLMediaElement, mediaElement, kendo.format(assert.messages.instanceof.default, 'this.media.get(0)', 'window.HTMLMediaElement'));
	                if (this.toolbar instanceof $ && this.volumeSlider instanceof Slider) {
	                    var oldSVG = this.toolbar.find(kendo.format(BUTTON_SELECTOR, COMMANDS.MUTE)).children('svg');
	                    var newSVG;
	                    if (mediaElement.muted) {
	                        this.volumeSlider.value(0);
	                        // Note: we need the actual HEIGHT and WIDTH attributes because the $.height and $.width methods update the STYLE attribute
	                        newSVG = $(SVG.SOUND)
	                            .attr({ height: oldSVG.attr('height'), width: oldSVG.attr('width') })
	                            .css({ margin: SVG_MARGIN });
	                    } else {
	                        this.volumeSlider.value(mediaElement.volume);
	                        // Note: we need the actual HEIGHT and WIDTH attributes because the $.height and $.width methods update the STYLE attributebute
	                        newSVG = $(SVG.MUTE)
	                            .attr({ height: oldSVG.attr('height'), width: oldSVG.attr('width') })
	                            .css({ margin: SVG_MARGIN });
	                    }
	                    oldSVG.replaceWith(newSVG);
	                }
	            },
	
	            /* Script URL */
	            /* jshint -W107 */
	
	            /**
	             * Add toolbar (play/pause, seeker, time, mute/unmute, volume, full screen)
	             * @private
	             */
	            _toolbar: function () {
	                var that = this;
	                that.toolbar = $('<div/>')
	                    .addClass(TOOLBAR_CLASS)
	                    .css({
	                        position: 'absolute',
	                        boxSizing: 'border-box',
	                        bottom: 0,
	                        left: 0,
	                        width: '100%',
	                        zIndex: 99,
	                        // We hide the toolbar until we get loadedmetadata to resize it properly.
	                        // We cannot use display:none which yields incorrect measurements
	                        visibility: 'hidden'
	                    })
	                    .appendTo(that.element);
	
	                // Play button
	                $('<a/>')
	                    .attr({ href: 'javascript:void(0);', title: that.options.messages.play })
	                    .attr(kendo.attr(COMMAND), COMMANDS.PLAY)
	                    .addClass(BUTTON_CLASS)
	                    .css({ overflow: 'hidden', display: 'inline-block' })
	                    .append(SVG.PLAY)
	                    .appendTo(that.toolbar);
	
	                // Seeker slider
	                var seekerDiv = $('<div/>')
	                    .addClass(SEEKER_CLASS)
	                    .css({ display: 'inline-block' })
	                    .appendTo(that.toolbar);
	                that._setSeekerSlider(1);
	
	                // Remaining time span
	                $('<span/>')
	                    .addClass(TIME_CLASS)
	                    .appendTo(that.toolbar);
	
	                // Mute/Unmute button
	                $('<a/>')
	                    .attr({ href: 'javascript:void(0);', title: that.options.messages.mute })
	                    .attr(kendo.attr(COMMAND), COMMANDS.MUTE)
	                    .addClass(BUTTON_CLASS)
	                    .css({ overflow: 'hidden', display: 'inline-block' })
	                    .append(SVG.MUTE)
	                    .appendTo(that.toolbar);
	
	                // Volume slider
	                var volumeDiv = $('<div/>')
	                    .addClass(VOLUME_CLASS)
	                    .css({ display: 'inline-block' })
	                    .appendTo(that.toolbar);
	                that._setVolumeSlider();
	
	                // Full screen button (video only)
	                if (that.options.mode === MODES.VIDEO) {
	                    $('<a/>')
	                        .attr({ href: 'javascript:void(0);', title: that.options.messages.full })
	                        .attr(kendo.attr(COMMAND), COMMANDS.FULL)
	                        .css({ overflow: 'hidden', display: 'inline-block' })
	                        .addClass(BUTTON_CLASS)
	                        .append(SVG.FULL)
	                        .appendTo(that.toolbar);
	                }
	            },
	
	            /* jshint +W107 */
	
	            /**
	             * Set the sleeker slider with new max
	             * @see http://www.telerik.com/forums/how-do-i-update-the-slider-max-option-after-creation
	             * @param max
	             * @private
	             */
	            _setSeekerSlider: function (max) {
	                var that = this;
	                var seekerDiv = that.element.find(SEEKER_SELECTOR);
	                var seekerSlider = seekerDiv.find('input').data('kendoSlider');
	                if (seekerSlider instanceof Slider) {
	                    seekerSlider.destroy();
	                    seekerDiv.empty();
	                }
	                that.seekerSlider = $('<input>')
	                    .appendTo(seekerDiv)
	                    .kendoSlider({
	                        max: max,
	                        min: 0,
	                        smallStep: 0.1,
	                        largeStep: 1,
	                        showButtons: false,
	                        tickPlacement: 'none',
	                        tooltip: { format: '{0} s.' },
	                        change: $.proxy(that._onSeekerSliderChange, that)
	                    }).data('kendoSlider');
	            },
	
	            /**
	             * Set the volume slider
	             * Note: the max is always 1
	             * @private
	             */
	            _setVolumeSlider: function () {
	                var that = this;
	                var volumeDiv = that.element.find(VOLUME_SELECTOR);
	                var volumeSlider = volumeDiv.find('input').data('kendoSlider');
	                if (volumeSlider instanceof Slider) {
	                    volumeSlider.destroy();
	                    volumeDiv.empty();
	                }
	                that.volumeSlider = $('<input>')
	                    .appendTo(volumeDiv)
	                    .kendoSlider({
	                        max: 1, // max volume is always 1
	                        min: 0,
	                        smallStep: 0.05,
	                        largeStep: 0.25,
	                        showButtons: false,
	                        tickPlacement: 'none',
	                        tooltip: { format: '{0:p0}' },
	                        change: $.proxy(that._onVolumeSliderChange, that)
	                    }).data('kendoSlider');
	            },
	
	            /**
	             * Event handler triggered when clicking a media player toolbar button
	             * @param e
	             * @private
	             */
	            _onButtonClick: function (e) {
	                var command = $(e.currentTarget).attr(kendo.attr(COMMAND));
	                switch (command) {
	                    case COMMANDS.PLAY:
	                        this.togglePlayPause();
	                        break;
	                    case COMMANDS.MUTE:
	                        this.toggleMute();
	                        break;
	                    case COMMANDS.FULL:
	                        this.toggleFullScreen();
	                        break;
	                }
	            },
	
	            /**
	             * Toggle play pause
	             */
	            togglePlayPause: function () {
	                var mediaElement = this.media.get(0);
	                assert.instanceof(window.HTMLMediaElement, mediaElement, kendo.format(assert.messages.instanceof.default, 'this.media.get(0)', 'window.HTMLMediaElement'));
	                if (mediaElement.paused && mediaElement.readyState >= 1) { // @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/readyState
	                    mediaElement.play();
	                } else {
	                    mediaElement.pause();
	                }
	            },
	
	            /**
	             * Toggle muted sound
	             */
	            toggleMute: function () {
	                var mediaElement = this.media.get(0);
	                assert.instanceof(window.HTMLMediaElement, mediaElement, kendo.format(assert.messages.instanceof.default, 'this.media.get(0)', 'window.HTMLMediaElement'));
	                mediaElement.muted = !mediaElement.muted;
	            },
	
	            /* This function's cyclomatic complexity is too high */
	            /* jshint -W074 */
	
	            /**
	             * set full screen mode
	             * @see https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API
	             * @see http://www.sitepoint.com/use-html5-full-screen-api/
	             */
	            toggleFullScreen: function () {
	                var mediaElement = this.media.get(0);
	                assert.instanceof(window.HTMLVideoElement, mediaElement, kendo.format(assert.messages.instanceof.default, 'this.media.get(0)', 'window.HTMLVideoElement'));
	                if (document.fullscreenElement === mediaElement ||
	                    document.webkitFullscreenElement === mediaElement ||
	                    document.msFullscreenElement === mediaElement ||
	                    document.mozFullScreenElement === mediaElement) {
	                    if ($.isFunction (document.exitFullscreen)) {
	                        document.exitFullscreen();
	                    } else if ($.isFunction (document.webkitExitFullscreen)) {
	                        document.webkitExitFullscreen();
	                    } else if ($.isFunction (document.msExitFullscreen)) {
	                        document.msExitFullscreen();
	                    } else if ($.isFunction (document.mozCancelFullScreen)) {
	                        document.mozCancelFullScreen();
	                    }
	                } else {
	                    if (document.fullscreenEnabled && $.isFunction (mediaElement.requestFullscreen)) {
	                        mediaElement.requestFullscreen();
	                    } else if (document.webkitFullscreenEnabled && $.isFunction (mediaElement.webkitRequestFullscreen)) {
	                        mediaElement.webkitRequestFullscreen(window.Element.ALLOW_KEYBOARD_INPUT);
	                    } else if (document.msFullscreenEnabled && $.isFunction (mediaElement.msRequestFullscreen)) {
	                        mediaElement.msRequestFullscreen();
	                    } else if (document.mozFullScreenEnabled && $.isFunction (mediaElement.mozRequestFullScreen)) {
	                        mediaElement.mozRequestFullScreen();
	                    }
	                }
	            },
	
	            /* jshint +W074 */
	
	            /**
	             * Event handler for changing the value of the volume slider
	             * @param e
	             * @private
	             */
	            _onVolumeSliderChange: function (e) {
	                this.volume(e.value);
	            },
	
	            /**
	             * API to get/set the volume
	             * @param value
	             * @returns {*|number}
	             */
	            volume: function (value) {
	                var mediaElement = this.media.get(0);
	                assert.instanceof(window.HTMLMediaElement, mediaElement, kendo.format(assert.messages.instanceof.default, 'this.media.get(0)', 'window.HTMLMediaElement'));
	                if ($.type(value) === UNDEFINED) {
	                    return mediaElement.volume;
	                } else {
	                    assert.type(NUMBER, value, kendo.format(assert.messages.type.default, 'value', NUMBER));
	                    if (value < 0) {
	                        value = 0;
	                    } else if (value > 1) {
	                        value = 1;
	                    }
	                    mediaElement.volume = value;
	                }
	            },
	
	            /**
	             * Event handler for changing the value of teh seeker slider
	             * ATTENTION: videos are not seekable (or loopable) in Chrome if the server is not configured to allow partial content requests (incl. range)
	             * @see http://stackoverflow.com/questions/8088364/html5-video-will-not-loop
	             * @param e
	             * @private
	             */
	            _onSeekerSliderChange: function (e) {
	                this.seek(e.value);
	            },
	
	            /**
	             * API to get/set the seeked currentTime
	             * @param value
	             */
	            seek: function (value) {
	                var mediaElement = this.media.get(0);
	                assert.instanceof(window.HTMLMediaElement, mediaElement, kendo.format(assert.messages.instanceof.default, 'this.media.get(0)', 'window.HTMLMediaElement'));
	                if ($.type(value) === UNDEFINED) {
	                    return mediaElement.currentTime;
	                } else {
	                    assert.type(NUMBER, value, kendo.format(assert.messages.type.default, 'value', NUMBER));
	                    if (value < 0) {
	                        value = 0;
	                    } else if (value > mediaElement.duration) {
	                        value = mediaElement.duration;
	                    }
	                    var paused = mediaElement.paused;
	                    mediaElement.pause();
	                    if (value >= mediaElement.seekable.start(0) && value <= mediaElement.seekable.end(0)) {
	                        mediaElement.currentTime = value;
	                    } else {
	                        mediaElement.currentTime = 0;
	                    }
	                    if (!paused) {
	                        mediaElement.play();
	                    }
	                }
	            },
	
	            /**
	             * Resizes the widget
	             * @see especially http://docs.telerik.com/kendo-ui/api/javascript/ui/slider#methods-resize
	             */
	            resize: function () {
	                var that = this;
	                if (that.media instanceof $ && that.toolbar instanceof $ && that.seekerSlider instanceof Slider && that.volumeSlider instanceof Slider) {
	                    // Note: height and width calculations do not work if display: none
	                    that.toolbar.css({ visibility: 'hidden' }).show();
	                    var buttons = that.toolbar.find('a.k-button').show();
	                    var seekerDiv = that.toolbar.find(SEEKER_SELECTOR).show();
	                    var timeDiv = that.toolbar.find(TIME_SELECTOR).show();
	                    var volumeDiv = that.toolbar.find(VOLUME_SELECTOR).show();
	                    var isVideo = that.options.mode === MODES.VIDEO;
	                    var height = isVideo ? that.options.toolbarHeight : that.element.height();
	                    var width = that.element.width();
	                    var ratio = height / 100;
	                    var fontRatio = 0.8;
	                    var margin = 4 * ratio;
	                    var radius = height - 2 * margin;
	                    var minSeekerSize = 1.5 * radius;
	                    // Resize element
	                    if (isVideo) {
	                        that.element.height(that.media.height());
	                    }
	                    // Resize toolbar
	                    that.toolbar.height(height);
	                    // Resize buttons
	                    buttons.css({ height: radius + PX, width: radius + PX, margin: margin + PX });
	                    buttons.children('svg')
	                        .attr({ height: Math.max(radius - 10, 0) + PX, width: Math.max(radius - 10, 0) + PX })
	                        .css({ margin: SVG_MARGIN });
	                    var buttonSize = radius + 2 * margin;
	                    // Resize timer
	                    timeDiv.css({ fontSize: (fontRatio * radius) + PX, margin: '0 ' + margin + PX, lineHeight: '1em' });
	                    // timeDiv.width(timeDiv.width()); // we do not want the width to change when the number of digits drops
	                    var timeSize = timeDiv.width() + 2 * margin;
	                    // Resize volume slider
	                    volumeDiv.css({ margin: 3 * margin + PX });
	                    that.volumeSlider.wrapper.width(radius);
	                    that.volumeSlider.resize();
	                    var volumeSize = volumeDiv.width() + 6 * margin;
	                    // Resize seeker slider
	                    var seekerSize = that.toolbar.width() - (buttons.length * buttonSize + timeSize + volumeSize);
	                    seekerDiv.css({ margin: 3 * margin + PX });
	                    that.seekerSlider.wrapper.width(Math.max(seekerSize - 6 * margin - 24 * ratio, 0)); // 24 * ratio is empirical
	                    that.seekerSlider.resize();
	                    // Update slider dimensions
	                    if (ratio > 0.5) {
	                        var tracks = that.toolbar.find('.k-slider-track');
	                        var hT =  8; // parseInt(tracks.css('height'), 10);
	                        var mT = -4; // parseInt(tracks.css('margin-top'), 10);
	                        tracks.css({ height: 2 * ratio * hT + PX, marginTop: 2 * ratio * mT + PX });
	                        var selections = that.toolbar.find('.k-slider-selection');
	                        selections.css({ height: 2 * ratio * hT + PX, marginTop: 2 * ratio * mT + PX });
	                        var handles = that.toolbar.find('.k-draghandle');
	                        // var tH = -4; // parseInt(handles.css('top'), 10);
	                        // var hH = 14; // parseInt(handles.css('height'), 10);
	                        // var wH = 13; // parseInt(handles.css('width'), 10);
	                        // var rH = 7;  // parseInt(handles.css('borderRadius'), 10);
	                        handles.css({ top: 2 * ratio * mT + PX, height: 4 * ratio * hT + PX, width: 4 * ratio * hT + PX, borderRadius: 2 * ratio * hT + PX });
	                        // Reset the position of the seeker handle
	                        handles.first().css({ left: -2 * ratio * hT + PX });
	                    }
	                    // Display/hide elements
	                    // Play button is always visible
	                    buttons.find(kendo.format(BUTTON_SELECTOR, COMMANDS.MUTE)).toggle(width >= buttons.length * buttonSize);
	                    buttons.find(kendo.format(BUTTON_SELECTOR, COMMANDS.FULL)).toggle(width >= (buttons.length - 1) * buttonSize);
	                    timeDiv.toggle(width >= buttons.length * buttonSize + timeSize);
	                    volumeDiv.toggle(width >= buttons.length * buttonSize + timeSize + volumeSize);
	                    seekerDiv.toggle(seekerDiv.width() >= minSeekerSize);
	                    that.toolbar.toggle(!isVideo || !that._enable).css({ visibility: 'visible' });
	                }
	            },
	
	            /**
	             * Enabled/disables the widget
	             * @param enable
	             */
	            enable: function (enable) {
	                var that = this;
	                if (that.toolbar instanceof $ && that.seekerSlider instanceof Slider && that.volumeSlider instanceof Slider) {
	                    if (typeof enable === UNDEFINED) {
	                        enable = true;
	                    }
	                    that.element.off(NS);
	                    that.toolbar.off(NS);
	                    if (enable) {
	                        if (that.options.mode === MODES.VIDEO) {
	                            that.element
	                                .on(ENTEREVENTS, function () { that.toolbar.show(EVENTDURATION); })
	                                .on(LEAVEEVENTS, function () { that.toolbar.hide(EVENTDURATION); });
	                        }
	                        that.toolbar
	                            .removeClass(DISABLE)
	                            .on(CLICK + NS, 'a.k-button', $.proxy(that._onButtonClick, that));
	                    } else {
	                        that.toolbar
	                            .addClass(DISABLE)
	                            .show();
	                    }
	                    that.seekerSlider.enable(enable);
	                    that.volumeSlider.enable(enable);
	                    that._enable = enable;
	                }
	            },
	
	            /**
	             * Clear widget and restore DOM
	             * @private
	             */
	            _clear: function () {
	                var that = this;
	                // unbind kendo
	                kendo.unbind(that.element);
	                // unbind all other events
	                that.element.find('*').off();
	                that.element.off();
	                // remove descendants
	                that.element.empty();
	                // remove element classes
	                that.element.removeClass(WIDGET_CLASS);
	            },
	
	            /**
	             * Destroy widget
	             */
	            destroy: function () {
	                var that = this;
	                Widget.fn.destroy.call(that);
	                that._clear();
	                kendo.destroy(that.element);
	            }
	
	        });
	
	        ui.plugin(MediaPlayer);
	
	    })(window.jQuery);
	
	    /* jshint +W071 */
	
	    return window.kendo;
	
	}, __webpack_require__(200));


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** 
	 * Kendo UI v2016.3.914 (http://www.telerik.com/kendo-ui)                                                                                                                                               
	 * Copyright 2016 Telerik AD. All rights reserved.                                                                                                                                                      
	 *                                                                                                                                                                                                      
	 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
	 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
	 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	                                                                                                                                                                                                       
	
	*/
	(function (f, define) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(210)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}(function () {
	    var __meta__ = {
	        id: 'slider',
	        name: 'Slider',
	        category: 'web',
	        description: 'The Slider widget provides a rich input for selecting values or ranges of values.',
	        depends: ['draganddrop']
	    };
	    (function ($, undefined) {
	        var kendo = window.kendo, Widget = kendo.ui.Widget, Draggable = kendo.ui.Draggable, extend = $.extend, format = kendo.format, parse = kendo.parseFloat, proxy = $.proxy, isArray = $.isArray, math = Math, support = kendo.support, pointers = support.pointers, msPointers = support.msPointers, CHANGE = 'change', SLIDE = 'slide', NS = '.slider', MOUSE_DOWN = 'touchstart' + NS + ' mousedown' + NS, TRACK_MOUSE_DOWN = pointers ? 'pointerdown' + NS : msPointers ? 'MSPointerDown' + NS : MOUSE_DOWN, MOUSE_UP = 'touchend' + NS + ' mouseup' + NS, TRACK_MOUSE_UP = pointers ? 'pointerup' : msPointers ? 'MSPointerUp' + NS : MOUSE_UP, MOVE_SELECTION = 'moveSelection', KEY_DOWN = 'keydown' + NS, CLICK = 'click' + NS, MOUSE_OVER = 'mouseover' + NS, FOCUS = 'focus' + NS, BLUR = 'blur' + NS, DRAG_HANDLE = '.k-draghandle', TRACK_SELECTOR = '.k-slider-track', TICK_SELECTOR = '.k-tick', STATE_SELECTED = 'k-state-selected', STATE_FOCUSED = 'k-state-focused', STATE_DEFAULT = 'k-state-default', STATE_DISABLED = 'k-state-disabled', DISABLED = 'disabled', UNDEFINED = 'undefined', TABINDEX = 'tabindex', getTouches = kendo.getTouches;
	        var SliderBase = Widget.extend({
	            init: function (element, options) {
	                var that = this;
	                Widget.fn.init.call(that, element, options);
	                options = that.options;
	                that._distance = round(options.max - options.min);
	                that._isHorizontal = options.orientation == 'horizontal';
	                that._isRtl = that._isHorizontal && kendo.support.isRtl(element);
	                that._position = that._isHorizontal ? 'left' : 'bottom';
	                that._sizeFn = that._isHorizontal ? 'width' : 'height';
	                that._outerSize = that._isHorizontal ? 'outerWidth' : 'outerHeight';
	                options.tooltip.format = options.tooltip.enabled ? options.tooltip.format || '{0}' : '{0}';
	                if (options.smallStep <= 0) {
	                    throw new Error('Kendo UI Slider smallStep must be a positive number.');
	                }
	                that._createHtml();
	                that.wrapper = that.element.closest('.k-slider');
	                that._trackDiv = that.wrapper.find(TRACK_SELECTOR);
	                that._setTrackDivWidth();
	                that._maxSelection = that._trackDiv[that._sizeFn]();
	                that._sliderItemsInit();
	                that._reset();
	                that._tabindex(that.wrapper.find(DRAG_HANDLE));
	                that[options.enabled ? 'enable' : 'disable']();
	                var rtlDirectionSign = kendo.support.isRtl(that.wrapper) ? -1 : 1;
	                that._keyMap = {
	                    37: step(-1 * rtlDirectionSign * options.smallStep),
	                    40: step(-options.smallStep),
	                    39: step(+1 * rtlDirectionSign * options.smallStep),
	                    38: step(+options.smallStep),
	                    35: setValue(options.max),
	                    36: setValue(options.min),
	                    33: step(+options.largeStep),
	                    34: step(-options.largeStep)
	                };
	                kendo.notify(that);
	            },
	            events: [
	                CHANGE,
	                SLIDE
	            ],
	            options: {
	                enabled: true,
	                min: 0,
	                max: 10,
	                smallStep: 1,
	                largeStep: 5,
	                orientation: 'horizontal',
	                tickPlacement: 'both',
	                tooltip: {
	                    enabled: true,
	                    format: '{0}'
	                }
	            },
	            _resize: function () {
	                this._setTrackDivWidth();
	                this.wrapper.find('.k-slider-items').remove();
	                this._maxSelection = this._trackDiv[this._sizeFn]();
	                this._sliderItemsInit();
	                this._refresh();
	                if (this.options.enabled) {
	                    this.enable(true);
	                }
	            },
	            _sliderItemsInit: function () {
	                var that = this, options = that.options;
	                var sizeBetweenTicks = that._maxSelection / ((options.max - options.min) / options.smallStep);
	                var pixelWidths = that._calculateItemsWidth(math.floor(that._distance / options.smallStep));
	                if (options.tickPlacement != 'none' && sizeBetweenTicks >= 2) {
	                    that._trackDiv.before(createSliderItems(options, that._distance));
	                    that._setItemsWidth(pixelWidths);
	                    that._setItemsTitle();
	                }
	                that._calculateSteps(pixelWidths);
	                if (options.tickPlacement != 'none' && sizeBetweenTicks >= 2 && options.largeStep >= options.smallStep) {
	                    that._setItemsLargeTick();
	                }
	            },
	            getSize: function () {
	                return kendo.dimensions(this.wrapper);
	            },
	            _setTrackDivWidth: function () {
	                var that = this, trackDivPosition = parseFloat(that._trackDiv.css(that._isRtl ? 'right' : that._position), 10) * 2;
	                that._trackDiv[that._sizeFn](that.wrapper[that._sizeFn]() - 2 - trackDivPosition);
	            },
	            _setItemsWidth: function (pixelWidths) {
	                var that = this, options = that.options, first = 0, last = pixelWidths.length - 1, items = that.wrapper.find(TICK_SELECTOR), i, paddingTop = 0, bordersWidth = 2, count = items.length, selection = 0;
	                for (i = 0; i < count - 2; i++) {
	                    $(items[i + 1])[that._sizeFn](pixelWidths[i]);
	                }
	                if (that._isHorizontal) {
	                    $(items[first]).addClass('k-first')[that._sizeFn](pixelWidths[last - 1]);
	                    $(items[last]).addClass('k-last')[that._sizeFn](pixelWidths[last]);
	                } else {
	                    $(items[last]).addClass('k-first')[that._sizeFn](pixelWidths[last]);
	                    $(items[first]).addClass('k-last')[that._sizeFn](pixelWidths[last - 1]);
	                }
	                if (that._distance % options.smallStep !== 0 && !that._isHorizontal) {
	                    for (i = 0; i < pixelWidths.length; i++) {
	                        selection += pixelWidths[i];
	                    }
	                    paddingTop = that._maxSelection - selection;
	                    paddingTop += parseFloat(that._trackDiv.css(that._position), 10) + bordersWidth;
	                    that.wrapper.find('.k-slider-items').css('padding-top', paddingTop);
	                }
	            },
	            _setItemsTitle: function () {
	                var that = this, options = that.options, items = that.wrapper.find(TICK_SELECTOR), titleNumber = options.min, count = items.length, i = that._isHorizontal && !that._isRtl ? 0 : count - 1, limit = that._isHorizontal && !that._isRtl ? count : -1, increment = that._isHorizontal && !that._isRtl ? 1 : -1;
	                for (; i - limit !== 0; i += increment) {
	                    $(items[i]).attr('title', format(options.tooltip.format, round(titleNumber)));
	                    titleNumber += options.smallStep;
	                }
	            },
	            _setItemsLargeTick: function () {
	                var that = this, options = that.options, items = that.wrapper.find(TICK_SELECTOR), i = 0, item, value;
	                if (removeFraction(options.largeStep) % removeFraction(options.smallStep) === 0 || that._distance / options.largeStep >= 3) {
	                    if (!that._isHorizontal && !that._isRtl) {
	                        items = $.makeArray(items).reverse();
	                    }
	                    for (i = 0; i < items.length; i++) {
	                        item = $(items[i]);
	                        value = that._values[i];
	                        var valueWithoutFraction = round(removeFraction(value - this.options.min));
	                        if (valueWithoutFraction % removeFraction(options.smallStep) === 0 && valueWithoutFraction % removeFraction(options.largeStep) === 0) {
	                            item.addClass('k-tick-large').html('<span class=\'k-label\'>' + item.attr('title') + '</span>');
	                            if (i !== 0 && i !== items.length - 1) {
	                                item.css('line-height', item[that._sizeFn]() + 'px');
	                            }
	                        }
	                    }
	                }
	            },
	            _calculateItemsWidth: function (itemsCount) {
	                var that = this, options = that.options, trackDivSize = parseFloat(that._trackDiv.css(that._sizeFn)) + 1, pixelStep = trackDivSize / that._distance, itemWidth, pixelWidths, i;
	                if (that._distance / options.smallStep - math.floor(that._distance / options.smallStep) > 0) {
	                    trackDivSize -= that._distance % options.smallStep * pixelStep;
	                }
	                itemWidth = trackDivSize / itemsCount;
	                pixelWidths = [];
	                for (i = 0; i < itemsCount - 1; i++) {
	                    pixelWidths[i] = itemWidth;
	                }
	                pixelWidths[itemsCount - 1] = pixelWidths[itemsCount] = itemWidth / 2;
	                return that._roundWidths(pixelWidths);
	            },
	            _roundWidths: function (pixelWidthsArray) {
	                var balance = 0, count = pixelWidthsArray.length, i;
	                for (i = 0; i < count; i++) {
	                    balance += pixelWidthsArray[i] - math.floor(pixelWidthsArray[i]);
	                    pixelWidthsArray[i] = math.floor(pixelWidthsArray[i]);
	                }
	                balance = math.round(balance);
	                return this._addAdditionalSize(balance, pixelWidthsArray);
	            },
	            _addAdditionalSize: function (additionalSize, pixelWidthsArray) {
	                if (additionalSize === 0) {
	                    return pixelWidthsArray;
	                }
	                var step = parseFloat(pixelWidthsArray.length - 1) / parseFloat(additionalSize == 1 ? additionalSize : additionalSize - 1), i;
	                for (i = 0; i < additionalSize; i++) {
	                    pixelWidthsArray[parseInt(math.round(step * i), 10)] += 1;
	                }
	                return pixelWidthsArray;
	            },
	            _calculateSteps: function (pixelWidths) {
	                var that = this, options = that.options, val = options.min, selection = 0, itemsCount = math.ceil(that._distance / options.smallStep), i = 1, lastItem;
	                itemsCount += that._distance / options.smallStep % 1 === 0 ? 1 : 0;
	                pixelWidths.splice(0, 0, pixelWidths[itemsCount - 2] * 2);
	                pixelWidths.splice(itemsCount - 1, 1, pixelWidths.pop() * 2);
	                that._pixelSteps = [selection];
	                that._values = [val];
	                if (itemsCount === 0) {
	                    return;
	                }
	                while (i < itemsCount) {
	                    selection += (pixelWidths[i - 1] + pixelWidths[i]) / 2;
	                    that._pixelSteps[i] = selection;
	                    val += options.smallStep;
	                    that._values[i] = round(val);
	                    i++;
	                }
	                lastItem = that._distance % options.smallStep === 0 ? itemsCount - 1 : itemsCount;
	                that._pixelSteps[lastItem] = that._maxSelection;
	                that._values[lastItem] = options.max;
	                if (that._isRtl) {
	                    that._pixelSteps.reverse();
	                    that._values.reverse();
	                }
	            },
	            _getValueFromPosition: function (mousePosition, dragableArea) {
	                var that = this, options = that.options, step = math.max(options.smallStep * (that._maxSelection / that._distance), 0), position = 0, halfStep = step / 2, i;
	                if (that._isHorizontal) {
	                    position = mousePosition - dragableArea.startPoint;
	                    if (that._isRtl) {
	                        position = that._maxSelection - position;
	                    }
	                } else {
	                    position = dragableArea.startPoint - mousePosition;
	                }
	                if (that._maxSelection - (parseInt(that._maxSelection % step, 10) - 3) / 2 < position) {
	                    return options.max;
	                }
	                for (i = 0; i < that._pixelSteps.length; i++) {
	                    if (math.abs(that._pixelSteps[i] - position) - 1 <= halfStep) {
	                        return round(that._values[i]);
	                    }
	                }
	            },
	            _getFormattedValue: function (val, drag) {
	                var that = this, html = '', tooltip = that.options.tooltip, tooltipTemplate, selectionStart, selectionEnd;
	                if (isArray(val)) {
	                    selectionStart = val[0];
	                    selectionEnd = val[1];
	                } else if (drag && drag.type) {
	                    selectionStart = drag.selectionStart;
	                    selectionEnd = drag.selectionEnd;
	                }
	                if (drag) {
	                    tooltipTemplate = drag.tooltipTemplate;
	                }
	                if (!tooltipTemplate && tooltip.template) {
	                    tooltipTemplate = kendo.template(tooltip.template);
	                }
	                if (isArray(val) || drag && drag.type) {
	                    if (tooltipTemplate) {
	                        html = tooltipTemplate({
	                            selectionStart: selectionStart,
	                            selectionEnd: selectionEnd
	                        });
	                    } else {
	                        selectionStart = format(tooltip.format, selectionStart);
	                        selectionEnd = format(tooltip.format, selectionEnd);
	                        html = selectionStart + ' - ' + selectionEnd;
	                    }
	                } else {
	                    if (drag) {
	                        drag.val = val;
	                    }
	                    if (tooltipTemplate) {
	                        html = tooltipTemplate({ value: val });
	                    } else {
	                        html = format(tooltip.format, val);
	                    }
	                }
	                return html;
	            },
	            _getDraggableArea: function () {
	                var that = this, offset = kendo.getOffset(that._trackDiv);
	                return {
	                    startPoint: that._isHorizontal ? offset.left : offset.top + that._maxSelection,
	                    endPoint: that._isHorizontal ? offset.left + that._maxSelection : offset.top
	                };
	            },
	            _createHtml: function () {
	                var that = this, element = that.element, options = that.options, inputs = element.find('input');
	                if (inputs.length == 2) {
	                    inputs.eq(0).prop('value', formatValue(options.selectionStart));
	                    inputs.eq(1).prop('value', formatValue(options.selectionEnd));
	                } else {
	                    element.prop('value', formatValue(options.value));
	                }
	                element.wrap(createWrapper(options, element, that._isHorizontal)).hide();
	                if (options.showButtons) {
	                    element.before(createButton(options, 'increase', that._isHorizontal)).before(createButton(options, 'decrease', that._isHorizontal));
	                }
	                element.before(createTrack(options, element));
	            },
	            _focus: function (e) {
	                var that = this, target = e.target, val = that.value(), drag = that._drag;
	                if (!drag) {
	                    if (target == that.wrapper.find(DRAG_HANDLE).eq(0)[0]) {
	                        drag = that._firstHandleDrag;
	                        that._activeHandle = 0;
	                    } else {
	                        drag = that._lastHandleDrag;
	                        that._activeHandle = 1;
	                    }
	                    val = val[that._activeHandle];
	                }
	                $(target).addClass(STATE_FOCUSED + ' ' + STATE_SELECTED);
	                if (drag) {
	                    that._activeHandleDrag = drag;
	                    drag.selectionStart = that.options.selectionStart;
	                    drag.selectionEnd = that.options.selectionEnd;
	                    drag._updateTooltip(val);
	                }
	            },
	            _focusWithMouse: function (target) {
	                target = $(target);
	                var that = this, idx = target.is(DRAG_HANDLE) ? target.index() : 0;
	                window.setTimeout(function () {
	                    that.wrapper.find(DRAG_HANDLE)[idx == 2 ? 1 : 0].focus();
	                }, 1);
	                that._setTooltipTimeout();
	            },
	            _blur: function (e) {
	                var that = this, drag = that._activeHandleDrag;
	                $(e.target).removeClass(STATE_FOCUSED + ' ' + STATE_SELECTED);
	                if (drag) {
	                    drag._removeTooltip();
	                    delete that._activeHandleDrag;
	                    delete that._activeHandle;
	                }
	            },
	            _setTooltipTimeout: function () {
	                var that = this;
	                that._tooltipTimeout = window.setTimeout(function () {
	                    var drag = that._drag || that._activeHandleDrag;
	                    if (drag) {
	                        drag._removeTooltip();
	                    }
	                }, 300);
	            },
	            _clearTooltipTimeout: function () {
	                var that = this;
	                window.clearTimeout(this._tooltipTimeout);
	                var drag = that._drag || that._activeHandleDrag;
	                if (drag && drag.tooltipDiv) {
	                    drag.tooltipDiv.stop(true, false).css('opacity', 1);
	                }
	            },
	            _reset: function () {
	                var that = this, element = that.element, formId = element.attr('form'), form = formId ? $('#' + formId) : element.closest('form');
	                if (form[0]) {
	                    that._form = form.on('reset', proxy(that._formResetHandler, that));
	                }
	            },
	            destroy: function () {
	                if (this._form) {
	                    this._form.off('reset', this._formResetHandler);
	                }
	                Widget.fn.destroy.call(this);
	            }
	        });
	        function createWrapper(options, element, isHorizontal) {
	            var orientationCssClass = isHorizontal ? ' k-slider-horizontal' : ' k-slider-vertical', style = options.style ? options.style : element.attr('style'), cssClasses = element.attr('class') ? ' ' + element.attr('class') : '', tickPlacementCssClass = '';
	            if (options.tickPlacement == 'bottomRight') {
	                tickPlacementCssClass = ' k-slider-bottomright';
	            } else if (options.tickPlacement == 'topLeft') {
	                tickPlacementCssClass = ' k-slider-topleft';
	            }
	            style = style ? ' style=\'' + style + '\'' : '';
	            return '<div class=\'k-widget k-slider' + orientationCssClass + cssClasses + '\'' + style + '>' + '<div class=\'k-slider-wrap' + (options.showButtons ? ' k-slider-buttons' : '') + tickPlacementCssClass + '\'></div></div>';
	        }
	        function createButton(options, type, isHorizontal) {
	            var buttonCssClass = '';
	            if (type == 'increase') {
	                buttonCssClass = isHorizontal ? 'k-i-arrow-e' : 'k-i-arrow-n';
	            } else {
	                buttonCssClass = isHorizontal ? 'k-i-arrow-w' : 'k-i-arrow-s';
	            }
	            return '<a class=\'k-button k-button-' + type + '\' aria-label=\'' + options[type + 'ButtonTitle'] + '\'>' + '<span class=\'k-icon ' + buttonCssClass + '\'></span></a>';
	        }
	        function createSliderItems(options, distance) {
	            var result = '<ul class=\'k-reset k-slider-items\'>', count = math.floor(round(distance / options.smallStep)) + 1, i;
	            for (i = 0; i < count; i++) {
	                result += '<li class=\'k-tick\' role=\'presentation\'>&nbsp;</li>';
	            }
	            result += '</ul>';
	            return result;
	        }
	        function createTrack(options, element) {
	            var dragHandleCount = element.is('input') ? 1 : 2, firstDragHandleTitle = dragHandleCount == 2 ? options.leftDragHandleTitle : options.dragHandleTitle;
	            return '<div class=\'k-slider-track\'><div class=\'k-slider-selection\'><!-- --></div>' + '<a href=\'#\' class=\'k-draghandle\' title=\'' + firstDragHandleTitle + '\' role=\'slider\' aria-valuemin=\'' + options.min + '\' aria-valuemax=\'' + options.max + '\' aria-valuenow=\'' + (dragHandleCount > 1 ? options.selectionStart || options.min : options.value || options.min) + '\'>Drag</a>' + (dragHandleCount > 1 ? '<a href=\'#\' class=\'k-draghandle\' title=\'' + options.rightDragHandleTitle + '\'role=\'slider\' aria-valuemin=\'' + options.min + '\' aria-valuemax=\'' + options.max + '\' aria-valuenow=\'' + (options.selectionEnd || options.max) + '\'>Drag</a>' : '') + '</div>';
	        }
	        function step(stepValue) {
	            return function (value) {
	                return value + stepValue;
	            };
	        }
	        function setValue(value) {
	            return function () {
	                return value;
	            };
	        }
	        function formatValue(value) {
	            return (value + '').replace('.', kendo.cultures.current.numberFormat['.']);
	        }
	        function calculatePrecision(value) {
	            var number = value.toString();
	            var precision = 0;
	            number = number.split('.');
	            if (number[1]) {
	                precision = number[1].length;
	            }
	            precision = precision > 10 ? 10 : precision;
	            return precision;
	        }
	        function round(value) {
	            var precision, power;
	            value = parseFloat(value, 10);
	            precision = calculatePrecision(value);
	            power = math.pow(10, precision || 0);
	            return math.round(value * power) / power;
	        }
	        function parseAttr(element, name) {
	            var value = parse(element.getAttribute(name));
	            if (value === null) {
	                value = undefined;
	            }
	            return value;
	        }
	        function defined(value) {
	            return typeof value !== UNDEFINED;
	        }
	        function removeFraction(value) {
	            return value * 10000;
	        }
	        var Slider = SliderBase.extend({
	            init: function (element, options) {
	                var that = this, dragHandle;
	                element.type = 'text';
	                options = extend({}, {
	                    value: parseAttr(element, 'value'),
	                    min: parseAttr(element, 'min'),
	                    max: parseAttr(element, 'max'),
	                    smallStep: parseAttr(element, 'step')
	                }, options);
	                element = $(element);
	                if (options && options.enabled === undefined) {
	                    options.enabled = !element.is('[disabled]');
	                }
	                SliderBase.fn.init.call(that, element, options);
	                options = that.options;
	                if (!defined(options.value) || options.value === null) {
	                    options.value = options.min;
	                    element.prop('value', formatValue(options.min));
	                }
	                options.value = math.max(math.min(options.value, options.max), options.min);
	                dragHandle = that.wrapper.find(DRAG_HANDLE);
	                this._selection = new Slider.Selection(dragHandle, that, options);
	                that._drag = new Slider.Drag(dragHandle, '', that, options);
	            },
	            options: {
	                name: 'Slider',
	                showButtons: true,
	                increaseButtonTitle: 'Increase',
	                decreaseButtonTitle: 'Decrease',
	                dragHandleTitle: 'drag',
	                tooltip: { format: '{0:#,#.##}' },
	                value: null
	            },
	            enable: function (enable) {
	                var that = this, options = that.options, clickHandler, move;
	                that.disable();
	                if (enable === false) {
	                    return;
	                }
	                that.wrapper.removeClass(STATE_DISABLED).addClass(STATE_DEFAULT);
	                that.wrapper.find('input').removeAttr(DISABLED);
	                clickHandler = function (e) {
	                    var touch = getTouches(e)[0];
	                    if (!touch) {
	                        return;
	                    }
	                    var mousePosition = that._isHorizontal ? touch.location.pageX : touch.location.pageY, dragableArea = that._getDraggableArea(), target = $(e.target);
	                    if (target.hasClass('k-draghandle')) {
	                        target.addClass(STATE_FOCUSED + ' ' + STATE_SELECTED);
	                        return;
	                    }
	                    that._update(that._getValueFromPosition(mousePosition, dragableArea));
	                    that._focusWithMouse(e.target);
	                    that._drag.dragstart(e);
	                    e.preventDefault();
	                };
	                that.wrapper.find(TICK_SELECTOR + ', ' + TRACK_SELECTOR).on(TRACK_MOUSE_DOWN, clickHandler).end().on(TRACK_MOUSE_DOWN, function () {
	                    $(document.documentElement).one('selectstart', kendo.preventDefault);
	                }).on(TRACK_MOUSE_UP, function () {
	                    that._drag._end();
	                });
	                that.wrapper.find(DRAG_HANDLE).attr(TABINDEX, 0).on(MOUSE_UP, function () {
	                    that._setTooltipTimeout();
	                }).on(CLICK, function (e) {
	                    that._focusWithMouse(e.target);
	                    e.preventDefault();
	                }).on(FOCUS, proxy(that._focus, that)).on(BLUR, proxy(that._blur, that));
	                move = proxy(function (sign) {
	                    var newVal = that._nextValueByIndex(that._valueIndex + sign * 1);
	                    that._setValueInRange(newVal);
	                    that._drag._updateTooltip(newVal);
	                }, that);
	                if (options.showButtons) {
	                    var mouseDownHandler = proxy(function (e, sign) {
	                        this._clearTooltipTimeout();
	                        if (e.which === 1 || support.touch && e.which === 0) {
	                            move(sign);
	                            this.timeout = setTimeout(proxy(function () {
	                                this.timer = setInterval(function () {
	                                    move(sign);
	                                }, 60);
	                            }, this), 200);
	                        }
	                    }, that);
	                    that.wrapper.find('.k-button').on(MOUSE_UP, proxy(function (e) {
	                        this._clearTimer();
	                        that._focusWithMouse(e.target);
	                    }, that)).on(MOUSE_OVER, function (e) {
	                        $(e.currentTarget).addClass('k-state-hover');
	                    }).on('mouseout' + NS, proxy(function (e) {
	                        $(e.currentTarget).removeClass('k-state-hover');
	                        this._clearTimer();
	                    }, that)).eq(0).on(MOUSE_DOWN, proxy(function (e) {
	                        mouseDownHandler(e, 1);
	                    }, that)).click(false).end().eq(1).on(MOUSE_DOWN, proxy(function (e) {
	                        mouseDownHandler(e, -1);
	                    }, that)).click(kendo.preventDefault);
	                }
	                that.wrapper.find(DRAG_HANDLE).off(KEY_DOWN, false).on(KEY_DOWN, proxy(this._keydown, that));
	                options.enabled = true;
	            },
	            disable: function () {
	                var that = this;
	                that.wrapper.removeClass(STATE_DEFAULT).addClass(STATE_DISABLED);
	                $(that.element).prop(DISABLED, DISABLED);
	                that.wrapper.find('.k-button').off(MOUSE_DOWN).on(MOUSE_DOWN, kendo.preventDefault).off(MOUSE_UP).on(MOUSE_UP, kendo.preventDefault).off('mouseleave' + NS).on('mouseleave' + NS, kendo.preventDefault).off(MOUSE_OVER).on(MOUSE_OVER, kendo.preventDefault);
	                that.wrapper.find(TICK_SELECTOR + ', ' + TRACK_SELECTOR).off(TRACK_MOUSE_DOWN).off(TRACK_MOUSE_UP);
	                that.wrapper.find(DRAG_HANDLE).attr(TABINDEX, -1).off(MOUSE_UP).off(KEY_DOWN).off(CLICK).off(FOCUS).off(BLUR);
	                that.options.enabled = false;
	            },
	            _update: function (val) {
	                var that = this, change = that.value() != val;
	                that.value(val);
	                if (change) {
	                    that.trigger(CHANGE, { value: that.options.value });
	                }
	            },
	            value: function (value) {
	                var that = this, options = that.options;
	                value = round(value);
	                if (isNaN(value)) {
	                    return options.value;
	                }
	                if (value >= options.min && value <= options.max) {
	                    if (options.value != value) {
	                        that.element.prop('value', formatValue(value));
	                        options.value = value;
	                        that._refreshAriaAttr(value);
	                        that._refresh();
	                    }
	                }
	            },
	            _refresh: function () {
	                this.trigger(MOVE_SELECTION, { value: this.options.value });
	            },
	            _refreshAriaAttr: function (value) {
	                var that = this, drag = that._drag, formattedValue;
	                if (drag && drag._tooltipDiv) {
	                    formattedValue = drag._tooltipDiv.text();
	                } else {
	                    formattedValue = that._getFormattedValue(value, null);
	                }
	                this.wrapper.find(DRAG_HANDLE).attr('aria-valuenow', value).attr('aria-valuetext', formattedValue);
	            },
	            _clearTimer: function () {
	                clearTimeout(this.timeout);
	                clearInterval(this.timer);
	            },
	            _keydown: function (e) {
	                var that = this;
	                if (e.keyCode in that._keyMap) {
	                    that._clearTooltipTimeout();
	                    that._setValueInRange(that._keyMap[e.keyCode](that.options.value));
	                    that._drag._updateTooltip(that.value());
	                    e.preventDefault();
	                }
	            },
	            _setValueInRange: function (val) {
	                var that = this, options = that.options;
	                val = round(val);
	                if (isNaN(val)) {
	                    that._update(options.min);
	                    return;
	                }
	                val = math.max(math.min(val, options.max), options.min);
	                that._update(val);
	            },
	            _nextValueByIndex: function (index) {
	                var count = this._values.length;
	                if (this._isRtl) {
	                    index = count - 1 - index;
	                }
	                return this._values[math.max(0, math.min(index, count - 1))];
	            },
	            _formResetHandler: function () {
	                var that = this, min = that.options.min;
	                setTimeout(function () {
	                    var value = that.element[0].value;
	                    that.value(value === '' || isNaN(value) ? min : value);
	                });
	            },
	            destroy: function () {
	                var that = this;
	                SliderBase.fn.destroy.call(that);
	                that.wrapper.off(NS).find('.k-button').off(NS).end().find(DRAG_HANDLE).off(NS).end().find(TICK_SELECTOR + ', ' + TRACK_SELECTOR).off(NS).end();
	                that._drag.draggable.destroy();
	                that._drag._removeTooltip(true);
	            }
	        });
	        Slider.Selection = function (dragHandle, that, options) {
	            function moveSelection(val) {
	                var selectionValue = val - options.min, index = that._valueIndex = math.ceil(round(selectionValue / options.smallStep)), selection = parseInt(that._pixelSteps[index], 10), selectionDiv = that._trackDiv.find('.k-slider-selection'), halfDragHanndle = parseInt(dragHandle[that._outerSize]() / 2, 10), rtlCorrection = that._isRtl ? 2 : 0;
	                selectionDiv[that._sizeFn](that._isRtl ? that._maxSelection - selection : selection);
	                dragHandle.css(that._position, selection - halfDragHanndle - rtlCorrection);
	            }
	            moveSelection(options.value);
	            that.bind([
	                CHANGE,
	                SLIDE,
	                MOVE_SELECTION
	            ], function (e) {
	                moveSelection(parseFloat(e.value, 10));
	            });
	        };
	        Slider.Drag = function (element, type, owner, options) {
	            var that = this;
	            that.owner = owner;
	            that.options = options;
	            that.element = element;
	            that.type = type;
	            that.draggable = new Draggable(element, {
	                distance: 0,
	                dragstart: proxy(that._dragstart, that),
	                drag: proxy(that.drag, that),
	                dragend: proxy(that.dragend, that),
	                dragcancel: proxy(that.dragcancel, that)
	            });
	            element.click(false);
	        };
	        Slider.Drag.prototype = {
	            dragstart: function (e) {
	                this.owner._activeDragHandle = this;
	                this.draggable.userEvents.cancel();
	                this._dragstart(e);
	                this.dragend();
	            },
	            _dragstart: function (e) {
	                var that = this, owner = that.owner, options = that.options;
	                if (!options.enabled) {
	                    e.preventDefault();
	                    return;
	                }
	                this.owner._activeDragHandle = this;
	                owner.element.off(MOUSE_OVER);
	                owner.wrapper.find('.' + STATE_FOCUSED).removeClass(STATE_FOCUSED + ' ' + STATE_SELECTED);
	                that.element.addClass(STATE_FOCUSED + ' ' + STATE_SELECTED);
	                $(document.documentElement).css('cursor', 'pointer');
	                that.dragableArea = owner._getDraggableArea();
	                that.step = math.max(options.smallStep * (owner._maxSelection / owner._distance), 0);
	                if (that.type) {
	                    that.selectionStart = options.selectionStart;
	                    that.selectionEnd = options.selectionEnd;
	                    owner._setZIndex(that.type);
	                } else {
	                    that.oldVal = that.val = options.value;
	                }
	                that._removeTooltip(true);
	                that._createTooltip();
	            },
	            _createTooltip: function () {
	                var that = this, owner = that.owner, tooltip = that.options.tooltip, html = '', wnd = $(window), tooltipTemplate, colloutCssClass;
	                if (!tooltip.enabled) {
	                    return;
	                }
	                if (tooltip.template) {
	                    tooltipTemplate = that.tooltipTemplate = kendo.template(tooltip.template);
	                }
	                $('.k-slider-tooltip').remove();
	                that.tooltipDiv = $('<div class=\'k-widget k-tooltip k-slider-tooltip\'><!-- --></div>').appendTo(document.body);
	                html = owner._getFormattedValue(that.val || owner.value(), that);
	                if (!that.type) {
	                    colloutCssClass = 'k-callout-' + (owner._isHorizontal ? 's' : 'e');
	                    that.tooltipInnerDiv = '<div class=\'k-callout ' + colloutCssClass + '\'><!-- --></div>';
	                    html += that.tooltipInnerDiv;
	                }
	                that.tooltipDiv.html(html);
	                that._scrollOffset = {
	                    top: wnd.scrollTop(),
	                    left: wnd.scrollLeft()
	                };
	                that.moveTooltip();
	            },
	            drag: function (e) {
	                var that = this, owner = that.owner, x = e.x.location, y = e.y.location, startPoint = that.dragableArea.startPoint, endPoint = that.dragableArea.endPoint, slideParams;
	                e.preventDefault();
	                if (owner._isHorizontal) {
	                    if (owner._isRtl) {
	                        that.val = that.constrainValue(x, startPoint, endPoint, x < endPoint);
	                    } else {
	                        that.val = that.constrainValue(x, startPoint, endPoint, x >= endPoint);
	                    }
	                } else {
	                    that.val = that.constrainValue(y, endPoint, startPoint, y <= endPoint);
	                }
	                if (that.oldVal != that.val) {
	                    that.oldVal = that.val;
	                    if (that.type) {
	                        if (that.type == 'firstHandle') {
	                            if (that.val < that.selectionEnd) {
	                                that.selectionStart = that.val;
	                            } else {
	                                that.selectionStart = that.selectionEnd = that.val;
	                            }
	                        } else {
	                            if (that.val > that.selectionStart) {
	                                that.selectionEnd = that.val;
	                            } else {
	                                that.selectionStart = that.selectionEnd = that.val;
	                            }
	                        }
	                        slideParams = {
	                            values: [
	                                that.selectionStart,
	                                that.selectionEnd
	                            ],
	                            value: [
	                                that.selectionStart,
	                                that.selectionEnd
	                            ]
	                        };
	                    } else {
	                        slideParams = { value: that.val };
	                    }
	                    owner.trigger(SLIDE, slideParams);
	                }
	                that._updateTooltip(that.val);
	            },
	            _updateTooltip: function (val) {
	                var that = this, options = that.options, tooltip = options.tooltip, html = '';
	                if (!tooltip.enabled) {
	                    return;
	                }
	                if (!that.tooltipDiv) {
	                    that._createTooltip();
	                }
	                html = that.owner._getFormattedValue(round(val), that);
	                if (!that.type) {
	                    html += that.tooltipInnerDiv;
	                }
	                that.tooltipDiv.html(html);
	                that.moveTooltip();
	            },
	            dragcancel: function () {
	                this.owner._refresh();
	                $(document.documentElement).css('cursor', '');
	                return this._end();
	            },
	            dragend: function () {
	                var that = this, owner = that.owner;
	                $(document.documentElement).css('cursor', '');
	                if (that.type) {
	                    owner._update(that.selectionStart, that.selectionEnd);
	                } else {
	                    owner._update(that.val);
	                    that.draggable.userEvents._disposeAll();
	                }
	                that.draggable.userEvents.cancel();
	                return that._end();
	            },
	            _end: function () {
	                var that = this, owner = that.owner;
	                owner._focusWithMouse(that.element);
	                owner.element.on(MOUSE_OVER);
	                return false;
	            },
	            _removeTooltip: function (noAnimation) {
	                var that = this, owner = that.owner;
	                if (that.tooltipDiv && owner.options.tooltip.enabled && owner.options.enabled) {
	                    if (noAnimation) {
	                        that.tooltipDiv.remove();
	                        that.tooltipDiv = null;
	                    } else {
	                        that.tooltipDiv.fadeOut('slow', function () {
	                            $(this).remove();
	                            that.tooltipDiv = null;
	                        });
	                    }
	                }
	            },
	            moveTooltip: function () {
	                var that = this, owner = that.owner, top = 0, left = 0, element = that.element, offset = kendo.getOffset(element), margin = 8, viewport = $(window), callout = that.tooltipDiv.find('.k-callout'), width = that.tooltipDiv.outerWidth(), height = that.tooltipDiv.outerHeight(), dragHandles, sdhOffset, diff, anchorSize;
	                if (that.type) {
	                    dragHandles = owner.wrapper.find(DRAG_HANDLE);
	                    offset = kendo.getOffset(dragHandles.eq(0));
	                    sdhOffset = kendo.getOffset(dragHandles.eq(1));
	                    if (owner._isHorizontal) {
	                        top = sdhOffset.top;
	                        left = offset.left + (sdhOffset.left - offset.left) / 2;
	                    } else {
	                        top = offset.top + (sdhOffset.top - offset.top) / 2;
	                        left = sdhOffset.left;
	                    }
	                    anchorSize = dragHandles.eq(0).outerWidth() + 2 * margin;
	                } else {
	                    top = offset.top;
	                    left = offset.left;
	                    anchorSize = element.outerWidth() + 2 * margin;
	                }
	                if (owner._isHorizontal) {
	                    left -= parseInt((width - element[owner._outerSize]()) / 2, 10);
	                    top -= height + callout.height() + margin;
	                } else {
	                    top -= parseInt((height - element[owner._outerSize]()) / 2, 10);
	                    left -= width + callout.width() + margin;
	                }
	                if (owner._isHorizontal) {
	                    diff = that._flip(top, height, anchorSize, viewport.outerHeight() + that._scrollOffset.top);
	                    top += diff;
	                    left += that._fit(left, width, viewport.outerWidth() + that._scrollOffset.left);
	                } else {
	                    diff = that._flip(left, width, anchorSize, viewport.outerWidth() + that._scrollOffset.left);
	                    top += that._fit(top, height, viewport.outerHeight() + that._scrollOffset.top);
	                    left += diff;
	                }
	                if (diff > 0 && callout) {
	                    callout.removeClass();
	                    callout.addClass('k-callout k-callout-' + (owner._isHorizontal ? 'n' : 'w'));
	                }
	                that.tooltipDiv.css({
	                    top: top,
	                    left: left
	                });
	            },
	            _fit: function (position, size, viewPortEnd) {
	                var output = 0;
	                if (position + size > viewPortEnd) {
	                    output = viewPortEnd - (position + size);
	                }
	                if (position < 0) {
	                    output = -position;
	                }
	                return output;
	            },
	            _flip: function (offset, size, anchorSize, viewPortEnd) {
	                var output = 0;
	                if (offset + size > viewPortEnd) {
	                    output += -(anchorSize + size);
	                }
	                if (offset + output < 0) {
	                    output += anchorSize + size;
	                }
	                return output;
	            },
	            constrainValue: function (position, min, max, maxOverflow) {
	                var that = this, val = 0;
	                if (min < position && position < max) {
	                    val = that.owner._getValueFromPosition(position, that.dragableArea);
	                } else {
	                    if (maxOverflow) {
	                        val = that.options.max;
	                    } else {
	                        val = that.options.min;
	                    }
	                }
	                return val;
	            }
	        };
	        kendo.ui.plugin(Slider);
	        var RangeSlider = SliderBase.extend({
	            init: function (element, options) {
	                var that = this, inputs = $(element).find('input'), firstInput = inputs.eq(0)[0], secondInput = inputs.eq(1)[0];
	                firstInput.type = 'text';
	                secondInput.type = 'text';
	                if (options && options.showButtons) {
	                    if (window.console) {
	                        window.console.warn('showbuttons option is not supported for the range slider, ignoring');
	                    }
	                    options.showButtons = false;
	                }
	                options = extend({}, {
	                    selectionStart: parseAttr(firstInput, 'value'),
	                    min: parseAttr(firstInput, 'min'),
	                    max: parseAttr(firstInput, 'max'),
	                    smallStep: parseAttr(firstInput, 'step')
	                }, {
	                    selectionEnd: parseAttr(secondInput, 'value'),
	                    min: parseAttr(secondInput, 'min'),
	                    max: parseAttr(secondInput, 'max'),
	                    smallStep: parseAttr(secondInput, 'step')
	                }, options);
	                if (options && options.enabled === undefined) {
	                    options.enabled = !inputs.is('[disabled]');
	                }
	                SliderBase.fn.init.call(that, element, options);
	                options = that.options;
	                if (!defined(options.selectionStart) || options.selectionStart === null) {
	                    options.selectionStart = options.min;
	                    inputs.eq(0).prop('value', formatValue(options.min));
	                }
	                if (!defined(options.selectionEnd) || options.selectionEnd === null) {
	                    options.selectionEnd = options.max;
	                    inputs.eq(1).prop('value', formatValue(options.max));
	                }
	                var dragHandles = that.wrapper.find(DRAG_HANDLE);
	                this._selection = new RangeSlider.Selection(dragHandles, that, options);
	                that._firstHandleDrag = new Slider.Drag(dragHandles.eq(0), 'firstHandle', that, options);
	                that._lastHandleDrag = new Slider.Drag(dragHandles.eq(1), 'lastHandle', that, options);
	            },
	            options: {
	                name: 'RangeSlider',
	                leftDragHandleTitle: 'drag',
	                rightDragHandleTitle: 'drag',
	                tooltip: { format: '{0:#,#.##}' },
	                selectionStart: null,
	                selectionEnd: null
	            },
	            enable: function (enable) {
	                var that = this, options = that.options, clickHandler;
	                that.disable();
	                if (enable === false) {
	                    return;
	                }
	                that.wrapper.removeClass(STATE_DISABLED).addClass(STATE_DEFAULT);
	                that.wrapper.find('input').removeAttr(DISABLED);
	                clickHandler = function (e) {
	                    var touch = getTouches(e)[0];
	                    if (!touch) {
	                        return;
	                    }
	                    var mousePosition = that._isHorizontal ? touch.location.pageX : touch.location.pageY, dragableArea = that._getDraggableArea(), val = that._getValueFromPosition(mousePosition, dragableArea), target = $(e.target), from, to, drag;
	                    if (target.hasClass('k-draghandle')) {
	                        that.wrapper.find('.' + STATE_FOCUSED).removeClass(STATE_FOCUSED + ' ' + STATE_SELECTED);
	                        target.addClass(STATE_FOCUSED + ' ' + STATE_SELECTED);
	                        return;
	                    }
	                    if (val < options.selectionStart) {
	                        from = val;
	                        to = options.selectionEnd;
	                        drag = that._firstHandleDrag;
	                    } else if (val > that.selectionEnd) {
	                        from = options.selectionStart;
	                        to = val;
	                        drag = that._lastHandleDrag;
	                    } else {
	                        if (val - options.selectionStart <= options.selectionEnd - val) {
	                            from = val;
	                            to = options.selectionEnd;
	                            drag = that._firstHandleDrag;
	                        } else {
	                            from = options.selectionStart;
	                            to = val;
	                            drag = that._lastHandleDrag;
	                        }
	                    }
	                    drag.dragstart(e);
	                    that._setValueInRange(from, to);
	                    that._focusWithMouse(drag.element);
	                };
	                that.wrapper.find(TICK_SELECTOR + ', ' + TRACK_SELECTOR).on(TRACK_MOUSE_DOWN, clickHandler).end().on(TRACK_MOUSE_DOWN, function () {
	                    $(document.documentElement).one('selectstart', kendo.preventDefault);
	                }).on(TRACK_MOUSE_UP, function () {
	                    if (that._activeDragHandle) {
	                        that._activeDragHandle._end();
	                    }
	                });
	                that.wrapper.find(DRAG_HANDLE).attr(TABINDEX, 0).on(MOUSE_UP, function () {
	                    that._setTooltipTimeout();
	                }).on(CLICK, function (e) {
	                    that._focusWithMouse(e.target);
	                    e.preventDefault();
	                }).on(FOCUS, proxy(that._focus, that)).on(BLUR, proxy(that._blur, that));
	                that.wrapper.find(DRAG_HANDLE).off(KEY_DOWN, kendo.preventDefault).eq(0).on(KEY_DOWN, proxy(function (e) {
	                    this._keydown(e, 'firstHandle');
	                }, that)).end().eq(1).on(KEY_DOWN, proxy(function (e) {
	                    this._keydown(e, 'lastHandle');
	                }, that));
	                that.options.enabled = true;
	            },
	            disable: function () {
	                var that = this;
	                that.wrapper.removeClass(STATE_DEFAULT).addClass(STATE_DISABLED);
	                that.wrapper.find('input').prop(DISABLED, DISABLED);
	                that.wrapper.find(TICK_SELECTOR + ', ' + TRACK_SELECTOR).off(TRACK_MOUSE_DOWN).off(TRACK_MOUSE_UP);
	                that.wrapper.find(DRAG_HANDLE).attr(TABINDEX, -1).off(MOUSE_UP).off(KEY_DOWN).off(CLICK).off(FOCUS).off(BLUR);
	                that.options.enabled = false;
	            },
	            _keydown: function (e, handle) {
	                var that = this, selectionStartValue = that.options.selectionStart, selectionEndValue = that.options.selectionEnd, dragSelectionStart, dragSelectionEnd, activeHandleDrag;
	                if (e.keyCode in that._keyMap) {
	                    that._clearTooltipTimeout();
	                    if (handle == 'firstHandle') {
	                        activeHandleDrag = that._activeHandleDrag = that._firstHandleDrag;
	                        selectionStartValue = that._keyMap[e.keyCode](selectionStartValue);
	                        if (selectionStartValue > selectionEndValue) {
	                            selectionEndValue = selectionStartValue;
	                        }
	                    } else {
	                        activeHandleDrag = that._activeHandleDrag = that._lastHandleDrag;
	                        selectionEndValue = that._keyMap[e.keyCode](selectionEndValue);
	                        if (selectionStartValue > selectionEndValue) {
	                            selectionStartValue = selectionEndValue;
	                        }
	                    }
	                    that._setValueInRange(round(selectionStartValue), round(selectionEndValue));
	                    dragSelectionStart = Math.max(selectionStartValue, that.options.selectionStart);
	                    dragSelectionEnd = Math.min(selectionEndValue, that.options.selectionEnd);
	                    activeHandleDrag.selectionEnd = Math.max(dragSelectionEnd, that.options.selectionStart);
	                    activeHandleDrag.selectionStart = Math.min(dragSelectionStart, that.options.selectionEnd);
	                    activeHandleDrag._updateTooltip(that.value()[that._activeHandle]);
	                    e.preventDefault();
	                }
	            },
	            _update: function (selectionStart, selectionEnd) {
	                var that = this, values = that.value();
	                var change = values[0] != selectionStart || values[1] != selectionEnd;
	                that.value([
	                    selectionStart,
	                    selectionEnd
	                ]);
	                if (change) {
	                    that.trigger(CHANGE, {
	                        values: [
	                            selectionStart,
	                            selectionEnd
	                        ],
	                        value: [
	                            selectionStart,
	                            selectionEnd
	                        ]
	                    });
	                }
	            },
	            value: function (value) {
	                if (value && value.length) {
	                    return this._value(value[0], value[1]);
	                } else {
	                    return this._value();
	                }
	            },
	            _value: function (start, end) {
	                var that = this, options = that.options, selectionStart = options.selectionStart, selectionEnd = options.selectionEnd;
	                if (isNaN(start) && isNaN(end)) {
	                    return [
	                        selectionStart,
	                        selectionEnd
	                    ];
	                } else {
	                    start = round(start);
	                    end = round(end);
	                }
	                if (start >= options.min && start <= options.max && end >= options.min && end <= options.max && start <= end) {
	                    if (selectionStart != start || selectionEnd != end) {
	                        that.element.find('input').eq(0).prop('value', formatValue(start)).end().eq(1).prop('value', formatValue(end));
	                        options.selectionStart = start;
	                        options.selectionEnd = end;
	                        that._refresh();
	                        that._refreshAriaAttr(start, end);
	                    }
	                }
	            },
	            values: function (start, end) {
	                if (isArray(start)) {
	                    return this._value(start[0], start[1]);
	                } else {
	                    return this._value(start, end);
	                }
	            },
	            _refresh: function () {
	                var that = this, options = that.options;
	                that.trigger(MOVE_SELECTION, {
	                    values: [
	                        options.selectionStart,
	                        options.selectionEnd
	                    ],
	                    value: [
	                        options.selectionStart,
	                        options.selectionEnd
	                    ]
	                });
	                if (options.selectionStart == options.max && options.selectionEnd == options.max) {
	                    that._setZIndex('firstHandle');
	                }
	            },
	            _refreshAriaAttr: function (start, end) {
	                var that = this, dragHandles = that.wrapper.find(DRAG_HANDLE), drag = that._activeHandleDrag, formattedValue;
	                formattedValue = that._getFormattedValue([
	                    start,
	                    end
	                ], drag);
	                dragHandles.eq(0).attr('aria-valuenow', start);
	                dragHandles.eq(1).attr('aria-valuenow', end);
	                dragHandles.attr('aria-valuetext', formattedValue);
	            },
	            _setValueInRange: function (selectionStart, selectionEnd) {
	                var options = this.options;
	                selectionStart = math.max(math.min(selectionStart, options.max), options.min);
	                selectionEnd = math.max(math.min(selectionEnd, options.max), options.min);
	                if (selectionStart == options.max && selectionEnd == options.max) {
	                    this._setZIndex('firstHandle');
	                }
	                this._update(math.min(selectionStart, selectionEnd), math.max(selectionStart, selectionEnd));
	            },
	            _setZIndex: function (type) {
	                this.wrapper.find(DRAG_HANDLE).each(function (index) {
	                    $(this).css('z-index', type == 'firstHandle' ? 1 - index : index);
	                });
	            },
	            _formResetHandler: function () {
	                var that = this, options = that.options;
	                setTimeout(function () {
	                    var inputs = that.element.find('input');
	                    var start = inputs[0].value;
	                    var end = inputs[1].value;
	                    that.values(start === '' || isNaN(start) ? options.min : start, end === '' || isNaN(end) ? options.max : end);
	                });
	            },
	            destroy: function () {
	                var that = this;
	                SliderBase.fn.destroy.call(that);
	                that.wrapper.off(NS).find(TICK_SELECTOR + ', ' + TRACK_SELECTOR).off(NS).end().find(DRAG_HANDLE).off(NS);
	                that._firstHandleDrag.draggable.destroy();
	                that._lastHandleDrag.draggable.destroy();
	            }
	        });
	        RangeSlider.Selection = function (dragHandles, that, options) {
	            function moveSelection(value) {
	                value = value || [];
	                var selectionStartValue = value[0] - options.min, selectionEndValue = value[1] - options.min, selectionStartIndex = math.ceil(round(selectionStartValue / options.smallStep)), selectionEndIndex = math.ceil(round(selectionEndValue / options.smallStep)), selectionStart = that._pixelSteps[selectionStartIndex], selectionEnd = that._pixelSteps[selectionEndIndex], halfHandle = parseInt(dragHandles.eq(0)[that._outerSize]() / 2, 10), rtlCorrection = that._isRtl ? 2 : 0;
	                dragHandles.eq(0).css(that._position, selectionStart - halfHandle - rtlCorrection).end().eq(1).css(that._position, selectionEnd - halfHandle - rtlCorrection);
	                makeSelection(selectionStart, selectionEnd);
	            }
	            function makeSelection(selectionStart, selectionEnd) {
	                var selection, selectionPosition, selectionDiv = that._trackDiv.find('.k-slider-selection');
	                selection = math.abs(selectionStart - selectionEnd);
	                selectionDiv[that._sizeFn](selection);
	                if (that._isRtl) {
	                    selectionPosition = math.max(selectionStart, selectionEnd);
	                    selectionDiv.css('right', that._maxSelection - selectionPosition - 1);
	                } else {
	                    selectionPosition = math.min(selectionStart, selectionEnd);
	                    selectionDiv.css(that._position, selectionPosition - 1);
	                }
	            }
	            moveSelection(that.value());
	            that.bind([
	                CHANGE,
	                SLIDE,
	                MOVE_SELECTION
	            ], function (e) {
	                moveSelection(e.values);
	            });
	        };
	        kendo.ui.plugin(RangeSlider);
	    }(window.kendo.jQuery));
	    return window.kendo;
	}, __webpack_require__(200)));

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(207)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    (function ($, undefined) {
	
	        var kendo = window.kendo;
	        var ui = kendo.ui;
	        var Widget = ui.Widget;
	        var ObservableArray = kendo.data.ObservableArray;
	        var assert = window.assert;
	        var logger = new window.Logger('kidoju.widgets.multicheckbox');
	        var NS = '.kendoMultiCheckBox';
	        var NULL = 'null';
	        var STRING = 'string';
	        var UNDEFINED = 'undefined';
	        var CHANGE = 'change';
	        var CLICK = 'click';
	        var ACTIVE = 'k-state-active';
	        var DISABLE = 'k-state-disabled';
	        var WIDGET_CLASS = 'kj-multicheckbox'; // 'k-widget kj-multicheckbox',
	        var CHECKBOX = '<div class="kj-multicheckbox-item"><input id="{1}_{2}" name="{1}" type="checkbox" class="k-checkbox" value="{0}"><label class="k-checkbox-label" for="{1}_{2}">{0}</label></div>';
	        var CHECKBOX_SELECTOR = 'input[type="checkbox"]';
	        var CHECKED = 'checked';
	        var READONLY = 'readonly';
	
	        /*********************************************************************************
	         * Helpers
	         *********************************************************************************/
	
	        /**
	         * Build a random hex string of length characters
	         * @param length
	         * @returns {string}
	         */
	        function randomString(length) {
	            var s = new Array(length + 1).join('x');
	            return s.replace(/x/g, function (c) {
	                /* jshint -W016 */
	                return (Math.random() * 16|0).toString(16);
	                /* jshint +W016 */
	            });
	        }
	
	        /**
	         * Get a random id
	         * @returns {string}
	         */
	        function randomId() {
	            return 'id_' + randomString(6);
	        }
	
	        /**
	         * Format a style string into a style object
	         * @param style
	         * @returns {*}
	         */
	        function formatStyle(style) {
	            if ($.isPlainObject(style)) {
	                return style;
	            } else if ($.type(style) === STRING) {
	                var ret = {};
	                var styleArray = style.split(';');
	                for (var i = 0; i < styleArray.length; i++) {
	                    var styleKeyValue = styleArray[i].split(':');
	                    if ($.isArray(styleKeyValue) && styleKeyValue.length === 2) {
	                        var key = styleKeyValue[0].trim();
	                        var value = styleKeyValue[1].trim();
	                        if (key.length && value.length) {
	                            ret[key] = value;
	                        }
	                    }
	                }
	                return ret;
	            } else {
	                return {};
	            }
	        }
	
	        /*********************************************************************************
	         * Widget
	         *********************************************************************************/
	
	        /**
	         * MultiCheckBox widget
	         */
	        var MultiCheckBox = Widget.extend({
	
	            /**
	             * Constructor
	             * @param element
	             * @param options
	             */
	            init: function (element, options) {
	                var that = this;
	                Widget.fn.init.call(that, element, options);
	                logger.debug('widget initialized');
	                that._value = that.options.value;
	                that._randomId = randomId();
	                that.setOptions(that.options);
	                that._layout();
	                that._dataSource();
	                that.enable(that.options.enable);
	            },
	
	            /**
	             * Widget options
	             */
	            options: {
	                name: 'MultiCheckBox',
	                autoBind: true,
	                dataSource: [],
	                itemStyle: {},
	                selectedStyle: {},
	                value: [],
	                enable: true
	            },
	
	            /**
	             *
	             * @param options
	             */
	            setOptions: function (options) {
	                var that = this;
	                Widget.fn.setOptions.call(that, options);
	                options = that.options;
	                options.groupStyle = formatStyle(options.groupStyle);
	                options.itemStyle = formatStyle(options.itemStyle);
	                options.selectedStyle = formatStyle(options.selectedStyle);
	            },
	
	            /**
	             * Widget events
	             */
	            events: [
	                CHANGE
	            ],
	
	            /**
	             * Gets/sets the value
	             * @param value
	             */
	            value: function (value) {
	                var that = this;
	                if ($.isArray(value) || value instanceof ObservableArray) {
	                    // Note, we are expecting an array of strings which is not checked here
	                    that._value = value;
	                    that._toggleUI();
	                } else if ($.type(value) === NULL) {
	                    that._value = [];
	                    that._toggleUI();
	                } else if ($.type(value) === UNDEFINED) {
	                    return that._value;
	                } else {
	                    throw new TypeError('`value` is expected to be a an array or null if not undefined');
	                }
	            },
	
	            /**
	             * Widget layout
	             * @private
	             */
	            _layout: function () {
	                var that = this;
	                that.wrapper = that.element;
	                that.element
	                    .addClass(WIDGET_CLASS);
	                // refresh updates checkboxes
	            },
	
	
	            /**
	             * Event handler for click event and radios and buttons
	             * Handles
	             * @param e
	             * @private
	             */
	            _onClick: function (e) {
	                assert.instanceof($.Event, e, kendo.format(assert.messages.instanceof.default, 'e', 'jQuery.Event'));
	                var that = this;
	                var _value = that._value = that._value || [];
	                var target = $(e.target);
	                var val = target.val();
	                var index = _value.indexOf(val);
	                var checked = target.prop(CHECKED);
	                if (checked && index === -1) {
	                    _value.push(val);
	                } else if (!checked && index >= 0) {
	                    _value.splice(index, 1);
	                }
	                that._toggleUI();
	                that.trigger(CHANGE, { value: that._value });
	            },
	
	            /**
	             * Update UI when value is changed
	             * @private
	             */
	            _toggleUI: function () {
	                var that = this;
	                var element = this.element;
	                assert.instanceof($, element, kendo.format(assert.messages.instanceof.default, 'this.element', 'jQuery'));
	                element.children('div')
	                    .attr('style', '')
	                    .css(that.options.itemStyle);
	                if ($.isArray(that._value) || that._value instanceof ObservableArray) {
	                    element.find(CHECKBOX_SELECTOR)
	                        .prop(CHECKED, false)
	                        .parent()
	                                .attr('style', '')
	                                .css($.extend({}, that.options.itemStyle));
	                    $.each(that._value, function (index, val) {
	                        element.find(CHECKBOX_SELECTOR + '[value="' + val + '"]')
	                            .prop(CHECKED, true)
	                            .parent()
	                                .attr('style', '')
	                                .css($.extend({}, that.options.itemStyle, that.options.selectedStyle));
	                    });
	                }
	            },
	
	            /**
	             * _dataSource function to bind refresh to the change event
	             * @private
	             */
	            _dataSource: function () {
	                var that = this;
	
	                // returns the datasource OR creates one if using array or configuration
	                that.dataSource = kendo.data.DataSource.create(that.options.dataSource);
	
	                // bind to the change event to refresh the widget
	                if (that._refreshHandler) {
	                    that.dataSource.unbind(CHANGE, that._refreshHandler);
	                }
	                that._refreshHandler = $.proxy(that.refresh, that);
	                that.dataSource.bind(CHANGE, that._refreshHandler);
	
	                // trigger a read on the dataSource if one hasn't happened yet
	                if (that.options.autoBind) {
	                    that.dataSource.fetch();
	                }
	            },
	
	            /**
	             * sets the dataSource for source binding
	             * @param dataSource
	             */
	            setDataSource: function (dataSource) {
	                var that = this;
	                // set the internal datasource equal to the one passed in by MVVM
	                that.options.dataSource = dataSource;
	                // rebuild the datasource if necessary, or just reassign
	                that._dataSource();
	            },
	
	            /**
	             * Refresh method (called when dataSource is updated)
	             * for example to add checkboxes
	             * @param e
	             */
	            refresh: function (e) {
	                var that = this;
	                var element = that.element;
	                assert.instanceof($, element, kendo.format(assert.messages.instanceof.default, 'this.element', 'jQuery'));
	                var items = that.dataSource.data();
	                if (e && e.items instanceof ObservableArray) {
	                    items = e.items;
	                }
	                // Note: we only add elements here (not modify or remove depending on e.action) and we might have to improve
	                that.element.empty();
	                $(items).each(function (index, item) {
	                    var checkbox = $(kendo.format(CHECKBOX, kendo.htmlEncode(item), that._randomId, item))
	                        .css(that.options.itemStyle)
	                        .appendTo(that.element);
	                });
	                // get rid of values that no more have a match in dataSource
	                var _value = that._value = that._value || [];
	                var data = that.dataSource.data();
	                var changed = false;
	                $.each(_value, function (index, val) {
	                    if (data.indexOf(val) === -1) {
	                        _value.splice(index, 1);
	                        changed = true;
	                    }
	                });
	                if (changed) {
	                    // that._toggleUI(); // not needed
	                    that.trigger(CHANGE, { value: that._value });
	                }
	            },
	
	            /**
	             * Enable/disable the widget
	             * @param enable
	             */
	            enable: function (enable) {
	                var that = this;
	                var element = that.element;
	                assert.instanceof($, element, kendo.format(assert.messages.instanceof.default, 'this.element', 'jQuery'));
	                if ($.type(enable) === UNDEFINED) {
	                    enable = true;
	                }
	                element.off(NS);
	                if (enable) {
	                    element.on(CLICK + NS, CHECKBOX_SELECTOR, $.proxy(that._onClick, that));
	                } else {
	                    // Because input are readonly and not disabled, we need to prevent default (checking checkbox) and let it bubble to the stage element to display the handle box
	                    element.on(CLICK + NS, CHECKBOX_SELECTOR, function (e) {
	                        e.preventDefault();
	                    });
	                }
	                element.find(CHECKBOX_SELECTOR)
	                    .toggleClass(DISABLE, !enable)
	                    // .prop('disabled', !enable) <--- suppresses the click event so elements are no more selectable in design mode
	                    .prop(READONLY, !enable);
	            },
	
	            /**
	             * Destroy widget
	             */
	            destroy: function () {
	                var that = this;
	                var element = this.element;
	                Widget.fn.destroy.call(that);
	                // unbind and destroy kendo
	                kendo.unbind(element);
	                kendo.destroy(element);
	                // unbind all other events
	                that.element.find('*').off();
	                that.element.off(NS);
	                // remove descendants
	                that.element.empty();
	                // remove element classes
	                that.element.removeClass(WIDGET_CLASS);
	            }
	
	        });
	
	        ui.plugin(MultiCheckBox);
	
	    })(window.jQuery);
	
	    return window.kendo;
	
	}, __webpack_require__(200));


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(207),
	        __webpack_require__(214)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    /* This function has too many statements. */
	    /* jshint -W071 */
	
	    (function ($, undefined) {
	
	        var kendo = window.kendo;
	        var ui = kendo.ui;
	        var Widget = ui.Widget;
	        var assert = window.assert;
	        var logger = new window.Logger('kidoju.widgets.quiz');
	        var NS = '.kendoQuiz';
	        var STRING = 'string';
	        var UNDEFINED = 'undefined';
	        var CHANGE = 'change';
	        var CLICK = 'click';
	        var ACTIVE = 'k-state-active';
	        var DISABLE = 'k-state-disabled';
	        var WIDGET_CLASS = 'kj-quiz'; // 'k-widget kj-quiz',
	        var BUTTON = '<input type="button" class="k-button kj-quiz-item" value="{0}">';
	        var RADIO = '<div class="kj-quiz-item"><input id="{1}_{2}" name="{1}" type="radio" class="k-radio" value="{0}"><label class="k-radio-label" for="{1}_{2}">{0}</label></div>';
	        var MARGIN = '0.2em';
	        var MODES = {
	                BUTTON: 'button',
	                DROPDOWN: 'dropdown',
	                RADIO: 'radio'
	            };
	        var CHECKED = 'checked';
	        var INPUT_SELECTOR = 'input';
	        var RADIO_SELECTOR = 'input[type="radio"]';
	        var BUTTON_SELECTOR = 'input[type="button"]';
	
	        /*********************************************************************************
	         * Helpers
	         *********************************************************************************/
	
	        var util = {
	
	            /**
	             * Build a random hex string of length characters
	             * @param length
	             * @returns {string}
	             */
	            randomString: function (length)
	            {
	                var s = new Array(length + 1).join('x');
	                return s.replace(/x/g, function (c) {
	                    /* jshint -W016 */
	                    return (Math.random() * 16 | 0).toString(16);
	                    /* jshint +W016 */
	                });
	            },
	
	            /**
	             * Get a random id
	             * @returns {string}
	             */
	            randomId: function () {
	                return 'id_' + util.randomString(6);
	            },
	
	            /**
	             * Format style
	             * @param style
	             * @returns {*}
	             */
	            formatStyle: function (style) {
	                if ($.isPlainObject(style)) {
	                    return style;
	                } else if ($.type(style) === STRING) {
	                    var ret = {};
	                    var styleArray = style.split(';');
	                    for (var i = 0; i < styleArray.length; i++) {
	                        var styleKeyValue = styleArray[i].split(':');
	                        if ($.isArray(styleKeyValue) && styleKeyValue.length === 2) {
	                            var key = styleKeyValue[0].trim();
	                            var value = styleKeyValue[1].trim();
	                            if (key.length && value.length) {
	                                ret[key] = value;
	                            }
	                        }
	                    }
	                    return ret;
	                } else {
	                    return {};
	                }
	            },
	
	            /**
	             * Get the scale of an element's CSS transformation
	             * Note: the same function is used in kidoju.widgets.stage
	             * @param element
	             * @returns {Number|number}
	             */
	            getTransformScale: function (element) {
	                assert.instanceof($, element, kendo.format(assert.messages.instanceof.default, 'element', 'jQuery'));
	                // element.css('transform') returns a matrix, so we have to read the style attribute
	                var match = (element.attr('style') || '').match(/scale\([\s]*([0-9\.]+)[\s]*\)/);
	                return $.isArray(match) && match.length > 1 ? parseFloat(match[1]) || 1 : 1;
	            }
	        };
	
	        /*********************************************************************************
	         * Widget
	         *********************************************************************************/
	
	        /**
	         * Quiz widget
	         */
	        var Quiz = Widget.extend({
	
	            /**
	             * Constructor
	             * @param element
	             * @param options
	             */
	            init: function (element, options) {
	                var that = this;
	                Widget.fn.init.call(that, element, options);
	                logger.debug('widget initialized');
	                that._value = that.options.value;
	                that._randomId = util.randomId();
	                that.setOptions(that.options);
	                that._layout();
	                that._dataSource();
	                that.enable(that.options.enable);
	            },
	
	            /**
	             * Diplay modes
	             */
	            modes: {
	                button: MODES.BUTTON,
	                dropdown: MODES.DROPDOWN,
	                radio: MODES.RADIO
	            },
	
	            /**
	             * Widget options
	             */
	            options: {
	                name: 'Quiz',
	                autoBind: true,
	                dataSource: [],
	                mode: MODES.BUTTON,
	                itemStyle: {},
	                selectedStyle: {},
	                value: null,
	                enable: true,
	                messages: {
	                    optionLabel: 'Select...'
	                }
	            },
	
	            /**
	             *
	             * @param options
	             */
	            setOptions: function (options) {
	                var that = this;
	                Widget.fn.setOptions.call(that, options);
	                options = that.options;
	                options.groupStyle = util.formatStyle(options.groupStyle);
	                options.itemStyle = util.formatStyle(options.itemStyle);
	                if (options.mode === MODES.BUTTON) {
	                    // Add default space between buttons
	                    options.itemStyle = $.extend({ marginRight: MARGIN, marginBottom: MARGIN }, options.itemStyle);
	                }
	                options.selectedStyle = util.formatStyle(options.selectedStyle);
	            },
	
	            /**
	             * Widget events
	             */
	            events: [
	                CHANGE
	            ],
	
	            /**
	             * Gets/sets the value
	             * @param value
	             */
	            value: function (value) {
	                var that = this;
	                if ($.type(value) === STRING) {
	                    // Note: Giving a value to the dropDownList that does not exist in dataSource is discarded without raising an error
	                    if (that._value !== value && that.dataSource instanceof kendo.data.DataSource && that.dataSource.data().indexOf(value) > -1) {
	                        that._value = value;
	                        that._toggleUI();
	                        // that.trigger(CHANGE);
	                    }
	                } else if (value === null) {
	                    if (that._value !== value) {
	                        that._value = null;
	                        that._toggleUI();
	                        // that.trigger(CHANGE);
	                    }
	                } else if ($.type(value) === 'undefined') {
	                    return that._value;
	                } else {
	                    throw new TypeError('`value` is expected to be a string if not undefined');
	                }
	            },
	
	            /**
	             * Widget layout
	             * @private
	             */
	            _layout: function () {
	                var that = this;
	                that.wrapper = that.element;
	                that.element
	                    .addClass(WIDGET_CLASS);
	                if (that.options.mode === MODES.DROPDOWN) {
	                    that._layoutDropDown();
	                }
	                // refresh updates buttons and radios
	            },
	
	            /**
	             * Widget layout as dropdown list
	             * @private
	             */
	            _layoutDropDown: function () {
	                var that = this;
	                that.dropDownList = $('<input>')
	                    .width('100%')
	                    .appendTo(that.element)
	                    .kendoDropDownList({
	                        autoBind: that.options.autoBind,
	                        change: $.proxy(that._onDropDownListChange, that), // change is not triggered by dropDownList api calls incl. value(), text(), ...
	                        open: $.proxy(that._onDropDownListOpen, that),
	                        dataSource: that.options.dataSource,
	                        optionLabel: that.options.messages.optionLabel,
	                        value: that.options.value,
	                        height: 400
	                        // valuePrimitive: true
	                    })
	                    .data('kendoDropDownList');
	            },
	
	            /**
	             * Event handler triggered when changing the value of the drop down list in the header
	             * @private
	             */
	            _onDropDownListChange: function () {
	                var that = this;
	                assert.instanceof(kendo.ui.DropDownList, that.dropDownList, kendo.format(assert.messages.instanceof.default, 'this.dropDownList', 'kendo.ui.DropDownList'));
	                var value = that.dropDownList.value();
	                if ($.type(value) === STRING && value.length) {
	                    that._value = value;
	                } else {
	                    that._value = null;
	                }
	                that.trigger(CHANGE, { value: this._value });
	            },
	
	            /**
	             * Event handler triggered when opening the popup list
	             * @param e
	             * @private
	             */
	            _onDropDownListOpen: function (e) {
	                var that = this;
	                // We need to scale the popup
	                var scaler = that.element.closest('.kj-stage');
	                var scale = util.getTransformScale(scaler);
	                var width = that.element.width();
	                var height = that.element.height();
	                var fontSize = parseInt(that.element.css('font-size'), 10);
	                var popup = that.dropDownList.popup;
	                popup.element
	                    .css({
	                        fontSize: Math.floor(fontSize * scale) + 'px',
	                        minWidth: Math.floor(width * scale) + 'px',
	                        width: Math.floor(width * scale) + 'px'
	                    });
	                // And reposition the popup
	                // popup.one('open', function () { // the popup is already opened so the open event won't fire
	                // popup.one('activate', function () { // activate is only triggered at the end of the open animation which flickers in FF
	                setTimeout(function () {
	                    var element = that.element.closest('.kj-element');
	                    if (scaler.length && element.length) {
	                        var top = element.position().top + scaler.offset().top;
	                        var popupTop = popup.wrapper.position().top;
	                        if (popupTop > top) {
	                            popup.wrapper.css('top', popupTop + (scale - 1) * height);
	                        }
	                    }
	                }, 0);
	            },
	
	            /**
	             * Event handler for click event and radios and buttons
	             * Handles
	             * @param e
	             * @private
	             */
	            _onClick: function (e) {
	                assert.instanceof($.Event, e, kendo.format(assert.messages.instanceof.default, 'e', 'jQuery.Event'));
	                var that = this;
	                var target = $(e.target);
	                var value = target.val();
	                if (value !== that._value) {
	                    that._value = value;
	                } else { // clicking the same value resets the button (and value)
	                    that._value = null;
	                }
	                that._toggleUI();
	                that.trigger(CHANGE, { value: that._value });
	            },
	
	            /**
	             * Update UI when value is changed
	             * @private
	             */
	            _toggleUI: function () {
	                var that = this;
	                var element = this.element;
	                assert.instanceof($, element, kendo.format(assert.messages.instanceof.default, 'this.element', 'jQuery'));
	                switch (that.options.mode) {
	                    case MODES.BUTTON:
	                        element.find(BUTTON_SELECTOR)
	                            .removeClass(ACTIVE)
	                            .attr('style', '')
	                            .css(that.options.itemStyle);
	                        if (that._value) {
	                            element.find(BUTTON_SELECTOR + '[value="' + that._value + '"]')
	                                .addClass(ACTIVE)
	                                .attr('style', '')
	                                .css($.extend({}, that.options.itemStyle, that.options.selectedStyle));
	                        }
	                        break;
	                    case MODES.DROPDOWN:
	                        assert.instanceof(kendo.ui.DropDownList, that.dropDownList, kendo.format(assert.messages.instanceof.default, 'this.dropDownList', 'kendo.ui.DropDownList'));
	                        that.dropDownList.text(that._value);
	                        break;
	                    // case MODES.RADIO:
	                    default:
	                        element.children('div')
	                            .attr('style', '')
	                            .css(that.options.itemStyle);
	                        if (that._value) {
	                            element.find(RADIO_SELECTOR + '[value="' + that._value + '"]')
	                                .prop(CHECKED, true)
	                                .parent()
	                                    .attr('style', '')
	                                    .css($.extend({}, that.options.itemStyle, that.options.selectedStyle));
	                        } else {
	                            element.find(RADIO_SELECTOR + ':checked')
	                                .prop(CHECKED, false);
	                        }
	                        break;
	                }
	            },
	
	            /**
	             * _dataSource function to bind refresh to the change event
	             * @private
	             */
	            _dataSource: function () {
	                var that = this;
	
	                // returns the datasource OR creates one if using array or configuration
	                that.dataSource = kendo.data.DataSource.create(that.options.dataSource);
	
	                // bind to the change event to refresh the widget
	                if (that._refreshHandler) {
	                    that.dataSource.unbind(CHANGE, that._refreshHandler);
	                }
	                that._refreshHandler = $.proxy(that.refresh, that);
	                that.dataSource.bind(CHANGE, that._refreshHandler);
	
	                // Assign dataSource to dropDownList
	                var dropDownList = that.dropDownList;
	                if (dropDownList instanceof kendo.ui.DropDownList && dropDownList.dataSource !== that.dataSource) {
	                    dropDownList.setDataSource(that.dataSource);
	                }
	
	                // trigger a read on the dataSource if one hasn't happened yet
	                if (that.options.autoBind) {
	                    that.dataSource.fetch();
	                }
	            },
	
	            /**
	             * sets the dataSource for source binding
	             * @param dataSource
	             */
	            setDataSource: function (dataSource) {
	                var that = this;
	                // set the internal datasource equal to the one passed in by MVVM
	                that.options.dataSource = dataSource;
	                // rebuild the datasource if necessary, or just reassign
	                that._dataSource();
	            },
	
	            /**
	             * Refresh method (called when dataSource is updated)
	             * for example to add buttons or options
	             * @param e
	             */
	            refresh: function (e) {
	                var that = this;
	                var element = this.element;
	                assert.instanceof($, element, kendo.format(assert.messages.instanceof.default, 'this.element', 'jQuery'));
	                if (that.options.mode === MODES.DROPDOWN) {
	                    assert.instanceof(kendo.ui.DropDownList, that.dropDownList, kendo.format(assert.messages.instanceof.default, 'that.dropDownList', 'kendo.ui.DropDownList'));
	                    that.dropDownList.refresh(e);
	                } else {
	                    var items = that.dataSource.data();
	                    if (e && e.items instanceof kendo.data.ObservableArray) {
	                        items = e.items;
	                    }
	                    // Note: we only add elements here (not modify or remove depending on e.action) and we might have to improve
	                    that.element.empty();
	                    $(items).each(function (index, item) {
	                        if (that.options.mode === MODES.BUTTON) {
	                            $(kendo.format(BUTTON, kendo.htmlEncode(item)))
	                                .css(that.options.itemStyle)
	                                .appendTo(that.element);
	                        } else if (that.options.mode === MODES.RADIO) {
	                            var radio = $(kendo.format(RADIO, kendo.htmlEncode(item), that._randomId, index))
	                                .css(that.options.itemStyle)
	                                .appendTo(that.element);
	                        }
	                    });
	                }
	                // Get rid of value if there is no more a match in the dataSource
	                if (that.dataSource.data().indexOf(that._value) === -1) {
	                    that._value = null;
	                    that.trigger(CHANGE, { value: that._value });
	                }
	            },
	
	            /**
	             * Enable/disable the widget
	             * @param enable
	             */
	            enable: function (enable) {
	                var that = this;
	                var element = this.element;
	                assert.instanceof($, element, kendo.format(assert.messages.instanceof.default, 'this.element', 'jQuery'));
	                if ($.type(enable) === UNDEFINED) {
	                    enable = true;
	                }
	                if (that.options.mode === MODES.DROPDOWN) {
	                    assert.instanceof(kendo.ui.DropDownList, that.dropDownList, kendo.format(assert.messages.instanceof.default, 'that.dropDownList', 'kendo.ui.DropDownList'));
	                    that.dropDownList.enable(enable);
	                } else {
	                    element.off(NS);
	                    if (enable) {
	                        element.on(CLICK + NS, INPUT_SELECTOR, $.proxy(that._onClick, that));
	                    } else {
	                        // Because input are readonly and not disabled, we need to prevent default (checking checkbox) and let it bubble to the stage element to display the handle box
	                        element.on(CLICK + NS, INPUT_SELECTOR, function (e) {
	                            e.preventDefault();
	                        });
	                    }
	                    element.find(INPUT_SELECTOR)
	                        .toggleClass(DISABLE, !enable)
	                        // .prop('disabled', !enable) <--- suppresses the click event so elements are no more selectable in design mode
	                        .prop('readonly', !enable);
	                }
	            },
	
	            /**
	             * Destroy widget
	             */
	            destroy: function () {
	                var that = this;
	                var element = this.element;
	                Widget.fn.destroy.call(that);
	                // Destroy the drop down list (especially the popup)
	                if (that.dropDownList) {
	                    that.dropDownList.destroy();
	                    that.dropDownList = undefined;
	                }
	                // unbind and destroy kendo
	                kendo.unbind(element);
	                kendo.destroy(element);
	                // unbind all other events
	                that.element.find('*').off();
	                that.element.off(NS);
	                // remove descendants
	                that.element.empty();
	                // remove element classes
	                that.element.removeClass(WIDGET_CLASS);
	            }
	
	        });
	
	        ui.plugin(Quiz);
	
	    })(window.jQuery);
	
	    /* jshint +W071 */
	
	    return window.kendo;
	
	}, __webpack_require__(200));


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(207)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    // TODO: check touch interfaces
	    // TODO: Add tooltip with value and/or description
	    // TODO: Display half stars
	    // TODO: Should we bind to the DOM change event to be notified when input value changes?????
	    // TODO: https://developers.google.com/structured-data/rich-snippets/reviews
	
	    (function ($, undefined) {
	
	        // shorten references to variables for uglification
	        // var fn = Function;
	        // var global = fn('return this')();
	        var kendo = window.kendo;
	        var ui = kendo.ui;
	        var Widget = ui.Widget;
	        // var assert = window.assert,
	        var logger = new window.Logger('kidoju.widgets.rating');
	        var NUMBER = 'number';
	        var STAR = 'star';
	        var STAR_P = '&#x2605;';
	        var STAR_O = '&#x2606;';
	        var STAR_SELECTOR = 'span.kj-rating-star';
	        var STATE_HOVER = 'k-state-hover';
	        var STATE_SELECTED = 'k-state-selected';
	        var STATE_DISABLED = 'k-state-disabled';
	        var RATING_MIN = 0;
	        var RATING_MAX = 5;
	        var RATING_STEP = 1;
	        var PRECISION = 3;
	        var NS = '.kendoRating';
	        var CLICK = 'click' + NS;
	        var MOUSEENTER = 'mouseenter';
	        var MOUSELEAVE = 'mouseleave';
	        var HOVEREVENTS = MOUSEENTER + NS + ' ' + MOUSELEAVE + NS;
	        var CHANGE = 'change';
	
	        /*********************************************************************************
	         * Helpers
	         *********************************************************************************/
	
	        /**
	         * rounding numbers for the star rating widget
	         * @method round
	         * @param value {Number}
	         * @return {Number}
	         */
	        function round(value) {
	            value = parseFloat(value);
	            var power = Math.pow(10, PRECISION || 0);
	            return Math.round(value * power) / power;
	        }
	
	        /*******************************************************************************************
	         * Rating
	         * SEE: http://css-tricks.com/star-ratings/
	         * SEE: http://www.fyneworks.com/jquery/star-rating/
	         * SEE: http://www.enfew.com/5-best-jquery-star-rating-plugins-tutorials/
	         *******************************************************************************************/
	
	        /**
	         * Rating (kendoRating)
	         * @class Rating
	         * @extend Widget
	         */
	        var Rating = Widget.extend({
	
	            /**
	             * Initializes the widget
	             * @method init
	             * @param element
	             * @param options
	             */
	            init: function (element, options) {
	                var that = this;
	                var input = $(element);
	                input.type = NUMBER;
	                that.ns = NS;
	                options = $.extend({
	                    value: parseFloat(input.attr('value') || RATING_MIN),
	                    min: parseFloat(input.attr('min') || RATING_MIN),
	                    max: parseFloat(input.attr('max') || RATING_MAX),
	                    step: parseFloat(input.attr('step') || RATING_STEP),
	                    disabled: input.prop('disabled'),
	                    readonly: input.prop('readonly')
	                }, options);
	                Widget.fn.init.call(that, element, options);
	                logger.debug('widget initialized');
	                that._layout();
	                that.value(options.value);
	                that.refresh();
	                kendo.notify(that);
	            },
	
	            /**
	             * Widget events
	             * @property events
	             */
	            events: [
	                CHANGE // Changing the rating value by clicking a star raises the change event
	            ],
	
	            /**
	             * Widget options
	             * @property options
	             */
	            options: {
	                name: 'Rating',
	                value: RATING_MIN,
	                min: RATING_MIN,
	                max: RATING_MAX,
	                step: RATING_STEP
	            },
	
	            /**
	             * Gets a sets the rating value
	             * @method value
	             * @param value
	             * @return {*}
	             */
	            value: function (value) {
	                var that = this;
	                var input = that.element;
	                var options = that.options;
	                value = parseFloat(value);
	                if (isNaN(value)) {
	                    return parseFloat(input.val());
	                } else if (value >= options.min && value <= options.max) {
	                    if (parseFloat(input.val()) !== value) {
	                        // update input element
	                        input.val(value);
	                        // also trigger the DOM change event so any subscriber gets notified
	                        // http://stackoverflow.com/questions/4672505/why-does-the-jquery-change-event-not-trigger-when-i-set-the-value-of-a-select-us
	                        input.trigger(CHANGE + NS);
	                    }
	                } else {
	                    throw new RangeError(kendo.format('Expecting a number between {0} and {1}', options.min, options.max));
	                }
	            },
	
	            /**
	             * Builds the widget layout
	             * @method _layout
	             * @private
	             */
	            _layout: function () {
	                var that = this;
	                var input = that.element;
	                var options = that.options;
	                that._clear();
	                input.wrap('<span class="kj-rating"/>');
	                input.hide();
	                input.on(CHANGE + NS, function () {
	                    // update widget
	                    that.refresh();
	                    that.trigger(CHANGE, { value: parseFloat(input.val()) });
	                });
	                // We need that.wrapper for visible/invisible bindings
	                that.wrapper = input.parent();
	                // Calculate the number of stars
	                var n = round((options.max - options.min) / options.step);  // number of stars
	                // Add stars to the DOM
	                for (var i = 1; i <= n; i++) {
	                    that.wrapper.append(kendo.format('<span class="kj-rating-star" data-star="{0}">{1}</span>', i, STAR_O));
	                }
	                // Make (non)editable
	                that._editable(options);
	            },
	
	            /**
	             * Toggles between enabled and readonly modes
	             * @private
	             */
	            _editable: function (options) {
	                var that = this;
	                var disabled = options.disabled;
	                var readonly = options.readonly;
	                var wrapper = that.wrapper;
	                wrapper.find(STAR_SELECTOR).off(NS);
	                if (!readonly && !disabled) {
	                    wrapper.removeClass(STATE_DISABLED);
	                    wrapper.find(STAR_SELECTOR)
	                        .on(HOVEREVENTS, $.proxy(that._toggleHover, that))
	                        .on(CLICK, $.proxy(that._onStarClick, that));
	                } else {
	                    wrapper.addClass(STATE_DISABLED);
	                }
	            },
	
	            /**
	             * Function called by the enabled/disabled bindings
	             * @param enable
	             */
	            enable: function (enable) {
	                this._editable({
	                    readonly: false,
	                    disabled: !(enable = enable === undefined ? true : enable)
	                });
	            },
	
	            /**
	             * Make the widget readonly
	             * @param readonly
	             */
	            /*
	            readonly: function (readonly) {
	                this._editable({
	                    readonly: readonly === undefined ? true : readonly,
	                    disable: false
	                });
	            },
	            */
	
	            /**
	             * Refreshes the widget
	             * @method refresh
	             */
	            refresh: function () {
	                var that = this;
	                var options = that.options;
	                if (that.wrapper) {
	                    var i = round((that.value() - options.min) / options.step);
	                    $.each(that.wrapper.find(STAR_SELECTOR), function (index, element) {
	                        var star = $(element);
	                        if (parseFloat(star.attr(kendo.attr(STAR))) <= i) {
	                            star.html(STAR_P).addClass(STATE_SELECTED);
	                        } else {
	                            star.html(STAR_O).removeClass(STATE_SELECTED);
	                        }
	                    });
	                }
	            },
	
	            /**
	             * Event handler for clicking/tapping a star
	             * @param e
	             * @private
	             */
	            _onStarClick: function (e) {
	                var that = this;
	                var options = that.options;
	                var i = parseFloat($(e.currentTarget).attr(kendo.attr(STAR)));
	                var value = options.min + i * options.step;
	                e.preventDefault();
	                that.value(value);
	            },
	
	            /**
	             * EVent handler for hovering stars
	             * @param e
	             * @private
	             */
	            _toggleHover: function (e) {
	                var that = this;
	                var i = parseFloat($(e.currentTarget).attr(kendo.attr(STAR)));
	                $.each(that.wrapper.find(STAR_SELECTOR), function (index, element) {
	                    var star = $(element);
	                    if (e.type === MOUSEENTER && parseFloat(star.attr(kendo.attr(STAR))) <= i) {
	                        star.html(STAR_P).addClass(STATE_HOVER);
	                    } else {
	                        star.html(star.hasClass(STATE_SELECTED) ? STAR_P : STAR_O).removeClass(STATE_HOVER);
	                    }
	                });
	            },
	
	            /**
	             * Clears the DOM from modifications made by the widget
	             * @method _clear
	             * @private
	             */
	            _clear: function () {
	                var that = this;
	                var input = that.element;
	                // remove wrapper and stars
	                if (that.wrapper) {
	                    that.wrapper.find(STAR_SELECTOR).off(NS).remove();
	                    input.unwrap();
	                    input.off(NS);
	                    delete that.wrapper;
	                    input.show();
	                }
	            },
	
	            /**
	             * Destroys the widget
	             * @method destroy
	             */
	            destroy: function () {
	                var that = this;
	                that._clear();
	                Widget.fn.destroy.call(this);
	            }
	        });
	
	        ui.plugin(Rating);
	
	    } (window.jQuery));
	
	    return window.kendo;
	
	}, __webpack_require__(200));


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(207),
	        __webpack_require__(233),
	        __webpack_require__(234)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    /* This function has too many statements. */
	    /* jshint -W071 */
	
	    (function ($, undefined) {
	
	        var kendo = window.kendo;
	        var ui = kendo.ui;
	        var Widget = ui.Widget;
	        var data = kendo.data;
	        var binders = data.binders;
	        var Binder = data.Binder;
	        var ObservableObject = data.ObservableObject;
	        var ObservableArray = data.ObservableArray;
	        var kidoju = window.kidoju;
	        var Tool = kidoju.Tool;
	        var PageComponent = kidoju.data.PageComponent;
	        var PageComponentCollectionDataSource = kidoju.data.PageComponentCollectionDataSource;
	        var assert = window.assert;
	        var logger = new window.Logger('kidoju.widgets.stage');
	        var STRING = 'string';
	        var NUMBER = 'number';
	        var NULL = null;
	        var UNDEFINED = 'undefined';
	        var NS = '.kendoStage';
	        var MOUSEDOWN = 'mousedown' + NS + ' touchstart' + NS;
	        var MOUSEMOVE = 'mousemove' + NS + ' touchmove' + NS;
	        var MOUSEUP = 'mouseup' + NS + ' touchend' + NS;
	        var CHANGE = 'change';
	        var DATABINDING = 'dataBinding';
	        var DATABOUND = 'dataBound';
	        var PROPERTYBINDING = 'propertyBinding';
	        var PROPERTYBOUND = 'propertyBound';
	        var SELECT = 'select';
	        // var ENABLE = 'enable';
	        var MOVE = 'move';
	        var RESIZE = 'resize';
	        var ROTATE = 'rotate'; // This constant is not simply an event
	        var ABSOLUTE = 'absolute';
	        var RELATIVE = 'relative';
	        var HIDDEN = 'hidden';
	        var DISPLAY = 'display';
	        var BLOCK = 'block';
	        var NONE = 'none';
	        var TOP = 'top';
	        var LEFT = 'left';
	        var HEIGHT = 'height';
	        var WIDTH = 'width';
	        var CURSOR = 'cursor';
	        var TRANSFORM = 'transform';
	        var CSS_ROTATE = 'rotate({0}deg)';
	        var CSS_SCALE = 'scale({0})';
	        var DATA_UID = kendo.attr('uid');
	        var DATA_TOOL = kendo.attr('tool');
	        var DATA_COMMAND = kendo.attr('command');
	        var DOT = '.';
	        var DIV = '<div />';
	        var DIV_W_CLASS = '<div class="{0}"></div>';
	        var WIDGET_CLASS = 'k-widget kj-stage';
	        var WRAPPER = kendo.format(DIV_W_CLASS, WIDGET_CLASS);
	        var ELEMENT_CLASS = 'kj-element';
	        var ELEMENT = '<div ' + DATA_UID + '="{0}" ' + DATA_TOOL + '="{1}" class="' + ELEMENT_CLASS + '"></div>';
	        var ELEMENT_SELECTOR = DOT + ELEMENT_CLASS + '[' + DATA_UID + '="{0}"]';
	        var OVERLAY_CLASS = 'kj-overlay';
	        var HANDLE_BOX_CLASS = 'kj-handle-box';
	        var HANDLE_BOX = kendo.format(DIV_W_CLASS, HANDLE_BOX_CLASS);
	        var HANDLE_BOX_SELECTOR = DOT + HANDLE_BOX_CLASS + '[' + DATA_UID + '="{0}"]';
	        var HANDLE_CLASS = 'kj-handle';
	        // Note: without touch-action: none, touch gestures won't work in Internet Explorer
	        var HANDLE_MOVE = '<span class="' + HANDLE_CLASS + '" ' + DATA_COMMAND + '="move" style="touch-action:none;"></span>';
	        var HANDLE_RESIZE = '<span class="' + HANDLE_CLASS + '" ' + DATA_COMMAND + '="resize" style="touch-action:none;"></span>';
	        var HANDLE_ROTATE = '<span class="' + HANDLE_CLASS + '" ' + DATA_COMMAND + '="rotate" style="touch-action:none;"></span>';
	        var HANDLE_MENU = '<span class="' + HANDLE_CLASS + '" ' + DATA_COMMAND + '="menu" style="touch-action:none;"></span>';
	        // var HANDLE_SELECTOR = '.kj-handle[' + DATA_COMMAND + '="{0}"]';
	        var NOPAGE_CLASS = 'kj-nopage';
	        var STATE = 'state';
	        var COMMANDS = {
	                MOVE: 'move',
	                RESIZE: 'resize',
	                ROTATE: 'rotate',
	                MENU: 'menu'
	            };
	        var POINTER = 'pointer';
	        var ACTIVE_TOOL = 'active';
	        var DEFAULTS = {
	                MODE: 'play',
	                SCALE: 1,
	                WIDTH: 1024,
	                HEIGHT: 768
	            };
	        var DEBUG_MOUSE_CLASS = 'debug-mouse';
	        var DEBUG_MOUSE_DIV = kendo.format(DIV_W_CLASS, DEBUG_MOUSE_CLASS);
	        var DEBUG_BOUNDS_CLASS = 'debug-bounds';
	        var DEBUG_BOUNDS = kendo.format(DIV_W_CLASS, DEBUG_BOUNDS_CLASS);
	        var DEBUG_CENTER_CLASS = 'debug-center';
	        var DEBUG_CENTER = '<div class="debug-center"></div>';
	
	
	        /*********************************************************************************
	         * Custom Bindings
	         *********************************************************************************/
	
	        /**
	         * Enable binding the properties value of a Stage widget
	         * @type {*|void}
	         */
	        binders.widget.properties = Binder.extend({
	            init: function (widget, bindings, options) {
	                Binder.fn.init.call(this, widget.element[0], bindings, options);
	                this.widget = widget;
	                this._change = $.proxy(this.change, this);
	                this.widget.bind(CHANGE, this._change);
	            },
	            change: function () {
	                this.bindings.properties.set(this.widget.properties());
	            },
	            refresh: function () {
	                this.widget.properties(this.bindings.properties.get());
	            },
	            destroy: function () {
	                this.widget.unbind(CHANGE, this._change);
	            }
	        });
	
	        /*********************************************************************************
	         * Widget
	         *********************************************************************************/
	
	        /**
	         * @class Stage Widget (kendoStage)
	         */
	        var Stage = Widget.extend({
	
	            /**
	             * Initializes the widget
	             * @param element
	             * @param options
	             */
	            init: function (element, options) {
	                var that = this;
	                Widget.fn.init.call(that, element, options);
	                logger.debug('widget initialized');
	                // TODO: we need to read scale, height and width both from styles and options and decide which wins
	                this._mode = this.options.mode;
	                this._scale = this.options.scale;
	                this._height = this.options.height;
	                this._width = this.options.width;
	                this._disabled = this.options.disabled;
	                this._readonly = this.options.readonly;
	                this._snapAngle = this.options.snapAngle;
	                this._snapGrid = this.options.snapGrid;
	                that._layout();
	                that._dataSource();
	                kendo.notify(that);
	            },
	
	            /**
	             * Widget modes
	             */
	            modes: {
	                design: 'design',
	                play: 'play',
	                review: 'review'
	            },
	
	            /**
	             * Widget events
	             */
	            events: [
	                CHANGE,
	                DATABINDING,
	                DATABOUND,
	                PROPERTYBINDING,
	                PROPERTYBOUND,
	                SELECT
	            ],
	
	            /**
	             * Widget options
	             */
	            options: {
	                name: 'Stage',
	                autoBind: true,
	                mode: DEFAULTS.MODE,
	                scale: DEFAULTS.SCALE,
	                height: DEFAULTS.HEIGHT,
	                width: DEFAULTS.WIDTH,
	                tools: kidoju.tools,
	                dataSource: undefined,
	                disabled: false,
	                readonly: false,
	                snapAngle: 0,
	                snapGrid: 0,
	                messages: {
	                    contextMenu: {
	                        delete: 'Delete',
	                        duplicate: 'Duplicate'
	                    },
	                    noPage: 'Please add or select a page'
	                }
	            },
	
	            /**
	             * @method setOptions
	             * @param options
	             */
	            /*
	            setOptions: function (options) {
	                // setOptions is called by value bindings
	                Widget.fn.setOptions.call(this, options);
	            },
	            */
	
	            /**
	             * Mode defines the operating mode of the Stage Widget
	             * @param value
	             * @return {*}
	             */
	            mode: function (value) {
	                var that = this;
	                if ($.type(value) !== UNDEFINED) {
	                    assert.type(STRING, value, kendo.format(assert.messages.type.default, 'value', STRING));
	                    if ($.type(that.modes[value]) === UNDEFINED) {
	                        throw new RangeError();
	                    }
	                    if (value !== that._mode) {
	                        that._mode = value;
	                        that._initializeMode();
	                        that.refresh();
	                    }
	                }
	                else {
	                    return that._mode;
	                }
	            },
	
	            /**
	             * Scale the widget
	             * @param value
	             * @return {*}
	             */
	            scale: function (value) {
	                var that = this;
	                if (value !== undefined) {
	                    if ($.type(value) !== NUMBER) {
	                        throw new TypeError();
	                    }
	                    if (value < 0) {
	                        throw new RangeError();
	                    }
	                    if (value !== that._scale) { // TODO: that.options.scale
	                        that._scale = value;
	                        that.wrapper.css({
	                            transformOrigin: '0 0',
	                            transform: kendo.format(CSS_SCALE, that._scale)
	                        });
	                        that.wrapper.find(DOT + HANDLE_CLASS).css({
	                            // transformOrigin: 'center center', // by default
	                            transform: kendo.format(CSS_SCALE, 1 / that._scale)
	                        });
	                        /*
	                        // Scaling the message does not work very well so we have simply increased the font-size
	                        that.element.find(DOT + NOPAGE_CLASS).css({
	                            // transformOrigin: 'center center', // by default
	                            transform: kendo.format(CSS_SCALE, 1 / that._scale)
	                        });
	                        */
	                    }
	                }
	                else {
	                    return that._scale;
	                }
	            },
	
	            /**
	             * Height of stage
	             * @param value
	             * @returns {string}
	             */
	            height: function (value) {
	                var that = this;
	                if (value) {
	                    if ($.type(value) !== NUMBER) {
	                        throw new TypeError();
	                    }
	                    if (value < 0) {
	                        throw new RangeError();
	                    }
	                    if (value !== that._height) {
	                        that._height = value;
	                    }
	                }
	                else {
	                    return that._height;
	                }
	            },
	
	            /**
	             * Width of stage
	             * @param value
	             * @returns {string}
	             */
	            width: function (value) {
	                var that = this;
	                if (value) {
	                    if ($.type(value) !== NUMBER) {
	                        throw new TypeError();
	                    }
	                    if (value < 0) {
	                        throw new RangeError();
	                    }
	                    if (value !== that._width) {
	                        that._width = value;
	                    }
	                }
	                else {
	                    return that._width;
	                }
	            },
	
	            /**
	             * IMPORTANT: index is 0 based
	             * @method index
	             * @param index
	             * @returns {*}
	             */
	            index: function (index) {
	                var that = this;
	                var component;
	                if (index !== undefined) {
	                    if ($.type(index) !== NUMBER || index % 1 !== 0) {
	                        throw new TypeError();
	                    } else if (index < 0 || (index > 0 && index >= that.length())) {
	                        throw new RangeError();
	                    } else {
	                        component = that.dataSource.at(index);
	                        that.value(component);
	                    }
	                } else {
	                    component = that.dataSource.getByUid(that._selectedUid);
	                    if (component instanceof PageComponent) {
	                        return that.dataSource.indexOf(component);
	                    } else {
	                        return -1;
	                    }
	                }
	            },
	
	            /**
	             * @method id
	             * @param id
	             * @returns {*}
	             */
	            id: function (id) {
	                var that = this;
	                var component;
	                if (id !== undefined) {
	                    if ($.type(id) !== NUMBER && $.type(id) !== STRING) {
	                        throw new TypeError();
	                    }
	                    component = that.dataSource.get(id);
	                    that.value(component);
	                } else {
	                    component = that.dataSource.getByUid(that._selectedUid);
	                    if (component instanceof PageComponent) {
	                        return component[component.idField];
	                    }
	                }
	            },
	
	            /* This function's cyclomatic complexity is too high. */
	            /* jshint -W074 */
	
	            /**
	             * Gets/Sets the value of the selected component in the explorer
	             * @method value
	             * @param component
	             * @returns {*}
	             */
	            value: function (component) {
	                var that = this;
	                if (component === NULL) {
	                    if (that._selectedUid !== NULL) {
	                        that._selectedUid = NULL;
	                        logger.debug('selected component uid set to null');
	                        that._toggleSelection();
	                        that.trigger(CHANGE, {
	                            index: undefined,
	                            value: NULL
	                        });
	                    }
	                } else if (component !== undefined) {
	                    if (!(component instanceof PageComponent)) {
	                        throw new TypeError();
	                    }
	                    // Note: when that.value() was previously named that.selection() with a custom binding
	                    // the selection binding was executed before the source binding so we had to record the selected component
	                    // in a temp variable (that._tmp) and assign it to the _selectedUid in the refresh method,
	                    // that is after the source was bound.
	                    // The corresponding code has now been removed after renaming that.selection() into that.value()
	                    // because the value binding is executed after the source binding.
	                    if (component.uid !== that._selectedUid && util.isGuid(component.uid)) {
	                        var index = that.dataSource.indexOf(component);
	                        if (index > -1) {
	                            that._selectedUid = component.uid;
	                            logger.debug('selected component uid set to ' + component.uid);
	                            that._toggleSelection();
	                            that.trigger(CHANGE, {
	                                index: index,
	                                value: component
	                            });
	                        }
	                    }
	                } else {
	                    if (that._selectedUid === NULL) {
	                        return NULL;
	                    } else {
	                        return that.dataSource.getByUid(that._selectedUid); // Returns undefined if not found
	                    }
	                }
	            },
	
	            /* jshint +W074 */
	
	            /**
	             * @method total()
	             * @returns {*}
	             */
	            length: function () {
	                return (this.dataSource instanceof PageComponentCollectionDataSource) ? this.dataSource.total() : -1;
	            },
	
	            /**
	             * Properties
	             * @param value
	             * @returns {*}
	             */
	            properties: function (value) {
	                var that = this;
	                if (value) {
	                    // if (!(value instanceof ObervableObject)) {
	                    //    throw new TypeError();
	                    // }
	                    if (value !== that._properties) {
	                        that._properties = value;
	                    }
	                }
	                else {
	                    return that._properties;
	                }
	            },
	
	            /**
	             * Get/set snap angle
	             * @param snapValue
	             */
	            snapAngle: function (snapValue) {
	                if ($.type(snapValue) === UNDEFINED) {
	                    return this._snapAngle;
	                } else if ($.type(snapValue) === NUMBER) {
	                    this._snapAngle = snapValue;
	                } else {
	                    throw new TypeError('Snap angle value should be a number');
	                }
	            },
	
	            /**
	             * Get/set snap grid
	             * @param snapValue
	             */
	            snapGrid: function (snapValue) {
	                if ($.type(snapValue) === UNDEFINED) {
	                    return this._snapGrid;
	                } else if ($.type(snapValue) === NUMBER) {
	                    this._snapGrid = snapValue;
	                } else {
	                    throw new TypeError('Snap grid value should be a number');
	                }
	            },
	
	            /**
	             * Changes the dataSource
	             * @method setDataSource
	             * @param dataSource
	             */
	            setDataSource: function (dataSource) {
	                // set the internal data source equal to the one passed in by MVVM
	                this.options.dataSource = dataSource;
	                // rebuild the datasource if necessary, or just reassign
	                this._dataSource();
	            },
	
	            /**
	             * Binds the widget to the change event of the dataSource
	             * See http://docs.telerik.com/kendo-ui/howto/create-custom-kendo-widget
	             * @method _dataSource
	             * @private
	             */
	            _dataSource: function () {
	                var that = this;
	                // if the DataSource is defined and the _refreshHandler is wired up, unbind because
	                // we need to rebuild the DataSource
	
	                // There is no reason why, in its current state, it would not work with any dataSource
	                // if ( that.dataSource instanceof DataSource && that._refreshHandler ) {
	                if (that.dataSource instanceof PageComponentCollectionDataSource && that._refreshHandler) {
	                    that.dataSource.unbind(CHANGE, that._refreshHandler);
	                }
	
	                that._initializeMode();
	
	                if (that.options.dataSource !== NULL) {  // use null to explicitly destroy the dataSource bindings
	
	                    // returns the datasource OR creates one if using array or configuration object
	                    that.dataSource = PageComponentCollectionDataSource.create(that.options.dataSource);
	
	                    that._refreshHandler = $.proxy(that.refresh, that);
	
	                    // bind to the change event to refresh the widget
	                    that.dataSource.bind(CHANGE, that._refreshHandler);
	
	                    if (that.options.autoBind) {
	                        that.dataSource.fetch();
	                    }
	                }
	            },
	
	            /**
	             * Builds the widget layout
	             * @private
	             */
	            _layout: function () {
	                var that = this;
	
	                // Set that.stage from the div element that makes the widget
	                that.stage = that.element
	                    .wrap(WRAPPER)
	                    .css({
	                        position: RELATIVE,  // !important
	                        overflow: HIDDEN,
	                        height: that.height(),
	                        width: that.width()
	                    });
	
	                // We need that.wrapper for visible/invisible bindings
	                that.wrapper = that.stage.parent()
	                    .css({
	                        position: RELATIVE,  // !important
	                        height: that.height(),
	                        width: that.width(),
	                        transformOrigin: '0 0', // 'top left', // !important without such attribute, element top left calculations are wrong
	                        transform: kendo.format(CSS_SCALE, that.scale())
	                    });
	            },
	
	            /**
	             * Initialize mode
	             * @private
	             */
	            _initializeMode: function () {
	
	                var that = this;
	                var modes = that.modes;
	                var dataSource = that.options.dataSource;
	
	                // Set mode
	                that._toggleNoPageMessage(!dataSource);
	                var readOnlyOverlay = !dataSource || that._disabled || that._readonly;
	                that._toggleReadOnlyOverlay(readOnlyOverlay);
	                var bindUserEntries = !!dataSource && that.mode() !== modes.design;
	                that._togglePropertyBindings(bindUserEntries);
	                var designMode = !!dataSource && that.mode() === modes.design;
	                var enabledDesignMode = designMode && !that._disabled && !that._readonly;
	                that._toggleHandleBox(enabledDesignMode);
	                that._toggleTransformEventHandlers(designMode);
	                that._toggleContextMenu(enabledDesignMode);
	            },
	
	            /**
	             * Toggles a message when there is no page to display
	             * @private
	             */
	            _toggleNoPageMessage: function (enable) {
	                assert.instanceof($, this.wrapper, kendo.format(assert.messages.instanceof.default, 'this.wrapper', 'jQuery'));
	                var wrapper = this.wrapper;
	
	                // clear
	                wrapper.children('.' + NOPAGE_CLASS).remove();
	
	                // set no data message
	                if (enable) {
	                    $(DIV)
	                        .addClass(NOPAGE_CLASS)
	                        .text(this.options.messages.noPage)
	                        .css({
	                            position: 'fixed',
	                            top: '50%',
	                            left: '50%',
	                            transform: 'translate(-50%, -50%)'
	                        })
	                        .appendTo(wrapper);
	                }
	            },
	
	            /**
	             * Toggles the readonly overlay
	             * @param enable
	             * @private
	             */
	            _toggleReadOnlyOverlay: function (enable) {
	                assert.instanceof($, this.wrapper, kendo.format(assert.messages.instanceof.default, 'this.wrapper', 'jQuery'));
	                var wrapper = this.wrapper;
	
	                // clear
	                wrapper.children('.' + OVERLAY_CLASS).remove();
	
	                // set overlay
	                if (enable) {
	                    // Add overlay to disable all controls (including audio and video controls)
	                    $(DIV)
	                        .addClass(OVERLAY_CLASS)
	                        .css({
	                            position: ABSOLUTE,
	                            display: BLOCK,
	                            top: 0,
	                            left: 0,
	                            height: this.height(),
	                            width: this.width()
	                        })
	                        .appendTo(wrapper);
	                }
	            },
	
	            /**
	             * Clear mode
	             * @private
	             */
	            _clearMode: function () {
	                // TODO: Possibly remove!!!!!!
	                var that = this;
	                if (that.stage instanceof $) {
	                    // Unbind elements
	                    $.each(that.stage.children(DOT + ELEMENT_CLASS), function (index, stageElement) {
	                        kendo.destroy(stageElement);
	                    });
	                    that.stage.empty();
	                }
	            },
	
	            /**
	             * Toggle property bindings
	             * @param enable
	             * @private
	             */
	            _togglePropertyBindings: function (enable) {
	                var that = this;
	
	                // Unbind property bindings
	                if ($.isFunction(that._propertyBinding)) {
	                    that.unbind(PROPERTYBINDING, that._propertyBinding);
	                }
	
	                if (enable) {
	                    // Bind properties
	                    that._propertyBinding = $.proxy(function () {
	                        var widget = this;
	                        if (widget.properties() instanceof ObservableObject) {
	                            $.each(widget.stage.children(DOT + ELEMENT_CLASS), function (index, stageElement) {
	                                // kendo.unbind(stageElement); // kendo.bind does unbind
	                                kendo.bind(stageElement, widget.properties());
	                            });
	                        }
	                    }, that);
	                    that.bind(PROPERTYBINDING, that._propertyBinding);
	                }
	            },
	
	            /**
	             * Toggle handle box
	             * Note:
	             * @param enable
	             * @private
	             */
	            _toggleHandleBox: function (enable) {
	                assert.instanceof($, this.wrapper, kendo.format(assert.messages.instanceof.default, 'this.wrapper', 'jQuery'));
	                var that = this;
	                var wrapper = that.wrapper;
	
	                // Clear
	                util.removeDebugVisualElements(wrapper);
	                $(document).off(NS);
	                wrapper.children(DOT + HANDLE_BOX_CLASS).remove();
	
	                // Setup handles
	                if (enable) {
	
	                    // Add handles
	                    $(HANDLE_BOX)
	                        .css({
	                            position: ABSOLUTE,
	                            display: NONE
	                        })
	                        .append(HANDLE_MOVE)
	                        .append(HANDLE_RESIZE)
	                        .append(HANDLE_ROTATE)
	                        .append(HANDLE_MENU)
	                        .appendTo(wrapper);
	
	                    // Add stage event handlers
	                    $(document) // was that.wrapper
	                        .on(MOUSEDOWN, $.proxy(that._onMouseDown, that))
	                        .on(MOUSEMOVE, $.proxy(that._onMouseMove, that))
	                        .on(MOUSEUP, $.proxy(that._onMouseUp, that));
	
	                    // Add debug visual elements
	                    util.addDebugVisualElements(wrapper);
	                }
	            },
	
	            /**
	             * Toggle transform event handlers
	             * @param enable
	             * @private
	             */
	            _toggleTransformEventHandlers: function (enable) {
	                assert.instanceof($, this.stage, kendo.format(assert.messages.instanceof.default, 'this.stage', 'jQuery'));
	                var that = this;
	                var stage = that.stage;
	
	                // Clear
	                stage.off(NS);
	
	                // Enable event handlers (also in navigation in design mode)
	                if (enable) {
	                    stage
	                        // .on(ENABLE + NS, DOT + ELEMENT_CLASS, $.proxy(that._enableStageElement, that))
	                        .on(MOVE + NS, DOT + ELEMENT_CLASS, $.proxy(that._moveStageElement, that))
	                        .on(RESIZE + NS, DOT + ELEMENT_CLASS, $.proxy(that._resizeStageElement, that))
	                        .on(ROTATE + NS, DOT + ELEMENT_CLASS, $.proxy(that._rotateStageElement, that));
	                }
	            },
	
	            /**
	             * Event handler called when adding or triggered when enabling an element
	             * @param e
	             * @param component
	             * @param enable
	             * @private
	             */
	            _enableStageElement: function (e, component, enable) {
	                var tools = this.options.tools;
	                assert.instanceof(ObservableObject, tools, kendo.format(assert.messages.instanceof.default, 'this.options.tools', 'kendo.data.ObservableObject'));
	                var tool = tools[component.tool];
	                assert.instanceof(Tool, tool, kendo.format(assert.messages.instanceof.default, 'tool', 'kidoju.Tool'));
	                if ($.isFunction(tool.onEnable)) {
	                    tool.onEnable(e, component, enable);
	                }
	            },
	
	            /**
	             * Event handler called when adding or triggered when moving an element
	             * @param e
	             * @param component
	             * @private
	             */
	            _moveStageElement: function (e, component) {
	                var tools = this.options.tools;
	                assert.instanceof(ObservableObject, tools, kendo.format(assert.messages.instanceof.default, 'this.options.tools', 'kendo.data.ObservableObject'));
	                var tool = tools[component.tool];
	                assert.instanceof(Tool, tool, kendo.format(assert.messages.instanceof.default, 'tool', 'kidoju.Tool'));
	                if ($.isFunction(tool.onMove)) {
	                    tool.onMove(e, component);
	                }
	            },
	
	            /**
	             * Event handler called when adding or triggered when resizing an element
	             * @param e
	             * @param component
	             * @private
	             */
	            _resizeStageElement: function (e, component) {
	                var tools = this.options.tools;
	                assert.instanceof(ObservableObject, tools, kendo.format(assert.messages.instanceof.default, 'this.options.tools', 'kendo.data.ObservableObject'));
	                var tool = tools[component.tool];
	                assert.instanceof(Tool, tool, kendo.format(assert.messages.instanceof.default, 'tool', 'kidoju.Tool'));
	                if ($.isFunction(tool.onResize)) {
	                    tool.onResize(e, component);
	                }
	            },
	
	            /**
	             * Event handler called when adding or triggered when rotating an element
	             * @param e
	             * @param component
	             * @private
	             */
	            _rotateStageElement: function (e, component) {
	                var tools = this.options.tools;
	                assert.instanceof(ObservableObject, tools, kendo.format(assert.messages.instanceof.default, 'this.options.tools', 'kendo.data.ObservableObject'));
	                var tool = tools[component.tool];
	                assert.instanceof(Tool, tool, kendo.format(assert.messages.instanceof.default, 'tool', 'kidoju.Tool'));
	                if ($.isFunction(tool.onRotate)) {
	                    tool.onRotate(e, component);
	                }
	            },
	
	            /**
	             * Toggle context menu
	             * @param enable
	             * @private
	             */
	            _toggleContextMenu: function (enable) {
	                var that = this;
	
	                // Clear (noting that kendo.ui.ContextMenu is not available in kidoju-Mobile)
	                if (kendo.ui && kendo.ui.ContextMenu && that.menu instanceof kendo.ui.ContextMenu) {
	                    that.menu.destroy();
	                    that.menu.element.remove();
	                    that.menu = undefined;
	                }
	
	                // Add context menu
	                if (enable) {
	                    // See http://docs.telerik.com/kendo-ui/api/javascript/ui/contextmenu
	                    that.menu = $('<ul class="kj-stage-menu"></ul>')
	                        // TODO: Bring forward, Push backward, Edit, etc.....
	                        .append('<li ' + DATA_COMMAND + '="delete">' + this.options.messages.contextMenu.delete + '</li>')
	                        .append('<li ' + DATA_COMMAND + '="duplicate">' + this.options.messages.contextMenu.duplicate + '</li>')
	                        .appendTo(that.wrapper)
	                        .kendoContextMenu({
	                            target: '.kj-handle[' + DATA_COMMAND + '="menu"]',
	                            showOn: MOUSEDOWN,
	                            select: $.proxy(that._contextMenuSelectHandler, that)
	                        })
	                        .data('kendoContextMenu');
	                }
	            },
	
	            /**
	             * Event handler for selecting an item in the context menu
	             * @param e
	             * @private
	             */
	            _contextMenuSelectHandler: function (e) {
	                assert.isPlainObject(e, kendo.format(assert.messages.isPlainObject.default, 'e'));
	                assert.instanceof($.Event, e.event, kendo.format(assert.messages.instanceof.default, 'e.event', 'jQuery.Event'));
	
	                // TODO: Consider an event dispatcher so that the same commands can be called from toolbar
	                // Check when implementing fonts, colors, etc....
	                var that = this;
	                var uid;
	                var item;
	                switch ($(e.item).attr(DATA_COMMAND)) {
	                    case 'delete':
	                        uid = that.wrapper.children(DOT + HANDLE_BOX_CLASS).attr(DATA_UID);
	                        item = that.dataSource.getByUid(uid);
	                        that.dataSource.remove(item);
	                        // This should raise the change event on the dataSource and call the refresh method of the widget
	                        break;
	                    case 'duplicate':
	                        uid = that.wrapper.children(DOT + HANDLE_BOX_CLASS).attr(DATA_UID);
	                        item = that.dataSource.getByUid(uid);
	                        var clone = item.clone();
	                        clone.top += 10;
	                        clone.left += 10;
	                        that.dataSource.add(clone);
	                        break;
	                }
	
	                // Close the menu
	                if (that.menu instanceof kendo.ui.ContextMenu) {
	                    that.menu.close();
	                }
	
	                // Event is handled, do not propagate
	                e.preventDefault();
	                // e.stopPropagation();
	            },
	
	            /**
	             * Add an element onto the stage either on a click or from dataSource
	             * @param component
	             * @private
	             */
	            _addStageElement: function (component) {
	                assert.instanceof(kendo.ui.Stage, this, kendo.format(assert.messages.instanceof.default, 'this', 'kendo.ui.Stage'));
	                assert.instanceof($, this.stage, kendo.format(assert.messages.instanceof.default, 'this.stage', 'jQuery'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                assert.type(STRING, component.tool, kendo.format(assert.messages.type.default, 'component.tool', STRING));
	                assert.type(NUMBER, component.left, kendo.format(assert.messages.type.default, 'component.left', NUMBER));
	                assert.type(NUMBER, component.top, kendo.format(assert.messages.type.default, 'component.top', NUMBER));
	
	                var that = this;
	                var stage = that.stage;
	
	                // Cannot add a stage element that already exists on stage
	                if (stage.children(kendo.format(ELEMENT_SELECTOR, component.uid)).length > 0) {
	                    return;
	                }
	
	                // Create stageElement
	                var stageElement = $(kendo.format(ELEMENT, component.uid, component.tool))
	                    .css({
	                        position: ABSOLUTE,
	                        top: component.get(TOP),
	                        left: component.get(LEFT),
	                        height: component.get(HEIGHT),
	                        width: component.get(WIDTH),
	                        // transformOrigin: 'center center', // by default
	                        transform: kendo.format(CSS_ROTATE, component.get(ROTATE))
	                    });
	
	                // Prepare stageElement with component
	                that._prepareStageElement(stageElement, component);
	
	                // Check index in the dataSource
	                var index = that.dataSource.indexOf(component);
	
	                // Append to the stage at index
	                var nextStageElement = stage.children(DOT + ELEMENT_CLASS + ':eq(' + index + ')');
	                if (nextStageElement.length) {
	                    nextStageElement.before(stageElement);
	                } else {
	                    stage.append(stageElement);
	                }
	
	                // init stageElement
	                that._initStageElement(stageElement, component);
	            },
	
	            /**
	             * Prepare Stage Element
	             * @param stageElement
	             * @param component
	             * @private
	             */
	            _prepareStageElement: function (stageElement, component) {
	                assert.instanceof($, stageElement, kendo.format(assert.messages.instanceof.default, 'stageElement', 'jQuery'));
	                assert.instanceof(PageComponent, component, kendo.format(assert.messages.instanceof.default, 'component', 'kidoju.data.PageComponent'));
	                assert.instanceof(kendo.ui.Stage, this, kendo.format(assert.messages.instanceof.default, 'this', 'kendo.ui.Stage'));
	                assert.instanceof($, this.stage, kendo.format(assert.messages.instanceof.default, 'this.stage', 'jQuery'));
	                assert.equal(component.uid, stageElement.attr(kendo.attr('uid')), 'The stageElement data-uid attribute is expected to equal the component uid');
	
	                var tool = this.options.tools[component.tool];
	                assert.instanceof(Tool, tool, kendo.format(assert.messages.instanceof.default, tool, 'kidoju.Tool'));
	                var mode = this.mode();
	                assert.enum(Object.keys(kendo.ui.Stage.fn.modes), mode, kendo.format(assert.messages.enum.default, 'mode', Object.keys(kendo.ui.Stage.fn.modes)));
	                var content = tool.getHtmlContent(component, mode);
	                if (!(content instanceof $)) {
	                    assert.type(STRING, content, kendo.format(assert.messages.type.default, 'tool.getHtmlContent(...)', STRING));
	                    content = $(content);
	                }
	
	                // Empty stage element
	                // stageElement.unbind();
	                kendo.destroy(stageElement);
	                stageElement.empty();
	
	                // Append content
	                stageElement.append(content);
	
	            },
	
	            /**
	             *
	             * @param stageElement
	             * @private
	             */
	            _initStageElement: function (stageElement, component) {
	                // In case stageElement is made from kendo UI controls
	                kendo.init(stageElement);
	
	                // We cannot trigger transform event handlers on stage elements
	                // because they are not yet added to the stage to which events are delegated
	                // Calling event handlers without raising events here has another benefit:
	                // We only need the event handlers in design mode - see _toggleTransformEventHandlers
	                /*
	                stageElement.trigger(ENABLE + NS, component);
	                stageElement.trigger(MOVE + NS, component);
	                stageElement.trigger(RESIZE + NS, component);
	                stageElement.trigger(ROTATE + NS, component);
	                */
	                this._enableStageElement({
	                    currentTarget: stageElement,
	                    preventDefault: $.noop,
	                    stopPropagation: $.noop
	                }, component, this.mode() === this.modes.play);
	                this._moveStageElement({
	                    currentTarget: stageElement,
	                    preventDefault: $.noop,
	                    stopPropagation: $.noop
	                }, component);
	                this._resizeStageElement({
	                    currentTarget: stageElement,
	                    preventDefault: $.noop,
	                    stopPropagation: $.noop
	                }, component);
	                this._rotateStageElement({
	                    currentTarget: stageElement,
	                    preventDefault: $.noop,
	                    stopPropagation: $.noop
	                }, component);
	            },
	
	            /**
	             * Remove an element from the stage
	             * @param uid
	             * @private
	             */
	            _removeStageElementByUid: function (uid) {
	
	                // TODO use a tool method to avoid leaks (remove all event handlers, ...)
	
	                // Find and remove stage element
	                var stageElement = this.stage.children(kendo.format(ELEMENT_SELECTOR, uid));
	                kendo.unbind(stageElement);
	                kendo.destroy(stageElement);
	                stageElement
	                    .off(NS)
	                    .remove();
	            },
	
	            /**
	             * Show handles on a stage element
	             * @method _showHandles
	             * @param uid
	             * @private
	             */
	            _showHandles: function (uid) {
	                var that = this;
	                var handleBox = that.wrapper.children(DOT + HANDLE_BOX_CLASS);
	                if (handleBox.length) {
	
	                    // Position handleBox on top of stageElement (same location, same size, same rotation)
	                    var stageElement = that.stage.children(kendo.format(ELEMENT_SELECTOR, uid));
	                    handleBox
	                        .css({
	                            top: stageElement.css(TOP),
	                            left: stageElement.css(LEFT),
	                            height: stageElement.css(HEIGHT),
	                            width: stageElement.css(WIDTH),
	                            // transformOrigin: 'center center', // by default
	                            transform: stageElement.css(TRANSFORM), // This might return a matrix
	                            display: BLOCK
	                        })
	                        .attr(DATA_UID, uid); // This is how we know which stageElement to transform when dragging handles
	
	                    // Scale and rotate handles
	                    handleBox.children(DOT + HANDLE_CLASS)
	                        .css({
	                            // transformOrigin: 'center center', // by default
	                            transform: kendo.format(CSS_ROTATE, -util.getTransformRotation(stageElement)) + ' ' + kendo.format(CSS_SCALE, 1 / that.scale())
	                        });
	                }
	            },
	
	            /**
	             * Hide handles
	             * @method _hideHandles
	             * @private
	             */
	            _hideHandles: function () {
	                this.wrapper.children(DOT + HANDLE_BOX_CLASS)
	                    .css({ display: NONE })
	                    .removeAttr(DATA_UID);
	            },
	
	            /**
	             * Start dragging an element
	             * @param e
	             * @private
	             */
	            // This function's cyclomatic complexity is too high.
	            /* jshint -W074 */
	            _onMouseDown: function (e) {
	                assert.instanceof($.Event, e, kendo.format(assert.messages.instanceof.default, 'e', 'jQuery.Event'));
	                assert.instanceof(kendo.ui.Stage, this, kendo.format(assert.messages.instanceof.default, 'this', 'kendo.ui.Stage'));
	
	                var that = this;
	                var tools = that.options.tools;
	                var activeToolId = tools.get(ACTIVE_TOOL);
	                var target = $(e.target);
	                var mouse = util.getMousePosition(e, that.stage);
	                var stageElement = target.closest(DOT + ELEMENT_CLASS);
	                var handle = target.closest(DOT + HANDLE_CLASS);
	                var uid;
	
	                // Close any context menu left opened if not selecting a menu item
	                if (that.menu instanceof kendo.ui.ContextMenu && !target.is('.k-link')) {
	                    that.menu.close();
	                }
	
	                if (activeToolId !== POINTER) {
	
	                    // When clicking the stage with an active tool, add a new element
	                    var tool = tools[activeToolId];
	                    assert.instanceof(Tool, tool, kendo.format(assert.messages.instanceof.default, 'tool', 'kidoju.Tool'));
	                    var scale = util.getTransformScale(that.wrapper);
	                    var left = mouse.x / scale;
	                    var top = mouse.y / scale;
	
	                    // Check that the mousedown occured within the boundaries of the stage
	                    if (left >= 0 && left <= this.stage.width() && top >= 0 && top <= this.stage.height()) {
	
	                        var item = new PageComponent({
	                            // id: kendo.guid(),
	                            tool: tool.id,
	                            left: left,
	                            top: top,
	                            width: tool.width,
	                            height: tool.height
	                            // rotate: tool.rotate?
	                        });
	                        that.dataSource.add(item);
	                        // Add triggers the change event on the dataSource which calls the refresh method
	
	                        tools.set(ACTIVE_TOOL, POINTER);
	
	                    }
	
	                    e.preventDefault(); // otherwise both touchstart and mousedown are triggered and code is executed twice
	                    e.stopPropagation();
	
	                } else if (handle.length) {
	
	                    // When hitting a handle with the pointer tool
	                    var command = handle.attr(DATA_COMMAND);
	                    if (command === COMMANDS.MENU) {
	                        $.noop(); // TODO: contextual menu here
	                    } else {
	                        var handleBox = that.wrapper.children(DOT + HANDLE_BOX_CLASS);
	                        uid = handleBox.attr(DATA_UID); // the uid of the stageElement which is being selected before hitting the handle
	                        stageElement = that.stage.children(kendo.format(ELEMENT_SELECTOR, uid));
	                        handleBox.data(STATE, {
	                            command: command,
	                            top: parseFloat(stageElement.css(TOP)) || 0, // stageElement.position().top does not work when scaled
	                            left: parseFloat(stageElement.css(LEFT)) || 0, // stageElement.position().left does not work when scaled
	                            height: stageElement.height(),
	                            width: stageElement.width(),
	                            angle: util.getTransformRotation(stageElement),
	                            scale: util.getTransformScale(that.wrapper),
	                            snapGrid: 0, // TODO
	                            snapAngle: 0, // TODO
	                            mouseX: mouse.x,
	                            mouseY: mouse.y,
	                            uid: uid
	                        });
	
	                        // log(handleBox.data(STATE));
	                        $(document.body).css(CURSOR, target.css(CURSOR));
	                    }
	                    e.preventDefault(); // otherwise both touchstart and mousedown are triggered and code is executed twice
	                    e.stopPropagation();
	
	                } else if (stageElement.length || target.is(DOT + HANDLE_BOX_CLASS)) {
	                    // When hitting a stage element or the handle box with the pointer tool
	                    uid = stageElement.attr(DATA_UID);
	                    if (util.isGuid(uid)) {
	                        var component = that.dataSource.getByUid(uid);
	                        if (component instanceof PageComponent) {
	                            that.value(component);
	                        }
	                    }
	
	                } else if (that.wrapper.find(target).length) {
	
	                    // When hitting anything else in the wrapper with the pointer tool
	                    that.value(NULL);
	                    e.preventDefault(); // otherwise both touchstart and mousedown are triggered and code is executed twice
	                    e.stopPropagation();
	
	                }
	
	                // Otherwise, let the event propagate
	            },
	            /* jshint +W074 */
	
	            /**
	             * While dragging an element on stage
	             * @param e
	             * @private
	             */
	            _onMouseMove: function (e) {
	                assert.instanceof($.Event, e, kendo.format(assert.messages.instanceof.default, 'e', 'jQuery.Event'));
	                assert.instanceof(kendo.ui.Stage, this, kendo.format(assert.messages.instanceof.default, 'this', 'kendo.ui.Stage'));
	                var that = this;
	                var handleBox = that.wrapper.children(DOT + HANDLE_BOX_CLASS);
	                var startState = handleBox.data(STATE);
	
	                // With a startState, we are dragging a handle
	                if ($.isPlainObject(startState)) {
	
	                    var mouse = util.getMousePosition(e, that.stage);
	                    var stageElement = that.stage.children(kendo.format(ELEMENT_SELECTOR, startState.uid));
	                    var item = that.dataSource.getByUid(startState.uid);
	                    var rect = stageElement[0].getBoundingClientRect();
	                    var bounds = {
	                            // TODO these calculations depend on the transformOrigin attribute of that.wrapper - ideally we should introduce transformOrigin in the calculation
	                            left: rect.left - that.stage.offset().left + $(that.stage.get(0).ownerDocument).scrollLeft(),
	                            top: rect.top - that.stage.offset().top + $(that.stage.get(0).ownerDocument).scrollTop(),
	                            height: rect.height,
	                            width: rect.width
	                        };
	                    var center = {
	                            x: bounds.left + bounds.width / 2,
	                            y: bounds.top + bounds.height / 2
	                        };
	
	                    util.updateDebugVisualElements({
	                        wrapper: that.wrapper,
	                        mouse: mouse,
	                        center: center,
	                        bounds: bounds,
	                        scale: startState.scale
	                    });
	
	                    if (startState.command === COMMANDS.MOVE) {
	                        item.set(LEFT, util.snap(startState.left + (mouse.x - startState.mouseX) / startState.scale, that._snapGrid));
	                        item.set(TOP, util.snap(startState.top + (mouse.y - startState.mouseY) / startState.scale, that._snapGrid));
	                        // Set triggers the change event on the dataSource which calls the refresh method to update the stage
	
	                    } else if (startState.command === COMMANDS.RESIZE) {
	                        // See https://github.com/Memba/Kidoju-Widgets/blob/master/test/samples/move-resize-rotate.md
	                        var dx = (mouse.x - startState.mouseX) / startState.scale; // horizontal distance from S to S'
	                        var dy = (mouse.y - startState.mouseY) / startState.scale; // vertical distance from S to S'
	                        var centerAfterMove = { // Also C'
	                                x: center.x + dx / 2,
	                                y: center.y + dy / 2
	                            };
	                        var topLeft = { // Also T
	                                x: startState.left,
	                                y: startState.top
	                            };
	                        var alpha = util.deg2rad(startState.angle);
	                        var mmprime = util.getRotatedPoint(topLeft, center, alpha); // Also M=M'
	                        var topLeftAfterMove = util.getRotatedPoint(mmprime, centerAfterMove, -alpha); // Also T'
	
	                        // TODO these calculations depend on the transformOrigin attribute of that.wrapper - ideally we should introduce transformOrigin in the calculation
	                        item.set(LEFT, Math.round(topLeftAfterMove.x));
	                        item.set(TOP, Math.round(topLeftAfterMove.y));
	                        item.set(HEIGHT, util.snap(startState.height - dx * Math.sin(alpha) + dy * Math.cos(alpha), that._snapGrid));
	                        item.set(WIDTH, util.snap(startState.width + dx * Math.cos(alpha) + dy * Math.sin(alpha), that._snapGrid));
	                        // Set triggers the change event on the dataSource which calls the refresh method to update the stage
	
	                    } else if (startState.command === COMMANDS.ROTATE) {
	                        var rad = util.getRadiansBetween2Points(center, {
	                                x: startState.mouseX,
	                                y: startState.mouseY
	                            }, mouse);
	                        var deg = util.snap((360 + startState.angle + util.rad2deg(rad)) % 360, that._snapAngle);
	                        item.set(ROTATE, deg);
	                        // Set triggers the change event on the dataSource which calls the refresh method to update the stage
	                    }
	
	                    e.preventDefault();
	                    e.stopPropagation();
	                }
	            },
	
	            /**
	             * At the end of dragging an element on stage
	             * @param e
	             * @private
	             */
	            _onMouseUp: function (e) {
	                assert.instanceof($.Event, e, kendo.format(assert.messages.instanceof.default, 'e', 'jQuery.Event'));
	                assert.instanceof(kendo.ui.Stage, this, kendo.format(assert.messages.instanceof.default, 'this', 'kendo.ui.Stage'));
	                var that = this;
	                var handleBox = that.wrapper.children(DOT + HANDLE_BOX_CLASS);
	                var startState = handleBox.data(STATE);
	
	                if ($.isPlainObject(startState)) {
	
	                    // Remove drag start state
	                    handleBox.removeData(STATE);
	
	                    // Reset cursor
	                    $(document.body).css(CURSOR, '');
	
	                    // Hide debug visual elements
	                    util.hideDebugVisualElements(that.wrapper);
	
	                }
	            },
	
	            /**
	             *
	             * @param options
	             * @private
	             */
	            _editable: function (options) {
	                var that = this;
	                var wrapper = that.wrapper;
	                var disabled = that._disabled = options.disabled;
	                var readonly = that._readonly = options.readonly;
	
	                // Clear
	
	                // Set
	                /*
	                if (!disabled && !readonly) {
	                    // TODO iterate through components and call onEnable
	                } else {
	
	                }
	                */
	            },
	
	            /**
	             * Enable/disable the widget
	             * @param enable
	             */
	            enable: function (enable) {
	                this._editable({
	                    readonly: false,
	                    disabled: !(enable = enable === undefined ? true : enable)
	                });
	            },
	
	            /**
	             * Make the widget readonly
	             * @param readonly
	             */
	            readonly: function (readonly) {
	                this._editable({
	                    readonly: readonly === undefined ? true : readonly,
	                    disabled: false
	                });
	            },
	
	            /**
	             * Refresh a stage widget
	             * @param e
	             */
	            // This function's cyclomatic complexity is too high.
	            /* jshint -W074 */
	            refresh: function (e) {
	                var that = this;
	                if (e === undefined || e.action === undefined) {
	                    var components = [];
	                    if (e === undefined && that.dataSource instanceof PageComponentCollectionDataSource) {
	                        components = that.dataSource.data();
	                    } else if (e && e.items instanceof ObservableArray) {
	                        components = e.items;
	                    }
	                    that._hideHandles();
	                    that.trigger(DATABINDING);
	                    $.each(that.stage.children(DOT + ELEMENT_CLASS), function (index, stageElement) {
	                        that._removeStageElementByUid($(stageElement).attr(DATA_UID));
	                    });
	                    $.each(components, function (index, component) {
	                        that._addStageElement(component);
	                    });
	
	                    // If the following line triggers `Uncaught TypeError: Cannot read property 'length' of null` in the console
	                    // This is probably because binding on properties has not been properly set - check html
	                    // as in <input type="text" style="width: 300px; height: 100px; font-size: 75px;" data-bind="value: ">
	                    that.trigger(DATABOUND);
	
	                    // We can only bind properties after all dataBound event handlers have executed
	                    // otherwise there is a mix of binding sources
	                    that.trigger(PROPERTYBINDING); // This calls an event handler in _initializePlayMode
	                    that.trigger(PROPERTYBOUND);
	
	                } else if (e.action === 'add') {
	                    $.each(e.items, function (index, component) {
	                        that._addStageElement(component);
	                        that.value(component);
	                    });
	
	                } else if (e.action === 'remove') {
	                    $.each(e.items, function (index, component) {
	                        that._removeStageElementByUid(component.uid);
	                        that.trigger(CHANGE, { action: e.action, value: component });
	                        if (that.wrapper.children(DOT + HANDLE_BOX_CLASS).attr(DATA_UID) === component.uid) {
	                            that.value(NULL);
	                        }
	                    });
	
	                } else if (e.action === 'itemchange') {
	                    $.each(e.items, function (index, component) {
	                        var stageElement = that.stage.children(kendo.format(ELEMENT_SELECTOR, component.uid));
	                        var handleBox = that.wrapper.children(kendo.format(HANDLE_BOX_SELECTOR, component.uid));
	                        if (stageElement.length) {
	                            switch (e.field) {
	                                case LEFT:
	                                    if (Math.round(stageElement.position().left) !== Math.round(component.left)) {
	                                        stageElement.css(LEFT, component.left);
	                                        handleBox.css(LEFT, component.left);
	                                        stageElement.trigger(MOVE + NS, component);
	                                    }
	                                    break;
	                                case TOP:
	                                    if (Math.round(stageElement.position().top) !== Math.round(component.top)) {
	                                        stageElement.css(TOP, component.top);
	                                        handleBox.css(TOP, component.top);
	                                        stageElement.trigger(MOVE + NS, component);
	                                    }
	                                    break;
	                                case HEIGHT:
	                                    if (Math.round(stageElement.height()) !== Math.round(component.height)) {
	                                        stageElement.css(HEIGHT, component.height);
	                                        handleBox.css(HEIGHT, component.height);
	                                        stageElement.trigger(RESIZE + NS, component);
	                                    }
	                                    break;
	                                case WIDTH:
	                                    if (Math.round(stageElement.width()) !== Math.round(component.width)) {
	                                        stageElement.css(WIDTH, component.width);
	                                        handleBox.css(WIDTH, component.width);
	                                        stageElement.trigger(RESIZE + NS, component);
	                                    }
	                                    break;
	                                case ROTATE:
	                                    if (Math.round(util.getTransformRotation(stageElement)) !== Math.round(component.rotate)) {
	                                        stageElement.css(TRANSFORM, kendo.format(CSS_ROTATE, component.rotate));
	                                        handleBox.css(TRANSFORM, kendo.format(CSS_ROTATE, component.rotate));
	                                        handleBox.children(DOT + HANDLE_CLASS)
	                                            .css(TRANSFORM, kendo.format(CSS_ROTATE, -component.rotate) + ' ' + kendo.format(CSS_SCALE, 1 / that.scale()));
	                                        stageElement.trigger(ROTATE + NS, component);
	                                    }
	                                    break;
	                                default:
	                                    if (/^attributes/.test(e.field) || /^properties/.test(e.field)) {
	                                        that._prepareStageElement(stageElement, component);
	                                        that._initStageElement(stageElement, component);
	                                    }
	                            }
	                        }
	                    });
	                }
	            },
	            /* jshint +W074 */
	
	            /**
	             * Toggle the selection
	             * @returns {h|*}
	             */
	            _toggleSelection: function () {
	                assert.instanceof(kendo.ui.Stage, this, kendo.format(assert.messages.instanceof.default, 'this', 'kendo.ui.Stage'));
	                var that = this;
	                var uid = that._selectedUid;
	                var handleBox = that.wrapper.children(DOT + HANDLE_BOX_CLASS);
	                // if (that.mode() === that.modes.design) {
	                if (handleBox.length) {
	                    var stageElement = that.stage.children(kendo.format(ELEMENT_SELECTOR, uid));
	                    if (util.isGuid(uid) && stageElement.length && handleBox.attr(DATA_UID) !== uid) {
	                        that._showHandles(uid);
	                        // select(null) should clear the selection
	                    } else if (uid === NULL && handleBox.css(DISPLAY) !== NONE) {
	                        that._hideHandles();
	                    }
	                }
	            },
	
	            /**
	             * Stage Elements
	             * @method items
	             * @returns {*}
	             */
	            items: function () {
	                // Do not return .kj-connector-surface
	                var element = this.element;
	                if ($.isFunction(element[0].getElementsByClassName)) { // To return an HTMLCollection when possible
	                    return element[0].getElementsByClassName(ELEMENT_CLASS);
	                } else { // Otherwise fallback to a simple array
	                    return $.makeArray(this.element.children(DOT + ELEMENT_CLASS));
	                }
	            },
	
	            /**
	             * Clears the DOM from modifications made by the widget
	             * @private
	             */
	            _clear: function () {
	                var that = this;
	                // clear mode
	                that._clearMode();
	                // unbind kendo
	                kendo.unbind(that.element);
	                // unbind all other events
	                that.element.find('*').off();
	                // empty and unwrap
	                that.element
	                    .off()
	                    .empty()
	                    .unwrap();
	            },
	
	            /**
	             * Destroys the widget
	             */
	            destroy: function () {
	                var that = this;
	                Widget.fn.destroy.call(that);
	                that._clear();
	                that.setDataSource(NULL);
	                kendo.destroy(that.element);
	            }
	
	        });
	
	        kendo.ui.plugin(Stage);
	
	        /*********************************************************************************
	         * Helpers
	         *********************************************************************************/
	
	        /**
	         * Utility functions
	         */
	        var util = {
	
	            /**
	             * Test valid guid
	             * @param value
	             * @returns {boolean}
	             */
	            isGuid: function (value) {
	                // http://stackoverflow.com/questions/7905929/how-to-test-valid-uuid-guid
	                return ($.type(value) === STRING) && (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/.test(value));
	            },
	
	            /**
	             * Convert radians to degrees
	             * @param deg
	             * @returns {number}
	             */
	            deg2rad: function (deg) {
	                return deg * Math.PI / 180;
	            },
	
	            /**
	             * Convert degrees to radians
	             * @param rad
	             * @returns {number}
	             */
	            rad2deg: function (rad) {
	                return rad * 180 / Math.PI;
	            },
	
	            /**
	             * Snapping consists in rounding the value to the closest multiple of snapValue
	             * @param value
	             * @param snapValue
	             * @returns {*}
	             */
	            snap: function (value, snapValue) {
	                assert.type(NUMBER, snapValue, assert.messages.type.default, 'snapValue', NUMBER);
	                snapValue = Math.round(snapValue);
	                if (snapValue) {
	                    return value % snapValue < snapValue / 2 ? value - value % snapValue : value + snapValue - value % snapValue;
	                } else {
	                    return Math.round(value);
	                }
	            },
	
	            /**
	             * Get the rotation angle (in degrees) of an element's CSS transformation
	             * @param element
	             * @returns {Number|number}
	             */
	            getTransformRotation: function (element) {
	                // $(element).css('transform') returns a matrix, so we have to read the style attribute
	                var match = ($(element).attr('style') || '').match(/rotate\([\s]*([0-9\.]+)[deg\s]*\)/);
	                return $.isArray(match) && match.length > 1 ? parseInt(match[1], 10) || 0 : 0;
	            },
	
	            /**
	             * Get the scale of an element's CSS transformation
	             * Note: the same function is used in kidoju.widgets.connector
	             * @param element
	             * @returns {Number|number}
	             */
	            getTransformScale: function (element) {
	                // $(element).css('transform') returns a matrix, so we have to read the style attribute
	                var match = ($(element).attr('style') || '').match(/scale\([\s]*([0-9\.]+)[\s]*\)/);
	                return $.isArray(match) && match.length > 1 ? parseFloat(match[1]) || 1 : 1;
	            },
	
	            /**
	             * Get the mouse (or touch) position
	             * @param e
	             * @param stage
	             * @returns {{x: *, y: *}}
	             */
	            getMousePosition: function (e, stage) {
	                // See http://www.jacklmoore.com/notes/mouse-position/
	                // See http://www.jqwidgets.com/community/topic/dragend-event-properties-clientx-and-clienty-are-undefined-on-ios/
	                // See http://www.devinrolsen.com/basic-jquery-touchmove-event-setup/
	                // ATTENTION: e.originalEvent.touches instanceof TouchList, not Array
	                var clientX = e.originalEvent && e.originalEvent.touches ? e.originalEvent.touches[0].clientX : e.clientX;
	                var clientY = e.originalEvent && e.originalEvent.touches ? e.originalEvent.touches[0].clientY : e.clientY;
	                // IMPORTANT: Position is relative to the stage and e.offsetX / e.offsetY do not work in Firefox
	                // var stage = $(e.target).closest('.kj-stage').find(kendo.roleSelector('stage'));
	                var mouse = {
	                        x: clientX - stage.offset().left + $(stage.get(0).ownerDocument).scrollLeft(),
	                        y: clientY - stage.offset().top + $(stage.get(0).ownerDocument).scrollTop()
	                    };
	                return mouse;
	            },
	
	            /**
	             * Rotate a point by an angle around a center
	             * @param point
	             * @param center
	             * @param radians
	             * @returns {*}
	             */
	            getRotatedPoint: function (point, center, radians) {
	                if ($.isPlainObject(point) && $.type(point.x) === 'number' && $.type(point.y) === 'number' &&
	                    $.isPlainObject(center) && $.type(center.x) === 'number' && $.type(center.y) === 'number' &&
	                    $.type(radians) === 'number') {
	                    return {
	                        // See http://stackoverflow.com/questions/786472/rotate-a-point-by-another-point-in-2d
	                        // See http://www.felixeve.co.uk/how-to-rotate-a-point-around-an-origin-with-javascript/
	                        x: center.x + (point.x - center.x) * Math.cos(radians) - (point.y - center.y) * Math.sin(radians),
	                        y: center.y + (point.x - center.x) * Math.sin(radians) + (point.y - center.y) * Math.cos(radians)
	                    };
	                }
	            },
	
	            /**
	             * Calculate the angle between two points rotated around a center
	             * @param center
	             * @param p1
	             * @param p2
	             * @returns {*}
	             */
	            getRadiansBetween2Points: function (center, p1, p2) {
	                if ($.isPlainObject(center) && $.type(center.x) === 'number' && $.type(center.y) === 'number' &&
	                    $.isPlainObject(p1) && $.type(p1.x) === 'number' && $.type(p1.y) === 'number' &&
	                    $.isPlainObject(p2) && $.type(p2.x) === 'number' && $.type(p2.y) === 'number') {
	                    // See http://www.euclideanspace.com/maths/algebra/vectors/angleBetween/
	                    // See http://stackoverflow.com/questions/7586063/how-to-calculate-the-angle-between-a-line-and-the-horizontal-axis
	                    // See http://code.tutsplus.com/tutorials/euclidean-vectors-in-flash--active-8192
	                    // See http://gamedev.stackexchange.com/questions/69649/using-atan2-to-calculate-angle-between-two-vectors
	                    return Math.atan2(p2.y - center.y, p2.x - center.x) - Math.atan2(p1.y - center.y, p1.x - center.x);
	                }
	            },
	
	            /**
	             * Add debug visual eleemnts
	             * @param wrapper
	             */
	            addDebugVisualElements: function (wrapper) {
	                if (window.app && window.app.DEBUG) {
	
	                    // Add bounding rectangle
	                    $(DEBUG_BOUNDS)
	                        .css({
	                            position: ABSOLUTE,
	                            border: '1px dashed #FF00FF',
	                            display: NONE
	                        })
	                        .appendTo(wrapper);
	
	                    // Add center of rotation
	                    $(DEBUG_CENTER)
	                        .css({
	                            position: ABSOLUTE,
	                            height: '20px',
	                            width: '20px',
	                            marginTop: '-10px',
	                            marginLeft: '-10px',
	                            borderRadius: '50%',
	                            backgroundColor: '#FF00FF',
	                            display: NONE
	                        })
	                        .appendTo(wrapper);
	
	                    // Add calculated mouse position
	                    $(DEBUG_MOUSE_DIV)
	                        .css({
	                            position: ABSOLUTE,
	                            height: '20px',
	                            width: '20px',
	                            marginTop: '-10px',
	                            marginLeft: '-10px',
	                            borderRadius: '50%',
	                            backgroundColor: '#00FFFF',
	                            display: NONE
	                        })
	                        .appendTo(wrapper);
	                }
	            },
	
	            /**
	             * Update debug visual elements
	             * @param options
	             */
	            updateDebugVisualElements: function (options) {
	                if (window.app && window.app.DEBUG && $.isPlainObject(options) && options.scale > 0) {
	
	                    // Display center of rotation
	                    options.wrapper.children(DOT + DEBUG_CENTER_CLASS).css({
	                        display: 'block',
	                        left: Math.round(options.center.x / options.scale),
	                        top: Math.round(options.center.y / options.scale)
	                    });
	
	                    // Display bounding rectangle
	                    options.wrapper.children(DOT + DEBUG_BOUNDS_CLASS).css({
	                        display: 'block',
	                        left: Math.round(options.bounds.left / options.scale),
	                        top: Math.round(options.bounds.top / options.scale),
	                        height: Math.round(options.bounds.height / options.scale),
	                        width: Math.round(options.bounds.width / options.scale)
	                    });
	
	                    // Display mouse calculated position
	                    options.wrapper.children(DOT + DEBUG_MOUSE_CLASS).css({
	                        display: 'block',
	                        left: Math.round(options.mouse.x / options.scale),
	                        top: Math.round(options.mouse.y / options.scale)
	                    });
	                }
	            },
	
	            /**
	             * Hide debug visual elements
	             * @param wrapper
	             */
	            hideDebugVisualElements: function (wrapper) {
	                if (window.app && window.app.DEBUG) {
	                    wrapper.children(DOT + DEBUG_CENTER_CLASS).css({ display: NONE });
	                    wrapper.children(DOT + DEBUG_BOUNDS_CLASS).css({ display: NONE });
	                    wrapper.children(DOT + DEBUG_MOUSE_CLASS).css({ display: NONE });
	                }
	            },
	
	            /**
	             * Remove debug visual elements
	             * @param wrapper
	             */
	            removeDebugVisualElements: function (wrapper) {
	                if (window.app && window.app.DEBUG) {
	                    wrapper.children(DOT + DEBUG_CENTER_CLASS).remove();
	                    wrapper.children(DOT + DEBUG_BOUNDS_CLASS).remove();
	                    wrapper.children(DOT + DEBUG_MOUSE_CLASS).remove();
	                }
	            }
	        };
	
	    }(window.jQuery));
	
	    /* jshint +W071 */
	
	    return window.kendo;
	
	}, __webpack_require__(200));


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(250),
	        __webpack_require__(251)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    /* This function has too many statements. */
	    /* jshint: -W071 */
	
	    (function (undefined) {
	
	        var app = window.app = window.app || {};
	        app.constants = {
	            ajaxTimeout: 5000
	        };
	
	    }());
	
	    /* jshint: +W071 */
	
	    return window.app;
	
	}, __webpack_require__(200));
	


/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true */
	/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(231),
	        __webpack_require__(232)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    (function ($, undefined) {
	
	        var app = window.app = window.app || {};
	        var assert = window.assert;
	        var logger = app.logger = app.logger || {};
	        var LEVELS = {
	            DEBUG: { NAME: 'DEBUG', VALUE: 1 },
	            INFO: { NAME: 'INFO', VALUE: 2 },
	            WARN: { NAME: 'WARN', VALUE: 4 },
	            ERROR: { NAME: 'ERROR', VALUE: 5 },
	            CRIT: { NAME: 'CRIT', VALUE: 6 }
	        };
	        var RX_LEVELS = new RegExp('^(' + Object.keys(LEVELS).join('|') + ')$', 'i');
	
	        // The following need to be defined in app.config.jsx
	        // logger.level = X
	        // logger.endPoint = http://xxxxxxx
	
	        /**
	         * IMPORTANT: the following functions are prefixed with underscores
	         * because they should not be called, i.e. always call window.Logger functions
	         */
	
	        /**
	         * Generic log function
	         * @param entry
	         * @param level
	         * @private
	         */
	        logger._log = function (entry, level, options) {
	            // Note: assert.type discards an entry of type Error, the processing is supposed to be done in windows.Logger
	            assert.type('object', entry, 'A log entry is supposed to be an object');
	            assert.match(RX_LEVELS, level, 'level is supposed to be any of `debug`, `info`, `warn`, `error` or `crit`');
	            var dfd =  $.Deferred();
	            if ((logger.level || 0) > LEVELS[level.toUpperCase()].VALUE) {
	                // Return false if the ajax call was not made, considering the logging level
	                return dfd.resolve(false);
	            }
	            $.ajax({
	                type: 'POST',
	                url: logger.endPoint || options.endPoint,
	                contentType: 'application/json',
	                // dataType: 'json', // <-- do not set the dataType since the response is always empty
	                data: JSON.stringify($.extend(entry, { date: new Date(), level: level.toLowerCase() }))
	            })
	                .done(function () {
	                    // Return true if the ajax call was successful
	                    return dfd.resolve(true);
	                })
	                .fail(dfd.reject);
	            return dfd.promise();
	        };
	
	        /**
	         * Log a debug entry
	         * @param entry
	         * @param options
	         */
	        logger._debug = function (entry, options) {
	            return logger._log(entry, LEVELS.DEBUG.NAME, options);
	        };
	
	        /**
	         * Log an info entry
	         * @param entry
	         * @param options
	         */
	        logger._info = function (entry, options) {
	            return logger._log(entry, LEVELS.INFO.NAME, options);
	        };
	
	        /**
	         * Log a warn entry
	         * @param entry
	         * @param options
	         */
	        logger._warn = function (entry, options) {
	            return logger._log(entry, LEVELS.WARN.NAME, options);
	        };
	
	        /**
	         * Log an error entry (the application can survive an error entry)
	         * @param entry
	         * @param options
	         */
	        logger._error = function (entry, options) {
	            return logger._log(entry, LEVELS.ERROR.NAME, options);
	        };
	
	        /**
	         * Log a critical entry (the application cannot survive a critical entry)
	         * @param entry
	         * @param options
	         */
	        logger._crit = function (entry, options) {
	            return logger._log(entry, LEVELS.CRIT.NAME, options);
	        };
	
	    }(window.jQuery));
	
	    return window.app;
	
	}, __webpack_require__(200));


/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(252),
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(250)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    /* This function has too many statements. */
	    /* jshint -W071 */
	
	    (function ($, undefined) {
	
	        /* jshint maxstatements: 48 */
	
	        var app = window.app;
	        var assert = window.assert;
	        var logger = new window.Logger('app.rapi');
	        var chrome = window.chrome;
	        var Fingerprint = window.Fingerprint;
	        var history = window.history;
	        var localStorage = window.localStorage;
	        var location = window.location;
	        var navigator = window.navigator;
	        var sessionStorage = window.sessionStorage;
	        var rapi = app.rapi = {}; // rapi stands for Restful API
	        var uris = app.uris = app.uris || {}; // they might have already been defined
	        var STRING = 'string';
	        var NUMBER = 'number';
	        // var UNDEFINED = 'undefined';
	        var EQUALS = '=';
	        var HASH = '#';
	        var PROVIDERS = ['facebook', 'google', 'live', 'twitter'];
	        var TOKEN = 'token';
	        var ACCESS_TOKEN = 'access_token';
	        var TOKEN_TYPE = 'token_type';
	        var EXPIRES_IN = 'expires_in';
	        var STATE = 'state';
	        var DELETE = 'DELETE';
	        var GET = 'GET';
	        var POST = 'POST';
	        var PUT = 'PUT';
	        var COMMANDS = ['publish', 'draft'];
	        var FORM_CONTENT_TYPE = 'application/x-www-form-urlencoded';
	        var JSON_CONTENT_TYPE = 'application/json';
	        var RX_IEXPLORE = /;\s(MSIE\s|Trident\/)/;
	        var RX_MONGODB_ID = /^[a-z0-9]{24}$/;
	        var RX_LANGUAGE = /^[a-z]{2}$/;
	        var RX_URL = /^http(s?)\:\/\//;
	        var AUTHENTICATION_SUCCESS = 'auth.success';
	        var AUTHENTICATION_FAILURE = 'auth.failure';
	
	        /**
	         * Location of our RESTful server
	         */
	        uris.rapi = uris.rapi || {};
	        if (!RX_URL.test(uris.rapi.root)) { // if not already defined
	            if (app.DEBUG) {
	                // Note best option is to modify the hosts file with a domain name as explained at http://www.rackspace.com/knowledge_center/article/how-do-i-modify-my-hosts-file
	                // especially because some authentication providers do not support ip addresses and others do not support localhost
	                // uris.rapi.root = 'http://10.0.0.105.xip.io:3001';
	                uris.rapi.root = 'http://localhost:3001';
	            } else {
	                uris.rapi.root = 'https://www.kidoju.com';
	            }
	        }
	
	        /**
	         * Location of our api endpoints (contrary to root, we do not care whether they have already been defined)
	         */
	        uris.rapi.ping = '/api/ping';
	        uris.rapi.oauth = {
	            signIn: '/api/auth/{0}/signin',
	            signOut: '/api/auth/signout',
	            refresh: '/api/auth/refresh',
	            revoke: '/api/auth/revoke'
	        };
	        uris.rapi.v1 = {
	            user: '/api/v1/users/{0}',
	            me: '/api/v1/users/me',
	            mySummaries: '/api/v1/users/me/{0}/summaries',
	            myActivities: '/api/v1/users/me/{0}/activities',
	            myFavourites: '/api/v1/users/me/{0}/favourites',
	            myFavourite: '/api/v1/users/me/{0}/favourites/{1}',
	            allLanguages: '/api/v1/languages',
	            language: '/api/v1/languages/{0}',
	            categories: '/api/v1/languages/{0}/categories',
	            summaries: '/api/v1/{0}/summaries',
	            summary: '/api/v1/{0}/summaries/{1}',
	            versions: '/api/v1/{0}/summaries/{1}/versions',
	            version: '/api/v1/{0}/summaries/{1}/versions/{2}',
	            activities: '/api/v1/{0}/summaries/{1}/activities',
	            activity: '/api/v1/{0}/summaries/{1}/activities/{2}',
	            upload: '/api/v1/{0}/summaries/{1}/files/upload',
	            files: '/api/v1/{0}/summaries/{1}/files',
	            file: '/api/v1/{0}/summaries/{1}/file/{2}'
	        };
	
	        /**
	         * Utility functions
	         * @type {{format: Function, getFingerPrint: Function, uuid: Function, setState: Function, getState: Function, getAccessTokenHashPos: Function, parseToken: Function, setToken: Function, getAccessToken: Function, clearToken: Function, cleanUrl: Function, cleanHistory: Function, getHeaders: Function, onDocumentReady: Function}}
	         */
	        rapi.util = {
	
	            /**
	             * Simple format function to replace {n} with the (n+1)th argument
	             * @param message
	             * @returns {*}
	             */
	            format: function (message) {
	                // Cannot assert message without exceeding the call stack size
	                var ret = message; // aka arguments[0]
	                for (var i = 1; i < arguments.length; i++) {
	                    var rx = new RegExp('\\{' + (i - 1).toString() + '\\}', 'g');
	                    ret = ret.replace(rx, (arguments[i] && typeof arguments[i].toString === 'function' ? arguments[i].toString() : ''));
	                }
	                return ret;
	            },
	
	            /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
	
	            /**
	             * Uses https://github.com/Valve/fingerprintjs to return a unique browser fingerprint
	             * See https://github.com/Memba/Kidoju-Server/issues/35
	             * @returns {*}
	             */
	            getFingerPrint: function () {
	                var hash = 0;
	                if ($.type(Fingerprint) === 'function') {
	                    hash = new Fingerprint({ canvas: true, ie_activex: false, screen_resolution: true }).get();
	                } else if (navigator && navigator.userAgent) {
	                    // See http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery
	                    var chr;
	                    var agent = navigator.userAgent;
	                    // hash = 0;
	                    for (var i = 0; i < agent.length; i++) {
	                        chr   = agent.charCodeAt(i);
	                        // Unexpected use of '<<' and '|='
	                        /* jshint -W016 */
	                        hash  = ((hash << 5) - hash) + chr;
	                        hash |= 0; // Convert to 32bit integer
	                        /* jshint +W016 */
	                    }
	                }
	                return Math.abs(hash); // We have experienced a negative fingerprint on PhantomJS in Travis-CI
	            },
	
	            /* jscs:enable requireCamelCaseOrUpperCaseIdentifiers */
	
	            /**
	             * Get a uuid
	             * @see https://github.com/Memba/Kidoju-Server/issues/31#issuecomment-77665098
	             * @returns {number}
	             */
	            uuid: function () {
	                var uuid = '';
	                var crypto = window.crypto || window.msCrypto;
	                if (crypto && $.isFunction(crypto.getRandomValues) && $.isFunction(Uint8Array) && navigator.userAgent.indexOf('PhantomJS') < 0) {
	                    // Note: $.isFunction(Uint8Array) is false in Safari for Windows which is good because crypto.getRandomValues(new Uint8Array(32)) returns undefined
	                    var Seed = function () {
	                        var b = [];
	                        Array.apply([], crypto.getRandomValues(new Uint8Array(32))).forEach(function (c) {
	                            b = b.concat(c.toString(16).split(''));
	                        });
	                        return function (i) {
	                            var t = '';
	                            switch (i) {
	                                case 8:
	                                    t += '-' + b.pop();
	                                    break;
	                                case 12:
	                                    t += '-4';
	                                    break;
	                                case 16:
	                                    /* jshint -W016 */
	                                    // Unexpected use of '&' and '|'
	                                    t += '-' + (parseInt(b.pop(), 16) & 0x3 | 0x8).toString(16);
	                                    /* jshint +W016 */
	                                    break;
	                                case 20:
	                                    t += '-' + b.pop();
	                                    break;
	                                default:
	                                    t += b.pop();
	                            }
	                            return t;
	                        };
	                    };
	                    var seed = Seed();
	                    for (var i = 0; i < 32; i++) {
	                        uuid += seed(i);
	                    }
	                } else {
	                    // see http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
	                    uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	                        /* jshint -W016 */
	                        // Unexpected use of '&' and '|'
	                        var r = Math.random() * 16|0;
	                        var v = (c === 'x' ? r : (r & 0x3 | 0x8));
	                        return v.toString(16);
	                        /* jshint +W016 */
	                    });
	                }
	                return uuid;
	            },
	
	            /**
	             * Saves an oAuth state in session storage
	             * @param state
	             */
	            setState: function (state) {
	                assert.type(STRING, state, rapi.util.format(assert.messages.type.default, 'state', STRING)); // Note: we could consider an assert.match here
	                var storage = RX_IEXPLORE.test(navigator.userAgent) ? localStorage : sessionStorage; // use localStorage in IE
	                if (storage) {
	                    storage.setItem(STATE, state);
	                    logger.debug({
	                        message: 'state added to sessionStorage',
	                        method: 'util.setState',
	                        data: { state: state }
	                    });
	                }
	            },
	
	            /**
	             * Reads and clears the oAuth state from session storage
	             */
	            getState: function () {
	                var state;
	                var storage = RX_IEXPLORE.test(navigator.userAgent) ? localStorage : sessionStorage; // use localStorage in IE
	                if (storage) {
	                    state = storage.getItem(STATE);
	                    storage.removeItem(STATE);
	                    logger.debug({
	                        message: 'state read and cleared from sessionStorage',
	                        method: 'util.getState',
	                        data: { state: state }
	                    });
	                }
	                return state;
	            },
	
	            /**
	             * Get the position of the hash preceding the access_token
	             * @param location
	             * @returns {number}
	             */
	            getAccessTokenHashPos: function (location) {
	                assert.type(STRING, location, rapi.util.format(assert.messages.type.default, 'location', STRING));
	                return Math.max(
	                    location.indexOf(HASH + ACCESS_TOKEN), // Facebook and Google return access_token first
	                    location.indexOf(HASH + TOKEN_TYPE), // Windows Live returns token_type first
	                    location.indexOf(HASH + EXPIRES_IN), // Others might have them in a different order
	                    location.indexOf(HASH + STATE)
	                );
	            },
	
	            /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
	
	            /**
	             * Parse the access token into a Javascript object
	             * @param url
	             * @returns {{}}
	             */
	            parseToken: function (url) {
	                // When running tests with grunt.mochaTest, the url is a file url - file:///C:/Users/Jacques-Louis/Creative Cloud Files/Kidoju/Kidoju.Server/test/client/app.cache.test.html
	                // if (!app.DEBUG) {
	                //    assert.match(RX_URL, url, rapi.util.format(assert.messages.match.default, 'url', RX_URL));
	                // }
	                var pos1 = rapi.util.getAccessTokenHashPos(url);
	                var qs = {};
	                var token = {};
	                if (pos1 >= 0) {
	                    logger.debug({
	                        message: 'token found in url',
	                        method: 'parseToken',
	                        data: { url: url, pos: pos1 }
	                    });
	
	                    // remove any trailing # and split along &
	                    var keyValues = url.substr(pos1 + 1).split('#')[0].split('&');
	
	                    // then iterate through key=value pairs to pupulate qs, our querystring object
	                    $.each(keyValues, function (index, keyValue) {
	                        var pos2 = keyValue.indexOf(EQUALS);
	                        if (pos2 > 0 && pos2 < keyValue.length - EQUALS.length) {
	                            // Parse strings for numbers
	                            var str = decodeURIComponent(keyValue.substr(pos2 + EQUALS.length));
	                            var val = parseInt(str, 10);
	                            qs[keyValue.substr(0, pos2)] = (!isNaN(val) && (val.toString() === str)) ? val : str;
	                        }
	                    });
	
	                    // Check access_token
	                    // Note: We could not find any better rule to match access tokens from facebook, google, live and twitter
	                    var accessTokenCheck = ($.type(qs.access_token) === STRING && qs.access_token.length > 10);
	
	                    // Note: We could check expires (Google and Windows Live are 3600 = 60*60 = 1h amd Facebook and Twitter are 5184000 = 60*60*24*60 = 60d)
	
	                    // Check state
	                    // Note: rapi.util.getState() erases state, so it is not indempotent
	                    var stateCheck = (rapi.util.getState() === qs.state && qs.state.indexOf(rapi.util.getFingerPrint()) === 0);
	
	                    // Check timestamp
	                    var now = Date.now();
	                    // Note there might be a lag, therefore -30s is required
	                    var tsCheck = ((now - qs.ts > -30 * 1000) && (now - qs.ts < 5 * 60 * 1000));
	
	                    logger.debug({
	                        message: 'token verified',
	                        method: 'parseToken',
	                        data: { qs: qs, accessTokenCheck: accessTokenCheck, stateCheck: stateCheck, tsCheck: tsCheck }
	                    });
	
	                    if (accessTokenCheck && stateCheck && tsCheck) {
	                        // purge unwanted properties (especially state and token_type)
	                        // as stated in https://github.com/Memba/Kidoju-Server/issues/29
	                        token = {
	                            access_token: qs.access_token,
	                            expires: qs.expires,
	                            ts: qs.ts
	                        };
	                        // setToken in localStorage
	                        rapi.util.setToken(token);
	                        // Notify page
	                        setTimeout(function () { $(document).trigger(AUTHENTICATION_SUCCESS); }, 500);
	                    } else {
	                        // Let's simply discard any attempt to set a token that does not pass the checks here above
	                        rapi.util.clearToken();
	                        // Notify page
	                        setTimeout(function () { $(document).trigger(AUTHENTICATION_FAILURE); }, 500);
	                    }
	
	                }
	                return token; // only for unit tests because all we need is setToken in localStorage
	            },
	
	            /**
	             * Saves a token in local storage
	             * @param accessToken
	             */
	            setToken: function (token) {
	                assert.isPlainObject(token, rapi.util.format(assert.messages.isPlainObject.default, 'token'));
	                assert.type(STRING, token.access_token, rapi.util.format(assert.messages.type.default, 'token.access_token', STRING));
	                assert.type(NUMBER, token.expires, rapi.util.format(assert.messages.type.default, 'token.expires', STRING));
	                assert.type(NUMBER, token.ts, rapi.util.format(assert.messages.type.default, 'token.ts', STRING));
	                if (localStorage) {
	                    localStorage.setItem(TOKEN, JSON.stringify(token));
	                    logger.debug({
	                        message: 'token added to localStorage',
	                        method: 'util.setToken',
	                        data: { token: token }
	                    });
	                }
	            },
	
	            /* jscs:enable requireCamelCaseOrUpperCaseIdentifiers */
	
	            /**
	             * Read an access token from storage
	             * @returns {*}
	             */
	            getAccessToken: function () {
	                if (localStorage) {
	                    var token = JSON.parse(localStorage.getItem(TOKEN));
	                    if ((!token) || (token.ts && token.expires && token.ts + 1000 * token.expires < Date.now())) {
	                        if (token) {
	                            localStorage.removeItem(TOKEN);
	                            logger.debug({
	                                message: 'access token read from localStorage has expired',
	                                method: 'util.getAccessToken',
	                                data: { token: token }
	                            });
	                        }
	                        return null;
	                    }
	                    logger.debug({
	                        message: 'access token read from localStorage is still valid',
	                        method: 'util.getAccessToken',
	                        data: { token: token }
	                    });
	                    return token[ACCESS_TOKEN];
	                } else {
	                    logger.error({
	                        message: 'without localStorage support, signing in cannot work',
	                        method: 'util.getAccessToken'
	                    });
	                    return null;
	                }
	            },
	
	            /**
	             * Ensure a refreshed token before expiration
	             */
	            ensureToken: function () {
	                if (localStorage) {
	                    var token = JSON.parse(localStorage.getItem(TOKEN));
	                    if ($.isPlainObject(token) &&  token.expires <= 24 * 60 * 60) {
	                        // if we have a short life token (Google and Live), i.e. expires === 3600, read token every minute and refresh no later than 15 minutes before expiration
	                        setInterval(function () {
	                            // we need to read the token again because if we remain a couple of hours on the same page (e.g. test designer), the token might have already been refreshed
	                            token = JSON.parse(localStorage.getItem(TOKEN));
	                            if ($.isPlainObject(token) && (Date.now() > token.ts + (token.expires - 10 * 60) * 1000)) {
	                                app.rapi.oauth.refresh();
	                            }
	                        }, 60 * 1000);
	                    }
	                    /*
	                     } else if ($.isPlainObject(token) &&  token.expires > 24 * 60 * 60) {
	                     // if we have a long life token (Facebook and Twitter), refresh is not available and we need to reset the token upon page load
	                     if (Date.now() > token.ts + 1000 * token.expires - 7 * 24 * 60 * 60 * 1000) {
	                     // Ideally, we should trigger the redirection required to acquire a new token silently (without login screen)
	                     // See https://github.com/Memba/Kidoju-Server/issues/68
	                     }
	                     }
	                     */
	                } else {
	                    logger.error({
	                        message: 'without localStorage support, signing in cannot work',
	                        method: 'util.ensureToken'
	                    });
	                }
	            },
	
	            /**
	             * Clear (delete) an access token from storage
	             */
	            clearToken: function () {
	                if (localStorage) {
	                    localStorage.removeItem(TOKEN);
	                    logger.debug({
	                        message: 'token removed from localStorage',
	                        method: 'util.clearToken'
	                    });
	                }
	            },
	
	            /**
	             * Remove any token information from a url
	             * Check its use in rapi.getSignInUrl where returnUrl would normally be window.location.href
	             * In a browser, the whole authentication process redirects the browser to returnUrl#access_token=...
	             * When authenticating again from this location, one would keep adding #access_token=... to the returnUrl, thus a requirement for cleaning it
	             * @param url
	             * @returns {*}
	             */
	            cleanUrl: function (url) {
	                // assert.match(RX_URL, url, rapi.util.format(assert.messages.match.default, 'url', RX_URL));
	                var ret = url;
	                var pos = rapi.util.getAccessTokenHashPos(url);
	                if (pos >= 0) {
	                    ret = ret.substring(0, pos);
	                }
	                if (ret.slice(-1) === HASH) { // remove trailing hash if any
	                    ret = ret.substring(0, ret.length - 1);
	                }
	                return ret;
	            },
	
	            /**
	             * Clean the history from token information
	             */
	            cleanHistory: function () {
	                var pos = rapi.util.getAccessTokenHashPos(location.hash);
	                if (pos >= 0) {
	                    if (history) {
	                        history.replaceState({}, document.title, location.pathname + location.hash.substr(0, pos));
	                    } else {
	                        location.hash = location.hash.substr(0, pos); // for older browsers, might leave a # behind
	                    }
	                }
	            },
	
	            /**
	             * Get headers for $.ajax calls
	             * @param options
	             * @returns {*}
	             */
	            getHeaders: function (options) {
	                assert.isPlainObject(options, rapi.util.format(assert.messages.isPlainObject.default, 'options'));
	                var headers = {};
	                if (options.security === true) {
	                    var accessToken = rapi.util.getAccessToken();
	                    if (typeof accessToken === STRING) {
	                        headers.Authorization = 'Bearer ' + accessToken;
	                    }
	                }
	                if (options.trace === true) {
	                    var trace = $('#trace').val();
	                    if (typeof trace === STRING) {
	                        headers['X-Trace-ID'] = trace.substr(0, 40); // should be long enough for a guid
	                    }
	                }
	                return headers;
	            }
	        };
	
	        /**
	         * Simple test functions
	         * @type {{getVersion: getVersion, getHeartbeat: getHeartbeat}}
	         */
	        rapi.test = {
	
	            /**
	             * Checks a ping (return true or false)
	             * @returns {*}
	             */
	            ping: function () {
	                logger.debug({
	                    message: '$.ajax',
	                    method: 'test.ping'
	                });
	                var dfd = new $.Deferred();
	                $.ajax({
	                    cache: false,
	                    headers: rapi.util.getHeaders({ trace: true }),
	                    type: GET,
	                    url: uris.rapi.root + uris.rapi.ping
	                }).done(function () {
	                    dfd.resolve(arguments[0].hasOwnProperty('ping') && arguments[0].ping === 'OK');
	                }).fail(function () {
	                    dfd.resolve(false);
	                });
	                return dfd.promise();
	            },
	
	            /**
	             * Return a successful promise
	             * Like $.noop(), used temporarily in development
	             * @returns {*}
	             */
	            dummyResolvedDeferred: function () {
	                logger.debug({
	                    message: 'dummy request',
	                    method: 'test.dummyResolvedDeferred'
	                });
	                var deferred = $.Deferred();
	                setTimeout(function () {
	                    deferred.resolve({ total: 0, data: [] });
	                }, 50);
	                return deferred.promise();
	            },
	
	            /**
	             * Return a failing promise
	             * Like $.noop(), used temporarily in development
	             * @returns {*}
	             */
	            dummyRejectedDeferred: function () {
	                logger.debug({
	                    message: 'dummy request',
	                    method: 'test.dummyRejectedDeferred'
	                });
	                var deferred = $.Deferred();
	                setTimeout(function () {
	                    deferred.reject(null, 0, 'Failed');
	                }, 50);
	                return deferred.promise();
	            }
	
	        };
	
	        /**
	         * oAuth authentication
	         * @type {{getSignInUrl: Function, signOut: Function, revoke: Function}}
	         */
	        rapi.oauth = {
	
	            /**
	             * Returns the authentication provider URL to call for signing in
	             * @param provider
	             * @param returnUrl
	             * @returns {*}
	             */
	            getSignInUrl: function (provider, returnUrl) {
	                assert.enum(PROVIDERS, provider, rapi.util.format(assert.messages.enum.default, 'provider', PROVIDERS));
	                assert.match(RX_URL, returnUrl, rapi.util.format(assert.messages.match.default, 'returnUrl', RX_URL));
	                logger.info({
	                    message: '$.ajax',
	                    method: 'auth.getSignInUrl',
	                    data: { provider: provider, returnUrl: returnUrl }
	                });
	                var ajax = $.Deferred();
	                var logout = $.Deferred();
	                if (provider === 'live') {
	                    // logout from Live to force a login screen (no need to clean up because there should be a redirection)
	                    var iframe = $('#live-logout');
	                    if (iframe.length) {
	                        iframe.attr('src', 'https://login.live.com/oauth20_logout.srf');
	                    } else {
	                        $('<iframe id="live-logout" src="https://login.live.com/oauth20_logout.srf" style="position: absolute; left: -1000px; visibility: hidden;"></iframe>').appendTo('body');
	                    }
	                    $('#live-logout').on('load', function () { logout.resolve(); });
	                } else {
	                    logout.resolve();
	                }
	                logout.promise().always(function () {
	                    var state = rapi.util.getFingerPrint() + '-' + rapi.util.uuid();
	                    rapi.util.setState(state);
	                    $.ajax({
	                        cache: false,
	                        data: {
	                            returnUrl: rapi.util.cleanUrl(returnUrl),
	                            state: state
	                        },
	                        headers: rapi.util.getHeaders({ trace: true }),
	                        type: GET,
	                        url: rapi.util.format(uris.rapi.root + uris.rapi.oauth.signIn, provider)
	                    }).done(ajax.resolve).fail(ajax.reject);
	                });
	                return ajax;
	            },
	
	            /**
	             * Sign out
	             * @returns {*}
	             */
	            signOut: function () {
	                logger.info({
	                    message: '$.ajax',
	                    method: 'auth.signout'
	                });
	                return $.ajax({
	                    contentType: FORM_CONTENT_TYPE,
	                    headers: rapi.util.getHeaders({ security: true, trace: true }),
	                    type: POST,
	                    url: uris.rapi.root + uris.rapi.oauth.signOut
	                }).always(function () {
	                    rapi.util.clearToken();
	                });
	            },
	
	            /**
	             * Refresh token
	             * @returns {*}
	             */
	            refresh: function () {
	                logger.info({
	                    message: '$.ajax',
	                    method: 'auth.refresh'
	                });
	                return $.ajax({
	                    cache: false,
	                    headers: rapi.util.getHeaders({ security: true, trace: true }),
	                    type: GET,
	                    url: uris.rapi.root + uris.rapi.oauth.refresh
	                }).done(function (token) {
	                    rapi.util.setToken(token);
	                }).fail(function () {
	                    rapi.util.clearToken();
	                });
	            },
	
	            /**
	             * Revoke
	             * @returns {*}
	             */
	            revoke: function () {
	                logger.info({
	                    message: '$.ajax',
	                    method: 'auth.revoke'
	                });
	                return $.ajax({
	                    contentType: FORM_CONTENT_TYPE,
	                    headers: rapi.util.getHeaders({ security: true, trace: true }),
	                    type: POST,
	                    url: uris.rapi.root + uris.rapi.oauth.revoke
	                }).always(function () {
	                    rapi.util.clearToken();
	                });
	            }
	
	        };
	
	        /**
	         * API version 1
	         * @type {{user: {getUser: Function, getMe: Function, updateMe: Function, getAllMyFavourites: Function, createMyFavourite: Function, deleteMyFavourite: Function, findMySummaries: Function, findMyActivities: Function}, taxonomy: {getAllLanguages: Function, getLanguage: Function, getAllCategories: Function}, content: {createSummary: Function, findSummaries: Function, getSummary: Function, updateSummary: Function, deleteSummary: Function, executeCommand: Function, findSummaryVersions: Function, getSummaryVersion: Function, getCurrentSummaryVersion: Function, updateSummaryVersion: Function, deleteSummaryVersion: Function, createSummaryActivity: Function, findSummaryActivities: Function, getSummaryActivity: Function, updateSummaryActivity: Function, deleteSummaryActivity: Function}}}
	         */
	        rapi.v1 = {
	
	            /**
	             * User profile, summaries and activities
	             */
	            user: {
	
	                /**
	                 * Get a public user profile
	                 * @param userId
	                 * @returns {*}
	                 */
	                getUser: function (userId) {
	                    assert.match(RX_MONGODB_ID, userId, rapi.util.format(assert.messages.match.default, 'userId', RX_MONGODB_ID));
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.user.getUser',
	                        data: { userId: userId }
	                    });
	                    return $.ajax({
	                        cache: false,
	                        headers: rapi.util.getHeaders({ trace: true }),
	                        type: GET,
	                        url: uris.rapi.root + rapi.util.format(uris.rapi.v1.user, userId)
	                    });
	                },
	
	                /**
	                 * Get me (the authenticated user)
	                 * @param querystring
	                 * @returns {*}
	                 */
	                getMe: function (querystring) {
	                    assert.isOptionalObject(querystring, rapi.util.format(assert.messages.isOptionalObject.default, 'querystring'));
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.user.getMe',
	                        data: { qs: querystring }
	                    });
	                    return $.ajax({
	                        cache: false,
	                        data: querystring,
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: GET,
	                        url: uris.rapi.root + uris.rapi.v1.me
	                    });
	                },
	
	                /**
	                 * Update me (the authenticated user)
	                 * @param user
	                 * @returns {*}
	                 */
	                updateMe: function (user) {
	                    assert.isPlainObject(user, rapi.util.format(assert.messages.isPlainObject.default, 'user'));
	                    // Note: considering we allow partial updates, we cannot check user properties here
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.user.updateMe',
	                        data: { user: user }
	                    });
	                    return $.ajax({
	                        contentType: JSON_CONTENT_TYPE,
	                        data: JSON.stringify(user),
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: PUT,
	                        url: uris.rapi.root + uris.rapi.v1.me
	                    });
	                },
	
	                /**
	                 * Get current user's list of favourites
	                 * @param language
	                 * @returns {*}
	                 */
	                getAllMyFavourites: function (language) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.user.getAllMyFavourites',
	                        data: { language: language }
	                    });
	                    return $.ajax({
	                        cache: false,
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: GET,
	                        url: uris.rapi.root  + rapi.util.format(uris.rapi.v1.myFavourites, language)
	                    });
	                },
	
	                /**
	                 * Create a new favourite
	                 * @param language
	                 * @param favourite ()
	                 */
	                createMyFavourite: function (language, favourite) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.isPlainObject(favourite, rapi.util.format(assert.messages.isPlainObject.default, 'favourite'));
	                    assert.type(STRING, favourite.name, rapi.util.format(assert.messages.type.default, 'favourite.name', STRING));
	                    assert.type(STRING, favourite.path, rapi.util.format(assert.messages.type.default, 'favourite.path', STRING));
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.user.createMyFavourite',
	                        data: { language: language, favourite: favourite }
	                    });
	                    return $.ajax({
	                        contentType: JSON_CONTENT_TYPE,
	                        data: JSON.stringify(favourite),
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: POST,
	                        url: uris.rapi.root  + rapi.util.format(uris.rapi.v1.myFavourites, language)
	                    });
	                },
	
	                /**
	                 * delete a favourite
	                 * @param language
	                 * @param favouriteId
	                 */
	                deleteMyFavourite: function (language, favouriteId) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, favouriteId, rapi.util.format(assert.messages.match.default, 'favouriteId', RX_MONGODB_ID));
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.user.deleteMyFavourite',
	                        data: { language: language, favouriteId: favouriteId }
	                    });
	                    return $.ajax({
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: DELETE,
	                        url: uris.rapi.root + rapi.util.format(uris.rapi.v1.myFavourite, language, favouriteId)
	                    });
	                },
	
	                /**
	                 * Find the authenticated users' summaries
	                 * IMPORTANT: includes non-published drafts
	                 * @param language
	                 * @param querystring
	                 * @returns {*}
	                 */
	                findMySummaries: function (language, querystring) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.isOptionalObject(querystring, rapi.util.format(assert.messages.isOptionalObject.default, 'querystring'));
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.user.findMySummaries',
	                        data: { language: language, qs: querystring }
	                    });
	                    return $.ajax({
	                        cache: false,
	                        data: querystring,
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: GET,
	                        url: uris.rapi.root + rapi.util.format(uris.rapi.v1.mySummaries, language)
	                    });
	                },
	
	                /**
	                 * Find the authenticated users' activities
	                 * @param language
	                 * @param querystring
	                 * @returns {*}
	                 */
	                findMyActivities: function (language, querystring) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.isOptionalObject(querystring, rapi.util.format(assert.messages.isOptionalObject.default, 'querystring'));
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.user.findMyActivities',
	                        data: { language: language, qs: querystring }
	                    });
	                    return $.ajax({
	                        cache: false,
	                        data: querystring,
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: GET,
	                        url: uris.rapi.root + rapi.util.format(uris.rapi.v1.myActivities, language)
	                    });
	                }
	            },
	
	            /**
	             * Languages and categories
	             */
	            taxonomy: {
	
	                /**
	                 * Get all languages with categories
	                 * @returns {*}
	                 */
	                getAllLanguages: function () {
	                    var url = uris.rapi.root + uris.rapi.v1.allLanguages;
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.taxonomy.getAllLanguages',
	                        data: { url: url }
	                    });
	                    return $.ajax({
	                        cache: true,
	                        headers: rapi.util.getHeaders({ trace: true }),
	                        type: GET,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Get a language - not very useful except to check that a language has categories
	                 * @param language
	                 * @returns {*}
	                 */
	                getLanguage: function (language) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.language, language);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.taxonomy.getLanguage',
	                        data: { url: url }
	                    });
	                    return $.ajax({
	                        cache: true,
	                        headers: rapi.util.getHeaders({ trace: true }),
	                        type: GET,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Get all categories for a language designated by its isoCode
	                 * @param language
	                 * @returns {*}
	                 */
	                getAllCategories: function (language) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.categories, language);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.taxonomy.getAllCategories',
	                        data: { url: url }
	                    });
	                    return $.ajax({
	                        cache: true,
	                        headers: rapi.util.getHeaders({ trace: true }),
	                        type: GET,
	                        url: url
	                    });
	                }
	            },
	
	            /**
	             * Summaries and activities
	             */
	            content: {
	
	                /**
	                 * Create a new summary
	                 * @param language
	                 * @param summary
	                 */
	                createSummary: function (language, summary) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.isPlainObject(summary, rapi.util.format(assert.messages.isPlainObject.default, 'summary'));
	                    // Note: we might want to check that this summary object has the required properties for a creation
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.summaries, language);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.createSummary',
	                        data: { url: url, summary: summary }
	                    });
	                    return $.ajax({
	                        contentType: JSON_CONTENT_TYPE,
	                        data: JSON.stringify(summary),
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: POST,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Find summaries
	                 * @param language
	                 * @param querystring
	                 */
	                findSummaries: function (language, querystring) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.isOptionalObject(querystring, rapi.util.format(assert.messages.isOptionalObject.default, 'querystring'));
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.summaries, language);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.findSummaries',
	                        data: { url: url, qs: querystring }
	                    });
	                    return $.ajax({
	                        cache: false,
	                        data: querystring,
	                        headers: rapi.util.getHeaders({ trace: true }),
	                        type: GET,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Get a summary by its summaryId
	                 * @param language
	                 * @param summaryId
	                 * @param querystring
	                 * @returns {*}
	                 */
	                getSummary: function (language, summaryId, querystring) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, summaryId, rapi.util.format(assert.messages.match.default, 'summaryId', RX_MONGODB_ID));
	                    assert.isOptionalObject(querystring, rapi.util.format(assert.messages.isOptionalObject.default, 'querystring'));
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.summary, language, summaryId);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.getSummary',
	                        data: { url: url, qs: querystring }
	                    });
	                    return $.ajax({
	                        cache: false,
	                        data: querystring,
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: GET,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Update a summary by its summaryId
	                 * @param language
	                 * @param summaryId
	                 * @param summary
	                 * @returns {*}
	                 */
	                updateSummary: function (language, summaryId, summary) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, summaryId, rapi.util.format(assert.messages.match.default, 'summaryId', RX_MONGODB_ID));
	                    assert.isPlainObject(summary, rapi.util.format(assert.messages.isPlainObject.default, 'summary'));
	                    // Note: considering we allow partial updates, we cannot check summary properties here
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.summary, language, summaryId);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.updateSummary',
	                        data: { url: url, summary: summary }
	                    });
	                    return $.ajax({
	                        contentType: JSON_CONTENT_TYPE,
	                        data:  JSON.stringify(summary),
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: PUT,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Delete a summary by its summaryId
	                 * @param language
	                 * @param summaryId
	                 * @returns {*}
	                 */
	                deleteSummary: function (language, summaryId) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, summaryId, rapi.util.format(assert.messages.match.default, 'summaryId', RX_MONGODB_ID));
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.summary, language, summaryId);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.deleteSummary',
	                        data: { url: url, summaryId: summaryId }
	                    });
	                    return $.ajax({
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: DELETE,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Execute a command
	                 * an exec is an object with a command and options
	                 * @param language
	                 * @param summaryId
	                 * @param exec
	                 * @returns {*}
	                 */
	                executeCommand: function (language, summaryId, exec) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, summaryId, rapi.util.format(assert.messages.match.default, 'summaryId', RX_MONGODB_ID));
	                    assert.isPlainObject(exec, rapi.util.format(assert.messages.isPlainObject.default, 'exec'));
	                    assert.enum(COMMANDS, exec.command, rapi.util.format(assert.messages.enum.default, 'exec.command', COMMANDS));
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.versions, language, summaryId);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.executeCommand',
	                        data: { url: url, exec: exec }
	                    });
	                    return $.ajax({
	                        contentType: JSON_CONTENT_TYPE,
	                        data: JSON.stringify(exec),
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: POST,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Find summary versions
	                 * Note: careful when including streams!!!!
	                 * @param language
	                 * @param summaryId
	                 * @param querystring
	                 */
	                findSummaryVersions: function (language, summaryId, querystring) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, summaryId, rapi.util.format(assert.messages.match.default, 'summaryId', RX_MONGODB_ID));
	                    assert.isOptionalObject(querystring, rapi.util.format(assert.messages.isOptionalObject.default, 'querystring'));
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.versions, language, summaryId);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.findSummaryVersions',
	                        data: { url: url, qs: querystring }
	                    });
	                    return $.ajax({
	                        cache: false,
	                        data: querystring,
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: GET,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Get a summary version (including stream)
	                 * @param language
	                 * @param summaryId
	                 * @param versionId
	                 * @param querystring
	                 */
	                getSummaryVersion: function (language, summaryId, versionId, querystring) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, summaryId, rapi.util.format(assert.messages.match.default, 'summaryId', RX_MONGODB_ID));
	                    assert.match(RX_MONGODB_ID, versionId, rapi.util.format(assert.messages.match.default, 'versionId', RX_MONGODB_ID));
	                    assert.isOptionalObject(querystring, rapi.util.format(assert.messages.isOptionalObject.default, 'querystring'));
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.version, language, summaryId, versionId);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.getSummaryVersion',
	                        data: { url: url, qs: querystring }
	                    });
	                    return $.ajax({
	                        cache: false,
	                        data: querystring,
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: GET,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Get the current (published) summary version
	                 * @param language
	                 * @param summaryId
	                 */
	                getCurrentSummaryVersion: function (language, summaryId/*,querystring*/) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, summaryId, rapi.util.format(assert.messages.match.default, 'summaryId', RX_MONGODB_ID));
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.version, language, summaryId);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.getCurrentSummaryVersion',
	                        data: { url: url }
	                    });
	                    return $.ajax({
	                        cache: false,
	                        // data: querystring,
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: GET,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Update a summary version
	                 * @param language
	                 * @param summaryId
	                 * @param versionId
	                 * @param version
	                 * @returns {*}
	                 */
	                updateSummaryVersion: function (language, summaryId, versionId, version) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, summaryId, rapi.util.format(assert.messages.match.default, 'summaryId', RX_MONGODB_ID));
	                    assert.match(RX_MONGODB_ID, versionId, rapi.util.format(assert.messages.match.default, 'versionId', RX_MONGODB_ID));
	                    assert.isPlainObject(version, rapi.util.format(assert.messages.isPlainObject.default, 'version'));
	                    // Note: considering we allow partial updates, we cannot check version properties here
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.version, language, summaryId, versionId);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.updateSummaryVersion',
	                        data: { url: url, version: version }
	                    });
	                    return $.ajax({
	                        contentType: JSON_CONTENT_TYPE,
	                        data: JSON.stringify(version),
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: PUT,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Delete a summary version
	                 * @param language
	                 * @param summaryId
	                 * @param versionId
	                 * @returns {*}
	                 */
	                deleteSummaryVersion: function (language, summaryId, versionId) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, summaryId, rapi.util.format(assert.messages.match.default, 'summaryId', RX_MONGODB_ID));
	                    assert.match(RX_MONGODB_ID, versionId, rapi.util.format(assert.messages.match.default, 'versionId', RX_MONGODB_ID));
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.version, language, summaryId, versionId);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.deleteSummaryVersion',
	                        data: { url: url }
	                    });
	                    return $.ajax({
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: DELETE,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Create summary activity
	                 * @param language
	                 * @param summaryId
	                 * @param querystring
	                 */
	                createSummaryActivity: function (language, summaryId, activity) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, summaryId, rapi.util.format(assert.messages.match.default, 'summaryId', RX_MONGODB_ID));
	                    assert.isPlainObject(activity, rapi.util.format(assert.messages.isPlainObject.default, 'activity'));
	                    // Note: we might want to check that this activity object has the required properties for a creation
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.activities, language, summaryId);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.createSummaryActivity',
	                        data: { url: url, activity: activity }
	                    });
	                    return $.ajax({
	                        contentType: JSON_CONTENT_TYPE,
	                        data: JSON.stringify(activity),
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: POST,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Find summary activities
	                 * @param language
	                 * @param summaryId
	                 * @param querystring
	                 */
	                findSummaryActivities: function (language, summaryId, querystring) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, summaryId, rapi.util.format(assert.messages.match.default, 'summaryId', RX_MONGODB_ID));
	                    assert.isOptionalObject(querystring, rapi.util.format(assert.messages.isOptionalObject.default, 'querystring'));
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.activities, language, summaryId);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.findSummaryActivities',
	                        data: { url: url, qs: querystring }
	                    });
	                    return $.ajax({
	                        cache: false,
	                        data: querystring,
	                        headers: rapi.util.getHeaders({ trace: true }),
	                        type: GET,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Get a summary activity
	                 * @param language
	                 * @param summaryId
	                 * @param activityId
	                 * @param querystring
	                 * @returns {*}
	                 */
	                getSummaryActivity: function (language, summaryId, activityId, querystring) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, summaryId, rapi.util.format(assert.messages.match.default, 'summaryId', RX_MONGODB_ID));
	                    assert.match(RX_MONGODB_ID, activityId, rapi.util.format(assert.messages.match.default, 'activityId', RX_MONGODB_ID));
	                    assert.isOptionalObject(querystring, rapi.util.format(assert.messages.isOptionalObject.default, 'querystring'));
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.activity, language, summaryId, activityId);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.getSummaryActivity',
	                        data: { url: url, qs: querystring }
	                    });
	                    return $.ajax({
	                        cache: false,
	                        data: querystring,
	                        headers: rapi.util.getHeaders({ trace: true }),
	                        type: GET,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Update a summary activity
	                 * @param language
	                 * @param summaryId
	                 * @param activityId
	                 * @param activity
	                 * @returns {*}
	                 */
	                updateSummaryActivity: function (language, summaryId, activityId, activity) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, summaryId, rapi.util.format(assert.messages.match.default, 'summaryId', RX_MONGODB_ID));
	                    assert.match(RX_MONGODB_ID, activityId, rapi.util.format(assert.messages.match.default, 'activityId', RX_MONGODB_ID));
	                    assert.isPlainObject(activity, rapi.util.format(assert.messages.isPlainObject.default, 'activity'));
	                    // Note: considering we allow partial updates, we cannot check activity properties here
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.activity, language, summaryId, activityId);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.updateSummaryActivity',
	                        data: { url: url, activity: activity }
	                    });
	                    return $.ajax({
	                        contentType: JSON_CONTENT_TYPE,
	                        data: JSON.stringify(activity),
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: PUT,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Delete a summary activity
	                 * @param language
	                 * @param summaryId
	                 * @param activityId
	                 * @returns {*}
	                 */
	                deleteSummaryActivity: function (language, summaryId, activityId) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, summaryId, rapi.util.format(assert.messages.match.default, 'summaryId', RX_MONGODB_ID));
	                    assert.match(RX_MONGODB_ID, activityId, rapi.util.format(assert.messages.match.default, 'activityId', RX_MONGODB_ID));
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.activity, language, summaryId, activityId);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.deleteSummaryActivity',
	                        data: { url: url }
	                    });
	                    return $.ajax({
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: DELETE,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Get a pre-signed url to upload summary files to Amazon S3
	                 * @param language
	                 * @param summaryId
	                 * @param file
	                 */
	                getUploadUrl: function (language, summaryId, file) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, summaryId, rapi.util.format(assert.messages.match.default, 'summaryId', RX_MONGODB_ID));
	                    if (!app.DEBUG) {
	                        // Note: when running unit tests, file is not an instance of window.File
	                        // See also https://developer.mozilla.org/en-US/docs/Using_files_from_web_applications
	                        assert.instanceof(window.File, file, rapi.util.format(assert.messages.instanceof.default, 'file', 'File'));
	                    }
	                    // Convert name for compatibility with dbutils.checkNoSQLInjection
	                    var fileName = file.name; // .toLowerCase();
	                    var pos = fileName.lastIndexOf('.');
	                    // In fileName.substr(0, pos), dots among other characters shall be replaced by underscores
	                    // We shall keep path delimiters (\, /) though and they shall fail server side
	                    // Then we trim underscores at both ends
	                    var s3Name = fileName.substr(0, pos).replace(/[^a-z0-9\\\/]+/gi, '_').replace(/(^_|_$)/, '') + '.' + fileName.substr(pos + 1);
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.upload, language, summaryId);
	                    // Log
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.getUploadUrl',
	                        data: { url: url, fileName: file.name, s3Name: s3Name, type: file.type, size: file.size }
	                    });
	                    // $.ajax
	                    return $.ajax({
	                        data: { file: s3Name, type: file.type, size: file.size },
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: GET,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Upload a file to a signed url
	                 * @param signedUrl
	                 * @param file
	                 */
	                uploadFile: function (signedUrl, file) {
	                    assert.match(RX_URL, signedUrl, rapi.util.format(assert.messages.match.default, 'signedUrl', RX_URL));
	                    assert.instanceof(window.File, file, rapi.util.format(assert.messages.instanceof.default, 'file', 'File'));
	                    var dfd = $.Deferred();
	                    // See http://stackoverflow.com/questions/11448578/how-to-send-binary-data-via-jquery-ajax-put-method
	                    // See http://stackoverflow.com/questions/5392344/sending-multipart-formdata-with-jquery-ajax
	                    // Log
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.uploadFile',
	                        data: { url: signedUrl, fileName: file.name, type: file.type, size: file.size }
	                    });
	                    // $.ajax
	                    $.ajax({
	                            contentType : file.type,
	                            data : file,
	                            headers: {
	                                // See http://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPUT.html
	                                // Should match the headers in the signed url
	                                'x-amz-acl': 'public-read',
	                                'cache-control': 'public, max-age=7776000, s-maxage=604800',
	                                'content-type': file.type // ,
	                                // 'content-length': file.length // <-- does not work
	                            },
	                            processData : false,
	                            type : 'PUT',
	                            url : signedUrl
	                        })
	                        .done(function () {
	                            // Note, we use a deferred to return the url of the uploaded file
	                            dfd.resolve({
	                                name: file.name,
	                                size: file.size,
	                                type: file.type,
	                                url: signedUrl.substr(0, signedUrl.indexOf('?'))
	                            });
	                        })
	                        .fail(dfd.reject);
	                    return dfd.promise();
	                },
	
	                /**
	                 * List all files for a summary designated by its id
	                 * @param language
	                 * @param summaryId
	                 */
	                getAllSummaryFiles: function (language, summaryId) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, summaryId, rapi.util.format(assert.messages.match.default, 'summaryId', RX_MONGODB_ID));
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.files, language, summaryId);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.getAllSummaryFiles',
	                        data: { url: url }
	                    });
	                    return $.ajax({
	                        headers: rapi.util.getHeaders({ trace: true }),
	                        type: GET,
	                        url: url
	                    });
	                },
	
	                /**
	                 * Delete a file designated by its id === name
	                 * @param language
	                 * @param summaryId
	                 * @param fileId
	                 * @returns {*}
	                 */
	                deleteFile: function (language, summaryId, fileId) {
	                    assert.match(RX_LANGUAGE, language, rapi.util.format(assert.messages.match.default, 'language', RX_LANGUAGE));
	                    assert.match(RX_MONGODB_ID, summaryId, rapi.util.format(assert.messages.match.default, 'summaryId', RX_MONGODB_ID));
	                    // assert.match(RX_MONGODB_ID, fileId, rapi.util.format(assert.messages.match.default, 'fileId', RX_MONGODB_ID));
	                    var url = uris.rapi.root + rapi.util.format(uris.rapi.v1.file, language, summaryId, fileId);
	                    logger.info({
	                        message: '$.ajax',
	                        method: 'v1.content.deleteFile',
	                        data: { url: url }
	                    });
	                    return $.ajax({
	                        headers: rapi.util.getHeaders({ security: true, trace: true }),
	                        type: DELETE,
	                        url: url
	                    });
	                }
	            }
	        };
	
	        /**
	         * When html page is loaded, detect and parse #access_token (see oAuth callback)
	         * CAREFUL: getHeaders({ security: true, trace: true }) is therefore not available until the HTML page is fully loaded!
	         */
	        $(function () {
	            if (!(chrome && $.isEmptyObject(chrome.app))) { // avoids an error in chrome packaged apps
	                rapi.util.parseToken(location.href);
	                rapi.util.cleanHistory();
	            }
	            rapi.util.ensureToken();
	        });
	
	    }(window.jQuery));
	
	    /* jshint +W071 */
	
	    return window.app;
	
	}, __webpack_require__(200));


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	* fingerprintJS 0.5.3 - Fast browser fingerprint library
	* https://github.com/Valve/fingerprintjs
	* Copyright (c) 2013 Valentin Vasilyev (valentin.vasilyev@outlook.com)
	* Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.
	*
	* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	* ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	;(function (name, context, definition) {
	  if (typeof module !== 'undefined' && module.exports) { module.exports = definition(); }
	  else if (true) { !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); }
	  else { context[name] = definition(); }
	})('Fingerprint', this, function () {
	  'use strict';
	  
	  var Fingerprint = function (options) {
	    var nativeForEach, nativeMap;
	    nativeForEach = Array.prototype.forEach;
	    nativeMap = Array.prototype.map;
	
	    this.each = function (obj, iterator, context) {
	      if (obj === null) {
	        return;
	      }
	      if (nativeForEach && obj.forEach === nativeForEach) {
	        obj.forEach(iterator, context);
	      } else if (obj.length === +obj.length) {
	        for (var i = 0, l = obj.length; i < l; i++) {
	          if (iterator.call(context, obj[i], i, obj) === {}) return;
	        }
	      } else {
	        for (var key in obj) {
	          if (obj.hasOwnProperty(key)) {
	            if (iterator.call(context, obj[key], key, obj) === {}) return;
	          }
	        }
	      }
	    };
	
	    this.map = function(obj, iterator, context) {
	      var results = [];
	      // Not using strict equality so that this acts as a
	      // shortcut to checking for `null` and `undefined`.
	      if (obj == null) return results;
	      if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
	      this.each(obj, function(value, index, list) {
	        results[results.length] = iterator.call(context, value, index, list);
	      });
	      return results;
	    };
	
	    if (typeof options == 'object'){
	      this.hasher = options.hasher;
	      this.screen_resolution = options.screen_resolution;
	      this.canvas = options.canvas;
	      this.ie_activex = options.ie_activex;
	    } else if(typeof options == 'function'){
	      this.hasher = options;
	    }
	  };
	
	  Fingerprint.prototype = {
	    get: function(){
	      var keys = [];
	      keys.push(navigator.userAgent);
	      keys.push(navigator.language);
	      keys.push(screen.colorDepth);
	      if (this.screen_resolution) {
	        var resolution = this.getScreenResolution();
	        if (typeof resolution !== 'undefined'){ // headless browsers, such as phantomjs
	          keys.push(this.getScreenResolution().join('x'));
	        }
	      }
	      keys.push(new Date().getTimezoneOffset());
	      keys.push(this.hasSessionStorage());
	      keys.push(this.hasLocalStorage());
	      keys.push(!!window.indexedDB);
	      //body might not be defined at this point or removed programmatically
	      if(document.body){
	        keys.push(typeof(document.body.addBehavior));
	      } else {
	        keys.push(typeof undefined);
	      }
	      keys.push(typeof(window.openDatabase));
	      keys.push(navigator.cpuClass);
	      keys.push(navigator.platform);
	      keys.push(navigator.doNotTrack);
	      keys.push(this.getPluginsString());
	      if(this.canvas && this.isCanvasSupported()){
	        keys.push(this.getCanvasFingerprint());
	      }
	      if(this.hasher){
	        return this.hasher(keys.join('###'), 31);
	      } else {
	        return this.murmurhash3_32_gc(keys.join('###'), 31);
	      }
	    },
	
	    /**
	     * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)
	     * 
	     * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
	     * @see http://github.com/garycourt/murmurhash-js
	     * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
	     * @see http://sites.google.com/site/murmurhash/
	     * 
	     * @param {string} key ASCII only
	     * @param {number} seed Positive integer only
	     * @return {number} 32-bit positive integer hash 
	     */
	
	    murmurhash3_32_gc: function(key, seed) {
	      var remainder, bytes, h1, h1b, c1, c2, k1, i;
	      
	      remainder = key.length & 3; // key.length % 4
	      bytes = key.length - remainder;
	      h1 = seed;
	      c1 = 0xcc9e2d51;
	      c2 = 0x1b873593;
	      i = 0;
	      
	      while (i < bytes) {
	          k1 = 
	            ((key.charCodeAt(i) & 0xff)) |
	            ((key.charCodeAt(++i) & 0xff) << 8) |
	            ((key.charCodeAt(++i) & 0xff) << 16) |
	            ((key.charCodeAt(++i) & 0xff) << 24);
	        ++i;
	        
	        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
	        k1 = (k1 << 15) | (k1 >>> 17);
	        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;
	
	        h1 ^= k1;
	            h1 = (h1 << 13) | (h1 >>> 19);
	        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
	        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
	      }
	      
	      k1 = 0;
	      
	      switch (remainder) {
	        case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
	        case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
	        case 1: k1 ^= (key.charCodeAt(i) & 0xff);
	        
	        k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
	        k1 = (k1 << 15) | (k1 >>> 17);
	        k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
	        h1 ^= k1;
	      }
	      
	      h1 ^= key.length;
	
	      h1 ^= h1 >>> 16;
	      h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
	      h1 ^= h1 >>> 13;
	      h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
	      h1 ^= h1 >>> 16;
	
	      return h1 >>> 0;
	    },
	
	    // https://bugzilla.mozilla.org/show_bug.cgi?id=781447
	    hasLocalStorage: function () {
	      try{
	        return !!window.localStorage;
	      } catch(e) {
	        return true; // SecurityError when referencing it means it exists
	      }
	    },
	    
	    hasSessionStorage: function () {
	      try{
	        return !!window.sessionStorage;
	      } catch(e) {
	        return true; // SecurityError when referencing it means it exists
	      }
	    },
	
	    isCanvasSupported: function () {
	      var elem = document.createElement('canvas');
	      return !!(elem.getContext && elem.getContext('2d'));
	    },
	
	    isIE: function () {
	      if(navigator.appName === 'Microsoft Internet Explorer') {
	        return true;
	      } else if(navigator.appName === 'Netscape' && /Trident/.test(navigator.userAgent)){// IE 11
	        return true;
	      }
	      return false;
	    },
	
	    getPluginsString: function () {
	      if(this.isIE() && this.ie_activex){
	        return this.getIEPluginsString();
	      } else {
	        return this.getRegularPluginsString();
	      }
	    },
	
	    getRegularPluginsString: function () {
	      return this.map(navigator.plugins, function (p) {
	        var mimeTypes = this.map(p, function(mt){
	          return [mt.type, mt.suffixes].join('~');
	        }).join(',');
	        return [p.name, p.description, mimeTypes].join('::');
	      }, this).join(';');
	    },
	
	    getIEPluginsString: function () {
	      if(window.ActiveXObject){
	        var names = ['ShockwaveFlash.ShockwaveFlash',//flash plugin
	          'AcroPDF.PDF', // Adobe PDF reader 7+
	          'PDF.PdfCtrl', // Adobe PDF reader 6 and earlier, brrr
	          'QuickTime.QuickTime', // QuickTime
	          // 5 versions of real players
	          'rmocx.RealPlayer G2 Control',
	          'rmocx.RealPlayer G2 Control.1',
	          'RealPlayer.RealPlayer(tm) ActiveX Control (32-bit)',
	          'RealVideo.RealVideo(tm) ActiveX Control (32-bit)',
	          'RealPlayer',
	          'SWCtl.SWCtl', // ShockWave player
	          'WMPlayer.OCX', // Windows media player
	          'AgControl.AgControl', // Silverlight
	          'Skype.Detection'];
	          
	        // starting to detect plugins in IE
	        return this.map(names, function(name){
	          try{
	            new ActiveXObject(name);
	            return name;
	          } catch(e){
	            return null;
	          }
	        }).join(';');
	      } else {
	        return ""; // behavior prior version 0.5.0, not breaking backwards compat.
	      }
	    },
	
	    getScreenResolution: function () {
	      return [screen.height, screen.width];
	    },
	
	    getCanvasFingerprint: function () {
	      var canvas = document.createElement('canvas');
	      var ctx = canvas.getContext('2d');
	      // https://www.browserleaks.com/canvas#how-does-it-work
	      var txt = 'http://valve.github.io';
	      ctx.textBaseline = "top";
	      ctx.font = "14px 'Arial'";
	      ctx.textBaseline = "alphabetic";
	      ctx.fillStyle = "#f60";
	      ctx.fillRect(125,1,62,20);
	      ctx.fillStyle = "#069";
	      ctx.fillText(txt, 2, 15);
	      ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
	      ctx.fillText(txt, 4, 17);
	      return canvas.toDataURL();
	    }
	  };
	
	
	  return Fingerprint;
	
	});


/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false, require: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(250)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    (function ($, undefined) {
	
	        var app = window.app = window.app || {};
	        var kendo = window.kendo;
	        var assert = window.assert;
	        var logger = new window.Logger('app.i18n');
	        var cultures = app.cultures = app.cultures || {};
	        var LOADED = 'i18n.loaded';
	        var LANGUAGE = 'language';
	        var UNDEFINED = 'undefined';
	        var STRING = 'string';
	        var ARRAY = 'array';
	
	        /**
	         * localization functions
	         */
	        var i18n = app.i18n = {
	
	            /**
	             * Load culture file for locale
	             * @param locale
	             * @param callback
	             */
	            load: function (locale) {
	
	                // Note: assume kendo is not yet loaded
	                assert.type(ARRAY, app.locales, '`app.locales` is expected to be an array');
	                assert.enum(app.locales, locale, '`locale` is expected to be one of ' + app.locales.toString());
	
	                var dfd = $.Deferred();
	
	                // Setter
	                function setLocale() {
	                    i18n.culture = cultures[locale];
	                    dfd.resolve();
	                }
	
	                if (cultures[locale]) {
	                    // locale already loaded
	                    setLocale();
	                } else {
	                    // locale needs to be loaded (see https://github.com/webpack/webpack/issues/923)
	                    var loader = __webpack_require__(254)("./app.culture." + locale + '.js');
	                    loader(setLocale);
	                }
	
	                return dfd.promise();
	            },
	
	            /* This function's cyclomatic complexity is too high. */
	            /* jshint -W074 */
	
	            /**
	             * Get/set locale
	             * Value set by the server on the html element of the page base on the url
	             * @param locale
	             * @returns {string|string}
	             */
	            locale: function (locale) {
	                /* jshint maxcomplexity: 8 */
	                if (typeof locale === STRING) {
	
	                    // Note: assume kendo is not yet loaded
	                    assert.type(ARRAY, app.locales, '`app.locales` is expected to be an array');
	                    assert.enum(app.locales, locale, '`locale` is expected to be one of ' + app.locales.toString());
	                    assert.ok($.type(window.device) === UNDEFINED || $.type(window.device.cordova) === UNDEFINED, 'This is not the way to change locale in phonegap/cordova');
	
	                    var href = app.uris.webapp.locale.replace('{0}', locale);
	                    if (window.top === window.self) {
	                        window.location.assign(href);
	                    } else {
	                        // This is an embedded player
	                        window.top.location.assign(href);
	                    }
	
	                } else if (locale === undefined) {
	
	                    // if (window.device && window.device.cordova) { // Phonegap
	                    if (app.mobile && kendo.mobile && kendo.mobile.Application &&
	                        app.mobile.application instanceof kendo.mobile.Application) {
	                        return window.localStorage.getItem(LANGUAGE) || 'en';
	                    } else { // Web application
	                        return document.getElementsByTagName('html')[0].getAttribute('lang') || 'en';
	                    }
	
	                } else {
	                    throw new TypeError('Bad locale: ' + locale);
	                }
	            }
	
	            /* jshint +W074 */
	
	        };
	
	        /**
	         * Load page locale (read from html tag)
	         */
	        $(function () {
	            var locale = i18n.locale();
	            i18n.load(locale)
	                .then(function () {
	                    // Log readiness
	                    logger.debug({
	                        message: locale + ' locale loaded',
	                        method: 'document.ready'
	                    });
	
	                    // trigger event for client localization of page
	                    $(document).trigger(LOADED);
	                });
	        });
	
	        /**
	         * Wait until locale is loaded to localize and hide preload
	         * @see http://blogs.telerik.com/kendoui/posts/11-10-06/foujui_flash_of_uninitialized_javascript_ui
	         */
	        $(document)
	            .on(LOADED, function () {
	                if ($.type(window.device) === UNDEFINED || $.type(window.device.cordova) === UNDEFINED) {
	                    $('body>div.k-loading-image').delay(400).fadeOut();
	                }
	            });
	
	
	    }(window.jQuery));
	
	    return window.app;
	
	}, __webpack_require__(200));


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./app.culture.en.js": 255,
		"./app.culture.fr.js": 258
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 254;


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	var cbs = [], 
		data;
	module.exports = function(cb) {
		if(cbs) cbs.push(cb);
		else cb(data);
	}
	__webpack_require__.e/* nsure */(1, function(require) {
		data = __webpack_require__(256);
		var callbacks = cbs;
		cbs = null;
		for(var i = 0, l = callbacks.length; i < l; i++) {
			callbacks[i](data);
		}
	});

/***/ },
/* 256 */,
/* 257 */,
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	var cbs = [], 
		data;
	module.exports = function(cb) {
		if(cbs) cbs.push(cb);
		else cb(data);
	}
	__webpack_require__.e/* nsure */(2, function(require) {
		data = __webpack_require__(259);
		var callbacks = cbs;
		cbs = null;
		for(var i = 0, l = callbacks.length; i < l; i++) {
			callbacks[i](data);
		}
	});

/***/ },
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false, require: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        // We are not loading window.kendo
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(250)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    (function ($, undefined) {
	
	        var app = window.app = window.app || {};
	        var kendo = window.kendo;
	        var logger = new window.Logger('app.theme');
	        var STRING = 'string';
	        var FUNCTION = 'function';
	        var THEME = 'theme';
	        var DEFAULT = 'flat';
	        // Note: app.i18n is not yet loaded, so we need a duplicated list
	        var ALL = ['black', 'blueopal', 'bootstrap', 'default', 'fiori', 'flat', 'highcontrast', 'material', 'materialblack',
	            'metro', 'metroblack', 'moonlight', 'nova', 'office365', 'silver', 'uniform'];
	
	        var localStorage; // = window.localStorage;
	        // The following is necessary when localStorage is explicitly disabled in browser settings
	        try { localStorage = window.localStorage; } catch (ex) {}
	
	        app.theme = {
	
	            /**
	             * Load a theme
	             * @param theme
	             */
	            load: function (theme) {
	                var dfd = $.Deferred();
	                var oldTheme = localStorage && localStorage.getItem(THEME);
	                var loader;
	                if (ALL.indexOf(theme) === -1) {
	                    theme = DEFAULT;
	                }
	                if (typeof oldTheme === STRING && oldTheme !== theme) {
	                    // See https://github.com/webpack/style-loader/issues/48
	                    // See https://github.com/webpack/webpack/issues/924
	                    // See https://github.com/webpack/webpack/issues/993
	                    loader = __webpack_require__(264)("./app.theme." + oldTheme + '.less');
	                    loader(function (style) {
	                        style.unuse();
	                    });
	                }
	                loader = __webpack_require__(264)("./app.theme." + theme + '.less');
	                loader(function (style) {
	                    style.use();
	                    if (localStorage && !$.isArray(matches)) {
	                        try {
	                            localStorage.setItem(THEME, theme);
	                        } catch (exception) {
	                            // A QoutaExceededError in raised in private browsing, which we do not care about
	                            // @see https://github.com/jlchereau/Kidoju-Webapp/issues/181
	                            // @see http://chrisberkhout.com/blog/localstorage-errors/
	                            if (!window.DOMException || !(exception instanceof window.DOMException) || exception.code !== window.DOMException.QUOTA_EXCEEDED_ERR) {
	                                throw exception;
	                            }
	                        }
	                    }
	                    // if (window.device && window.device.cordova) { // Phonegap
	                    if (app.mobile && kendo.mobile && kendo.mobile.Application &&
	                        app.mobile.application instanceof kendo.mobile.Application) {
	                        app.mobile.application.skin(theme);
	                    } else { // Web application
	                        $(document.documentElement).removeClass('k-' + oldTheme).addClass('k-' + theme);
	                    }
	                    app.theme.updateCharts(theme);
	                    logger.debug({
	                        message: 'theme changed to ' + theme,
	                        method: 'load'
	                    });
	                    dfd.resolve();
	                });
	                return dfd.promise();
	            },
	
	            /* Blocks are nested too deeply. */
	            /* jshint -W073 */
	
	            /**
	             * Update dataviz charts with new theme
	             * @see http://demos.telerik.com/kendo-ui/content/shared/js/theme-chooser.js
	             * @param theme
	             */
	            updateCharts: function (theme) {
	                var themable = ['Chart', 'TreeMap', 'Diagram', 'StockChart', 'Sparkline', 'RadialGauge', 'LinearGauge'];
	                if (kendo.dataviz && $.type(theme) === STRING) {
	                    for (var i = 0; i < themable.length; i++) {
	                        // Set globally for new widgets
	                        var widget = kendo.dataviz.ui[themable[i]];
	                        if (widget) {
	                            widget.fn.options.theme = theme;
	                        }
	                        // Redraw existing widgets
	                        var elements = $(kendo.roleSelector(themable[i].toLowerCase()));
	                        for (var j = 0; j < elements.length; j++) {
	                            var instance = $(elements[j]).data('kendo' + themable[i]);
	                            if (instance && $.type(instance.setOptions) === FUNCTION && $.type(instance.redraw) === FUNCTION) {
	                                // instance.options.theme = theme;
	                                instance.setOptions({ theme: theme });
	                                instance.redraw();
	                            }
	                        }
	                    }
	                }
	            },
	
	            /* jshint +W073 */
	
	            /**
	             * Update QR Codes
	             * QR Codes are not themable, so we need to set color and background
	             * @param theme
	             */
	            updateQRCodes: function (theme) {
	                // TODO
	            },
	
	            /**
	             * Get/set theme name
	             * @param theme
	             */
	            name: function (theme) {
	                if ($.type(theme) === STRING) {
	                    app.theme.load(theme);
	                } else if (theme === undefined) {
	                    if ($.isArray(matches) && matches.length === 2 && $.type(matches[1] === STRING)) {
	                        return matches[1].trim().toLowerCase();
	                    } else {
	                        theme = localStorage && localStorage.getItem(THEME);
	                        return ($.type(theme) === STRING) ? theme : DEFAULT;
	                    }
	                } else {
	                    throw new TypeError('bad theme');
	                }
	            }
	
	        };
	
	        // find a match in querystring (embedded player)
	        var matches = /theme=([^&]+)/.exec(window.location.search.substr(1));
	        // get theme from match or from localstorage ur use DEFAULT
	        var theme = app.theme.name();
	        // load theme
	        app.theme.load(theme);
	
	    }(window.jQuery));
	
	    return window.app;
	
	}, __webpack_require__(200));


/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./app.theme.fiori.less": 265,
		"./app.theme.flat.less": 305,
		"./app.theme.material.less": 320,
		"./app.theme.nova.less": 335,
		"./app.theme.office365.less": 345
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 264;


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	var cbs = [], 
		data;
	module.exports = function(cb) {
		if(cbs) cbs.push(cb);
		else cb(data);
	}
	__webpack_require__.e/* nsure */(3, function(require) {
		data = __webpack_require__(266);
		var callbacks = cbs;
		cbs = null;
		for(var i = 0, l = callbacks.length; i < l; i++) {
			callbacks[i](data);
		}
	});

/***/ },
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	var cbs = [], 
		data;
	module.exports = function(cb) {
		if(cbs) cbs.push(cb);
		else cb(data);
	}
	__webpack_require__.e/* nsure */(4, function(require) {
		data = __webpack_require__(306);
		var callbacks = cbs;
		cbs = null;
		for(var i = 0, l = callbacks.length; i < l; i++) {
			callbacks[i](data);
		}
	});

/***/ },
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	var cbs = [], 
		data;
	module.exports = function(cb) {
		if(cbs) cbs.push(cb);
		else cb(data);
	}
	__webpack_require__.e/* nsure */(5, function(require) {
		data = __webpack_require__(321);
		var callbacks = cbs;
		cbs = null;
		for(var i = 0, l = callbacks.length; i < l; i++) {
			callbacks[i](data);
		}
	});

/***/ },
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	var cbs = [], 
		data;
	module.exports = function(cb) {
		if(cbs) cbs.push(cb);
		else cb(data);
	}
	__webpack_require__.e/* nsure */(6, function(require) {
		data = __webpack_require__(336);
		var callbacks = cbs;
		cbs = null;
		for(var i = 0, l = callbacks.length; i < l; i++) {
			callbacks[i](data);
		}
	});

/***/ },
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	var cbs = [], 
		data;
	module.exports = function(cb) {
		if(cbs) cbs.push(cb);
		else cb(data);
	}
	__webpack_require__.e/* nsure */(7, function(require) {
		data = __webpack_require__(346);
		var callbacks = cbs;
		cbs = null;
		for(var i = 0, l = callbacks.length; i < l; i++) {
			callbacks[i](data);
		}
	});

/***/ },
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false, require: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(234),
	        __webpack_require__(250),
	        __webpack_require__(253),
	        __webpack_require__(251)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    /**
	     * IMPORTANT
	     * Since AssetManager is a Kidoju widget, this could have been in kidoju.data.js
	     * but kidoju.data.js has no idea of our S3 infrastructure or the way we store file uris using custom schemes
	     *
	     * Therefore preferably, this could have been in app.models.js
	     * but the transport is dependant upon the tool (set by a component selection) and the summaryId (set by the page url)
	     * when app.models is a wrapper for rapi calls which neither know the tool or the summaryId
	     * Maybe this could be parameterized but then it would have to be feeded into the AssetManager.
	     */
	
	    /* This function has too many statements. */
	    /* jshint -W071 */
	
	    (function ($, undefined) {
	
	        var kendo = window.kendo;
	        var kidoju = window.kidoju;
	        var app = window.app;
	        var i18n = app.i18n;
	        var rapi = app.rapi;
	        var assert = window.assert;
	        var logger = new window.Logger('app.assets');
	        var STRING = 'string';
	        var NUMBER = 'number';
	        var ARRAY = 'array';
	        var VERSION_HIDDEN_FIELD = 'input[type="hidden"][name="version"]';
	        var DATA_SCHEME = 'data://';
	        var RX_DATA_URL = /^data:\/\/s\/([^\/]+)\/([^\/]+)\/([^\/]+)$/;
	
	        // Ensure app.assets have been loaded from app.config.jsx
	        assert.isPlainObject(app.assets, kendo.format(assert.messages.isPlainObject.default, 'app.assets'));
	
	        /**
	         * Set the dataSource transport
	         * @type {{create: transport.create, read: transport.read, update: transport.update, destroy: transport.destroy}}
	         * Note: When we will organizations, we might consider a summaryTransport and an organizationTransport to fill two separate tabs from an AssetManager
	         */
	        function transport(tool) {
	            return {
	                create: function (options) {
	                    var locale = i18n.locale();
	                    var params = JSON.parse($(VERSION_HIDDEN_FIELD).val());
	                    var data = options.data;
	                    assert.instanceof(window.File, data.file, kendo.format(assert.messages.instanceof.default, 'data.file', 'File'));
	                    assert.type(NUMBER, data.size, kendo.format(assert.messages.type.default, 'data.size', NUMBER));
	                    logger.debug({
	                        message: 'getting a secure upload url',
	                        method: tool + '.transport.create',
	                        data: { language: locale, summaryId: params.summaryId, tool: tool }
	                    });
	                    rapi.v1.content.getUploadUrl(locale, params.summaryId, data.file)
	                        .done(function (uploadUrl) {
	                            logger.debug({
	                                message: 'uploading to secure url',
	                                method: tool + '.transport.create',
	                                data: { language: locale, summaryId: params.summaryId, tool: tool, uploadUrl: uploadUrl }
	                            });
	                            rapi.v1.content.uploadFile(uploadUrl, data.file)
	                                .done(function (response) {
	                                    assert.isPlainObject(response, kendo.format(assert.messages.isPlainObject.default, 'response'));
	                                    assert.type(STRING, response.name, kendo.format(assert.messages.type.default, 'response.name', STRING));
	                                    assert.type(NUMBER, response.size, kendo.format(assert.messages.type.default, 'response.size', NUMBER));
	                                    assert.type(STRING, response.type, kendo.format(assert.messages.type.default, 'response.type', STRING));
	                                    assert.type(STRING, response.url, kendo.format(assert.messages.type.default, 'response.url', STRING));
	                                    response.url = response.url.replace(kidoju.assets[tool].schemes.data, DATA_SCHEME);
	                                    logger.debug({
	                                        message: 'new file uploaded',
	                                        method: tool + '.transport.create',
	                                        data: $.extend({ language: locale, summaryId: params.summaryId, tool: tool }, response)
	                                    });
	                                    options.success({ data: [response], total: 1 });
	                                    assert.instanceof(kendo.ui.Notification, app.notification, kendo.format(assert.messages.instanceof.default, 'app.notification', 'kendo.ui.Notification'));
	                                    app.notification.success(i18n.culture.editor.notifications.fileCreateSuccess);
	                                })
	                                .fail(function (xhr, status, error) {
	                                    logger.error({
	                                        message: 'file storage upload error',
	                                        method: tool + '.transport.create',
	                                        data: { status: status, error: error, response: xhr.responseText }
	                                    });
	                                    options.error(xhr, status, error);
	                                    assert.instanceof(kendo.ui.Notification, app.notification, kendo.format(assert.messages.instanceof.default, 'app.notification', 'kendo.ui.Notification'));
	                                    app.notification.error(i18n.culture.editor.notifications.fileCreateFailure);
	                                });
	                        })
	                        .fail(function (xhr, status, error) {
	                            logger.error({
	                                message: 'secure upload url error',
	                                method: tool + '.transport.create',
	                                data: { status: status, error: error, reponse: xhr.responseText }
	                            });
	                            options.error(xhr, status, error);
	                            assert.instanceof(kendo.ui.Notification, app.notification, kendo.format(assert.messages.instanceof.default, 'app.notification', 'kendo.ui.Notification'));
	                            app.notification.error(i18n.culture.editor.notifications.uploadUrlFailure);
	                        });
	                },
	                read: function (options) {
	                    var locale = i18n.locale();
	                    var params = JSON.parse($(VERSION_HIDDEN_FIELD).val());
	                    rapi.v1.content.getAllSummaryFiles(locale, params.summaryId)
	                        .done(function (response) {
	                            assert.isPlainObject(response, kendo.format(assert.messages.isPlainObject.default, 'response'));
	                            assert.type(ARRAY, response.data, kendo.format(assert.messages.type.default, 'response.data', ARRAY));
	                            assert.type(NUMBER, response.total, kendo.format(assert.messages.type.default, 'response.total', NUMBER));
	                            var path = kidoju.assets[tool].schemes.data;
	                            $.each(response.data, function (index, data) {
	                                assert.isPlainObject(data, kendo.format(assert.messages.isPlainObject.default, 'data'));
	                                assert.type(STRING, data.url, kendo.format(assert.messages.type.default, 'data.url', STRING));
	                                data.url = data.url.replace(path, DATA_SCHEME);
	                            });
	                            options.success(response);
	                        })
	                        .fail(function (xhr, status, error) {
	                            logger.error({
	                                message: 'file storage read error',
	                                method: tool + '.transport.read',
	                                data: { status: status, error: error, reponse: xhr.responseText }
	                            });
	                            options.error(xhr, status, error);
	                            assert.instanceof(kendo.ui.Notification, app.notification, kendo.format(assert.messages.instanceof.default, 'app.notification', 'kendo.ui.Notification'));
	                            app.notification.error(i18n.culture.editor.notifications.filesLoadFailure);
	                        });
	                },
	                update: function (options) {
	                    // Should not be used...
	                    options.success(options.data);
	                },
	                destroy: function (options) {
	                    var locale = i18n.locale();
	                    var params = JSON.parse($(VERSION_HIDDEN_FIELD).val());
	                    var data = options.data;
	                    assert.isPlainObject(data, kendo.format(assert.messages.isPlainObject.default, 'data'));
	                    assert.type(STRING, data.url, kendo.format(assert.messages.type.default, 'data.url', STRING));
	                    var matches = data.url.match(RX_DATA_URL);
	                    assert.equal(4, matches.length, kendo.format(assert.messages.equal.default, 'matches.length', 4));
	                    assert.equal(locale, matches[1], kendo.format(assert.messages.equal.default, 'matches[1]', locale));
	                    assert.equal(params.summaryId, matches[2], kendo.format(assert.messages.equal.default, 'matches[2]', params.summaryId));
	                    rapi.v1.content.deleteFile(matches[1], matches[2], matches[3])
	                        .done(function (response) {
	                            logger.debug({
	                                message: 'file deleted',
	                                method: tool + '.transport.create',
	                                data: $.extend({ language: locale, summaryId: params.summaryId, tool: tool }, response)
	                            });
	                            options.success({ data: [data], total: 1 });
	                            assert.instanceof(kendo.ui.Notification, app.notification, kendo.format(assert.messages.instanceof.default, 'app.notification', 'kendo.ui.Notification'));
	                            app.notification.success(i18n.culture.editor.notifications.fileDeleteSuccess);
	                        })
	                        .fail(function (xhr, status, error) {
	                            logger.error({
	                                message: 'file storage deletion error',
	                                method: tool + '.transport.destroy',
	                                data: { status: status, error: error, reponse: xhr.responseText }
	                            });
	                            options.error(xhr, status, error);
	                            assert.instanceof(kendo.ui.Notification, app.notification, kendo.format(assert.messages.instanceof.default, 'app.notification', 'kendo.ui.Notification'));
	                            app.notification.error(i18n.culture.editor.notifications.fileDeleteFailure);
	                        });
	                }
	            };
	        }
	
	        // Note: ./webapp/config.default.json is read by ./web_modules/app.config.jsx to produce app.assets
	
	        // Build audio tool assets
	        var audio = app.assets.audio;
	        assert.isPlainObject(audio, kendo.format(assert.messages.isPlainObject.default, 'app.assets.audio'));
	        kidoju.assets.audio = new kidoju.ToolAssets($.extend(audio, { transport: transport('audio') }));
	
	        // Build icon assets
	        var icon = app.assets.icon;
	        assert.isPlainObject(icon, kendo.format(assert.messages.isPlainObject.default, 'app.assets.icon'));
	        kidoju.assets.icon = new kidoju.ToolAssets($.extend(icon, { transport: null }));
	
	        // Build image tool assets
	        var image = app.assets.image;
	        assert.isPlainObject(image, kendo.format(assert.messages.isPlainObject.default, 'app.assets.image'));
	        kidoju.assets.image = new kidoju.ToolAssets($.extend(image, { transport: transport('image') }));
	
	        // Build video tool assets
	        var video = app.assets.video;
	        assert.isPlainObject(video, kendo.format(assert.messages.isPlainObject.default, 'app.assets.video'));
	        kidoju.assets.video = new kidoju.ToolAssets($.extend(video, { transport: transport('video') }));
	
	        // Log readiness
	        logger.debug({
	            message: 'Assets configured'
	        });
	
	    }(window.jQuery));
	
	    /* jshint +W071 */
	
	    return window.app;
	
	}, __webpack_require__(200));


/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(362), // <-- keep first or adapt function (md5)
	        __webpack_require__(202),
	        __webpack_require__(204),
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(250),
	        __webpack_require__(251),
	        __webpack_require__(363),
	        __webpack_require__(233),
	        __webpack_require__(234)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    // TODO: app.cultures (search below)
	})(function (md5) {
	
	    'use strict';
	
	    // Depending how md5.js is loaded
	    // We need `md5` for webpack and `window.md5` for grunt mocha
	    md5 = md5 || window.md5;
	
	    /* This function has too many statements. */
	    /* jshint -W071 */
	
	    /* This function's cyclomatic complexity is too high. */
	    /* jshint -W074 */
	
	    (function ($, undefined) {
	
	        /* jshint maxcomplexity: 8 */
	
	        /**
	         * IMPORTANT NOTE 1
	         * Lazy models are simplified/flattened readonly models (all properties are non-editable) to load in Lazy datasources
	         * Other models are used for CRUD operations and might have nested models like MongoDB schemas
	         *
	         * IMPORTANT NOTE 2
	         * All calculated fields used in MVVM to display properly formatted data are marked with an appended $
	         * The reason is to recognize them in kendo templates where they should be used as functions with trailing ()
	         * whereas they should be used as properties without trailing () in data-bind attributes
	         */
	
	        var app = window.app = window.app || {};
	        var kendo = window.kendo;
	        var kidoju = window.kidoju;
	        var Model = kidoju.data.Model;
	        var DataSource = kidoju.data.DataSource;
	        var Stream = kidoju.data.Stream;
	        var Node = kendo.data.Node;
	        var HierarchicalDataSource = kendo.data.HierarchicalDataSource;
	        var assert = window.assert;
	        var logger = new window.Logger('app.models');
	        var rapi = app.rapi;
	        var models = app.models = app.models || {};
	        var i18n = app.i18n = app.i18n || {
	                locale: function () { return 'en'; },
	                culture: {
	                    dateFormat: 'dd MMM yyyy',
	                    languages: [
	                        {
	                            value: 'en',
	                            name: 'English',
	                            icon: ''
	                        },
	                        {
	                            value: 'fr',
	                            name: 'French',
	                            icon: ''
	                        }
	                    ],
	                    finder: {
	                        treeview: {
	                            rootNodes: {
	                                home: {
	                                    text: 'Home',
	                                    icon: 'home'
	                                },
	                                favourites: {
	                                    text: 'Favourites',
	                                    icon: 'star'
	                                },
	                                categories: {
	                                    text: 'Categories',
	                                    icon: 'folders2'
	                                }
	                            }
	                        }
	                    },
	                    versions: {
	                        draft: {
	                            name: 'Draft'
	                        },
	                        published: {
	                            name: 'Version {0}'
	                        }
	                    }
	                }
	            };
	        var uris = app.uris = app.uris || {}; // we expect to have app.uris.rapi = {...}
	        uris.cdn = uris.cdn || {
	                icons: 'https://cdn.kidoju.com/images/o_collection/svg/office/{0}.svg'
	            };
	        uris.mobile = {
	            icons: './img/{0}.svg'
	        };
	        uris.webapp = uris.webapp  || { // this is for testing only
	                editor      : window.location.protocol + '//' + window.location.host + '/{0}/e/{1}/{2}',
	                finder      : window.location.protocol + '//' + window.location.host + '/{0}',
	                player      : window.location.protocol + '//' + window.location.host + '/{0}/x/{1}/{2}',
	                user        : window.location.protocol + '//' + window.location.host + '/{0}/u/{1}',
	                summary     : window.location.protocol + '//' + window.location.host + '/{0}/s/{1}'
	            };
	        var STRING = 'string';
	        var NUMBER = 'number';
	        var DATE = 'date';
	        var BOOLEAN = 'boolean';
	        var CHANGE = 'change';
	        var ITEMCHANGE = 'itemchange';
	        var RX_MONGODB_ID = /^[a-z0-9]{24}$/;
	        var HASHBANG = '#!';
	        var HOME = 'home';
	        var FAVOURITES = 'favourites';
	        var CATEGORIES = 'categories';
	        var VERSION_STATE = { DRAFT: 0, PUBLISHED: 5 };
	        var MD5_A = '0cc175b9c0f1b6a831c399e269772661';
	
	        /*******************************************************************************
	         * Helpers
	         *******************************************************************************/
	
	        /**
	         * Filter an object to a list of fields
	         * @param obj
	         * @param fields (an array or a [space, comma, semi-colon] delimited string)
	         */
	        function filter(obj, fields) {
	            if ($.isPlainObject(obj) && ($.isArray(fields) || $.type(fields) === STRING)) {
	                var ret = {};
	                var fieldArray = $.isArray(fields) ? fields : fields.split(/[\s,;]+/);
	                for (var i = 0; i < fieldArray.length; i++) {
	                    if (obj.hasOwnProperty(fieldArray[i])) {
	                        ret[fieldArray[i]] = obj[fieldArray[i]];
	                    }
	                }
	                return ret;
	            }
	            return obj;
	        }
	
	        /*
	         // See kendo.date and kendo.timezone in kendo.core
	         http://www.telerik.com/forums/undocumented-use-of-kendo-timezones
	         function applyZone(date, fromZone, toZone) {
	         if (toZone) {
	         date = kendo.timezone.convert(date, fromZone, toZone);
	         } else {
	         date = kendo.timezone.remove(date, fromZone);
	         }
	         return date;
	         }
	         */
	
	
	        /*******************************************************************************
	         * Taxonomy
	         *******************************************************************************/
	
	        /**
	         * LazyCategory
	         * @type {kidoju.data.Model}
	         */
	        models.LazyCategory = Model.define({
	            id: 'id', // the identifier of the model, which is required for isNew() to work
	            fields: {
	                id: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                },
	                icon: {
	                    type: STRING,
	                    editable: false
	                },
	                language: {
	                    type: STRING,
	                    editable: false
	                },
	                depth: { // `level` seems to be reserved in kendo.ui.TreeView
	                    type: NUMBER,
	                    editable: false
	                },
	                name: {
	                    type: STRING,
	                    editable: false
	                },
	                parentId: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                }
	            },
	            icon$: function () {
	                return kendo.format((window.device && window.device.cordova) ? uris.mobile.icons : uris.cdn.icons, this.get('icon'));
	            }
	        });
	
	        /**
	         * LazyCategoryDataSource
	         * A readonly datasource of flattened categories
	         * @type {kendo.data.DataSource}
	         */
	        models.LazyCategoryDataSource = DataSource.extend({
	            init: function (options) {
	
	                var that = this;
	
	                DataSource.fn.init.call(that, $.extend(true, {}, {
	                    transport: {
	                        read: $.proxy(that._transport._read, that)
	                    },
	                    schema: {
	                        data: 'data',
	                        total: 'total',
	                        errors: 'error',
	                        modelBase: models.LazyCategory,
	                        model: models.LazyCategory
	                    }
	                }, options));
	
	            },
	            /*
	             * Setting _transport._read here with a reference above is a trick
	             * so as to be able to replace this function in mockup scenarios
	             */
	            _transport: {
	                _read: function (options) {
	                    logger.debug({
	                        message: 'dataSource.read',
	                        method: 'app.models.LazyCategoryDataSource.transport.read'
	                        // data: options
	                    });
	                    app.cache.getLeveledCategories(i18n.locale())
	                        .done(function (response) {
	                            options.success(response);
	                        })
	                        .fail(function (xhr, status, error) {
	                            options.error(xhr, status, error);
	                        });
	                }
	            }
	        });
	
	        /*******************************************************************************
	         * Searches and Rummages
	         *******************************************************************************/
	
	        /**
	         * Search model
	         * Note: Search is more about content than taxonomy, but saving a search adds to rummages
	         * @type {kidoju.data.Model}
	         */
	        models.Search = Model.define({
	            id: 'userId', // the identifier of the model, which is required for isNew() to work
	            fields: {
	                userId: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                },
	                age: {
	                    type: NUMBER,
	                    nullable: true
	                },
	                author: {
	                    type: STRING
	                },
	                category: {
	                    type: STRING
	                },
	                favourite: { // name of favourite when saveChecked
	                    type: STRING
	                },
	                navbar: { // text search in navbar
	                    type: STRING
	                },
	                saveChecked: {
	                    type: BOOLEAN,
	                    defaultValue: false
	                },
	                sort: {
	                    type: STRING,
	                    defaultValue: 'd' // other possible values are 'r' and 'v' for dates, rates and views
	                },
	                text: { // text search
	                    type: STRING
	                }
	            },
	
	            /**
	             * Contructor
	             * @param data
	             */
	            init: function (data) {
	                var that = this;
	                Model.fn.init.call(that, data);
	                this.bind(CHANGE, $.proxy(that._onChange, that));
	            },
	
	            /**
	             * Whether there is enough data to save a favourite
	             * @returns {boolean}
	             */
	            isSavable$: function () {
	                return RX_MONGODB_ID.test(this.get('userId')) &&
	                    (this.get('age') !== this.defaults.age || this.get('author') !== this.defaults.author || this.get('category') !== this.defaults.category || this.get('text') !== this.defaults.text);
	            },
	
	            /**
	             * Event handler for the change event
	             * @param e
	             * @private
	             */
	            _onChange: function (e) {
	                if (e.field === 'saveChecked' && !this.get('saveChecked')) {
	                    this.set('favourite', this.defaults.favourite);
	                } else if (!this.isSavable$() && this.get('saveChecked')) {
	                    this.set('saveChecked', this.defaults.saveChecked);
	                }
	            },
	
	            /* This function's cyclomatic complexity is too high. */
	            /* jshint -W074 */
	
	            /**
	             * get the hash
	             * the hashchange event handler will actually trigger the search so that searches can be bookmarked as favourites
	             * @param advanced
	             * @returns {string}
	             */
	            getHash: function (advanced) {
	                if (advanced) { // build hash from search panel
	                    var options = {
	                        filter: {
	                            logic : 'and',
	                            filters: []
	                        },
	                        sort: []
	                    };
	
	                    // Filter
	                    var age = this.get('age');
	                    if ($.type(age) === NUMBER) {
	                        options.filter.filters.push({ field: 'minAge', operator: 'lte', value: age });
	                        options.filter.filters.push({ field: 'maxAge', operator: 'gte', value: age });
	                    }
	                    var author = this.get('author');
	                    if ($.type(author) === STRING && author.trim().length) {
	                        options.filter.filters.push({ field: 'author.lastName', operator: 'startswith', value: author.trim() });
	                    }
	                    var category = this.get('category');
	                    if (RX_MONGODB_ID.test(category)) {
	                        options.filter.filters.push({ field: 'categories', operator: 'eq', value: category });
	                    }
	                    var text = this.get('text');
	                    if ($.type(text) === STRING && text.trim().length) {
	                        options.filter.filters.push({ field: '$text', operator: 'eq', value: text.trim() });
	                        // Note: the language is added server side based on the url, so do not bother here
	                    }
	
	                    var length = options.filter.filters.length;
	
	                    if (length === 0) {
	                        return HASHBANG; // '';
	                    } else if (length === 1) {
	                        options.filter = options.filter.filters[0];
	                    }
	
	                    // Sort
	                    var sort = this.get('sort');
	                    switch (sort) {
	                        case 'd': // sort by dates
	                            options.sort = [{ field: 'updated', dir: 'desc' }];
	                            break;
	                        case 'r': // sort by ratings
	                            options.sort = [{ field: 'metrics.ratings.average', dir: 'desc' }];
	                            break;
	                        case 'v': // sort by number of views
	                            options.sort = [{ field: 'metrics.views.count', dir: 'desc' }];
	                            break;
	                    }
	
	                    // Return hash
	                    return HASHBANG + $.param(options);
	
	                } else { // build hash from navbar
	
	                    var navbar = this.get('navbar').trim();
	
	                    // Return hash - this is a different format that can be used for sitelink search snippet
	                    // https://developers.google.com/webmasters/richsnippets/sitelinkssearch
	                    return HASHBANG + (navbar ? 'q=' + encodeURIComponent(navbar) : '');
	
	                }
	            },
	
	            /* jshint +W074 */
	
	            /**
	             * Load search
	             * @returns {*}
	             */
	            load: function () {
	                var that = this;
	                return app.cache.getMe()
	                    .done(function (me) {
	                        // TODO in order to set a default age, we would need the date of birth
	                        if ($.isPlainObject(me) && RX_MONGODB_ID.test(me.id)) {
	                            // Since we have marked fields as non editable, we cannot use 'that.set',
	                            // This should raise a change event on the parent viewModel
	                            that.accept({ userId: me.id });
	                        } else {
	                            that.accept({ userId: null });
	                        }
	                    });
	            },
	
	            /**
	             * Reset search
	             */
	            reset: function () {
	                this.set('age', this.defaults.age);
	                this.set('author', this.defaults.author);
	                this.set('category', this.defaults.category);
	                this.set('favourite', this.defaults.favourite);
	                this.set('navbar', this.defaults.navbar);
	                this.set('saveChecked', this.defaults.saveChecked);
	                this.set('sort', this.defaults.sort);
	                this.set('text', this.defaults.text);
	            },
	
	            /**
	             * Save search as favourite
	             * @returns {*}
	             */
	            save: function () {
	                // We need a userId to save a search as a user favourite
	                assert.match(RX_MONGODB_ID, this.userId, kendo.format(assert.messages.match.default, 'this.userId', RX_MONGODB_ID));
	                var root = window.location.protocol + '//' + window.location.host;
	                var finder = kendo.format(uris.webapp.finder, i18n.locale());
	                finder = finder.indexOf(root) === 0 ? finder.substr(root.length) : finder;
	                var favourite = {
	                    name: this.get('favourite').trim(),
	                    path: finder + this.getHash(true)
	                };
	                // TODO: we should rather update the cache
	                app.cache.removeMyFavourites(i18n.locale());
	                // Save a favourite on the current user
	                return rapi.v1.user.createMyFavourite(i18n.locale(), favourite);
	            }
	        });
	
	        /**
	         * Rummage node (displayed in treeview on find page)
	         * @type {kendo.data.Node}
	         */
	        models.Rummage = Node.define({
	            id: 'id',
	            hasChildren: true,
	            children: {
	                schema: {
	                    data: 'items'
	                }
	            },
	            fields: {
	                id: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                },
	                name: {
	                    type: STRING,
	                    editable: false
	                },
	                icon: {
	                    type: STRING,
	                    editable: false
	                },
	                path: {
	                    type: STRING,
	                    nullable: true,
	                    editable: false
	                },
	                type: { // 0 = groups/folders, 1 = home, 2 = categories, 3 = favourites
	                    type: NUMBER,
	                    editable: false
	                }
	            },
	
	            /* This function's cyclomatic complexity is too high. */
	            /* jshint -W074 */
	
	            /**
	             * Return a complete path
	             * @returns {*}
	             */
	            path$: function () {
	                var root = window.location.protocol + '//' + window.location.host;
	                var finder = kendo.format(uris.webapp.finder, i18n.locale());
	                finder = finder.indexOf(root) === 0 ? finder.substr(root.length) : finder;
	                switch (this.get('type')) {
	                    case 1: // home
	                        return finder + HASHBANG; // Note: without hashbang, the page is reloaded
	                    case 2: // categories
	                        return finder + HASHBANG + $.param({ filter: { field: 'categories', operator: 'eq', value: this.get('id') } });
	                    case 3: // favourites
	                        return this.get('path');
	                    default: // including 0 (no hypertext link)
	                        return null; // should not be used!!!
	                }
	            },
	
	            /* jshint +W074 */
	
	            /**
	             * Return a complete icon path
	             * @returns {*}
	             */
	            icon$: function () {
	                return kendo.format(uris.cdn.icons, this.get('icon'));
	            }
	        });
	
	        // Children schema model cannot be set until the model exists
	        // See http://www.telerik.com/forums/display-of-calculated-fields-in-treeview-template
	        models.Rummage.prototype.children.schema.model = models.Rummage;
	        // models.Rummage.prototype.children.schema.modelBase = models.Rummage;
	
	        /**
	         * Hierarchical datasource of rummages
	         * @type {*|void}
	         */
	        models.RummageHierarchicalDataSource = HierarchicalDataSource.extend({
	            init: function (options) {
	
	                var that = this;
	
	                HierarchicalDataSource.fn.init.call(that, $.extend(true, {}, {
	                    transport: {
	                        read: $.proxy(that._transport._read, that),
	                        update: $.proxy(that._transport._update, that),
	                        destroy: $.proxy(that._transport._destroy, that)
	                    },
	                    schema: {
	                        model: models.Rummage,
	                        modelBase: models.Rummage
	                    }
	                }, options));
	
	            },
	            _transport: {
	                _read: function (options) {
	                    logger.debug({
	                        message: 'dataSource.read',
	                        method: 'app.models.RummageHierarchicalDataSource.transport.read'
	                        // data: options.data
	                    });
	                    $.when(
	                        app.cache.getFavouriteHierarchy(i18n.locale()),
	                        app.cache.getCategoryHierarchy(i18n.locale())
	                        )
	                        .done(function (favourites, categories) {
	                            var rootNodes = i18n.culture.finder.treeview.rootNodes;
	                            var rummages = [
	                                { id: HOME, icon: rootNodes.home.icon, name: rootNodes.home.name, type: 1 },
	                                { id: FAVOURITES, icon: rootNodes.favourites.icon, name: rootNodes.favourites.name, items: favourites, type: 0 },
	                                { id: CATEGORIES, icon: rootNodes.categories.icon, name: rootNodes.categories.name, items: categories, type: 0 }
	                            ];
	                            options.success(rummages);
	                        })
	                        .fail(function (xhr, status, error) {
	                            options.error(xhr, status, error);
	                        });
	                },
	                _update: function (options) {
	                    // Update is required because it is called on the parent node before any destroy of a child node
	                    return options.success(options.data);
	                },
	                _destroy: function (options) {
	                    logger.debug({
	                        message: 'dataSource.destroy',
	                        method: 'app.models.RummageHierarchicalDataSource.transport.destroy',
	                        data: options.data
	                    });
	                    // assert.isPlainObject(options, kendo.format(assert.messages.isPlainObject.default, 'options'));
	                    assert.isPlainObject(options.data, kendo.format(assert.messages.isPlainObject.default, 'options.data'));
	                    assert.match(RX_MONGODB_ID, options.data.id, kendo.format(assert.messages.match.default, 'options.data.id', RX_MONGODB_ID));
	                    return app.rapi.v1.user.deleteMyFavourite(i18n.locale(), options.data.id)
	                        .done(function () {
	                            app.cache.removeMyFavourites(i18n.locale())
	                                .always(function () {
	                                    options.success(options.data);
	                                });
	                        })
	                        .fail(options.error);
	                }
	            }
	        });
	
	        /************************************************************************************
	         * Metrics
	         ************************************************************************************/
	
	        /**
	         * CountReferenceModel
	         * @type {kidoju.data.Model}
	         */
	        models.CountReference = Model.define({
	            fields: {
	                count: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                }
	            }
	        });
	
	        /**
	         * AverageReferenceModel
	         * @type {kidoju.data.Model}
	         */
	        models.AverageReference = Model.define({
	            fields: {
	                average: {
	                    type: NUMBER,
	                    editable: false,
	                    nullable: true, // average is null when there is no count
	                    parse: function (value) {
	                        return isNaN(value) ? null : value;
	                    },
	                    serializable: false
	                }
	            }
	        });
	
	        /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
	
	        /**
	         * RatingCountReference
	         * @type {kidoju.data.Model}
	         */
	        models.RatingCountReference = Model.define({
	            fields: {
	                average: {
	                    type: NUMBER,
	                    editable: false,
	                    nullable: true, // average is null when there is no count
	                    parse: function (value) {
	                        return isNaN(value) ? null : value;
	                    },
	                    serializable: false
	                },
	                count_1: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_2: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_3: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_4: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_5: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                }
	            }
	        });
	
	        /**
	         * ScoreCountReference
	         * @type {kidoju.data.Model}
	         */
	        models.ScoreCountReference = Model.define({
	            fields: {
	                average: {
	                    type: NUMBER,
	                    editable: false,
	                    nullable: true, // average is null when there is no count
	                    parse: function (value) {
	                        return isNaN(value) ? null : value;
	                    },
	                    serializable: false
	                },
	                count_00: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_05: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_10: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_15: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_20: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_25: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_30: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_35: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_40: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_45: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_50: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_55: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_60: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_65: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_70: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_75: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_80: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_85: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_90: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                },
	                count_95: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false,
	                    serializable: false
	                }
	            },
	            /**
	             * Return an array ready for a kendo.dataviz.Chart histogram
	             * To draw on the chart, see http://docs.telerik.com/kendo-ui/dataviz/chart/how-to/draw-on-scatter-plots
	             */
	            series: function () {
	                return [
	                    { score:  '0+', count: this.get('count_00') },
	                    { score:  '5+', count: this.get('count_05') },
	                    { score: '10+', count: this.get('count_10') },
	                    { score: '15+', count: this.get('count_15') },
	                    { score: '20+', count: this.get('count_20') },
	                    { score: '25+', count: this.get('count_25') },
	                    { score: '30+', count: this.get('count_30') },
	                    { score: '35+', count: this.get('count_35') },
	                    { score: '40+', count: this.get('count_40') },
	                    { score: '45+', count: this.get('count_45') },
	                    { score: '50+', count: this.get('count_50') },
	                    { score: '55+', count: this.get('count_55') },
	                    { score: '60+', count: this.get('count_60') },
	                    { score: '65+', count: this.get('count_65') },
	                    { score: '70+', count: this.get('count_70') },
	                    { score: '75+', count: this.get('count_75') },
	                    { score: '80+', count: this.get('count_80') },
	                    { score: '85+', count: this.get('count_85') },
	                    { score: '90+', count: this.get('count_90') },
	                    { score: '95+', count: this.get('count_95') }
	                ];
	            }
	        });
	
	        /* jscs:enable requireCamelCaseOrUpperCaseIdentifiers */
	
	        /**
	         * UserMetricsReference model
	         * @type {kidoju.data.Model}
	         */
	        models.UserMetricsReference = Model.define({
	            fields: {
	                comments: {
	                    defaultValue: {},
	                    editable: false,
	                    parse: function (value) {
	                        return value instanceof models.CountReference ? value : new models.CountReference(value);
	                    },
	                    serializable: false
	                },
	                ratings: {
	                    defaultValue: {},
	                    editable: false,
	                    parse: function (value) {
	                        return value instanceof models.RatingCountReference ? value : new models.RatingCountReference(value);
	                    },
	                    serializable: false
	                },
	                scores: {
	                    defaultValue: {},
	                    editable: false,
	                    parse: function (value) {
	                        return value instanceof models.ScoreCountReference ? value : new models.ScoreCountReference(value);
	                    },
	                    serializable: false
	                },
	                summaries: {
	                    defaultValue: {},
	                    editable: false,
	                    parse: function (value) {
	                        return value instanceof models.CountReference ? value : new models.CountReference(value);
	                    },
	                    serializable: false
	                }
	            },
	
	            /* This function's cyclomatic complexity is too high. */
	            /* jshint -W074 */
	
	            // We might as well call them student points
	            actorPoints$: function () {
	                var ratings =
	                    (this.get('ratings.count_1') || 0) +
	                    (this.get('ratings.count_2') || 0) +
	                    (this.get('ratings.count_3') || 0) +
	                    (this.get('ratings.count_4') || 0) +
	                    (this.get('ratings.count_5') || 0);
	                var average = this.get('scores.average');
	                var count =
	                    // this.get('scores.count_00') || 0 +
	                    // (this.get('scores.count_00') || 0) +
	                    // (this.get('scores.count_05') || 0) +
	                    // (this.get('scores.count_10') || 0) +
	                    // (this.get('scores.count_15') || 0) +
	                    // (this.get('scores.count_20') || 0) +
	                    (this.get('scores.count_25') || 0) +
	                    (this.get('scores.count_30') || 0) +
	                    (this.get('scores.count_35') || 0) +
	                    (this.get('scores.count_40') || 0) +
	                    (this.get('scores.count_45') || 0) +
	                    (this.get('scores.count_50') || 0) +
	                    (this.get('scores.count_55') || 0) +
	                    (this.get('scores.count_60') || 0) +
	                    (this.get('scores.count_65') || 0) +
	                    (this.get('scores.count_70') || 0) +
	                    (this.get('scores.count_75') || 0) +
	                    (this.get('scores.count_80') || 0) +
	                    (this.get('scores.count_85') || 0) +
	                    (this.get('scores.count_90') || 0) +
	                    (this.get('scores.count_95') || 0);
	                // Each score above 25 is worth its prorata of 1 point (100/100)
	                // And we add some bonus points for rating Kidojus
	                return Math.round(count * average / 100 + 0.1 * ratings);
	            },
	
	            /* jshint +W074 */
	
	            // We might as well call them teacher points
	            authorPoints$: function () {
	                // Each published Kidoju quiz is worth 10 points
	                return this.get('summaries.count') || 0;
	            }
	        });
	
	        /**
	         * SummaryMetricsReference model
	         * @type {kidoju.data.Model}
	         */
	        models.SummaryMetricsReference = Model.define({
	            fields: {
	                comments: {
	                    defaultValue: {},
	                    editable: false,
	                    parse: function (value) {
	                        return value instanceof models.CountReference ? value : new models.CountReference(value);
	                    },
	                    serializable: false
	                },
	                ratings: {
	                    defaultValue: {},
	                    editable: false,
	                    parse: function (value) {
	                        return value instanceof models.RatingCountReference ? value : new models.RatingCountReference(value);
	                    },
	                    serializable: false
	                },
	                scores: {
	                    defaultValue: {},
	                    editable: false,
	                    parse: function (value) {
	                        return value instanceof models.ScoreCountReference ? value : new models.ScoreCountReference(value);
	                    },
	                    serializable: false
	                },
	                views: {
	                    defaultValue: {},
	                    editable: false,
	                    parse: function (value) {
	                        return value instanceof models.CountReference ? value : new models.CountReference(value);
	                    },
	                    serializable: false
	                }
	            }
	        });
	
	        /************************************************************************************
	         * Users
	         ************************************************************************************/
	
	        /**
	         * UserReference Model
	         * @class
	         * @type {kidoju.data.Model}
	         */
	        models.UserReference = Model.define({
	            id: 'userId', // the identifier of the model, which is required for isNew() to work
	            fields: {
	                userId: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                },
	                firstName: {
	                    type: STRING,
	                    editable: false,
	                    serializable: false
	                },
	                lastName: {
	                    type: STRING,
	                    editable: false,
	                    serializable: false
	                }
	            },
	            fullName$: function () {
	                return ((this.get('firstName') || '').trim() + ' ' + (this.get('lastName') || '').trim()).trim();
	            },
	            userUri$: function () {
	                return kendo.format(uris.webapp.user, i18n.locale(), this.get('userId'));
	            }
	        });
	
	        /**
	         * CurrentUser model
	         * Minimal non-editable user to display in the navbar
	         *
	         * @type {kidoju.data.Model}
	         */
	        models.CurrentUser = Model.define({
	            id: 'id', // the identifier of the model, which is required for isNew() to work
	            fields: {
	                id: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                },
	                firstName: {
	                    type: STRING,
	                    editable: false
	                },
	                lastName: {
	                    type: STRING,
	                    editable: false
	                },
	                picture: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                }
	                // timezone (for display of dates), born (for searches)
	            },
	            fullName$: function () {
	                return ((this.get('firstName') || '').trim() + ' ' + (this.get('lastName') || '').trim()).trim();
	            },
	            picture$: function () {
	                return this.get('picture') || kendo.format(uris.cdn.icons, 'user');
	            },
	            isAuthenticated$: function () {
	                return RX_MONGODB_ID.test(this.get('id'));
	            },
	            userUri$: function () {
	                return kendo.format(uris.webapp.user, i18n.locale(), this.get('id'));
	            },
	            reset: function () {
	                // Since we have marked fields as non editable, we cannot use 'that.set'
	                this.accept({
	                    id: this.defaults.id,
	                    firstName: this.defaults.firstName,
	                    lastName: this.defaults.lastName,
	                    picture: this.defaults.picture
	                });
	            },
	            load: function () {
	                var that = this;
	                return app.cache.getMe()
	                    .done(function (data) {
	                        if ($.isPlainObject(data) && RX_MONGODB_ID.test(data.id)) {
	                            // Since we have marked fields as non editable, we cannot use 'that.set',
	                            // This should raise a change event on the parent viewModel
	                            that.accept({
	                                id: data.id,
	                                firstName: data.firstName,
	                                lastName: data.lastName,
	                                picture: data.picture
	                            });
	                        } else {
	                            that.reset();
	                        }
	                    });
	            }
	        });
	
	        /**
	         * Account model
	         * @type {kidoju.data.Model}
	         */
	        models.Account = Model.define({
	            id: 'id', // the identifier of the model, which is required for isNew() to work
	            fields: {
	                id: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true,
	                    serializable: false
	                },
	                email: {
	                    type: STRING,
	                    editable: false,
	                    serializable: false
	                },
	                firstName: {
	                    type: STRING,
	                    editable: false,
	                    serializable: false
	                },
	                gender: {
	                    type: STRING,
	                    editable: false,
	                    serializable: false
	                },
	                lastName: {
	                    type: STRING,
	                    editable: false,
	                    serializable: false
	                },
	                link: {
	                    type: STRING,
	                    editable: false,
	                    serializable: false
	                },
	                locale:{
	                    type: STRING,
	                    editable: false,
	                    serializable: false
	                },
	                timezone: {
	                    type: STRING,
	                    editable: false,
	                    serializable: false
	                },
	                picture: {
	                    type: STRING,
	                    editable: false,
	                    serializable: false
	                },
	                updated: {
	                    type: DATE,
	                    editable: false,
	                    serializable: false
	                },
	                verified: {
	                    type: BOOLEAN,
	                    editable: false,
	                    serializable: false
	                }
	            }
	        });
	
	        /**
	         * User model
	         * @type {kidoju.data.Model}
	         */
	        models.User = Model.define({
	            id: 'id', // the identifier of the model, which is required for isNew() to work
	            fields: {
	                id: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true,
	                    serializable: false
	                },
	                born: {
	                    type: DATE,
	                    nullable: true
	                },
	                created: {
	                    type: DATE,
	                    editable: false,
	                    serializable: false
	                },
	                description: {
	                    type: STRING
	                },
	                email: {
	                    type: STRING
	                },
	                firstName: {
	                    type: STRING
	                },
	                lastName: {
	                    type: STRING
	                },
	                // Note: favourites are stored with users but are displayed with rummages
	                language: {
	                    type: STRING
	                },
	                metrics: {
	                    defaultValue: {},
	                    editable: false,
	                    parse: function (value) {
	                        return value instanceof models.UserMetricsReference ? value : new models.UserMetricsReference(value);
	                    },
	                    serializable: false
	                },
	                picture: {
	                    type: STRING
	                },
	                updated: {
	                    type: DATE,
	                    editable: false,
	                    serializable: false
	                },
	                // For complex types, the recommendation is to leave the type undefined and set a default value
	                // See: http://www.telerik.com/forums/model---complex-model-with-nested-objects-or-list-of-objects
	                // See: http://demos.telerik.com/kendo-ui/grid/editing-custom
	                facebook: {
	                    defaultValue: null,
	                    editable: false,
	                    serializable: false,
	                    parse: function (value) {
	                        // return $.isPlainObject(value) ? new models.Account(value) : null;
	                        return (value instanceof models.Account || value === null) ? value : new models.Account(value);
	                    }
	                },
	                google: {
	                    defaultValue: null,
	                    editable: false,
	                    serializable: false,
	                    parse: function (value) {
	                        return (value instanceof models.Account || value === null) ? value : new models.Account(value);
	                    }
	                },
	                live: {
	                    defaultValue: null,
	                    editable: false,
	                    serializable: false,
	                    parse: function (value) {
	                        return (value instanceof models.Account || value === null) ? value : new models.Account(value);
	                    }
	                },
	                twitter: {
	                    defaultValue: null,
	                    editable: false,
	                    serializable: false,
	                    parse: function (value) {
	                        return (value instanceof models.Account || value === null) ? value : new models.Account(value);
	                    }
	                }
	            },
	
	            /* This function's cyclomatic complexity is too high. */
	            /* jshint -W074 */
	
	            /**
	             * Gets a unique list of email addresses from user accounts
	             * @returns {Array}
	             */
	            emails$: function () {
	                var emails = [];
	                var facebook = (this.get('facebook.email') || '').trim().toLowerCase();
	                var google = (this.get('google.email') || '').trim().toLowerCase();
	                var live = (this.get('live.email') || '').trim().toLowerCase();
	                var twitter = (this.get('twitter.email') || '').trim().toLowerCase();
	                if (facebook.length && emails.indexOf(facebook) === -1) {
	                    emails.push(facebook);
	                }
	                if (google.length && emails.indexOf(google) === -1) {
	                    emails.push(google);
	                }
	                if (live.length && emails.indexOf(live) === -1) {
	                    emails.push(live);
	                }
	                if (twitter.length && emails.indexOf(twitter) === -1) {
	                    emails.push(twitter);
	                }
	                return emails;
	            },
	
	            /**
	             * Gets a unique list of first names from user accounts
	             * // TODO: we should not mix firstNames and lastNames from sepearate accounts so this needs to be reviewed
	             * @returns {Array}
	             */
	            firstNames$: function () {
	                var firstNames = [];
	                var facebook = (this.get('facebook.firstName') || '').trim(); // TODO Capitalize (camel case)
	                var google = (this.get('google.firstName') || '').trim();
	                var live = (this.get('live.firstName') || '').trim();
	                var twitter = (this.get('twitter.firstName') || '').trim();
	                if (facebook.length && firstNames.indexOf(facebook) === -1) {
	                    firstNames.push(facebook);
	                }
	                if (google.length && firstNames.indexOf(google) === -1) {
	                    firstNames.push(google);
	                }
	                if (live.length && firstNames.indexOf(live) === -1) {
	                    firstNames.push(live);
	                }
	                if (twitter.length && firstNames.indexOf(twitter) === -1) {
	                    firstNames.push(twitter);
	                }
	                return firstNames;
	            },
	
	            /**
	             * Gets a unique list of last names from user accounts
	             * // TODO: we should not mix firstNames and lastNames from sepearate accounts so this needs to be reviewed
	             * @returns {Array}
	             */
	            lastNames$: function () {
	                var lastNames = [];
	                var facebook = (this.get('facebook.lastName') || '').trim().toUpperCase();
	                var google = (this.get('google.lastName') || '').trim().toUpperCase();
	                var live = (this.get('live.lastName') || '').trim().toUpperCase();
	                var twitter = (this.get('twitter.lastName') || '').trim().toUpperCase();
	                if (facebook.length && lastNames.indexOf(facebook) === -1) {
	                    lastNames.push(facebook);
	                }
	                if (google.length && lastNames.indexOf(google) === -1) {
	                    lastNames.push(google);
	                }
	                if (live.length && lastNames.indexOf(live) === -1) {
	                    lastNames.push(live);
	                }
	                if (twitter.length && lastNames.indexOf(twitter) === -1) {
	                    lastNames.push(twitter);
	                }
	                return lastNames;
	            },
	
	            /* jshint +W074 */
	
	            /**
	             * Get user's full name
	             * @returns {string}
	             */
	            fullName$: function () {
	                return ((this.get('firstName') || '').trim() + ' ' + (this.get('lastName') || '').trim()).trim();
	            },
	
	            /**
	             * Get user's avatar
	             * @returns {*}
	             */
	            picture$: function () {
	                return this.get('picture') || kendo.format(uris.cdn.icons, 'user');
	            },
	
	            /**
	             * Get user's uri
	             * @returns {*}
	             */
	            userUri$: function () {
	                return kendo.format(uris.webapp.user, i18n.locale(), this.get('id'));
	            },
	
	            /**
	             * Get actor medal (based on actor/student) points
	             * @returns {*}
	             */
	            actorMedalUri$: function () {
	                var points = this.metrics.actorPoints$();
	                var medals = ['grey', 'yellow', 'orange', 'pink', 'red', 'blue', 'green', 'black'];
	                var index = Math.min(Math.floor(points / 10), 7);
	                return kendo.format(uris.cdn.icons, 'medal_' + medals[index]);
	            },
	
	            /**
	             * Get author medal (based on author/teacher) points
	             * @returns {*}
	             */
	            authorMedalUri$: function () {
	                var points = this.metrics.authorPoints$();
	                var medals = ['grey', 'yellow', 'orange', 'pink', 'red', 'blue', 'green', 'black'];
	                var index = Math.min(Math.floor(points / 10), 7);
	                return kendo.format(uris.cdn.icons, 'medal2_' + medals[index]);
	            },
	
	            /**
	             * Load
	             * @param data
	             * @returns {*}
	             */
	            load: function (data) {
	                var that = this;
	                var dfd = $.Deferred();
	                // Actually data is never an id in our web application
	                if (RX_MONGODB_ID.test(data)) {
	                    app.cache.getMe()
	                        .done(function (me) {
	                            if ($.isPlainObject(me) && data === me.id) {
	                                // The authenticated user requests his own profile
	                                // Get the full profile including provider accounts
	                                rapi.v1.user.getMe()
	                                    .done(function (user) {
	                                        that.accept(user);
	                                        dfd.resolve(user);
	                                    })
	                                    .fail(dfd.reject);
	                            } else {
	                                // Any user requests another user's public profile
	                                // Get a public profile with limited information
	                                rapi.v1.user.getUser(data)
	                                    .done(function (user) {
	                                        that.accept(user);
	                                        dfd.resolve(user);
	                                    })
	                                    .fail(dfd.reject);
	                            }
	                        })
	                        .fail(dfd.reject);
	                } else if ($.isPlainObject(data) && RX_MONGODB_ID.test(data.id)) {
	                    app.cache.getMe()
	                        .done(function (me) {
	                            if ($.isPlainObject(me) && data.id === me.id) {
	                                // The authenticated user requests his own profile
	                                // Get the full profile including provider accounts
	                                rapi.v1.user.getMe()
	                                    .done(function (user) {
	                                        that.accept(user);
	                                        dfd.resolve(user);
	                                    })
	                                    .fail(dfd.reject);
	                            } else {
	                                // Any user requests another user's public profile
	                                // Get a public profile with limited information
	                                that.accept(data);
	                                dfd.resolve(data);
	                            }
	                        })
	                        .fail(dfd.reject);
	                } else {
	                    // dfd.reject(xhr, status, error);
	                    dfd.reject('TODO', 'TODO', 'TODO'); // TODO
	                }
	                return dfd.promise();
	            },
	
	            /**
	             * Save
	             * @param fields
	             * @returns {*}
	             */
	            save: function (fields) {
	                var that = this;
	                var dfd = $.Deferred();
	                if (that.dirty) {  // TODO Validate
	                    var data = filter(that.toJSON(), fields);
	                    // serializable === false in User model field properies (see above) discards the following data
	                    assert.isPlainObject(data, kendo.format(assert.messages.isPlainObject.default, 'data'));
	                    assert.isUndefined(data.created, kendo.format(assert.messages.isUndefined.default, 'data.created'));
	                    assert.isUndefined(data.facebook, kendo.format(assert.messages.isUndefined.default, 'data.facebook'));
	                    assert.isUndefined(data.google, kendo.format(assert.messages.isUndefined.default, 'data.google'));
	                    assert.isUndefined(data.id, kendo.format(assert.messages.isUndefined.default, 'data.id'));
	                    assert.isUndefined(data.live, kendo.format(assert.messages.isUndefined.default, 'data.live'));
	                    assert.isUndefined(data.twitter, kendo.format(assert.messages.isUndefined.default, 'data.twitter'));
	                    assert.isUndefined(data.updated, kendo.format(assert.messages.isUndefined.default, 'data.updated'));
	                    rapi.v1.user.updateMe(data)
	                        .done(function (data) {
	                            // Note: data is not parsed, so dates are string
	                            that.accept(data); // this updates dirty and updated
	                            dfd.resolve(data);
	                        })
	                        .fail(function (xhr, status, error) {
	                            dfd.reject(xhr, status, error);
	                        });
	                } else {
	                    setTimeout(function () {
	                        dfd.resolve(); // nothing to save, nothing to return
	                    }, 0);
	                }
	                return dfd.promise();
	            }
	
	        });
	
	        /*********************************************************************************
	         * Summaries
	         *********************************************************************************/
	
	        /**
	         * New summary model
	         * This model is essentially used by the create window in header.ejs
	         * @type {kidoju.data.Model}
	         */
	        models.NewSummary = Model.define({
	            id: 'id', // the identifier of the model, which is required for isNew() to work
	            fields: {
	                id: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                },
	                author: {
	                    defaultValue: {},
	                    parse: function (value) {
	                        return value instanceof models.UserReference ? value : new models.UserReference(value);
	                    }
	                },
	                category: {
	                    nullable: true,
	                    parse: function (value) {
	                        return (value instanceof models.LazyCategory || value === null) ? value : new models.LazyCategory(value);
	                    }
	                },
	                language: {
	                    type: STRING,
	                    defaultValue: i18n.locale(),
	                    editable: false,
	                    validation: {
	                        required: true
	                    }
	                },
	                title: {
	                    type: STRING,
	                    validation: {
	                        required: true,
	                        pattern: '^\\S[^<>]{4,48}\\S$'
	                    }
	                }/*,
	                 type: {
	                 type: STRING,
	                 validation: {
	                 required: true
	                 }
	                 }*/
	            },
	            language$: function () {
	                var locale = this.get('language');
	                var languages = i18n.culture.languages;
	                for (var i = 0; i < languages.length; i++) {
	                    if (languages[i].value === locale) {
	                        return languages[i].name;
	                    }
	                }
	                return null ;
	            },
	            load: function () {
	                var that = this;
	                return app.cache.getMe()
	                    .done(function (me) {
	                        if ($.isPlainObject(me) && RX_MONGODB_ID.test(me.id)) {
	                            me.userId = me.id;
	                            // delete me.picture;
	                            that.set('author', new models.UserReference(me));
	                            // that.set('language', i18n.locale());
	                        }
	                    });
	            },
	            reset: function () {
	                var that = this;
	                that.set('category', this.defaults.category);
	                that.set('title', this.defaults.title);
	                // that.set('type', this.defaults.type);
	            },
	            save: function () {
	                var that = this;
	                // We could also have used toJSON and deleted any useless data
	                var newSummary = {
	                    author: {
	                        userId: that.get('author.userId')
	                        // Let the server feed the authenticated user firstName and lastName from author.userId
	                    },
	                    // Make an array of categories and the server will use this category to set the default icon
	                    categories: [that.get('category.id')],
	                    language: that.get('language'),
	                    title: that.get('title'),
	                    type: that.get('type.value')
	                };
	                // Call server to create a new summary and return a promise
	                return rapi.v1.content.createSummary(i18n.locale(), newSummary);
	            }
	        });
	
	        /**
	         * Lazy summary model (for lazy loading in lists)
	         * @type {kidoju.data.Model}
	         */
	        models.LazySummary = Model.define({
	            id: 'id', // the identifier of the model, which is required for isNew() to work
	            fields: {
	                id: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                },
	                comments: {
	                    type: NUMBER,
	                    editable: false
	                },
	                created: {
	                    type: DATE,
	                    editable: false
	                },
	                firstName: {
	                    type: STRING,
	                    editable: false
	                },
	                language: {
	                    type: STRING,
	                    editable: false
	                },
	                lastName: {
	                    type: STRING,
	                    editable: false
	                },
	                icon: {
	                    type: STRING,
	                    editable: false
	                },
	                published: {
	                    type: DATE,
	                    nullable: true,
	                    editable: false
	                },
	                ratings: {
	                    type: NUMBER,
	                    nullable: true,
	                    editable: false
	                },
	                scores: {
	                    type: NUMBER,
	                    nullable: true,
	                    editable: false
	                },
	                tags: {
	                    // type: Array
	                    defaultValue: [],
	                    editable: false
	                },
	                title: {
	                    type: STRING,
	                    editable: false
	                },
	                type: {
	                    type: STRING,
	                    editable: false
	                },
	                updated: {
	                    type: DATE,
	                    editable: false
	                },
	                userId: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                },
	                views: {
	                    type: NUMBER,
	                    defaultValue: 0,
	                    editable: false
	                }
	            },
	            authorName$: function () {
	                return ((this.get('firstName') || '').trim() + ' ' + (this.get('lastName') || '').trim()).trim();
	            },
	            authorUri$: function () {
	                return kendo.format(uris.webapp.user, i18n.locale(), this.get('userId'));
	            },
	            icon$: function () {
	                return kendo.format(uris.cdn.icons, this.get('icon'));
	            },
	            summaryUri$: function () {
	                return kendo.format(uris.webapp.summary, i18n.locale(), this.get('id'));
	            },
	            tags$: function () {
	                var ret = [];
	                var tags = this.get('tags');
	                if (tags instanceof kendo.data.ObservableArray) {
	                    ret = tags.map(function (tag) {
	                        return {
	                            name: tag,
	                            hash: HASHBANG + $.param({ filter: { field:'tags', operator:'eq', value:tag } })
	                        };
	                    });
	                }
	                return ret;
	            },
	            createDraft: function () {
	                return rapi.v1.content.executeCommand(this.get('language'), this.get('id'), { command: 'draft' });
	            },
	            publish: function () {
	                // TODO: check state to avoid a call if not necessary
	                return rapi.v1.content.executeCommand(this.get('language'), this.get('id'), { command: 'publish' });
	            }
	        });
	
	        /**
	         * DataSource of Lazy summaries
	         * @type {kendo.Observable}
	         */
	        models.LazySummaryDataSource = DataSource.extend({
	
	            init: function (options) {
	
	                var that = this;
	
	                // Cache the userId from options
	                that.userId = options && options.userId;
	
	                DataSource.fn.init.call(that, $.extend(true, {}, {
	                    transport: {
	                        read: $.proxy(that._transport._read, that)
	                    },
	                    serverFiltering: true,
	                    serverSorting: true,
	                    pageSize: 5,
	                    serverPaging: true,
	                    schema: {
	                        data: 'data',
	                        total: 'total',
	                        errors: 'error',
	                        modelBase: models.LazySummary,
	                        model: models.LazySummary,
	                        parse: function (response) {
	                            // We parse the response to flatten data for our LazySummary model (instead of using field.from and field.defaultValue definitions)
	                            if (response && $.type(response.total) === NUMBER && $.isArray(response.data)) {
	                                $.each(response.data, function (index, summary) {
	                                    // We need to flatten author and metrics in case we need to represent data in a kendo.ui.Grid
	                                    // Flatten author
	                                    assert.isPlainObject(summary.author, kendo.format(assert.messages.isPlainObject.default, 'summary.author'));
	                                    summary.userId = summary.author.userId;
	                                    summary.firstName = summary.author.firstName;
	                                    summary.lastName = summary.author.lastName;
	                                    delete summary.author;
	                                    // Flatten metrics
	                                    summary.comments = summary.metrics && summary.metrics.comments && summary.metrics.comments.count || 0;
	                                    summary.ratings = summary.metrics && summary.metrics.ratings && summary.metrics.ratings.average || null;
	                                    summary.scores = summary.metrics && summary.metrics.scores && summary.metrics.scores.average || null;
	                                    summary.views = summary.metrics && summary.metrics.views && summary.metrics.views.count || 0;
	                                    if ($.isPlainObject(summary.metrics)) {
	                                        delete summary.metrics;
	                                    }
	                                });
	                            }
	                            return response;
	                        }
	                    }
	                }, options));
	
	            },
	            load: function (options) {
	                var that = this;
	                that.userId = options && options.userId;
	                return that.query(options);
	            },
	            /*
	             * Setting _transport._read here with a reference above is a trick
	             * so as to be able to replace this function in mockup scenarios
	             */
	            _transport: {
	                _read: function (options) {
	
	                    var that = this;
	
	                    logger.debug({
	                        message: 'dataSource.read',
	                        method: 'app.models.LazySummaryDataSource.transport.read',
	                        data: { userId: that.userId }
	                    });
	
	                    // add options.filter.filters.push({ field: 'language', operator: 'eq', value: i18n.locale() });
	                    // ATTENTION logic and or or
	
	                    options.data.fields = 'author,icon,metrics.comments.count,language,metrics.ratings.average,metrics.scores.average,metrics.views.count,published,tags,title,type,updated';
	                    options.data.sort = options.data.sort || [{ field: 'updated', dir: 'desc' }];
	
	                    if (!RX_MONGODB_ID.test(that.userId)) {
	
	                        // Without user id, we just query public summaries
	                        rapi.v1.content.findSummaries(i18n.locale(), options.data)
	                            .done(function (response) {
	                                options.success(response);
	                            })
	                            .fail(function (xhr, status, error) {
	                                options.error(xhr, status, error);
	                            });
	
	                    } else {
	
	                        // With a userId, we request all summaries the author of which has such userId
	                        app.cache.getMe()
	                            .done(function (me) {
	
	                                if ($.isPlainObject(me) && that.userId === me.id) {
	
	                                    // If we request the summaries of the authenticated user, include drafts
	                                    rapi.v1.user.findMySummaries(i18n.locale(), options.data)
	                                        .done(function (response) {
	                                            options.success(response);
	                                        })
	                                        .fail(function (xhr, status, error) {
	                                            options.error(xhr, status, error);
	                                        });
	
	                                } else {
	
	                                    // If we request the summaries of an author who is not the (authenticated/anonymous) user, only fetch public/published summaries
	                                    options.data.filter = {
	                                        logic: 'and',
	                                        filters: [
	                                            { field: 'author.userId', operator: 'eq', value: that.userId }
	                                        ]
	                                    };
	
	                                    rapi.v1.content.findSummaries(i18n.locale(), options.data)
	                                        .done(function (response) {
	                                            options.success(response);
	                                        })
	                                        .fail(function (xhr, status, error) {
	                                            options.error(xhr, status, error);
	                                        });
	                                }
	
	                            })
	                            .fail(function (xhr, status, error) {
	                                options.error(xhr, status, error);
	                            });
	                    }
	                }
	            }
	        });
	
	        /**
	         * Summary model
	         * @type {kidoju.data.Model}
	         */
	        models.Summary = Model.define({
	            id: 'id', // the identifier of the model, which is required for isNew() to work
	            fields: {
	                id: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true,
	                    serializable: false
	                },
	                author: {
	                    // For complex types, the recommendation is to leave the type undefined and set a default value
	                    // See: http://www.telerik.com/forums/model---complex-model-with-nested-objects-or-list-of-objects
	                    // See: http://demos.telerik.com/kendo-ui/grid/editing-custom
	                    defaultValue: null,
	                    editable: false,
	                    serializable: false,
	                    parse: function (value) {
	                        return (value instanceof models.UserReference || value === null) ? value : new models.UserReference(value);
	                    }
	                },
	                categories: {
	                    defaultValue: []
	                },
	                created: {
	                    type: DATE,
	                    editable: false,
	                    serializable: false
	                },
	                description: {
	                    type: STRING
	                },
	                icon: {
	                    type: STRING,
	                    defaultValue: 'spacer'
	                },
	                language: {
	                    type: STRING,
	                    editable: false,
	                    serializable: false
	                },
	                minAge: {
	                    type: NUMBER,
	                    defaultValue: 0
	                },
	                maxAge: {
	                    type: NUMBER,
	                    defaultValue: 99
	                },
	                metrics: {
	                    defaultValue: {},
	                    editable: false,
	                    parse: function (value) {
	                        return value instanceof models.SummaryMetricsReference ? value : new models.SummaryMetricsReference(value);
	                    },
	                    serializable: false
	                },
	                published: {
	                    type: DATE,
	                    editable: false,
	                    nullable: true,
	                    serializable: false
	                },
	                tags: {
	                    defaultValue: []
	                },
	                title: {
	                    type: STRING
	                },
	                type: {
	                    type: STRING,
	                    editable: false,
	                    serializable: false
	                },
	                updated: {
	                    type: DATE,
	                    editable: false,
	                    serializable: false
	                }
	            },
	            categories$: function () {
	                var that = this;
	                var ret = [];
	                if ($.isFunction(that.parent)) {
	                    var viewModel = that.parent();
	                    if (viewModel instanceof kendo.Observable) {
	                        var ids = this.get('categories') || [];
	                        var categories = viewModel.get('categories'); // This supposes the parent viewModel as categories
	                        if (categories instanceof models.LazyCategoryDataSource) {
	                            categories = categories.data();
	                            $.each(ids, function (index, id) {
	                                var found = $.grep(categories, function (category) {
	                                    return category.id === id;
	                                });
	                                if (found.length) {
	                                    ret.push(found[0].name);
	                                }
	                            });
	                        }
	                    }
	                }
	                return ret.join(', '); // TODO: sort
	            },
	            icon$: function () {
	                return kendo.format(uris.cdn.icons, this.get('icon'));
	            },
	            tags$: function () {
	                return this.get('tags').join(', ');
	            },
	            init: function (data) {
	                var that = this;
	                Model.fn.init.call(that, data);
	                that.bind(CHANGE, $.proxy(that._onChange, that));
	            },
	            _onChange: function (e) {
	                // call the base function
	                Model.fn._notifyChange.call(this, e);
	                Model.fn._notifyChange.call(this, e);
	                // kendo only handles add/remove on arrays of child elements
	                // set dirty when an itemchange occurs in an array, e.g. versions
	                // See: http://blog.falafel.com/Blogs/JoshEastburn/josh-eastburn/2014/04/25/dirty-children-and-kendo-ui
	                if (e.action === ITEMCHANGE) {
	                    this.dirty = true;
	                }
	            },
	            load: function (data) {
	                var that = this;
	                var dfd = $.Deferred();
	                if (RX_MONGODB_ID.test(data)) {
	                    // data is a summary id and we fetch a full summary
	                    rapi.v1.content.getSummary(i18n.locale(), data)
	                        .done(function (summary) {
	                            that.accept(summary);
	                            dfd.resolve(summary);
	                        })
	                        .fail(dfd.reject);
	                } else if ($.isPlainObject(data) && RX_MONGODB_ID.test(data.id)) {
	                    if (data.published instanceof Date) {
	                        // data is a published summary and we use model.accept to load data
	                        that.accept(data);
	                        dfd.resolve(data);
	                    } else {
	                        // data is a draft summary, hence it is incomplete
	                        // because the webapp could not fetch the summary without authentication
	                        // We therefore need to fetch a full summary
	                        // data is a summary id and we fetch a full summary
	                        rapi.v1.content.getSummary(i18n.locale(), data.id)
	                            .done(function (summary) {
	                                that.accept(summary);
	                                dfd.resolve(summary);
	                            })
	                            .fail(dfd.reject);
	                    }
	                } else {
	                    // dfd.reject(xhr, status, error);
	                    dfd.reject('TODO', 'TODO', 'TODO'); // TODO
	                }
	                return dfd.promise();
	            },
	            save: function (fields) {
	                var that = this;
	                var dfd = $.Deferred();
	                if (that.dirty) { // TODO Validate
	                    var data = filter(that.toJSON(), fields);
	                    assert.isPlainObject(data, kendo.format(assert.messages.isPlainObject.default, 'data'));
	                    // Check that all model fields marked as serializable === false won't be sent
	                    assert.isUndefined(data.author, kendo.format(assert.messages.isUndefined.default, 'data.author'));
	                    assert.isUndefined(data.created, kendo.format(assert.messages.isUndefined.default, 'data.created'));
	                    assert.isUndefined(data.id, kendo.format(assert.messages.isUndefined.default, 'data.id'));
	                    assert.isUndefined(data.language, kendo.format(assert.messages.isUndefined.default, 'data.language'));
	                    assert.isUndefined(data.metrics, kendo.format(assert.messages.isUndefined.default, 'data.metrics'));
	                    assert.isUndefined(data.type, kendo.format(assert.messages.isUndefined.default, 'data.type'));
	                    assert.isUndefined(data.updated, kendo.format(assert.messages.isUndefined.default, 'data.updated'));
	                    var language = that.get('language');
	                    var id = that.get('id');
	                    rapi.v1.content.updateSummary(language, id, data)
	                        .done(function (data) {
	                            // Note: data is not parsed, so dates are string
	                            that.accept(data); // this updates dirty and updated
	                            dfd.resolve(data);
	                        })
	                        .fail(function (xhr, status, error) {
	                            dfd.reject(xhr, status, error);
	                        });
	                } else {
	                    setTimeout(function () {
	                        dfd.resolve(); // nothing to save
	                    }, 0);
	                }
	                return dfd.promise();
	            },
	            createDraft: function () {
	                return rapi.v1.content.executeCommand(this.get('language'), this.get('id'), { command: 'draft' });
	            },
	            publish: function () {
	                return rapi.v1.content.executeCommand(this.get('language'), this.get('id'), { command: 'publish' });
	            },
	            rate: function (value) {
	                // TODO: what if already rated?????
	                // TODO: check that an author cannot rate his own summaries
	                return rapi.v1.content.createSummaryActivity(this.get('language'), this.get('id'), { type: 'rating', value: value });
	            }
	        });
	
	        /*********************************************************************************
	         * Versions
	         *********************************************************************************/
	
	        /**
	         * Lazy version
	         * @type {kidoju.data.Model}
	         */
	        models.LazyVersion = Model.define({
	            id: 'id', // the identifier of the model, which is required for isNew() to work
	            fields: {
	                id: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                },
	                // created
	                // language
	                name: {
	                    type: STRING,
	                    editable: false
	                },
	                state: {
	                    type: NUMBER,
	                    editable: false
	                },
	                // stream
	                summaryId: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                }
	                // type
	                // updated
	                // userId
	            },
	            versionPlayUri$: function () {
	                return kendo.format(uris.webapp.player, i18n.locale(), this.get('summaryId'), this.get('id'), '').slice(0, -1);
	            },
	            versionEditUri$: function () {
	                return kendo.format(uris.webapp.editor, i18n.locale(), this.get('summaryId'), this.get('id'));
	            },
	            iframe$: function () {
	                // TODO consider the sandbox attribute -- see http://www.html5rocks.com/en/tutorials/security/sandboxed-iframes/
	                return kendo.format(
	                    '<iframe src="{0}?embed=true{1}" style="height:500px;width:100%;border:solid 1px #d5d5d5;"></iframe>',
	                    this.versionPlayUri$(),
	                    app && app.theme && $.isFunction(app.theme.name) ? '&theme=' + app.theme.name() : ''
	                );
	            }
	        });
	
	        /**
	         * Lazy version data source (especially for drop down list)
	         * @type {*|void}
	         */
	        models.LazyVersionDataSource = DataSource.extend({
	
	            init: function (options) {
	                var that = this;
	
	                that.summaryId = options && options.summaryId;
	
	                DataSource.fn.init.call(that, $.extend(true, {}, {
	                    transport: {
	                        read: $.proxy(that._transport._read, that),
	                        destroy: $.proxy(that._transport._destroy, that),
	                        update: $.proxy(that._transport._update, that)
	                    },
	                    serverFiltering: true,
	                    serverSorting: true,
	                    pageSize: 100,
	                    serverPaging: true,
	                    schema: {
	                        data: 'data',
	                        total: 'total',
	                        errors: 'error',
	                        modelBase: models.LazyVersion,
	                        model: models.LazyVersion,
	                        parse: function (response) {
	                            // Name versions: draft, version 1, version 2, ....
	                            if (response && $.type(response.total === NUMBER && $.isArray(response.data))) {
	                                $.each(response.data, function (index, version) {
	                                    if (version.state === VERSION_STATE.DRAFT) {
	                                        version.name = i18n.culture.versions.draft.name;
	                                    } else {
	                                        version.name = kendo.format(i18n.culture.versions.published.name, response.data.length - index);
	                                    }
	                                });
	                            }
	                            return response;
	                        }
	                    }
	                }, options));
	            },
	            load: function (options) {
	                var that = this;
	                that.summaryId = options && options.summaryId;
	                return that.query(options);
	                // return that.read();
	            },
	            /*
	             * Setting _transport._read here with a reference above is a trick
	             * so as to be able to replace this function in mockup scenarios
	             */
	            _transport: {
	                _read: function (options) {
	
	                    assert.isPlainObject(options, kendo.format(assert.messages.isPlainObject.default, 'options'));
	                    assert.isPlainObject(options.data, kendo.format(assert.messages.isPlainObject.default, 'options.data'));
	                    // assert.type(STRING, options.data.summaryId, kendo.format(assert.messages.type.default, 'options.data.summaryId', STRING));
	                    // assert.equal(this.summaryId, options.data.summaryId, kendo.format(assert.messages.equal.default, options.data.summaryId, this.summaryId ));
	
	                    var that = this;
	
	                    logger.debug({
	                        message: 'dataSource.read',
	                        method: 'app.models.LazyVersionDataSource.transport.read',
	                        data: { language: i18n.locale(), summaryId: that.summaryId }
	                    });
	
	                    options.data.fields = 'state,summaryId';
	                    options.data.sort = [{ field: 'id', dir: 'desc' }];
	
	                    rapi.v1.content.findSummaryVersions(i18n.locale(), that.summaryId, options.data)
	                        .done(function (response) {
	                            options.success(response);
	                        })
	                        .fail(function (xhr, error, status) {
	                            options.error(xhr, error, status);
	                        });
	                },
	                _destroy: function (options) {
	
	                    assert.isPlainObject(options, kendo.format(assert.messages.isPlainObject.default, 'options'));
	                    assert.isPlainObject(options.data, kendo.format(assert.messages.isPlainObject.default, 'options.data'));
	                    assert.type(STRING, options.data.id, kendo.format(assert.messages.type.default, 'options.data.id', STRING));
	                    assert.type(STRING, options.data.summaryId, kendo.format(assert.messages.type.default, 'options.data.summaryId', STRING));
	                    assert.equal(this.summaryId, options.data.summaryId, kendo.format(assert.messages.equal.default, options.data.summaryId, this.summaryId));
	
	                    var that = this;
	
	                    logger.debug({
	                        message: 'dataSource.destroy',
	                        method: 'app.models.LazyVersionDataSource.transport.destroy',
	                        data: { language: i18n.locale(), summaryId: options.data.summaryId, versionId: options.data.id }
	                    });
	
	                    rapi.v1.content.deleteSummaryVersion(i18n.locale(), options.data.summaryId, options.data.id)
	                        .done(function (response) {
	                            options.success(response);
	                        })
	                        .fail(function (xhr, error, status) {
	                            options.error(xhr, error, status);
	                        });
	                }
	            }
	
	        });
	
	        /**
	         * Version
	         * @type {kidoju.data.Model}
	         */
	        models.Version = Model.define({
	            id: 'id', // the identifier of the model, which is required for isNew() to work
	            fields: {
	                id: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true,
	                    serializable: false
	                },
	                created: {
	                    type: DATE,
	                    editable: false,
	                    serializable: false
	                },
	                language: {
	                    type: STRING,
	                    editable: false,
	                    serializable: false
	                },
	                state: {
	                    type: NUMBER,
	                    editable: false,
	                    serializable: false
	                },
	                stream: {
	                    defaultValue: new Stream(),
	                    nullable: false,
	                    parse: function (value) {
	                        return value instanceof Stream ? value : new Stream(value);
	                    }
	                },
	                summaryId: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true,
	                    serializable: false
	                },
	                type: {
	                    type: STRING,
	                    editable: false,
	                    serializable: false
	                },
	                updated: {
	                    type: DATE,
	                    editable: false,
	                    serializable: false
	                },
	                userId: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true,
	                    serializable: false
	                }
	            },
	            versionPlayUri$: function () {
	                return kendo.format(uris.webapp.player, i18n.locale(), this.get('summaryId'), this.get('id'), '').slice(0, -1);
	            },
	            versionEditUri$: function () {
	                return kendo.format(uris.webapp.editor, i18n.locale(), this.get('summaryId'), this.get('id'));
	            },
	            load: function (summaryId, versionId) {
	                var that = this;
	                return rapi.v1.content.getSummaryVersion(i18n.locale(), summaryId, versionId)
	                    .done(function (version) {
	                        that.accept(version);
	                        assert.equal(MD5_A, md5('a'), kendo.format(assert.messages.equal.default, 'md5("a")', MD5_A));
	                        that._md5 = md5(JSON.stringify(that.toJSON()));
	                    });
	            },
	            save: function () {
	                var that = this;
	                // That.dirty is not updated when modifying dataSource items
	                // so we have no way to optimize and avoid saving unmodified versions based on `dirty`
	                // like we have done elsewhere
	                var _md5 = that._md5;
	                var data = that.toJSON(true); // true means with hierarchy of data sources
	                assert.isPlainObject(data, kendo.format(assert.messages.isPlainObject.default, 'data'));
	                assert.isUndefined(data.created, kendo.format(assert.messages.isUndefined.default, 'data.created'));
	                assert.isUndefined(data.id, kendo.format(assert.messages.isUndefined.default, 'data.id'));
	                assert.isUndefined(data.language, kendo.format(assert.messages.isUndefined.default, 'data.language'));
	                assert.isUndefined(data.state, kendo.format(assert.messages.isUndefined.default, 'data.state'));
	                assert.isUndefined(data.summaryId, kendo.format(assert.messages.isUndefined.default, 'data.summaryId'));
	                assert.isUndefined(data.type, kendo.format(assert.messages.isUndefined.default, 'data.type'));
	                assert.isUndefined(data.updated, kendo.format(assert.messages.isUndefined.default, 'data.updated'));
	                assert.isUndefined(data.userId, kendo.format(assert.messages.isUndefined.default, 'data.userId'));
	                assert.equal(MD5_A, md5('a'), kendo.format(assert.messages.equal.default, 'md5("a")', MD5_A));
	                that._md5 = md5(JSON.stringify(data));
	                if (that._md5 !== _md5) { // if (that.dirty) { // TODO Validate
	                    var language = that.get('language');
	                    var summaryId = that.get('summaryId');
	                    var versionId = that.get('id');
	                    return rapi.v1.content.updateSummaryVersion(language, summaryId, versionId, data)
	                        .done(function (data) {
	                            // Note: data is not parsed, so dates are string
	                            that.accept(data); // this updates dirty and updated
	                        });
	                } else {
	                    return $.Deferred().resolve().promise();
	                }
	            }
	        });
	
	        /**
	         * Version reference for activities
	         * @type {kidoju.data.Model}
	         */
	        models.VersionReference = Model.define({
	            id: 'versionId', // the identifier of the model, which is required for isNew() to work
	            fields: {
	                language: {
	                    type: STRING,
	                    editable: false
	                },
	                summaryId: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                },
	                title: {
	                    type: STRING,
	                    editable: false
	                },
	                versionId: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                }
	            }
	        });
	
	        /*********************************************************************************
	         * Activities
	         *********************************************************************************/
	
	        /**
	         * Activity model
	         * @type {kidoju.data.Model}
	         */
	        models.LazyActivity = Model.define({
	            id: 'id', // the identifier of the model, which is required for isNew() to work
	            fields: {
	                id: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                },
	                /*
	                 created: {
	                 type: DATE,
	                 editable: false
	                 },
	                 */
	                firstName: {
	                    type: STRING,
	                    editable: false
	                },
	                language: {
	                    type: STRING,
	                    editable: false
	                },
	                lastName: {
	                    type: STRING,
	                    editable: false
	                },
	                /*text: {
	                 type: STRING,
	                 nullable: true,
	                 editable: false
	                 },*/
	                type: {
	                    type: STRING,
	                    editable: false
	                },
	                updated: {
	                    type: DATE,
	                    editable: false
	                },
	                score: {
	                    type: NUMBER,
	                    nullable: true,
	                    editable: false
	                },
	                summaryId: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                },
	                title: {
	                    type: STRING,
	                    editable: false
	                },
	                userId: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                },
	                versionId: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                }/*,
	                 value: {
	                 type: NUMBER,
	                 nullable: true,
	                 editable: false
	                 }*/
	            },
	            actorName$: function () {
	                return ((this.get('firstName') || '').trim() + ' ' + (this.get('lastName') || '').trim()).trim();
	            },
	            actorUri$: function () {
	                return kendo.format(uris.webapp.user, this.get('language'), this.get('userId'));
	            },
	            scoreUri$: function () {
	                return kendo.format(uris.webapp.player, this.get('language'), this.get('summaryId'), this.get('versionId')) +
	                    kendo.format('#/report/{0}', this.get('id')); // TODO: add to config files
	            },
	            summaryUri$: function () {
	                // Some activities like `creation` may refer to unpublished summaries and we do not know whether the summary is published or not
	                // Therefore, we should always bypass server-side data requests to display such summaries
	                // This is not an issue regarding SEO because activities are only displayed to authenticated user
	                return kendo.format(uris.webapp.summary, this.get('language'), this.get('summaryId'));
	            }
	        });
	
	        /**
	         * Datasource of user activities
	         * @type {kendo.Observable}
	         */
	        models.LazyActivityDataSource = DataSource.extend({
	
	            init: function (options) {
	                var that = this;
	
	                that.summaryId = options && options.summaryId;
	
	                DataSource.fn.init.call(that, $.extend(true, {}, {
	                    transport: {
	                        read: $.proxy(that._transport._read, that)
	                    },
	                    serverFiltering: true,
	                    serverSorting: true,
	                    pageSize: 5,
	                    serverPaging: true,
	                    schema: {
	                        data: 'data',
	                        total: 'total',
	                        errors: 'error',
	                        modelBase: models.LazyActivity,
	                        model: models.LazyActivity,
	                        parse: function (response) {
	                            // we parse the response to flatten data for our LazyActivity model (instead of using field.from and field.defaultValue definitions)
	                            if (response && $.type(response.total === NUMBER && $.isArray(response.data))) {
	
	                                /* This function's cyclomatic complexity is too high. */
	                                /* jshint -W074 */
	
	                                $.each(response.data, function (index, activity) {
	                                    // Flatten actor
	                                    activity.userId = activity.actor && activity.actor.userId || null;
	                                    activity.firstName = activity.actor && activity.actor.firstName || '';
	                                    activity.lastName = activity.actor && activity.actor.lastName || '';
	                                    if (activity.actor) {
	                                        delete activity.actor;
	                                    }
	                                    // Flatten version
	                                    activity.language = activity.version && activity.version.language || i18n.locale();
	                                    activity.summaryId = activity.version && activity.version.summaryId || null;
	                                    activity.title = activity.version && activity.version.title || '';
	                                    activity.versionId = activity.version && activity.version.versionId || null;
	                                    if (activity.version) {
	                                        delete activity.version;
	                                    }
	                                });
	
	                                /* jshint +W074 */
	                            }
	                            return response;
	                        }
	                    }
	                }, options));
	            },
	            load: function (options) {
	                var that = this;
	                that.summaryId = options && options.summaryId;
	                return that.query(options);
	                // return that.read();
	            },
	            /*
	             * Setting _transport._read here with a reference above is a trick
	             * so as to be able to replace this function in mockup scenarios
	             */
	            _transport: {
	                _read: function (options) {
	
	                    var that = this;
	
	                    logger.debug({
	                        message: 'dataSource.read',
	                        method: 'app.models.LazyActivityDataSource.transport.read',
	                        data: { summaryId: that.summaryId }
	                    });
	
	                    if (RX_MONGODB_ID.test(that.summaryId)) { // If we have a summaryId for the content being displayed, we fetch summary activities
	
	                        options.data.fields = 'actor,score,type,updated,version';
	                        options.data.sort = options.data.sort || [{ field: 'updated', dir: 'desc' }];
	
	                        rapi.v1.content.findSummaryActivities(i18n.locale(), that.summaryId, options.data)
	                            .done(function (response) {
	                                options.success(response);
	                            })
	                            .fail(function (xhr, status, error) {
	                                options.error(xhr, status, error);
	                            });
	
	                    } else { // Without a summaryId, we need an authenticated user to fetch user activities
	
	                        // options.data.fields = 'actor,score,type,updated,version'; <-- actor is always the same
	                        options.data.fields = 'score,type,updated,version';
	                        options.data.sort = options.data.sort || [{ field: 'updated', dir: 'desc' }];
	
	                        rapi.v1.user.findMyActivities(i18n.locale(), options.data)
	                            .done(function (response) {
	                                options.success(response);
	                            })
	                            .fail(function (xhr, status, error) {
	                                options.error(xhr, status, error);
	                            });
	                    }
	                }
	            }
	        });
	
	        /**
	         * Activity model
	         * @type {kidoju.data.Model}
	         */
	        models.Activity = Model.define({
	            id: 'id', // the identifier of the model, which is required for isNew() to work
	            fields: {
	                id: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                },
	                actor: { // <--- models.UserReference
	                    // For complex types, the recommendation is to leave the type undefined and set a default value
	                    // See: http://www.telerik.com/forums/model---complex-model-with-nested-objects-or-list-of-objects
	                    // See: http://demos.telerik.com/kendo-ui/grid/editing-custom
	                    defaultValue: null,
	                    parse: function (value) {
	                        return (value instanceof models.UserReference || value === null) ? value : new models.UserReference(value);
	                    }
	                },
	                created: {
	                    type: DATE,
	                    editable: false
	                },
	                type: {
	                    type: STRING,
	                    editable: false
	                },
	                updated: {
	                    type: DATE,
	                    editable: false
	                },
	                version: { // <--- models.VersionReference
	                    // For complex types, the recommendation is to leave the type undefined and set a default value
	                    // See: http://www.telerik.com/forums/model---complex-model-with-nested-objects-or-list-of-objects
	                    // See: http://demos.telerik.com/kendo-ui/grid/editing-custom
	                    defaultValue: null,
	                    parse: function (value) {
	                        return (value instanceof models.VersionReference || value === null) ? value : new models.VersionReference(value);
	                    }
	                }
	            },
	            load: function (summaryId, activityId) {
	                var that = this;
	                return rapi.v1.content.getSummaryActivity(i18n.locale(), summaryId, activityId)
	                    .done(function (activity) {
	                        that.accept(activity);
	                    });
	            },
	            save: function () {
	                var that = this;
	                var language = that.get('version.language') || i18n.locale();
	                var summaryId = that.get('version.summaryId');
	                var activity = that.toJSON(true); // true means with hierarchy of data sources
	                if (that.isNew()) {
	                    return rapi.v1.content.createSummaryActivity(language, summaryId, activity)
	                        .done(function (data) {
	                            // Note: data is not parsed, so dates are string
	                            that.accept(data); // this updates dirty and updated
	                        });
	                } else {
	                    var activityId = that.get('id');
	                    return rapi.v1.content.updateSummaryActivity(language, summaryId, activityId, activity)
	                        .done(function (data) {
	                            // Note: data is not parsed, so dates are string
	                            that.accept(data); // this updates dirty and updated
	                        });
	                }
	            }
	        });
	
	        /**
	         * Comment model
	         * @type {kidoju.data.Model}
	         */
	        models.Comment = models.Activity.define({
	            fields: {
	                text: {
	                    type: STRING
	                },
	                // the authenticated user
	                userId: {
	                    type: STRING,
	                    editable: false,
	                    nullable: true
	                }
	            },
	            init: function (data) {
	                // Call the base init method
	                Model.fn.init.call(this, data);
	                // Enforce the type
	                this.type = 'comment';
	            },
	            actor$: function () {
	                return ((this.get('actor.firstName') || '').trim() + ' ' + (this.get('actor.lastName') || '').trim()).trim();
	            },
	            // TODO: add actorUri$
	            isEditable$: function () {
	                return this.get('actor.userId') === this.get('userId');
	            },
	            color$: function () {
	                var hex = '000000';
	                var name = this.get('actor.lastName');
	                for (var i = 0; i < Math.min(3, name.length) ; i++) {
	                    // 26 alphabet lower case letters spanning char codes 65 to 91,
	                    // we need to 'space' them to create more color variety
	                    hex += ((43 * name.charCodeAt(i)) % 256).toString(16);
	                }
	                return '#' + hex.slice(-6);
	            }
	        });
	
	        /**
	         * Datasource of comments
	         * @type {kendo.Observable}
	         */
	        models.CommentDataSource = DataSource.extend({
	
	            init: function (options) {
	                var that = this;
	                that.userId = options && options.userId; // the authenticated user
	                that.summaryId = options && options.summaryId;
	
	                DataSource.fn.init.call(that, $.extend(true, {}, {
	                    transport: {
	                        create: $.proxy(that._transport._create, that),
	                        destroy: $.proxy(that._transport._destroy, that),
	                        read: $.proxy(that._transport._read, that),
	                        update: $.proxy(that._transport._update, that)
	                    },
	                    serverFiltering: true,
	                    serverSorting: true,
	                    pageSize: 5,
	                    serverPaging: true,
	                    schema: {
	                        data: function (response) {
	                            // See: http://www.telerik.com/forums/transport-methods-and-ids-created-on-the-server
	                            if (response && $.type(response.total) === NUMBER && $.isArray(response.data)) { // read list
	                                return response.data;
	                            } else { // create, update, delete
	                                return response;
	                            }
	                        },
	                        total: 'total',
	                        errors: 'error',
	                        modelBase: models.Comment,
	                        model: models.Comment,
	                        parse: function (response) {
	                            // add userId of authenticated user
	                            if (response) {
	                                if ($.type(response.total) === NUMBER && $.isArray(response.data)) { // a read
	                                    $.each(response.data, function (index, comment) {
	                                        comment.userId = that.userId;
	                                    });
	                                } else { // a create or update
	                                    response.userId = that.userId;
	                                }
	                            }
	                            return response;
	                        }
	                    }
	                }, options));
	            },
	            load: function (options) {
	                var that = this;
	                that.summaryId = options && options.summaryId;
	                that.userId = options && options.userId;
	                return that.query(options);
	            },
	            /*
	             * Setting _transport._read here with a reference above is a trick
	             * so as to be able to replace this function in mockup scenarios
	             */
	            _transport: {
	                _create: function (options) {
	                    var that = this;
	                    rapi.v1.content.createSummaryActivity(
	                            (options.data.version && options.data.version.language) || i18n.locale(),
	                            (options.data.version && options.data.version.summaryId) || that.summaryId,
	                        { type: 'comment', text: options.data.text }
	                        )
	                        .done(function (response) {
	                            options.success(response);
	                        })
	                        .fail(function (xhr, status, error) {
	                            options.error(xhr, status, error);
	                        });
	                },
	                _destroy: function (options) {
	                    var that = this;
	                    rapi.v1.content.deleteSummaryActivity(
	                        options.data.version.language,
	                        options.data.version.summaryId,
	                        options.data.id
	                        )
	                        .done(function (response) {
	                            options.success(response);
	                        })
	                        .fail(function (xhr, status, error) {
	                            options.error(xhr, status, error);
	                        });
	                },
	                _read: function (options) {
	                    var that = this;
	                    // We cannot fetch activities without a summary Id
	                    assert.match(RX_MONGODB_ID, that.summaryId, kendo.format(assert.messages.match.default, 'this.summaryId', RX_MONGODB_ID));
	                    options.data.fields = 'actor,created,text,updated,version';
	                    options.data.filter = { field: 'type', operator: 'eq', value: 'Comment' };
	                    options.data.sort = [{ field: 'id', dir: 'desc' }];
	                    rapi.v1.content.findSummaryActivities(
	                        i18n.locale(),
	                        that.summaryId,
	                        options.data
	                        )
	                        .done(function (response) {
	                            options.success(response);
	                        })
	                        .fail(function (xhr, status, error) {
	                            options.error(xhr, status, error);
	                        });
	                },
	                _update: function (options) {
	                    rapi.v1.content.updateSummaryActivity(
	                        options.data.version.language,
	                        options.data.version.summaryId,
	                        options.data.id,
	                        { text: options.data.text }
	                        )
	                        .done(function (response) {
	                            options.success(response);
	                        })
	                        .fail(function (xhr, status, error) {
	                            options.error(xhr, status, error);
	                        });
	                }
	            }
	        });
	
	        /**
	         * Score model
	         * @type {kidoju.data.Model}
	         */
	        models.Score = models.Activity.define({
	            fields: {
	                test: {
	                    defaultValue: null
	                    /*
	                     A test is a hash object of
	                     val_abcd: {
	                     result: true/false,
	                     score: n,
	                     value: 'user answer'
	                     }
	                     */
	                },
	                score: {
	                    type: NUMBER,
	                    editable: false
	                }
	            },
	            init: function (data) {
	                // Call the base init method
	                Model.fn.init.call(this, data);
	                // Enforce the type
	                this.type = 'score';
	            },
	            scoreName$ : function () {
	                var id = this.get('id');
	                if (RX_MONGODB_ID.test(id)) {
	                    return kendo.format('{0:' + i18n.culture.dateFormat + '} ({1:p0})', this.get('created'), this.get('score') / 100);
	                }
	            }
	        });
	
	        /**
	         * Datasource of summary scores
	         * This is used both for the leaderboard on the summary page and in the player, accordingly, userId is optional
	         * @type {kendo.Observable}
	         */
	        models.ScoreDataSource = DataSource.extend({
	
	            init: function (options) {
	                var that = this;
	                that.summaryId = options && options.summaryId;
	                that.userId = options && options.userId; // optional authenticated user
	                that.versionId = options && options.versionId;
	                DataSource.fn.init.call(that, $.extend(true, {}, {
	                    transport: {
	                        read: $.proxy(that._transport._read, that)
	                    },
	                    serverFiltering: true,
	                    serverSorting: true,
	                    pageSize: 100,
	                    serverPaging: true,
	                    schema: {
	                        data: function (response) {
	                            // See: http://www.telerik.com/forums/transport-methods-and-ids-created-on-the-server
	                            if (response && $.type(response.total) === NUMBER && $.isArray(response.data)) { // read list
	                                return response.data;
	                            } else { // create, update, delete
	                                return response;
	                            }
	                        },
	                        total: 'total',
	                        errors: 'error',
	                        modelBase: models.Score,
	                        model: models.Score,
	                        parse: function (response) {
	                            // add userId of authenticated user
	                            if (response) {
	                                if ($.type(response.total) === NUMBER && $.isArray(response.data)) { // a read
	                                    $.each(response.data, function (index, comment) {
	                                        comment.userId = that.userId;
	                                    });
	                                } else { // a create or update
	                                    response.userId = that.userId;
	                                }
	                            }
	                            return response;
	                        }
	                    }
	                }, options));
	            },
	            load: function (options) {
	                var that = this;
	                that.summaryId = options && options.summaryId;
	                that.userId = options && options.userId;
	                that.versionId = options && options.versionId;
	                return that.query(options);
	            },
	            /*
	             * Setting _transport._read here with a reference above is a trick
	             * so as to be able to replace this function in mockup scenarios
	             */
	            _transport: {
	                _read: function (options) {
	                    var that = this;
	                    // We cannot fetch scores without a summary Id, version Id and user Id
	                    assert.match(RX_MONGODB_ID, that.summaryId, kendo.format(assert.messages.match.default, 'this.summaryId', RX_MONGODB_ID));
	                    // assert.match(RX_MONGODB_ID, that.userId, kendo.format(assert.messages.match.default, 'this.userId', RX_MONGODB_ID));
	                    assert.match(RX_MONGODB_ID, that.versionId, kendo.format(assert.messages.match.default, 'this.versionId', RX_MONGODB_ID));
	                    options.data.fields = 'created,score,test,updated'; // Cannot get created without updated
	                    options.data.filter = [
	                        { field: 'type', operator: 'eq', value: 'Score' },
	                        { field: 'version.versionId', operator: 'eq', value: that.versionId }
	                    ];
	                    if (RX_MONGODB_ID.test(that.userId)) {
	                        options.data.filter.push({ field: 'actor.userId', operator: 'eq', value: that.userId });
	                    }
	                    options.data.sort = [{ field: 'id', dir: 'desc' }];
	                    rapi.v1.content.findSummaryActivities(
	                        i18n.locale(),
	                        that.summaryId,
	                        options.data
	                        )
	                        .done(function (response) {
	                            options.success(response);
	                        })
	                        .fail(function (xhr, status, error) {
	                            options.error(xhr, status, error);
	                        });
	                }
	            }
	        });
	
	
	    }(window.jQuery));
	
	    /* jshint +W074 */
	    /* jshint +W071 */
	
	    return window.app;
	
	}, __webpack_require__(200));


/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * JavaScript MD5
	 * https://github.com/blueimp/JavaScript-MD5
	 *
	 * Copyright 2011, Sebastian Tschan
	 * https://blueimp.net
	 *
	 * Licensed under the MIT license:
	 * http://www.opensource.org/licenses/MIT
	 *
	 * Based on
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */
	
	/*global unescape, define, module */
	
	;(function ($) {
	  'use strict'
	
	  /*
	  * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	  * to work around bugs in some JS interpreters.
	  */
	  function safe_add (x, y) {
	    var lsw = (x & 0xFFFF) + (y & 0xFFFF)
	    var msw = (x >> 16) + (y >> 16) + (lsw >> 16)
	    return (msw << 16) | (lsw & 0xFFFF)
	  }
	
	  /*
	  * Bitwise rotate a 32-bit number to the left.
	  */
	  function bit_rol (num, cnt) {
	    return (num << cnt) | (num >>> (32 - cnt))
	  }
	
	  /*
	  * These functions implement the four basic operations the algorithm uses.
	  */
	  function md5_cmn (q, a, b, x, s, t) {
	    return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b)
	  }
	  function md5_ff (a, b, c, d, x, s, t) {
	    return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t)
	  }
	  function md5_gg (a, b, c, d, x, s, t) {
	    return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t)
	  }
	  function md5_hh (a, b, c, d, x, s, t) {
	    return md5_cmn(b ^ c ^ d, a, b, x, s, t)
	  }
	  function md5_ii (a, b, c, d, x, s, t) {
	    return md5_cmn(c ^ (b | (~d)), a, b, x, s, t)
	  }
	
	  /*
	  * Calculate the MD5 of an array of little-endian words, and a bit length.
	  */
	  function binl_md5 (x, len) {
	    /* append padding */
	    x[len >> 5] |= 0x80 << (len % 32)
	    x[(((len + 64) >>> 9) << 4) + 14] = len
	
	    var i
	    var olda
	    var oldb
	    var oldc
	    var oldd
	    var a = 1732584193
	    var b = -271733879
	    var c = -1732584194
	    var d = 271733878
	
	    for (i = 0; i < x.length; i += 16) {
	      olda = a
	      oldb = b
	      oldc = c
	      oldd = d
	
	      a = md5_ff(a, b, c, d, x[i], 7, -680876936)
	      d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586)
	      c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819)
	      b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330)
	      a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897)
	      d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426)
	      c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341)
	      b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983)
	      a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416)
	      d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417)
	      c = md5_ff(c, d, a, b, x[i + 10], 17, -42063)
	      b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162)
	      a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682)
	      d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101)
	      c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290)
	      b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329)
	
	      a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510)
	      d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632)
	      c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713)
	      b = md5_gg(b, c, d, a, x[i], 20, -373897302)
	      a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691)
	      d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083)
	      c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335)
	      b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848)
	      a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438)
	      d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690)
	      c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961)
	      b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501)
	      a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467)
	      d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784)
	      c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473)
	      b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734)
	
	      a = md5_hh(a, b, c, d, x[i + 5], 4, -378558)
	      d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463)
	      c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562)
	      b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556)
	      a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060)
	      d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353)
	      c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632)
	      b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640)
	      a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174)
	      d = md5_hh(d, a, b, c, x[i], 11, -358537222)
	      c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979)
	      b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189)
	      a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487)
	      d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835)
	      c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520)
	      b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651)
	
	      a = md5_ii(a, b, c, d, x[i], 6, -198630844)
	      d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415)
	      c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905)
	      b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055)
	      a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571)
	      d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606)
	      c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523)
	      b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799)
	      a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359)
	      d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744)
	      c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380)
	      b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649)
	      a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070)
	      d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379)
	      c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259)
	      b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551)
	
	      a = safe_add(a, olda)
	      b = safe_add(b, oldb)
	      c = safe_add(c, oldc)
	      d = safe_add(d, oldd)
	    }
	    return [a, b, c, d]
	  }
	
	  /*
	  * Convert an array of little-endian words to a string
	  */
	  function binl2rstr (input) {
	    var i
	    var output = ''
	    for (i = 0; i < input.length * 32; i += 8) {
	      output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF)
	    }
	    return output
	  }
	
	  /*
	  * Convert a raw string to an array of little-endian words
	  * Characters >255 have their high-byte silently ignored.
	  */
	  function rstr2binl (input) {
	    var i
	    var output = []
	    output[(input.length >> 2) - 1] = undefined
	    for (i = 0; i < output.length; i += 1) {
	      output[i] = 0
	    }
	    for (i = 0; i < input.length * 8; i += 8) {
	      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32)
	    }
	    return output
	  }
	
	  /*
	  * Calculate the MD5 of a raw string
	  */
	  function rstr_md5 (s) {
	    return binl2rstr(binl_md5(rstr2binl(s), s.length * 8))
	  }
	
	  /*
	  * Calculate the HMAC-MD5, of a key and some data (raw strings)
	  */
	  function rstr_hmac_md5 (key, data) {
	    var i
	    var bkey = rstr2binl(key)
	    var ipad = []
	    var opad = []
	    var hash
	    ipad[15] = opad[15] = undefined
	    if (bkey.length > 16) {
	      bkey = binl_md5(bkey, key.length * 8)
	    }
	    for (i = 0; i < 16; i += 1) {
	      ipad[i] = bkey[i] ^ 0x36363636
	      opad[i] = bkey[i] ^ 0x5C5C5C5C
	    }
	    hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)
	    return binl2rstr(binl_md5(opad.concat(hash), 512 + 128))
	  }
	
	  /*
	  * Convert a raw string to a hex string
	  */
	  function rstr2hex (input) {
	    var hex_tab = '0123456789abcdef'
	    var output = ''
	    var x
	    var i
	    for (i = 0; i < input.length; i += 1) {
	      x = input.charCodeAt(i)
	      output += hex_tab.charAt((x >>> 4) & 0x0F) +
	      hex_tab.charAt(x & 0x0F)
	    }
	    return output
	  }
	
	  /*
	  * Encode a string as utf-8
	  */
	  function str2rstr_utf8 (input) {
	    return unescape(encodeURIComponent(input))
	  }
	
	  /*
	  * Take string arguments and return either raw or hex encoded strings
	  */
	  function raw_md5 (s) {
	    return rstr_md5(str2rstr_utf8(s))
	  }
	  function hex_md5 (s) {
	    return rstr2hex(raw_md5(s))
	  }
	  function raw_hmac_md5 (k, d) {
	    return rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))
	  }
	  function hex_hmac_md5 (k, d) {
	    return rstr2hex(raw_hmac_md5(k, d))
	  }
	
	  function md5 (string, key, raw) {
	    if (!key) {
	      if (!raw) {
	        return hex_md5(string)
	      }
	      return raw_md5(string)
	    }
	    if (!raw) {
	      return hex_hmac_md5(key, string)
	    }
	    return raw_hmac_md5(key, string)
	  }
	
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return md5
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	  } else if (typeof module === 'object' && module.exports) {
	    module.exports = md5
	  } else {
	    $.md5 = md5
	  }
	}(this))


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2013-2016 Memba Sarl. All rights reserved.
	 * Sources at https://github.com/Memba
	 */
	
	/* jshint browser: true, jquery: true */
	/* globals define: false */
	
	(function (f, define) {
	    'use strict';
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(250),
	        __webpack_require__(251)
	    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(function () {
	
	    'use strict';
	
	    /* This function has too many statements. */
	    /* jshint -W071 */
	
	    (function ($, undefined) {
	
	        /* jshint maxstatements: 28 */
	
	        var app = window.app;
	        var localStorage = window.localStorage;
	        var sessionStorage = window.sessionStorage;
	        // var assert = new window.assert;
	        var logger = new window.Logger('app.cache');
	        var rapi = app.rapi;
	        var cache = app.cache = app.cache || {};
	        var LOCAL_EXPIRES = 24 * 60 * 60; // 1 day
	        var SESSION_EXPIRES = 5 * 60; // 5 minutes
	        var NOCACHE = app.NOCACHE || false; // cache by default
	        var STRING = 'string';
	        var NULL = null;
	        var ME = cache.ME = 'me'; // Public because used in app.models.js
	        var CATEGORIES = 'categories.';
	        var FAVOURITES = 'favourites.';
	
	        /**
	         * Sets an item in browser local storage
	         * @param name
	         * @param value
	         * @param expires (in seconds, 1 day by default)
	         * @private
	         */
	        cache._setLocalItem = function (name, value, expires) {
	            if (!NOCACHE && localStorage) {
	                localStorage.setItem(name, JSON.stringify({
	                    ts: Date.now(),
	                    expires: expires || LOCAL_EXPIRES,
	                    value: value
	                }));
	                logger.debug({
	                    message: 'value set in localStorage',
	                    method: 'app.cache._setLocalItem',
	                    data: { name: name, value: value, expires: expires }
	                });
	            } else {
	                logger.debug({
	                    message: 'localStorage not supported or NOCACHE option set',
	                    method: 'app.cache._setLocalItem'
	                });
	            }
	        };
	
	        /**
	         * Gets an item from browser local storage
	         * @param name
	         * @returns {*}
	         * @private
	         */
	        cache._getLocalItem = function (name) {
	            if (!NOCACHE && localStorage) {
	                var item = JSON.parse(localStorage.getItem(name));
	                if ((!item) || (item.ts && item.expires && item.ts + 1000 * item.expires < Date.now())) {
	                    if (item) {
	                        localStorage.removeItem(name);
	                        logger.debug({
	                            message: 'value read from localStorage has expired',
	                            method: 'app.cache._getLocalItem',
	                            data: { name: name }
	                        });
	                    }
	                    return NULL;
	                }
	                logger.debug({
	                    message: 'value read from localStorage is still valid',
	                    method: 'app.cache._getLocalItem',
	                    data: { name: name }
	                });
	                return item.value;
	            } else {
	                logger.debug({
	                    message: 'localStorage not supported or NOCACHE option set',
	                    method: 'app.cache._getLocalItem'
	                });
	                return NULL;
	            }
	        };
	
	        /**
	         * Removes an item from browser local storage
	         * @param regexp
	         * @private
	         */
	        cache._removeLocalItem = function (regexp) {
	            if (localStorage) {
	                if (!(regexp instanceof RegExp)) {
	                    regexp = new RegExp(regexp);
	                }
	                for (var i = 0; i < localStorage.length; i++) {
	                    var key = localStorage.key(i);
	                    if (regexp.test(key)) {
	                        localStorage.removeItem(key);
	                        logger.debug({
	                            message: 'value removed from localStorage',
	                            method: 'app.cache._removeLocalItem',
	                            data: { rx: regexp, key: key }
	                        });
	                    }
	                }
	            }
	        };
	
	        /**
	         * Sets an item in browser session storage
	         * @param name
	         * @param value
	         * @param expires (in seconds, 5 min by default)
	         * @private
	         */
	        cache._setSessionItem = function (name, value, expires) {
	            if (!NOCACHE && sessionStorage) {
	                sessionStorage.setItem(name, JSON.stringify({
	                    ts: Date.now(),
	                    expires: expires || SESSION_EXPIRES,
	                    value: value
	                }));
	                logger.debug({
	                    message: 'value set in sessionStorage',
	                    method: 'app.cache._setSessionItem',
	                    data: { name: name, value: value, expires: expires }
	                });
	            } else {
	                logger.debug({
	                    message: 'sessionStorage not supported or NOCACHE option set',
	                    method: 'app.cache._setSessionItem'
	                });
	            }
	        };
	
	        /**
	         * Gets an item from browser session storage
	         * @param name
	         * @returns {*}
	         * @private
	         */
	        cache._getSessionItem = function (name) {
	            if (!NOCACHE && sessionStorage) {
	                var item = JSON.parse(sessionStorage.getItem(name));
	                if ((!item) || (item.ts && item.expires && item.ts + 1000 * item.expires < Date.now())) {
	                    if (item) {
	                        sessionStorage.removeItem(name);
	                        logger.debug({
	                            message: 'value read from sessionStorage has expired',
	                            method: 'app.cache._getSessionItem',
	                            data: { name: name }
	                        });
	                    }
	                    return NULL;
	                }
	                logger.debug({
	                    message: 'value read from sessionStorage is still valid',
	                    method: 'app.cache._getSessionItem',
	                    data: { name: name }
	                });
	                return item.value;
	            } else {
	                logger.debug({
	                    message: 'sessionStorage not supported or NOCACHE option set',
	                    method: 'app.cache._getLocalItem'
	                });
	                return NULL;
	            }
	        };
	
	        /**
	         * Removes an item from browser session storage
	         * @param regexp
	         * @private
	         */
	        cache._removeSessionItem = function (regexp) {
	            if (sessionStorage) {
	                if (!(regexp instanceof RegExp)) {
	                    regexp = new RegExp(regexp);
	                }
	                for (var i = 0; i < sessionStorage.length; i++) {
	                    var key = sessionStorage.key(i);
	                    if (regexp.test(key)) {
	                        sessionStorage.removeItem(key);
	                        logger.debug({
	                            message: 'value removed from sessionStorage',
	                            method: 'app.cache._removeSessionItem',
	                            data: { rx: regexp, key: key }
	                        });
	                    }
	                }
	            }
	        };
	
	        /**
	         * Get the (un)authenticated user
	         */
	        cache.getMe = function () {
	            var dfd = $.Deferred();
	            var me = cache._getSessionItem(ME);
	            var token = rapi.util.getAccessToken();
	            if ((token && me && me.id === NULL) || // remove unauthenticated me, since we have a valid token
	                (!token && me && $.type(me.id) === STRING)) { // remove authenticated me since we do not have a valid token
	                cache.removeMe();
	                me = NULL;
	            }
	            if (me) {
	                logger.debug({
	                    message: 'me found in cache',
	                    method: 'app.cache.getMe',
	                    data: { me: me }
	                });
	                // setTimeout(function () {
	                dfd.resolve(me);
	                // }, 0);
	            } else {
	                rapi.v1.user.getMe({ fields: 'firstName lastName picture' })
	                    .done(function (response) {
	                        cache.removeMyFavourites();
	                        cache._setSessionItem(ME, response);
	                        dfd.resolve(response);
	                    })
	                    .fail(function (xhr, status, error) {
	                        if (xhr.status === 401) { // Unauthorised = not authenticated
	                            var response =  { id: NULL };
	                            cache.removeMyFavourites();
	                            rapi.util.clearToken(); // Token is necessarily invalid if user.getMe failed
	                            cache._setSessionItem(ME, response);
	                            dfd.resolve(response);
	                        } else { // any other error
	                            dfd.reject(xhr, status, error); // be consistent with $.ajax in case of error
	                        }
	                    });
	            }
	            return dfd.promise();
	        };
	
	        /**
	         * Remove the authenticated user from cache
	         * Also remove his favourites, but not his token
	         */
	        cache.removeMe = function () {
	            cache._removeSessionItem('^' + ME);
	            cache._removeSessionItem('^' + FAVOURITES);
	        };
	
	        /**
	         * Get a list of categories
	         * @param locale (ISO code)
	         */
	        cache.getAllCategories = function (locale) {
	            var categories = cache._getLocalItem(CATEGORIES + locale);
	            if ($.isArray(categories)) {
	                logger.debug({
	                    message: 'categories found in cache',
	                    method: 'app.cache.getAllCategories',
	                    data: { locale: locale }
	                });
	                var dfd = $.Deferred();
	                // setTimeout(function () {
	                dfd.resolve({ total: categories.length, data: categories });
	                // }, 0);
	                return dfd.promise();
	            } else {
	                return rapi.v1.taxonomy.getAllCategories(locale)
	                    .done(function (response) {
	                        cache._setLocalItem(CATEGORIES + locale, response.data); // response = { total: ..., data: [...] }
	                    });
	            }
	        };
	
	        /**
	         * Get a hierarchy of categories
	         * @param locale
	         */
	        cache.getCategoryHierarchy = function (locale) {
	            var dfd = $.Deferred();
	            cache.getAllCategories(locale)
	                .done(function (response) {
	                    var hash = {};
	                    $.each(response.data, function (index, value) {
	                        // See http://docs.telerik.com/kendo-ui/getting-started/web/treeview/overview#item-definition
	                        // See http://docs.telerik.com/kendo-ui/getting-started/web/treeview/binding-to-flat-data#method-1-initial-pre-processing-of-all-data
	                        var item = {
	                                id: value.id,
	                                name: value.name,
	                                icon: value.icon,
	                                type: 2
	                            };
	                        var id = value.id;
	                        var parentId = value.parentId || 'root';
	                        hash[id] = hash[id] || [];
	                        hash[parentId] = hash[parentId] || [];
	                        item.items = hash[id];
	                        hash[parentId].push(item);
	                    });
	                    dfd.resolve(hash.root || []);
	                })
	                .fail(function (xhr, status, error) {
	                    dfd.reject(xhr, status, error);
	                });
	            return dfd.promise();
	        };
	
	        /**
	         * Get a flat hierarchy of categories with depth level, in the same order as the hierarchy
	         * @param locale
	         * @returns {*}
	         */
	        cache.getLeveledCategories = function (locale) {
	            var dfd = $.Deferred();
	            cache.getCategoryHierarchy(locale)
	                .done(function (response) {
	                    function Flatten(categories, parentId, depth) {
	                        for (var i = 0, length = categories.length; i < length; i++) {
	                            var category = categories[i];
	                            flat.push({
	                                id: category.id,
	                                icon: category.icon,
	                                depth: depth, // `level` seems to be reserved in kendo.ui.TreeView
	                                name: category.name,
	                                parentId: parentId,
	                                type: category.type
	                            });
	                            if ($.isArray(category.items) && category.items.length) {
	                                Flatten(category.items, category.id, depth + 1);
	                            }
	                        }
	                    }
	                    var flat = [];
	                    Flatten(response, null, 0);
	                    dfd.resolve({ total: flat.length, data: flat });
	                })
	                .fail(function (xhr, status, error) {
	                    dfd.reject(xhr, status, error);
	                });
	            return dfd.promise();
	        };
	
	        /**
	         * Get all my favourites
	         * @param locale (ISO code)
	         */
	        cache.getAllMyFavourites = function (locale) {
	            var dfd;
	            var me = cache._getSessionItem(ME);
	            var favourites = cache._getSessionItem(FAVOURITES + locale);
	            if ($.isArray(favourites)) {
	                logger.debug({
	                    message: 'favourites found in cache',
	                    method: 'app.cache.getAllMyFavourites',
	                    data: { locale: locale }
	                });
	                dfd = $.Deferred();
	                setTimeout(function () {
	                    dfd.resolve({ total: favourites.length, data: favourites });
	                }, 0);
	                return dfd.promise();
	            } else if (me && me.id === NULL) {
	                dfd = $.Deferred();
	                setTimeout(function () {
	                    dfd.resolve({ total: 0, data: [] });
	                }, 0);
	                return dfd.promise();
	            } else {
	                return rapi.v1.user.getAllMyFavourites(locale).done(function (response) {
	                    cache._setSessionItem(FAVOURITES + locale, response.data); // response = { total: ..., data: [...] }
	                });
	            }
	        };
	
	        /**
	         * Returns a hierarchy of favourites
	         * @param locale
	         */
	        cache.getFavouriteHierarchy = function (locale) {
	            var dfd = $.Deferred();
	            cache.getAllMyFavourites(locale)
	                .done(function (response) {
	                    var favourites = response.data;
	                    $.each(favourites, function (index, favourite) {
	                        delete favourite.language;
	                        favourite.icon = 'star';
	                        favourite.type = 3;
	                        // We might consider subtypes in the future to organize favourites (searches, users, summaries, channels, ...)
	                    });
	                    dfd.resolve(favourites);
	                })
	                .fail(function (xhr, status, error) {
	                    if (xhr && xhr.status === 401) {
	                        dfd.resolve([]);
	                    } else {
	                        dfd.reject(xhr, status, error);
	                    }
	                });
	            return dfd.promise();
	        };
	
	        /**
	         * Remove favourites
	         * @param locale (ISO code)
	         */
	        cache.removeMyFavourites = function (locale) {
	            cache._removeSessionItem('^' + FAVOURITES + locale);
	        };
	
	    }(window.jQuery));
	
	    /* jshint +W071 */
	
	    return window.app;
	
	}, __webpack_require__(200));


/***/ }
/******/ ]);
//# sourceMappingURL=app.bundle.js.map?v=0.2.57